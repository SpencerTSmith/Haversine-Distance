#include "common.h"

#define C_Token_Type(X)               \
  X(C_TOKEN_NONE)                     \
  X(C_TOKEN_OPEN_PARENTHESIS)         \
  X(C_TOKEN_OPEN_CURLY_BRACE)         \
  X(C_TOKEN_OPEN_SQUARE_BRACE)        \
  X(C_TOKEN_CLOSE_PARENTHESIS)        \
  X(C_TOKEN_CLOSE_CURLY_BRACE)        \
  X(C_TOKEN_CLOSE_SQUARE_BRACE)       \
  X(C_TOKEN_STAR)                     \
  X(C_TOKEN_ADD)                     \
  X(C_TOKEN_SUBTRACT)                    \
  X(C_TOKEN_ASSIGN)                    \
  X(C_TOKEN_COMMA)                    \
  X(C_TOKEN_SEMICOLON)                \
  X(C_TOKEN_DOT)                      \
  X(C_TOKEN_TILDE)                    \
  X(C_TOKEN_DECREMENT)                \
  X(C_TOKEN_INCREMENT)                \
  X(C_TOKEN_COMPARE_EQUAL)            \
  X(C_TOKEN_LOGICAL_AND)              \
  X(C_TOKEN_LOGICAL_OR)               \
  X(C_TOKEN_BITWISE_AND)              \
  X(C_TOKEN_BITWISE_OR)               \
  X(C_TOKEN_LITERAL_STRING)           \
  X(C_TOKEN_LITERAL_INT)              \
  X(C_TOKEN_KEYWORD_INT)              \
  X(C_TOKEN_KEYWORD_CHAR)             \
  X(C_TOKEN_IDENTIFIER)               \
  X(C_TOKEN_EOF)

ENUM_TABLE(C_Token_Type);

typedef struct C_Token C_Token;
struct C_Token
{
  C_Token_Type type;
  String value;
};

typedef struct C_Lexer C_Lexer;
struct C_Lexer
{
  String source;
  usize  at;
};

// Single character tokens... some special logic required for e.g. =,&,| (could be ==,&&,||)
// In those cases we check and then grab the 2nd token type of the triple
// As well for operation assignment tokens (+=, -=, &=, etc.)
// We use the 3rd of the triple
static C_Token_Type c_token_table[][3] =
{
  ['('] = {C_TOKEN_OPEN_PARENTHESIS,   C_TOKEN_NONE,          C_TOKEN_NONE},
  [')'] = {C_TOKEN_CLOSE_PARENTHESIS,  C_TOKEN_NONE,          C_TOKEN_NONE},
  ['{'] = {C_TOKEN_OPEN_CURLY_BRACE,   C_TOKEN_NONE,          C_TOKEN_NONE},
  ['}'] = {C_TOKEN_CLOSE_CURLY_BRACE,  C_TOKEN_NONE,          C_TOKEN_NONE},
  ['['] = {C_TOKEN_OPEN_SQUARE_BRACE,  C_TOKEN_NONE,          C_TOKEN_NONE},
  [']'] = {C_TOKEN_CLOSE_SQUARE_BRACE, C_TOKEN_NONE,          C_TOKEN_NONE},

  ['-'] = {C_TOKEN_SUBTRACT,           C_TOKEN_DECREMENT,     C_TOKEN_NONE},
  ['*'] = {C_TOKEN_STAR,               C_TOKEN_NONE,          C_TOKEN_MULTIPLY_ASSIGN},
  ['/'] = {C_TOKEN_DIVIDE,             C_TOKEN_NONE,          C_TOKEN_DIVIDE_ASSIGN},
  ['%'] = {C_TOKEN_MODULO,             C_TOKEN_NONE,          C_TOKEN_MODULO_ASSIGN},
  ['+'] = {C_TOKEN_ADD,                C_TOKEN_INCREMENT,     C_TOKEN_ADD_ASSIGN},
  ['='] = {C_TOKEN_ASSIGN,             C_TOKEN_COMPARE_EQUAL, C_TOKEN_NONE},
  [','] = {C_TOKEN_COMMA,              C_TOKEN_NONE,          C_TOKEN_NONE},
  [';'] = {C_TOKEN_SEMICOLON,          C_TOKEN_NONE,          C_TOKEN_NONE},
  ['.'] = {C_TOKEN_DOT,                C_TOKEN_NONE,          C_TOKEN_NONE},
  ['~'] = {C_TOKEN_TILDE,              C_TOKEN_NONE,          C_TOKEN_NOT_ASSIGN},
  ['&'] = {C_TOKEN_BITWISE_AND,        C_TOKEN_LOGICAL_AND,   C_TOKEN_AND_ASSIGN},
  ['|'] = {C_TOKEN_BITWISE_OR,         C_TOKEN_LOGICAL_OR,    C_TOKEN_OR_ASSIGN},
};

DEFINE_ARRAY(C_Token);

static
b32 c_lexer_incomplete(C_Lexer lexer)
{
  return lexer.at < lexer.source.count;
}

static
u8 *c_lexer_at(C_Lexer lexer)
{
  ASSERT(c_lexer_incomplete(lexer), "Out of bounds access in C lexer.");
  return lexer.source.v + lexer.at;
}

static
void c_lexer_advance(C_Lexer *lexer, usize count)
{
  lexer->at += count;
}

static
String c_lexer_get_token_value(C_Lexer *lexer, usize count)
{
  // FIXME: hmm
  usize max  = lexer->source.count;
  usize wish = lexer->at + count;
  usize real = wish < max ? count : max - lexer->at;

  String result =
  {
    .v = c_lexer_at(*lexer),
    .count = real,
  };

  return result;
}

static
void c_lexer_eat_whitespace(C_Lexer *lexer)
{
  while (c_lexer_incomplete(*lexer))
  {
    u8 curr_char = *c_lexer_at(*lexer);
    if (char_is_whitespace(curr_char))
    {
      c_lexer_advance(lexer, 1);
    }
    else
    {
      break;
    }
  }
}

static
b32 c_lexer_in_bounds(C_Lexer lexer, usize at)
{
  return at < lexer.source.count;
}

static
C_Token_Array tokenize_c_code(Arena *arena, String code)
{
  C_Token_Array result = {0};

  C_Lexer lexer =
  {
    .source = code,
    .at = 0,
  };

  // TODO: Not thrilled about this comma operator here, but can't think of anything nicer
  // to do yet
  while (c_lexer_eat_whitespace(&lexer), c_lexer_incomplete(lexer))
  {
    u8 curr_char = *c_lexer_at(lexer);

    C_Token token = {0};

    if (curr_char < STATIC_COUNT(c_token_table))
    {
      token.type = c_token_table[curr_char][0];
    }

    if (token.type != C_TOKEN_NONE) // Match from the table!
    {
      b32 could_be_double = c_token_table[curr_char][1] != C_TOKEN_NONE; // e.g. &&
      b32 could_be_assign = c_token_table[curr_char][2] != C_TOKEN_NONE; // e.g. &=

      usize token_length = 1; // Could actually be 2 after we check the above cases!
      if (could_be_double || could_be_assign)
      {
        if (c_lexer_in_bounds(lexer, lexer.at + 1))
        {
          u8 next_char = lexer.source.v[lexer.at + 1];
          if (next_char == curr_char)
          {
            token.type = c_token_table[curr_char][1];
            token.value = c_lexer_get_token_value(&lexer, 2);
          }
          else if (next_char == '=')
          {
            token.type = c_token_table[curr_char][2];
            token.value = c_lexer_get_token_value(&lexer, 2);
          }
        }
      }

      token.value = c_lexer_get_token_value(&lexer, token_length);
    }
    else
    {
      if (char_is_alphabetic(curr_char) || curr_char == '_') // Identifier or keyword
      {

      }
      else if (curr_char == '"') // String literal
      {

      }
      else if (curr_char == '\'') // Character literal
      {

      }
      else if (char_is_digit(curr_char)) // Number literal
      {

      }
    }

    usize advance = 1; // We'll just skip ahead if we haven't gotten a real token... maybe not best plan?
    if (token.type != C_TOKEN_NONE)
    {
      array_add(arena, result, token);
      advance = token.value.count;
    }
    c_lexer_advance(&lexer, advance);
  }

  return result;
}
