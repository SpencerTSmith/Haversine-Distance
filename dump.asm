
calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x3fb9]        # 4fc8 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x3fca]        # 4ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x3fcc]        # 4ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x3fca]        # 5000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x3fc2]        # 5008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x3fba]        # 5010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x3fb2]        # 5018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x3faa]        # 5020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x3fa2]        # 5028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x3f9a]        # 5030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x3f92]        # 5038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x3f8a]        # 5040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x3f82]        # 5048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x3f7a]        # 5050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x3f72]        # 5058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x3f6a]        # 5060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x3f62]        # 5068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x3f5a]        # 5070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x3f52]        # 5078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x3f4a]        # 5080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x3f42]        # 5088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x3f3a]        # 5090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x3f32]        # 5098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001180 <parser_at.part.0>:
  String source;
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
    1180:	push   rax
{
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    1181:	lea    rcx,[rip+0x2790]        # 3918 <__PRETTY_FUNCTION__.6>
    1188:	mov    edx,0x2f
    118d:	lea    rsi,[rip+0x1e70]        # 3004 <_IO_stdin_used+0x4>
    1194:	lea    rdi,[rip+0x2075]        # 3210 <_IO_stdin_used+0x210>
    119b:	call   1090 <__assert_fail@plt>

00000000000011a0 <arena_pop_to.part.0>:
  arena->next_offset = aligned_offset + size;

  return ptr;
}

void arena_pop_to(Arena *arena, isize offset)
    11a0:	push   rax
{
  ASSERT(offset < arena->next_offset,
    11a1:	lea    rcx,[rip+0x2780]        # 3928 <__PRETTY_FUNCTION__.7>
    11a8:	mov    edx,0x217
    11ad:	lea    rsi,[rip+0x1e61]        # 3015 <_IO_stdin_used+0x15>
    11b4:	lea    rdi,[rip+0x20a5]        # 3260 <_IO_stdin_used+0x260>
    11bb:	call   1090 <__assert_fail@plt>

00000000000011c0 <arena_make_backed.cold>:
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    11c0:	lea    rcx,[rip+0x2789]        # 3950 <__PRETTY_FUNCTION__.9>
    11c7:	mov    edx,0x1e5
    11cc:	lea    rsi,[rip+0x1e42]        # 3015 <_IO_stdin_used+0x15>
    11d3:	lea    rdi,[rip+0x2106]        # 32e0 <_IO_stdin_used+0x2e0>
    11da:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    11df:	lea    rcx,[rip+0x276a]        # 3950 <__PRETTY_FUNCTION__.9>
    11e6:	mov    edx,0x1e6
    11eb:	lea    rsi,[rip+0x1e23]        # 3015 <_IO_stdin_used+0x15>
    11f2:	lea    rdi,[rip+0x2137]        # 3330 <_IO_stdin_used+0x330>
    11f9:	call   1090 <__assert_fail@plt>

00000000000011fe <arena_alloc.cold>:
  ASSERT(arena->base != NULL, "Arena memory is null");
    11fe:	lea    rcx,[rip+0x2733]        # 3938 <__PRETTY_FUNCTION__.8>
    1205:	mov    edx,0x1fe
    120a:	lea    rsi,[rip+0x1e04]        # 3015 <_IO_stdin_used+0x15>
    1211:	lea    rdi,[rip+0x2160]        # 3378 <_IO_stdin_used+0x378>
    1218:	call   1090 <__assert_fail@plt>

000000000000121d <arena_pop_to.cold>:
{
    121d:	push   rax
    121e:	call   11a0 <arena_pop_to.part.0>

0000000000001223 <arena_pop.cold>:
  // Should we zero out the memory?
  arena->next_offset = offset;
}

void arena_pop(Arena *arena, isize size)
{
    1223:	push   rax
    1224:	call   11a0 <arena_pop_to.part.0>

0000000000001229 <scratch_end.cold>:
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
  return scratch;
}

void scratch_end(Scratch *scratch)
{
    1229:	push   rax
    122a:	call   11a0 <arena_pop_to.part.0>

000000000000122f <get_json_token.cold>:
    122f:	call   1180 <parser_at.part.0>

0000000000001234 <json_object_to_f64.cold>:

  return result;
}

f64 json_object_to_f64(JSON_Object *object)
{
    1234:	push   rax
  ASSERT(object, "Must pass valid object to f64 conversion");
    1235:	lea    rcx,[rip+0x26c4]        # 3900 <__PRETTY_FUNCTION__.5>
    123c:	mov    edx,0x1c2
    1241:	lea    rsi,[rip+0x1dbc]        # 3004 <_IO_stdin_used+0x4>
    1248:	lea    rdi,[rip+0x22a9]        # 34f8 <_IO_stdin_used+0x4f8>
    124f:	call   1090 <__assert_fail@plt>
    1254:	cs nop WORD PTR [rax+rax*1+0x0]
    125e:	xchg   ax,ax

0000000000001260 <main>:

  return (fabs(a) - fabs(b)) <= epsilon;
}

int main(int args_count, char **args)
{
    1260:	push   r15
    1262:	push   r14
    1264:	push   r13
    1266:	push   r12
    1268:	push   rbp
    1269:	push   rbx
    126a:	sub    rsp,0x1c8
    1271:	mov    QWORD PTR [rsp+0x30],rsi
    1276:	mov    rax,QWORD PTR fs:0x28
    127f:	mov    QWORD PTR [rsp+0x1b8],rax
    1287:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    1289:	cmp    edi,0x3
    128c:	je     12cd <main+0x6d>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    128e:	mov    rsi,QWORD PTR [rsi]
    1291:	lea    rdi,[rip+0x2298]        # 3530 <_IO_stdin_used+0x530>
    1298:	xor    eax,eax
    129a:	call   1070 <printf@plt>
    return 1;
    129f:	mov    eax,0x1
  {
    arena_free(&arena);
  }

  end_profiling();
}
    12a4:	mov    rdx,QWORD PTR [rsp+0x1b8]
    12ac:	sub    rdx,QWORD PTR fs:0x28
    12b5:	jne    1d03 <main+0xaa3>
    12bb:	add    rsp,0x1c8
    12c2:	pop    rbx
    12c3:	pop    rbp
    12c4:	pop    r12
    12c6:	pop    r13
    12c8:	pop    r14
    12ca:	pop    r15
    12cc:	ret
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    12cd:	rdtsc
static Profiler g_profiler;

static
void begin_profiling()
{
  g_profiler = (Profiler)
    12cf:	xor    esi,esi
    12d1:	lea    rdi,[rip+0x3e48]        # 5120 <g_profiler>
    12d8:	shl    rdx,0x20
    12dc:	mov    rbx,rax
    12df:	or     rbx,rdx
    12e2:	mov    edx,0x28010
    12e7:	call   10a0 <memset@plt>
  Arena arena = {0};
    12ec:	xor    eax,eax
    12ee:	mov    ecx,0x8
    12f3:	lea    rdi,[rsp+0xa0]
    12fb:	rep stos DWORD PTR [rdi],eax
  arena = arena_make(GB(4));
    12fd:	mov    esi,0x1
    1302:	lea    rdi,[rsp+0x50]
    1307:	mov    QWORD PTR [rip+0x3e12],rbx        # 5120 <g_profiler>
    130e:	shl    rsi,0x20
    1312:	call   2190 <arena_make>
    1317:	movdqu xmm0,XMMWORD PTR [rsp+0x50]
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    131d:	mov    QWORD PTR [rip+0x3e00],0x5        # 5128 <g_profiler+0x8>
    1328:	movaps XMMWORD PTR [rsp+0xa0],xmm0
    1330:	movdqu xmm0,XMMWORD PTR [rsp+0x60]
    1336:	movaps XMMWORD PTR [rsp+0xb0],xmm0
    133e:	rdtsc

  // Make sure this is the last thing to run
  pass.start = read_cpu_timer();

  return pass;
    1340:	lea    rcx,[rip+0x1d39]        # 3080 <_IO_stdin_used+0x80>
    1347:	shl    rdx,0x20
    source = read_file_to_arena(&arena, args[1]);
    134b:	lea    r15,[rsp+0xa0]
    1353:	mov    QWORD PTR [rsp+0xc0],rcx
    135b:	or     rax,rdx
    135e:	mov    rdi,r15
    1361:	xor    edx,edx
    1363:	mov    QWORD PTR [rsp+0xc8],0x4
    136f:	mov    QWORD PTR [rsp+0xd0],rax
    1377:	xor    eax,eax
    1379:	mov    QWORD PTR [rsp+0xd8],rax
    1381:	mov    rax,QWORD PTR [rsp+0x30]
    1386:	mov    QWORD PTR [rsp+0xe0],0x5
    1392:	mov    rsi,QWORD PTR [rax+0x8]
    1396:	mov    QWORD PTR [rsp+0xe8],rdx
    139e:	mov    QWORD PTR [rsp+0x38],r15
    13a3:	call   22f0 <read_file_to_arena>
  PROFILE_SCOPE("read")
    13a8:	sub    rsp,0x30
    13ac:	mov    ecx,0xc
    13b1:	lea    rsi,[rsp+0xf0]
    13b9:	mov    rdi,rsp
    source = read_file_to_arena(&arena, args[1]);
    13bc:	mov    rbx,rax
    13bf:	mov    rbp,rdx
  PROFILE_SCOPE("read")
    13c2:	rep movs DWORD PTR [rdi],DWORD PTR [rsi]
    13c4:	call   1e40 <__profile_end_pass>
    .parent_index = g_profiler.current_parent_zone,
    13c9:	mov    rcx,QWORD PTR [rip+0x3d58]        # 5128 <g_profiler+0x8>
  g_profiler.current_parent_zone = zone_index;
    13d0:	mov    QWORD PTR [rip+0x3d4d],0x6        # 5128 <g_profiler+0x8>
    13db:	rdtsc
  return pass;
    13dd:	lea    rdi,[rip+0x1ca1]        # 3085 <_IO_stdin_used+0x85>
    13e4:	shl    rdx,0x20
    13e8:	mov    QWORD PTR [rsp+0x148],rcx
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    13f0:	mov    ecx,0x18
    13f5:	or     rax,rdx
    13f8:	xor    edx,edx
    13fa:	mov    QWORD PTR [rsp+0x120],rdi
    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    1402:	mov    rdi,r15
    1405:	movq   xmm0,rax
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    140a:	mov    rax,rbp
    140d:	movhps xmm0,QWORD PTR [rip+0x3e24]        # 5238 <g_profiler+0x118>
    1414:	mov    QWORD PTR [rsp+0x128],0xf
    1420:	div    rcx
    1423:	movaps XMMWORD PTR [rsp+0x130],xmm0
    142b:	mov    QWORD PTR [rsp+0x140],0x6
    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    1437:	mov    edx,0x8
    143c:	add    rsp,0x30
    1440:	mov    rsi,rax
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    1443:	mov    r12,rax
    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    1446:	shl    rsi,0x5
    144a:	call   2270 <arena_alloc>
  PROFILE_SCOPE("haversine alloc")
    144f:	mov    ecx,0xc
    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    1454:	mov    QWORD PTR [rsp+0x20],rax
  PROFILE_SCOPE("haversine alloc")
    1459:	sub    rsp,0x30
    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    145d:	mov    r14,rax
  PROFILE_SCOPE("haversine alloc")
    1460:	lea    rsi,[rsp+0x120]
    1468:	mov    rdi,rsp
    146b:	rep movs DWORD PTR [rdi],DWORD PTR [rsi]
    146d:	call   1e40 <__profile_end_pass>
    .parent_index = g_profiler.current_parent_zone,
    1472:	mov    rcx,QWORD PTR [rip+0x3caf]        # 5128 <g_profiler+0x8>
  g_profiler.current_parent_zone = zone_index;
    1479:	mov    QWORD PTR [rip+0x3ca4],0x3        # 5128 <g_profiler+0x8>
    1484:	rdtsc
  return pass;
    1486:	lea    rdi,[rip+0x245b]        # 38e8 <__func__.4>
    148d:	shl    rdx,0x20
    1491:	mov    QWORD PTR [rsp+0x1d8],rcx
  JSON_Parser parser =
    1499:	xor    ecx,ecx
    149b:	or     rax,rdx
    149e:	mov    QWORD PTR [rsp+0x1b0],rdi
  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    14a6:	lea    rdi,[rsp+0xb0]
  JSON_Parser parser =
    14ae:	mov    QWORD PTR [rsp+0x180],rbx
    14b6:	movq   xmm0,rax
    14bb:	movhps xmm0,QWORD PTR [rip+0x3cfe]        # 51c0 <g_profiler+0xa0>
    14c2:	mov    QWORD PTR [rsp+0x190],rcx
    14ca:	movaps XMMWORD PTR [rsp+0x1c0],xmm0
    14d2:	mov    QWORD PTR [rsp+0x1b8],0xa
    14de:	mov    QWORD PTR [rsp+0x1d0],0x3
    14ea:	mov    QWORD PTR [rsp+0x188],rbp
  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    14f2:	add    rsp,0x30
    14f6:	lea    rbx,[rsp+0x150]
    14fe:	mov    rsi,rbx
    1501:	mov    QWORD PTR [rsp+0x48],rbx
    1506:	call   2440 <get_json_token>
    150b:	sub    rsp,0x20
    150f:	mov    rsi,rbx
    1512:	xor    edx,edx
    1514:	movdqa xmm0,XMMWORD PTR [rsp+0xa0]
    151d:	mov    rax,QWORD PTR [rsp+0xb0]
    1525:	xor    ecx,ecx
    1527:	mov    rdi,r15
    152a:	movups XMMWORD PTR [rsp],xmm0
    152e:	mov    QWORD PTR [rsp+0x10],rax
    1533:	call   2a60 <parse_json_object>
  profile_end_func();
    1538:	mov    ecx,0xc
    153d:	push   rsi
  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    153e:	mov    r9,rax
  profile_end_func();
    1541:	push   rsi
    1542:	lea    rsi,[rsp+0x1b0]
    154a:	mov    rdi,rsp
    154d:	mov    QWORD PTR [rsp+0x70],rsi
    1552:	rep movs DWORD PTR [rdi],DWORD PTR [rsi]
    1554:	call   1e40 <__profile_end_pass>
  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    1559:	add    rsp,0x30
    155d:	mov    edx,0x5
    1562:	mov    rdi,r9
    1565:	lea    rsi,[rip+0x1b29]        # 3095 <_IO_stdin_used+0x95>
    156c:	call   1ea0 <lookup_json_object>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    1571:	mov    rbx,QWORD PTR [rax+0x20]
    1575:	test   rbx,rbx
    1578:	je     1c8b <main+0xa2b>
    157e:	cmp    rbp,0x17
    1582:	jbe    1c8b <main+0xa2b>
    1588:	mov    rbp,r14
    158b:	mov    r15d,0x1
    1591:	lea    r13,[rip+0x1b03]        # 309b <_IO_stdin_used+0x9b>
    1598:	nop    DWORD PTR [rax+rax*1+0x0]
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    15a0:	lea    rax,[rip+0x3b79]        # 5120 <g_profiler>
    15a7:	mov    rcx,QWORD PTR [rax+0x140]
    .parent_index = g_profiler.current_parent_zone,
    15ae:	mov    rsi,QWORD PTR [rax+0x8]
  g_profiler.current_parent_zone = zone_index;
    15b2:	mov    QWORD PTR [rip+0x3b6b],0x7        # 5128 <g_profiler+0x8>
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    15bd:	mov    QWORD PTR [rsp+0x8],rcx
    15c2:	rdtsc
    15c4:	shl    rdx,0x20
  return pass;
    15c8:	mov    QWORD PTR [rsp+0x1a8],rsi
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    15d0:	mov    rdi,rbx
    15d3:	lea    rsi,[rip+0x1acf]        # 30a9 <_IO_stdin_used+0xa9>
    15da:	or     rax,rdx
    15dd:	mov    edx,0x2
    15e2:	mov    QWORD PTR [rsp+0x180],r13
    15ea:	mov    QWORD PTR [rsp+0x188],0xd
    15f6:	movq   xmm0,rax
    15fb:	movhps xmm0,QWORD PTR [rsp+0x8]
    1600:	mov    QWORD PTR [rsp+0x1a0],0x7
    160c:	movaps XMMWORD PTR [rsp+0x190],xmm0
    1614:	call   1ea0 <lookup_json_object>
    1619:	mov    rdi,rax
    161c:	call   2be0 <json_object_to_f64>
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    1621:	lea    rsi,[rip+0x1a84]        # 30ac <_IO_stdin_used+0xac>
    1628:	mov    edx,0x2
    162d:	mov    rdi,rbx
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    1630:	movsd  QWORD PTR [rsp+0x8],xmm0
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    1636:	call   1ea0 <lookup_json_object>
    163b:	mov    rdi,rax
    163e:	call   2be0 <json_object_to_f64>
    1643:	movsd  xmm1,QWORD PTR [rsp+0x8]
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    1649:	mov    edx,0x2
    164e:	mov    rdi,rbx
    1651:	lea    rsi,[rip+0x1a57]        # 30af <_IO_stdin_used+0xaf>
    1658:	unpcklpd xmm1,xmm0
    165c:	movaps XMMWORD PTR [rsp+0x10],xmm1
    1661:	call   1ea0 <lookup_json_object>
    1666:	mov    rdi,rax
    1669:	call   2be0 <json_object_to_f64>
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    166e:	lea    rsi,[rip+0x1a3d]        # 30b2 <_IO_stdin_used+0xb2>
    1675:	mov    edx,0x2
    167a:	mov    rdi,rbx
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    167d:	movsd  QWORD PTR [rsp+0x8],xmm0
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    1683:	call   1ea0 <lookup_json_object>
    1688:	mov    rdi,rax
    168b:	call   2be0 <json_object_to_f64>
        pairs[pair_count] = pair;
    1690:	movsd  xmm4,QWORD PTR [rsp+0x8]
    1696:	movapd xmm1,XMMWORD PTR [rsp+0x10]
      PROFILE_SCOPE("child convert")
    169c:	sub    rsp,0x30
        pairs[pair_count] = pair;
    16a0:	unpcklpd xmm4,xmm0
    16a4:	movups XMMWORD PTR [rbp+0x0],xmm1
      PROFILE_SCOPE("child convert")
    16a8:	movdqa xmm0,XMMWORD PTR [rsp+0x1b0]
        pairs[pair_count] = pair;
    16b1:	movups XMMWORD PTR [rbp+0x10],xmm4
      PROFILE_SCOPE("child convert")
    16b5:	movups XMMWORD PTR [rsp],xmm0
    16b9:	movdqa xmm0,XMMWORD PTR [rsp+0x1c0]
    16c2:	movups XMMWORD PTR [rsp+0x10],xmm0
    16c7:	movdqa xmm0,XMMWORD PTR [rsp+0x1d0]
    16d0:	movups XMMWORD PTR [rsp+0x20],xmm0
    16d5:	call   1e40 <__profile_end_pass>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    16da:	mov    rbx,QWORD PTR [rbx+0x28]
    16de:	add    rsp,0x30
    16e2:	mov    rsi,r15
    16e5:	test   rbx,rbx
    16e8:	setne  dl
    16eb:	cmp    r15,r12
    16ee:	setb   al
    16f1:	add    r15,0x1
    16f5:	add    rbp,0x20
    16f9:	test   dl,al
    16fb:	jne    15a0 <main+0x340>
    .parent_index = g_profiler.current_parent_zone,
    1701:	mov    rdi,QWORD PTR [rip+0x3a20]        # 5128 <g_profiler+0x8>
        pair_count += 1;
    1708:	mov    ebx,esi
  g_profiler.current_parent_zone = zone_index;
    170a:	mov    QWORD PTR [rip+0x3a13],0x8        # 5128 <g_profiler+0x8>
    1715:	rdtsc
  return pass;
    1717:	lea    rcx,[rip+0x1997]        # 30b5 <_IO_stdin_used+0xb5>
    171e:	mov    rbp,QWORD PTR [rsp+0x20]
    1723:	shl    rdx,0x20
    1727:	shl    rsi,0x5
    172b:	mov    QWORD PTR [rsp+0x120],rcx
    1733:	mov    QWORD PTR [rsp+0x148],rdi
    173b:	or     rax,rdx
    for (usize i = 0; i < pair_count; i++)
    173e:	add    rbp,rsi
  f64 sum = 0.0;
    1741:	mov    QWORD PTR [rsp+0x8],0x0
    174a:	movq   xmm0,rax
    174f:	movhps xmm0,QWORD PTR [rip+0x3b32]        # 5288 <g_profiler+0x168>
    1756:	mov    QWORD PTR [rsp+0x128],0x3
    1762:	mov    QWORD PTR [rsp+0x140],0x8
    176e:	movaps XMMWORD PTR [rsp+0x130],xmm0
    1776:	cs nop WORD PTR [rax+rax*1+0x0]
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    1780:	movsd  xmm1,QWORD PTR [r14+0x18]
    1786:	movsd  xmm3,QWORD PTR [r14+0x8]
  f64 lat1 = y0;
  f64 lat2 = y1;
  f64 lon1 = x0;
  f64 lon2 = x1;

  f64 d_lat = to_radians(lat2 - lat1);
    178c:	movapd xmm0,xmm1
    1790:	movsd  QWORD PTR [rsp+0x20],xmm1
    1796:	subsd  xmm0,xmm3
  return degrees / PI;
    179a:	divsd  xmm0,QWORD PTR [rip+0x21ee]        # 3990 <__PRETTY_FUNCTION__.9+0x40>
  f64 d_lat = to_radians(lat2 - lat1);
    17a2:	movsd  QWORD PTR [rsp+0x10],xmm3
  f64 d_lon = to_radians(lon2 - lon1);
  lat1 = to_radians(lat1);
  lat2 = to_radians(lat2);

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    17a8:	mulsd  xmm0,QWORD PTR [rip+0x21e8]        # 3998 <__PRETTY_FUNCTION__.9+0x48>
    17b0:	call   1130 <sin@plt>
  return degrees / PI;
    17b5:	movsd  xmm3,QWORD PTR [rsp+0x10]
    17bb:	divsd  xmm3,QWORD PTR [rip+0x21cd]        # 3990 <__PRETTY_FUNCTION__.9+0x40>
  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    17c3:	movsd  QWORD PTR [rsp+0x28],xmm0
  return degrees / PI;
    17c9:	movapd xmm0,xmm3
  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    17cd:	call   10b0 <cos@plt>
  return degrees / PI;
    17d2:	movsd  xmm1,QWORD PTR [rsp+0x20]
    17d8:	divsd  xmm1,QWORD PTR [rip+0x21b0]        # 3990 <__PRETTY_FUNCTION__.9+0x40>
  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    17e0:	movsd  QWORD PTR [rsp+0x10],xmm0
  return degrees / PI;
    17e6:	movapd xmm0,xmm1
  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    17ea:	call   10b0 <cos@plt>
    17ef:	movsd  QWORD PTR [rsp+0x20],xmm0
  f64 d_lon = to_radians(lon2 - lon1);
    17f5:	movsd  xmm0,QWORD PTR [r14+0x10]
    17fb:	subsd  xmm0,QWORD PTR [r14]
  return degrees / PI;
    1800:	divsd  xmm0,QWORD PTR [rip+0x2188]        # 3990 <__PRETTY_FUNCTION__.9+0x40>
  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    1808:	mulsd  xmm0,QWORD PTR [rip+0x2188]        # 3998 <__PRETTY_FUNCTION__.9+0x48>
    1810:	call   1130 <sin@plt>
    1815:	movsd  xmm1,QWORD PTR [rsp+0x10]
    181b:	mulsd  xmm1,QWORD PTR [rsp+0x20]
    1821:	pxor   xmm7,xmm7
  return x * x;
    1825:	mulsd  xmm0,xmm0
    1829:	movsd  xmm2,QWORD PTR [rsp+0x28]
    182f:	mulsd  xmm2,xmm2
  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    1833:	mulsd  xmm0,xmm1
    1837:	addsd  xmm0,xmm2
  f64 c = 2.0 * asin(sqrt(a));
    183b:	ucomisd xmm7,xmm0
    183f:	ja     1cf9 <main+0xa99>
    1845:	sqrtsd xmm0,xmm0
    1849:	call   1140 <asin@plt>
    for (usize i = 0; i < pair_count; i++)
    184e:	add    r14,0x20
    1852:	addsd  xmm0,xmm0

  f64 result = sphere_radius * c;
    1856:	mulsd  xmm0,QWORD PTR [rip+0x2142]        # 39a0 <__PRETTY_FUNCTION__.9+0x50>
      sum += result;
    185e:	addsd  xmm0,QWORD PTR [rsp+0x8]
    1864:	movsd  QWORD PTR [rsp+0x8],xmm0
    for (usize i = 0; i < pair_count; i++)
    186a:	cmp    rbp,r14
    186d:	jne    1780 <main+0x520>
  PROFILE_SCOPE("sum")
    1873:	sub    rsp,0x30
    1877:	mov    ecx,0xc
    187c:	lea    rsi,[rsp+0x150]
    1884:	mov    rdi,rsp
    1887:	rep movs DWORD PTR [rdi],DWORD PTR [rsi]
    1889:	call   1e40 <__profile_end_pass>
    .parent_index = g_profiler.current_parent_zone,
    188e:	mov    rcx,QWORD PTR [rip+0x3893]        # 5128 <g_profiler+0x8>
  g_profiler.current_parent_zone = zone_index;
    1895:	mov    QWORD PTR [rip+0x3888],0x9        # 5128 <g_profiler+0x8>
    18a0:	rdtsc
  return pass;
    18a2:	lea    rdi,[rip+0x1810]        # 30b9 <_IO_stdin_used+0xb9>
    18a9:	shl    rdx,0x20
    18ad:	mov    QWORD PTR [rsp+0x180],rdi
    18b5:	or     rax,rdx
    18b8:	mov    QWORD PTR [rsp+0x1a8],rcx
    18c0:	mov    QWORD PTR [rsp+0x188],0x5
    18cc:	movq   xmm0,rax
    18d1:	movhps xmm0,QWORD PTR [rip+0x39d8]        # 52b0 <g_profiler+0x190>
    18d8:	mov    QWORD PTR [rsp+0x1a0],0x9
    18e4:	movaps XMMWORD PTR [rsp+0x190],xmm0
    String solution_dump = read_file_to_arena(&arena, args[2]);
    18ec:	mov    rax,QWORD PTR [rsp+0x60]
    18f1:	add    rsp,0x30
    18f5:	mov    rdi,QWORD PTR [rsp+0x38]
    18fa:	mov    rsi,QWORD PTR [rax+0x10]
    18fe:	call   22f0 <read_file_to_arena>
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    1903:	cmp    rdx,0xb
    1907:	jbe    1c19 <main+0x9b9>
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    190d:	mov    r8d,DWORD PTR [rax+0x8]
      if (solution_pairs == pair_count)
    1911:	cmp    r8d,ebx
    1914:	jne    1c3d <main+0x9dd>
    sum /= pair_count;
    191a:	movsd  xmm1,QWORD PTR [rsp+0x8]
    1920:	pxor   xmm0,xmm0
      f64 solution_sum   = *(f64 *)solution_dump.data;
    1924:	movsd  xmm2,QWORD PTR [rax]
    sum /= pair_count;
    1928:	cvtsi2sd xmm0,ebx
    192c:	divsd  xmm1,xmm0
  return (fabs(a) - fabs(b)) <= epsilon;
    1930:	movapd xmm0,xmm2
    1934:	andpd  xmm0,XMMWORD PTR [rip+0x2084]        # 39c0 <__PRETTY_FUNCTION__.9+0x70>
    193c:	movapd xmm3,xmm1
    1940:	andpd  xmm3,XMMWORD PTR [rip+0x2078]        # 39c0 <__PRETTY_FUNCTION__.9+0x70>
    1948:	subsd  xmm0,xmm3
        if (epsilon_equal(solution_sum, sum))
    194c:	movsd  xmm3,QWORD PTR [rip+0x2054]        # 39a8 <__PRETTY_FUNCTION__.9+0x58>
    1954:	comisd xmm3,xmm0
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    1958:	movapd xmm0,xmm2
        if (epsilon_equal(solution_sum, sum))
    195c:	jae    1ba3 <main+0x943>
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    1962:	mov    edx,0x68
    1967:	mov    edi,0x1
    196c:	mov    eax,0x2
    1971:	lea    rcx,[rip+0x1c70]        # 35e8 <_IO_stdin_used+0x5e8>
    1978:	lea    rsi,[rip+0x1740]        # 30bf <_IO_stdin_used+0xbf>
    197f:	call   1ff0 <log_message>
  PROFILE_SCOPE("check")
    1984:	sub    rsp,0x30
    1988:	mov    ecx,0xc
    198d:	mov    rsi,QWORD PTR [rsp+0x78]
    1992:	mov    rdi,rsp
    1995:	rep movs DWORD PTR [rdi],DWORD PTR [rsi]
    1997:	call   1e40 <__profile_end_pass>
    .parent_index = g_profiler.current_parent_zone,
    199c:	mov    rcx,QWORD PTR [rip+0x3785]        # 5128 <g_profiler+0x8>
  g_profiler.current_parent_zone = zone_index;
    19a3:	mov    QWORD PTR [rip+0x377a],0xa        # 5128 <g_profiler+0x8>
    19ae:	rdtsc
  return pass;
    19b0:	lea    rdi,[rip+0x171d]        # 30d4 <_IO_stdin_used+0xd4>
    19b7:	shl    rdx,0x20
    19bb:	mov    QWORD PTR [rsp+0x1d8],rcx
    19c3:	or     rax,rdx
    19c6:	mov    QWORD PTR [rsp+0x1b0],rdi
    19ce:	movq   xmm0,rax
    19d3:	mov    QWORD PTR [rsp+0x1b8],0x4
    19df:	movhps xmm0,QWORD PTR [rip+0x38f2]        # 52d8 <g_profiler+0x1b8>
    19e6:	mov    QWORD PTR [rsp+0x1d0],0xa
    19f2:	movaps XMMWORD PTR [rsp+0x1c0],xmm0
    arena_free(&arena);
    19fa:	mov    rdi,QWORD PTR [rsp+0x68]
    19ff:	add    rsp,0x30
    1a03:	call   2230 <arena_free>
  PROFILE_SCOPE("free")
    1a08:	sub    rsp,0x30
    1a0c:	mov    ecx,0xc
    1a11:	mov    rsi,QWORD PTR [rsp+0x70]
    1a16:	mov    rdi,rsp
    1a19:	rep movs DWORD PTR [rdi],DWORD PTR [rsi]
    1a1b:	call   1e40 <__profile_end_pass>
    1a20:	rdtsc
    1a22:	shl    rdx,0x20
  if (total_delta)
    1a26:	add    rsp,0x30
    1a2a:	or     rax,rdx
    1a2d:	sub    rax,QWORD PTR [rip+0x36ec]        # 5120 <g_profiler>
    1a34:	mov    rbx,rax
    1a37:	jne    1a40 <main+0x7e0>
    1a39:	xor    eax,eax
    1a3b:	jmp    12a4 <main+0x44>
    1a40:	rdtsc
  gettimeofday(&value, 0);
    1a42:	xor    esi,esi
    1a44:	lea    r12,[rsp+0x70]
    1a49:	mov    r13,rax
    1a4c:	shl    rdx,0x20
    1a50:	mov    rdi,r12
    1a53:	or     r13,rdx
    1a56:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a5b:	imul   rbp,QWORD PTR [rsp+0x70],0xf4240
    1a64:	add    rbp,QWORD PTR [rsp+0x78]
  while (os_delta < os_wait_time)
    1a69:	nop    DWORD PTR [rax+0x0]
  gettimeofday(&value, 0);
    1a70:	xor    esi,esi
    1a72:	mov    rdi,r12
    1a75:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a7a:	imul   rcx,QWORD PTR [rsp+0x70],0xf4240
    1a83:	add    rcx,QWORD PTR [rsp+0x78]
    os_delta = os_end - os_start;
    1a88:	sub    rcx,rbp
  while (os_delta < os_wait_time)
    1a8b:	cmp    rcx,0x1869f
    1a92:	jbe    1a70 <main+0x810>
    1a94:	rdtsc
    1a96:	shl    rdx,0x20
    1a9a:	or     rax,rdx
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1a9d:	xor    edx,edx
  u64 cpu_delta = cpu_end - cpu_start;
    1a9f:	sub    rax,r13
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1aa2:	imul   rax,rax,0xf4240
    1aa9:	div    rcx
    printf("[PROFILE] Total duration: %lu (%fms @ CPU Frequency: %u)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1aac:	test   rbx,rbx
    1aaf:	js     1c64 <main+0xa04>
    1ab5:	pxor   xmm5,xmm5
    1ab9:	cvtsi2sd xmm5,rbx
    1abe:	movsd  QWORD PTR [rsp+0x8],xmm5
    1ac4:	movsd  xmm0,QWORD PTR [rsp+0x8]
    1aca:	pxor   xmm1,xmm1
    1ace:	mov    rdx,rax
    1ad1:	mov    rsi,rbx
    1ad4:	cvtsi2sd xmm1,rax
    1ad9:	lea    rdi,[rip+0x1b78]        # 3658 <_IO_stdin_used+0x658>
    1ae0:	mov    eax,0x1
    1ae5:	lea    rbx,[rip+0x3644]        # 5130 <g_profiler+0x10>
    1aec:	divsd  xmm0,xmm1
    1af0:	lea    rbp,[rbx+0x28000]
    1af7:	mulsd  xmm0,QWORD PTR [rip+0x1eb1]        # 39b0 <__PRETTY_FUNCTION__.9+0x60>
    1aff:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1b04:	jmp    1b1d <main+0x8bd>
    1b06:	cs nop WORD PTR [rax+rax*1+0x0]
    1b10:	add    rbx,0x28
    1b14:	cmp    rbx,rbp
    1b17:	je     1a39 <main+0x7d9>
      if (zone->elapsed_inclusive)
    1b1d:	cmp    QWORD PTR [rbx+0x18],0x0
    1b22:	je     1b10 <main+0x8b0>
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1b24:	mov    r8,QWORD PTR [rbx+0x10]
    1b28:	test   r8,r8
    1b2b:	js     1bd0 <main+0x970>
    1b31:	pxor   xmm0,xmm0
    1b35:	cvtsi2sd xmm0,r8
    1b3a:	divsd  xmm0,QWORD PTR [rsp+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1b40:	mov    esi,DWORD PTR [rbx+0x8]
    1b43:	mov    rcx,QWORD PTR [rbx+0x20]
    1b47:	lea    rdi,[rip+0x1b4a]        # 3698 <_IO_stdin_used+0x698>
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1b4e:	mulsd  xmm0,QWORD PTR [rip+0x1e62]        # 39b8 <__PRETTY_FUNCTION__.9+0x68>
        printf("[PROFILE] Zone '%.*s':\n"
    1b56:	mov    rdx,QWORD PTR [rbx]
    1b59:	mov    eax,0x1
    1b5e:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1b63:	mov    rsi,QWORD PTR [rbx+0x18]
    1b67:	cmp    QWORD PTR [rbx+0x10],rsi
    1b6b:	je     1b10 <main+0x8b0>
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1b6d:	test   rsi,rsi
    1b70:	js     1bf8 <main+0x998>
    1b76:	pxor   xmm0,xmm0
    1b7a:	cvtsi2sd xmm0,rsi
    1b7f:	divsd  xmm0,QWORD PTR [rsp+0x8]
    1b85:	mulsd  xmm0,QWORD PTR [rip+0x1e2b]        # 39b8 <__PRETTY_FUNCTION__.9+0x68>
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1b8d:	mov    eax,0x1
    1b92:	lea    rdi,[rip+0x1b57]        # 36f0 <_IO_stdin_used+0x6f0>
    1b99:	call   1070 <printf@plt>
    1b9e:	jmp    1b10 <main+0x8b0>
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    1ba3:	mov    edx,0x64
    1ba8:	mov    edi,0x3
    1bad:	mov    eax,0x2
    1bb2:	lea    rcx,[rip+0x1a67]        # 3620 <_IO_stdin_used+0x620>
    1bb9:	lea    rsi,[rip+0x14ff]        # 30bf <_IO_stdin_used+0xbf>
    1bc0:	call   1ff0 <log_message>
    1bc5:	jmp    1984 <main+0x724>
    1bca:	nop    WORD PTR [rax+rax*1+0x0]
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1bd0:	mov    rax,r8
    1bd3:	mov    rdx,r8
    1bd6:	pxor   xmm0,xmm0
    1bda:	shr    rax,1
    1bdd:	and    edx,0x1
    1be0:	or     rax,rdx
    1be3:	cvtsi2sd xmm0,rax
    1be8:	addsd  xmm0,xmm0
    1bec:	jmp    1b3a <main+0x8da>
    1bf1:	nop    DWORD PTR [rax+0x0]
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1bf8:	mov    rax,rsi
    1bfb:	mov    rdx,rsi
    1bfe:	pxor   xmm0,xmm0
    1c02:	shr    rax,1
    1c05:	and    edx,0x1
    1c08:	or     rax,rdx
    1c0b:	cvtsi2sd xmm0,rax
    1c10:	addsd  xmm0,xmm0
    1c14:	jmp    1b7f <main+0x91f>
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    1c19:	lea    rcx,[rip+0x1940]        # 3560 <_IO_stdin_used+0x560>
    1c20:	mov    edx,0x72
    1c25:	lea    rsi,[rip+0x1493]        # 30bf <_IO_stdin_used+0xbf>
    1c2c:	xor    eax,eax
    1c2e:	mov    edi,0x1
    1c33:	call   1ff0 <log_message>
    1c38:	jmp    1984 <main+0x724>
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    1c3d:	mov    r9d,ebx
    1c40:	mov    edx,0x6d
    1c45:	mov    edi,0x1
    1c4a:	xor    eax,eax
    1c4c:	lea    rcx,[rip+0x194d]        # 35a0 <_IO_stdin_used+0x5a0>
    1c53:	lea    rsi,[rip+0x1465]        # 30bf <_IO_stdin_used+0xbf>
    1c5a:	call   1ff0 <log_message>
    1c5f:	jmp    1984 <main+0x724>
    printf("[PROFILE] Total duration: %lu (%fms @ CPU Frequency: %u)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1c64:	mov    rdx,rbx
    1c67:	mov    rcx,rbx
    1c6a:	pxor   xmm0,xmm0
    1c6e:	shr    rdx,1
    1c71:	and    ecx,0x1
    1c74:	or     rdx,rcx
    1c77:	cvtsi2sd xmm0,rdx
    1c7c:	addsd  xmm0,xmm0
    1c80:	movsd  QWORD PTR [rsp+0x8],xmm0
    1c86:	jmp    1ac4 <main+0x864>
    .parent_index = g_profiler.current_parent_zone,
    1c8b:	mov    rcx,QWORD PTR [rip+0x3496]        # 5128 <g_profiler+0x8>
  g_profiler.current_parent_zone = zone_index;
    1c92:	mov    QWORD PTR [rip+0x348b],0x8        # 5128 <g_profiler+0x8>
    1c9d:	rdtsc
  return pass;
    1c9f:	lea    rdi,[rip+0x140f]        # 30b5 <_IO_stdin_used+0xb5>
    1ca6:	xor    ebx,ebx
    1ca8:	shl    rdx,0x20
    1cac:	mov    QWORD PTR [rsp+0x120],rdi
    1cb4:	or     rax,rdx
    1cb7:	mov    QWORD PTR [rsp+0x148],rcx
  f64 sum = 0.0;
    1cbf:	mov    QWORD PTR [rsp+0x8],0x0
    1cc8:	movq   xmm0,rax
    1ccd:	movhps xmm0,QWORD PTR [rip+0x35b4]        # 5288 <g_profiler+0x168>
    1cd4:	mov    QWORD PTR [rsp+0x128],0x3
    1ce0:	mov    QWORD PTR [rsp+0x140],0x8
    1cec:	movaps XMMWORD PTR [rsp+0x130],xmm0
    1cf4:	jmp    1873 <main+0x613>
  f64 c = 2.0 * asin(sqrt(a));
    1cf9:	call   1160 <sqrt@plt>
    1cfe:	jmp    1849 <main+0x5e9>
}
    1d03:	call   1060 <__stack_chk_fail@plt>
    1d08:	nop    DWORD PTR [rax+rax*1+0x0]

0000000000001d10 <_start>:
    1d10:	endbr64
    1d14:	xor    ebp,ebp
    1d16:	mov    r9,rdx
    1d19:	pop    rsi
    1d1a:	mov    rdx,rsp
    1d1d:	and    rsp,0xfffffffffffffff0
    1d21:	push   rax
    1d22:	push   rsp
    1d23:	xor    r8d,r8d
    1d26:	xor    ecx,ecx
    1d28:	lea    rdi,[rip+0xfffffffffffff531]        # 1260 <main>
    1d2f:	call   QWORD PTR [rip+0x3283]        # 4fb8 <__libc_start_main@GLIBC_2.34>
    1d35:	hlt
    1d36:	cs nop WORD PTR [rax+rax*1+0x0]
    1d40:	lea    rdi,[rip+0x3399]        # 50e0 <stdout@GLIBC_2.2.5>
    1d47:	lea    rax,[rip+0x3392]        # 50e0 <stdout@GLIBC_2.2.5>
    1d4e:	cmp    rax,rdi
    1d51:	je     1d68 <_start+0x58>
    1d53:	mov    rax,QWORD PTR [rip+0x3266]        # 4fc0 <_ITM_deregisterTMCloneTable@Base>
    1d5a:	test   rax,rax
    1d5d:	je     1d68 <_start+0x58>
    1d5f:	jmp    rax
    1d61:	nop    DWORD PTR [rax+0x0]
    1d68:	ret
    1d69:	nop    DWORD PTR [rax+0x0]
    1d70:	lea    rdi,[rip+0x3369]        # 50e0 <stdout@GLIBC_2.2.5>
    1d77:	lea    rsi,[rip+0x3362]        # 50e0 <stdout@GLIBC_2.2.5>
    1d7e:	sub    rsi,rdi
    1d81:	mov    rax,rsi
    1d84:	shr    rsi,0x3f
    1d88:	sar    rax,0x3
    1d8c:	add    rsi,rax
    1d8f:	sar    rsi,1
    1d92:	je     1da8 <_start+0x98>
    1d94:	mov    rax,QWORD PTR [rip+0x3235]        # 4fd0 <_ITM_registerTMCloneTable@Base>
    1d9b:	test   rax,rax
    1d9e:	je     1da8 <_start+0x98>
    1da0:	jmp    rax
    1da2:	nop    WORD PTR [rax+rax*1+0x0]
    1da8:	ret
    1da9:	nop    DWORD PTR [rax+0x0]
    1db0:	endbr64
    1db4:	cmp    BYTE PTR [rip+0x334d],0x0        # 5108 <stderr@GLIBC_2.2.5+0x8>
    1dbb:	jne    1df0 <_start+0xe0>
    1dbd:	push   rbp
    1dbe:	cmp    QWORD PTR [rip+0x3212],0x0        # 4fd8 <__cxa_finalize@GLIBC_2.2.5>
    1dc6:	mov    rbp,rsp
    1dc9:	je     1dd8 <_start+0xc8>
    1dcb:	mov    rdi,QWORD PTR [rip+0x32d6]        # 50a8 <__dso_handle>
    1dd2:	call   QWORD PTR [rip+0x3200]        # 4fd8 <__cxa_finalize@GLIBC_2.2.5>
    1dd8:	call   1d40 <_start+0x30>
    1ddd:	mov    BYTE PTR [rip+0x3324],0x1        # 5108 <stderr@GLIBC_2.2.5+0x8>
    1de4:	pop    rbp
    1de5:	ret
    1de6:	cs nop WORD PTR [rax+rax*1+0x0]
    1df0:	ret
    1df1:	nop    DWORD PTR [rax+0x0]
    1df5:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1e00:	endbr64
    1e04:	jmp    1d70 <_start+0x60>
    1e09:	cs nop WORD PTR [rax+rax*1+0x0]
    1e13:	cs nop WORD PTR [rax+rax*1+0x0]
    1e1d:	cs nop WORD PTR [rax+rax*1+0x0]
    1e27:	cs nop WORD PTR [rax+rax*1+0x0]
    1e31:	cs nop WORD PTR [rax+rax*1+0x0]
    1e3b:	nop    DWORD PTR [rax+rax*1+0x0]

0000000000001e40 <__profile_end_pass>:
}

static
void __profile_end_pass(Profile_Pass pass)
{
    1e40:	mov    r8,QWORD PTR [rsp+0x30]
    1e45:	rdtsc
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    1e47:	lea    rdi,[rip+0x32d2]        # 5120 <g_profiler>
  u64 elapsed = read_cpu_timer() - pass.start;
    1e4e:	mov    rcx,QWORD PTR [rsp+0x18]

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
  current->elapsed_exclusive += elapsed;
  current->hit_count += 1;
  current->name = pass.name; // Stupid...
    1e53:	movdqu xmm0,XMMWORD PTR [rsp+0x8]
    1e59:	shl    rdx,0x20
  g_profiler.current_parent_zone = pass.parent_index;
    1e5d:	mov    QWORD PTR [rip+0x32c4],r8        # 5128 <g_profiler+0x8>
    1e64:	or     rax,rdx
  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    1e67:	mov    rdx,QWORD PTR [rsp+0x28]
  u64 elapsed = read_cpu_timer() - pass.start;
    1e6c:	mov    rsi,rax
  current->elapsed_exclusive += elapsed;
    1e6f:	lea    rdx,[rdx+rdx*4]
  u64 elapsed = read_cpu_timer() - pass.start;
    1e73:	sub    rsi,rcx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
  parent->elapsed_exclusive -= elapsed;
    1e76:	sub    rcx,rax
  current->elapsed_exclusive += elapsed;
    1e79:	add    QWORD PTR [rdi+rdx*8+0x20],rsi
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    1e7e:	add    rsi,QWORD PTR [rsp+0x20]
  current->hit_count += 1;
    1e83:	add    QWORD PTR [rdi+rdx*8+0x30],0x1
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    1e89:	mov    QWORD PTR [rdi+rdx*8+0x28],rsi
  current->name = pass.name; // Stupid...
    1e8e:	movups XMMWORD PTR [rdi+rdx*8+0x10],xmm0
  parent->elapsed_exclusive -= elapsed;
    1e93:	lea    rdx,[r8+r8*4]
    1e97:	add    QWORD PTR [rdi+rdx*8+0x20],rcx
}
    1e9c:	ret
    1e9d:	nop    DWORD PTR [rax]

0000000000001ea0 <lookup_json_object>:
{
    1ea0:	push   r12
    1ea2:	push   rbp
    1ea3:	mov    rbp,rdx
    1ea6:	push   rbx
    1ea7:	sub    rsp,0x30
    .parent_index = g_profiler.current_parent_zone,
    1eab:	mov    rcx,QWORD PTR [rip+0x3276]        # 5128 <g_profiler+0x8>
  g_profiler.current_parent_zone = zone_index;
    1eb2:	mov    QWORD PTR [rip+0x326b],0x4        # 5128 <g_profiler+0x8>
    1ebd:	rdtsc
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    1ebf:	mov    rbx,QWORD PTR [rdi+0x20]
    1ec3:	shl    rdx,0x20
  return pass;
    1ec7:	mov    QWORD PTR [rsp+0x28],rcx
    1ecc:	mov    QWORD PTR [rsp+0x8],0x12
    1ed5:	or     rax,rdx
    1ed8:	lea    rdx,[rip+0x19b1]        # 3890 <__func__.1>
    1edf:	movq   xmm0,rax
    1ee4:	mov    QWORD PTR [rsp],rdx
    1ee8:	movhps xmm0,QWORD PTR [rip+0x32f9]        # 51e8 <g_profiler+0xc8>
    1eef:	mov    QWORD PTR [rsp+0x20],0x4
    1ef8:	movaps XMMWORD PTR [rsp+0x10],xmm0
    1efd:	test   rbx,rbx
    1f00:	je     1f31 <lookup_json_object+0x91>
    1f02:	mov    r12,rsi
    1f05:	jmp    1f19 <lookup_json_object+0x79>
    1f07:	nop    WORD PTR [rax+rax*1+0x0]
    1f10:	mov    rbx,QWORD PTR [rbx+0x28]
    1f14:	test   rbx,rbx
    1f17:	je     1f31 <lookup_json_object+0x91>
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1f19:	cmp    rbp,QWORD PTR [rbx+0x8]
    1f1d:	jne    1f10 <lookup_json_object+0x70>
    1f1f:	mov    rsi,QWORD PTR [rbx]
    1f22:	mov    rdx,rbp
    1f25:	mov    rdi,r12
    1f28:	call   10d0 <memcmp@plt>
    1f2d:	test   eax,eax
    1f2f:	jne    1f10 <lookup_json_object+0x70>
  profile_end_func();
    1f31:	sub    rsp,0x30
    1f35:	movdqa xmm0,XMMWORD PTR [rsp+0x30]
    1f3b:	movups XMMWORD PTR [rsp],xmm0
    1f3f:	movdqa xmm0,XMMWORD PTR [rsp+0x40]
    1f45:	movups XMMWORD PTR [rsp+0x10],xmm0
    1f4a:	movdqa xmm0,XMMWORD PTR [rsp+0x50]
    1f50:	movups XMMWORD PTR [rsp+0x20],xmm0
    1f55:	call   1e40 <__profile_end_pass>
}
    1f5a:	add    rsp,0x60
    1f5e:	mov    rax,rbx
    1f61:	pop    rbx
    1f62:	pop    rbp
    1f63:	pop    r12
    1f65:	ret
    1f66:	cs nop WORD PTR [rax+rax*1+0x0]

0000000000001f70 <file_size>:
{
    1f70:	sub    rsp,0xa8
  stat(name, &stats);
    1f77:	mov    rsi,QWORD PTR fs:0x28
    1f80:	mov    QWORD PTR [rsp+0x98],rsi
    1f88:	mov    rsi,rsp
    1f8b:	call   1100 <stat@plt>
  return stats.st_size;
    1f90:	mov    rax,QWORD PTR [rsp+0x30]
}
    1f95:	mov    rdx,QWORD PTR [rsp+0x98]
    1f9d:	sub    rdx,QWORD PTR fs:0x28
    1fa6:	jne    1fb0 <file_size+0x40>
    1fa8:	add    rsp,0xa8
    1faf:	ret
    1fb0:	call   1060 <__stack_chk_fail@plt>
    1fb5:	data16 cs nop WORD PTR [rax+rax*1+0x0]

0000000000001fc0 <strings_equal>:
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1fc0:	cmp    rsi,rcx
    1fc3:	je     1fd0 <strings_equal+0x10>
    1fc5:	xor    eax,eax
}
    1fc7:	ret
    1fc8:	nop    DWORD PTR [rax+rax*1+0x0]
    1fd0:	mov    rax,rdx
{
    1fd3:	sub    rsp,0x8
    1fd7:	mov    rdx,rsi
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1fda:	mov    rsi,rax
    1fdd:	call   10d0 <memcmp@plt>
    1fe2:	test   eax,eax
    1fe4:	sete   al
}
    1fe7:	add    rsp,0x8
    1feb:	ret
    1fec:	nop    DWORD PTR [rax+0x0]

0000000000001ff0 <log_message>:
{
    1ff0:	push   rbp
    1ff1:	mov    r10,rdx
    1ff4:	mov    rbp,rcx
    1ff7:	push   rbx
    1ff8:	sub    rsp,0xd8
    1fff:	mov    QWORD PTR [rsp+0x40],r8
    2004:	mov    QWORD PTR [rsp+0x48],r9
    2009:	test   al,al
    200b:	je     2044 <log_message+0x54>
    200d:	movaps XMMWORD PTR [rsp+0x50],xmm0
    2012:	movaps XMMWORD PTR [rsp+0x60],xmm1
    2017:	movaps XMMWORD PTR [rsp+0x70],xmm2
    201c:	movaps XMMWORD PTR [rsp+0x80],xmm3
    2024:	movaps XMMWORD PTR [rsp+0x90],xmm4
    202c:	movaps XMMWORD PTR [rsp+0xa0],xmm5
    2034:	movaps XMMWORD PTR [rsp+0xb0],xmm6
    203c:	movaps XMMWORD PTR [rsp+0xc0],xmm7
  FILE *stream = stderr;
    2044:	mov    rbx,QWORD PTR fs:0x28
    204d:	mov    QWORD PTR [rsp+0x18],rbx
    2052:	mov    rbx,QWORD PTR [rip+0x30a7]        # 5100 <stderr@GLIBC_2.2.5>
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    2059:	mov    eax,edi
    205b:	lea    rcx,[rip+0x305e]        # 50c0 <level_strings>
    2062:	mov    rdx,QWORD PTR [rcx+rax*8]
  if (level <= LOG_ERROR)
    2066:	cmp    edi,0x1
    2069:	jbe    20e8 <log_message+0xf8>
      stream = stdout;
    206b:	cmp    edi,0x3
    206e:	cmove  rbx,QWORD PTR [rip+0x306a]        # 50e0 <stdout@GLIBC_2.2.5>
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    2076:	xor    eax,eax
    2078:	lea    rsi,[rip+0xfba]        # 3039 <_IO_stdin_used+0x39>
    207f:	mov    rdi,rbx
    2082:	call   10f0 <fprintf@plt>
  vfprintf(stream, message, args);
    2087:	mov    rsi,rbp
    208a:	mov    rdi,rbx
    208d:	mov    rdx,rsp
  va_start(args, message);
    2090:	mov    DWORD PTR [rsp],0x20
    2097:	lea    rax,[rsp+0xf0]
    209f:	mov    DWORD PTR [rsp+0x4],0x30
    20a7:	mov    QWORD PTR [rsp+0x8],rax
    20ac:	lea    rax,[rsp+0x20]
    20b1:	mov    QWORD PTR [rsp+0x10],rax
  vfprintf(stream, message, args);
    20b6:	call   1120 <vfprintf@plt>
  fprintf(stream, "\n");
    20bb:	mov    rsi,rbx
    20be:	mov    edi,0xa
    20c3:	call   10c0 <fputc@plt>
}
    20c8:	mov    rax,QWORD PTR [rsp+0x18]
    20cd:	sub    rax,QWORD PTR fs:0x28
    20d6:	jne    2101 <log_message+0x111>
    20d8:	add    rsp,0xd8
    20df:	pop    rbx
    20e0:	pop    rbp
    20e1:	ret
    20e2:	nop    WORD PTR [rax+rax*1+0x0]
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    20e8:	mov    rcx,rsi
    20eb:	mov    r8,r10
    20ee:	lea    rsi,[rip+0xf2d]        # 3022 <_IO_stdin_used+0x22>
    20f5:	mov    rdi,rbx
    20f8:	xor    eax,eax
    20fa:	call   10f0 <fprintf@plt>
    20ff:	jmp    2087 <log_message+0x97>
}
    2101:	call   1060 <__stack_chk_fail@plt>
    2106:	cs nop WORD PTR [rax+rax*1+0x0]

0000000000002110 <read_file_to_memory>:
{
    2110:	push   r12
    2112:	mov    r12,rsi
  FILE *file = fopen(name, "rb");
    2115:	lea    rsi,[rip+0xf2b]        # 3047 <_IO_stdin_used+0x47>
{
    211c:	push   rbp
    211d:	push   rbx
    211e:	mov    rbx,rdi
    2121:	sub    rsp,0x10
    2125:	mov    QWORD PTR [rsp+0x8],rdx
  FILE *file = fopen(name, "rb");
    212a:	call   1110 <fopen@plt>
  if (file == NULL)
    212f:	mov    rdx,QWORD PTR [rsp+0x8]
    2134:	test   rax,rax
    2137:	je     2163 <read_file_to_memory+0x53>
    2139:	mov    rbp,rax
  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    213c:	mov    rdi,r12
    213f:	mov    rcx,rax
    2142:	mov    esi,0x1
    2147:	call   1040 <fread@plt>
  fclose(file);
    214c:	mov    rdi,rbp
  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    214f:	mov    rbx,rax
  fclose(file);
    2152:	call   1050 <fclose@plt>
}
    2157:	add    rsp,0x10
    215b:	mov    rax,rbx
    215e:	pop    rbx
    215f:	pop    rbp
    2160:	pop    r12
    2162:	ret
    LOG_ERROR("Unable to open file: %s", name);
    2163:	mov    r8,rbx
    2166:	lea    rcx,[rip+0xedd]        # 304a <_IO_stdin_used+0x4a>
    216d:	xor    eax,eax
    216f:	xor    ebx,ebx
    2171:	mov    edx,0x17b
    2176:	lea    rsi,[rip+0xe98]        # 3015 <_IO_stdin_used+0x15>
    217d:	mov    edi,0x1
    2182:	call   1ff0 <log_message>
    return 0;
    2187:	jmp    2157 <read_file_to_memory+0x47>
    2189:	nop    DWORD PTR [rax+0x0]

0000000000002190 <arena_make>:
{
    2190:	push   rbp
    2191:	mov    rbp,rdi
    2194:	push   rbx
    2195:	mov    rbx,rsi
  arena.base = (u8 *)calloc(reserve_size, 1);
    2198:	mov    esi,0x1
    219d:	mov    rdi,rbx
{
    21a0:	sub    rsp,0x8
  arena.base = (u8 *)calloc(reserve_size, 1);
    21a4:	call   10e0 <calloc@plt>
  if (arena.base == NULL)
    21a9:	test   rax,rax
    21ac:	je     21cc <arena_make+0x3c>
  return arena;
    21ae:	movq   xmm0,rbx
    21b3:	mov    QWORD PTR [rbp+0x0],rax
}
    21b7:	mov    rax,rbp
  return arena;
    21ba:	mov    DWORD PTR [rbp+0x18],0x0
    21c1:	movups XMMWORD PTR [rbp+0x8],xmm0
}
    21c5:	add    rsp,0x8
    21c9:	pop    rbx
    21ca:	pop    rbp
    21cb:	ret
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    21cc:	xor    edi,edi
    21ce:	lea    rcx,[rip+0x10eb]        # 32c0 <_IO_stdin_used+0x2c0>
    21d5:	mov    edx,0x1d9
    21da:	lea    rsi,[rip+0xe34]        # 3015 <_IO_stdin_used+0x15>
    21e1:	call   1ff0 <log_message>
    21e6:	mov    edi,0xffffffff
    21eb:	call   1150 <exit@plt>

00000000000021f0 <arena_make_backed>:
{
    21f0:	sub    rsp,0x8
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    21f4:	test   rsi,rsi
    21f7:	je     11c0 <arena_make_backed.cold>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    21fd:	test   rdx,rdx
    2200:	je     11df <arena_make_backed.cold+0x1f>
    2206:	movq   xmm0,rdx
  return arena;
    220b:	mov    QWORD PTR [rdi],rsi
    220e:	mov    rax,rdi
    2211:	mov    DWORD PTR [rdi+0x18],0x1
    2218:	movups XMMWORD PTR [rdi+0x8],xmm0
}
    221c:	add    rsp,0x8
    2220:	ret
    2221:	nop    DWORD PTR [rax+0x0]
    2225:	data16 cs nop WORD PTR [rax+rax*1+0x0]

0000000000002230 <arena_free>:
{
    2230:	mov    rax,rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    2233:	test   BYTE PTR [rdi+0x18],0x1
    2237:	je     2248 <arena_free+0x18>
  ZERO_STRUCT(arena);
    2239:	pxor   xmm0,xmm0
    223d:	movups XMMWORD PTR [rdi],xmm0
    2240:	movups XMMWORD PTR [rdi+0x10],xmm0
    2244:	ret
    2245:	nop    DWORD PTR [rax]
{
    2248:	sub    rsp,0x18
    free(arena->base);
    224c:	mov    rdi,QWORD PTR [rdi]
    224f:	mov    QWORD PTR [rsp+0x8],rax
    2254:	call   1030 <free@plt>
    2259:	mov    rax,QWORD PTR [rsp+0x8]
  ZERO_STRUCT(arena);
    225e:	pxor   xmm0,xmm0
    2262:	movups XMMWORD PTR [rax],xmm0
    2265:	movups XMMWORD PTR [rax+0x10],xmm0
}
    2269:	add    rsp,0x18
    226d:	ret
    226e:	xchg   ax,ax

0000000000002270 <arena_alloc>:
void *arena_alloc(Arena *arena, isize size, isize alignment) {
    2270:	push   rbp
    2271:	push   rbx
    2272:	sub    rsp,0x8
  ASSERT(arena->base != NULL, "Arena memory is null");
    2276:	mov    rax,QWORD PTR [rdi]
    2279:	test   rax,rax
    227c:	je     11fe <arena_alloc.cold>
    2282:	mov    rcx,rdx
  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    2285:	mov    rdx,QWORD PTR [rdi+0x10]
  if ((aligned_offset + size) > arena->capacity)
    2289:	mov    r9,QWORD PTR [rdi+0x8]
    228d:	mov    rbx,rdi
  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    2290:	lea    rdx,[rdx+rcx*1-0x1]
    2295:	neg    rcx
    2298:	and    rdx,rcx
  if ((aligned_offset + size) > arena->capacity)
    229b:	lea    rbp,[rdx+rsi*1]
    229f:	cmp    rbp,r9
    22a2:	jg     22bd <arena_alloc+0x4d>
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    22a4:	lea    rdi,[rax+rdx*1]
    22a8:	mov    rdx,rsi
    22ab:	xor    esi,esi
    22ad:	call   10a0 <memset@plt>
  arena->next_offset = aligned_offset + size;
    22b2:	mov    QWORD PTR [rbx+0x10],rbp
}
    22b6:	add    rsp,0x8
    22ba:	pop    rbx
    22bb:	pop    rbp
    22bc:	ret
    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    22bd:	xor    edi,edi
    22bf:	mov    r8,rbp
    22c2:	lea    rcx,[rip+0x10e7]        # 33b0 <_IO_stdin_used+0x3b0>
    22c9:	xor    eax,eax
    22cb:	mov    edx,0x207
    22d0:	lea    rsi,[rip+0xd3e]        # 3015 <_IO_stdin_used+0x15>
    22d7:	call   1ff0 <log_message>
    22dc:	mov    edi,0xffffffff
    22e1:	call   1150 <exit@plt>
    22e6:	cs nop WORD PTR [rax+rax*1+0x0]

00000000000022f0 <read_file_to_arena>:
{
    22f0:	push   r15
    22f2:	push   r14
    22f4:	push   r13
    22f6:	push   r12
    22f8:	push   rbp
    22f9:	mov    rbp,rdi
    22fc:	push   rbx
    22fd:	sub    rsp,0xb8
    2304:	mov    r12,QWORD PTR fs:0x28
    230d:	mov    QWORD PTR [rsp+0xa8],r12
    2315:	mov    r12,rsi
  stat(name, &stats);
    2318:	lea    rsi,[rsp+0x10]
    231d:	mov    rdi,r12
    2320:	call   1100 <stat@plt>
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    2325:	mov    rdi,rbp
  Arena save = *arena;
    2328:	mov    r15,QWORD PTR [rbp+0x0]
    232c:	mov    r14d,DWORD PTR [rbp+0x18]
  return stats.st_size;
    2330:	mov    rbx,QWORD PTR [rsp+0x40]
  Arena save = *arena;
    2335:	movdqu xmm0,XMMWORD PTR [rbp+0x8]
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    233a:	mov    edx,0x1
    233f:	mov    rsi,rbx
  Arena save = *arena;
    2342:	movaps XMMWORD PTR [rsp],xmm0
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    2346:	call   2270 <arena_alloc>
  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    234b:	mov    rdx,rbx
    234e:	mov    rdi,r12
    2351:	mov    rsi,rax
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    2354:	mov    r13,rax
  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    2357:	call   2110 <read_file_to_memory>
    235c:	cmp    rax,rbx
    235f:	je     2394 <read_file_to_arena+0xa4>
    LOG_ERROR("Unable to read file: %s", name);
    2361:	mov    r8,r12
    2364:	mov    edx,0x19d
    2369:	mov    edi,0x1
    236e:	xor    eax,eax
    2370:	lea    rcx,[rip+0xceb]        # 3062 <_IO_stdin_used+0x62>
    2377:	lea    rsi,[rip+0xc97]        # 3015 <_IO_stdin_used+0x15>
    237e:	call   1ff0 <log_message>
    *arena = save; // Rollback allocation
    2383:	movdqa xmm0,XMMWORD PTR [rsp]
    2388:	mov    QWORD PTR [rbp+0x0],r15
    238c:	mov    DWORD PTR [rbp+0x18],r14d
    2390:	movups XMMWORD PTR [rbp+0x8],xmm0
  return result;
    2394:	mov    rax,r13
    2397:	mov    rdx,rbx
}
    239a:	mov    rcx,QWORD PTR [rsp+0xa8]
    23a2:	sub    rcx,QWORD PTR fs:0x28
    23ab:	jne    23bf <read_file_to_arena+0xcf>
    23ad:	add    rsp,0xb8
    23b4:	pop    rbx
    23b5:	pop    rbp
    23b6:	pop    r12
    23b8:	pop    r13
    23ba:	pop    r14
    23bc:	pop    r15
    23be:	ret
    23bf:	call   1060 <__stack_chk_fail@plt>
    23c4:	nop
    23c5:	data16 cs nop WORD PTR [rax+rax*1+0x0]

00000000000023d0 <arena_pop_to>:
  ASSERT(offset < arena->next_offset,
    23d0:	cmp    QWORD PTR [rdi+0x10],rsi
    23d4:	jle    121d <arena_pop_to.cold>
  arena->next_offset = offset;
    23da:	mov    QWORD PTR [rdi+0x10],rsi
    23de:	ret
    23df:	nop

00000000000023e0 <arena_pop>:
  arena_pop_to(arena, arena->next_offset - size);
    23e0:	mov    rdx,QWORD PTR [rdi+0x10]
    23e4:	mov    rax,rdx
    23e7:	sub    rax,rsi
  ASSERT(offset < arena->next_offset,
    23ea:	cmp    rdx,rax
    23ed:	jle    1223 <arena_pop.cold>
  arena->next_offset = offset;
    23f3:	mov    QWORD PTR [rdi+0x10],rax
    23f7:	ret
    23f8:	nop    DWORD PTR [rax+rax*1+0x0]

0000000000002400 <arena_clear>:
  arena->next_offset = 0;
    2400:	mov    QWORD PTR [rdi+0x10],0x0
}
    2408:	ret
    2409:	nop    DWORD PTR [rax+0x0]

0000000000002410 <scratch_begin>:
  return scratch;
    2410:	mov    rdx,QWORD PTR [rdi+0x10]
    2414:	mov    rax,rdi
}
    2417:	ret
    2418:	nop    DWORD PTR [rax+rax*1+0x0]

0000000000002420 <scratch_end>:
  arena_pop_to(scratch->arena, scratch->offset_save);
    2420:	mov    rax,QWORD PTR [rdi]
    2423:	mov    rdx,QWORD PTR [rdi+0x8]
  ASSERT(offset < arena->next_offset,
    2427:	cmp    rdx,QWORD PTR [rax+0x10]
    242b:	jge    1229 <scratch_end.cold>
  ZERO_STRUCT(scratch);
    2431:	pxor   xmm0,xmm0
  arena->next_offset = offset;
    2435:	mov    QWORD PTR [rax+0x10],rdx
  ZERO_STRUCT(scratch);
    2439:	movups XMMWORD PTR [rdi],xmm0
    243c:	ret
    243d:	nop    DWORD PTR [rax]

0000000000002440 <get_json_token>:
  return parser->at < parser->source.count;
    2440:	mov    r8,QWORD PTR [rsi+0x10]
    2444:	mov    rdx,QWORD PTR [rsi+0x8]
{
    2448:	mov    r9,rdi
  while (parser_incomplete(parser)  &&
    244b:	cmp    r8,rdx
    244e:	jae    24cb <get_json_token+0x8b>
  return parser->source.data + parser->at;
    2450:	mov    rcx,QWORD PTR [rsi]
    2453:	mov    edi,0x800013
    2458:	nop    DWORD PTR [rax+rax*1+0x0]
    2460:	movzx  eax,BYTE PTR [rcx+r8*1]
    2465:	sub    eax,0x9
    2468:	cmp    al,0x17
    246a:	ja     24a0 <get_json_token+0x60>
    246c:	bt     rdi,rax
    2470:	jae    24a0 <get_json_token+0x60>
  parser->at += advance;
    2472:	add    r8,0x1
    2476:	mov    QWORD PTR [rsi+0x10],r8
  while (parser_incomplete(parser)  &&
    247a:	cmp    r8,rdx
    247d:	jne    2460 <get_json_token+0x20>
  parser->at += advance;
    247f:	add    rdx,0x1
  JSON_Token token = {0};
    2483:	xor    eax,eax
    2485:	xor    r10d,r10d
  parser->at += advance;
    2488:	mov    QWORD PTR [rsi+0x10],rdx
  JSON_Token token = {0};
    248c:	xor    edx,edx
  return token;
    248e:	mov    QWORD PTR [r9+0x10],rax
}
    2492:	mov    rax,r9
  return token;
    2495:	mov    DWORD PTR [r9],edx
    2498:	mov    QWORD PTR [r9+0x8],r10
}
    249c:	ret
    249d:	nop    DWORD PTR [rax]
  if (parser_incomplete(parser)) // If we've not reached the end of file
    24a0:	cmp    r8,rdx
    24a3:	jae    24cb <get_json_token+0x8b>
  return parser->source.data + parser->at;
    24a5:	lea    r10,[rcx+r8*1]
    switch (*parser_at(parser))
    24a9:	movzx  eax,BYTE PTR [r10]
    24ad:	sub    eax,0x22
    24b0:	cmp    al,0x5b
    24b2:	ja     2528 <get_json_token+0xe8>
    24b4:	lea    rdi,[rip+0x1265]        # 3720 <_IO_stdin_used+0x720>
    24bb:	movzx  eax,al
{
    24be:	sub    rsp,0x18
    switch (*parser_at(parser))
    24c2:	movsxd rax,DWORD PTR [rdi+rax*4]
    24c6:	add    rax,rdi
    24c9:	jmp    rax
    24cb:	mov    rdx,r8
    24ce:	jmp    247f <get_json_token+0x3f>
  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    24d0:	cmp    DWORD PTR [r10],0x736c6166
    24d7:	je     26c0 <get_json_token+0x280>
    24dd:	mov    QWORD PTR [rsp],r10
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    24e1:	lea    rcx,[rip+0xf08]        # 33f0 <_IO_stdin_used+0x3f0>
    24e8:	mov    edx,0xee
    24ed:	mov    QWORD PTR [rsp+0x8],r9
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    24f2:	lea    rsi,[rip+0xb0b]        # 3004 <_IO_stdin_used+0x4>
    24f9:	mov    edi,0x1
    24fe:	xor    eax,eax
    2500:	call   1ff0 <log_message>
    2505:	mov    r10,QWORD PTR [rsp]
    2509:	mov    r9,QWORD PTR [rsp+0x8]
  JSON_Token token = {0};
    250e:	xor    eax,eax
    2510:	xor    edx,edx
  return token;
    2512:	mov    QWORD PTR [r9+0x10],rax
}
    2516:	mov    rax,r9
  return token;
    2519:	mov    DWORD PTR [r9],edx
    251c:	mov    QWORD PTR [r9+0x8],r10
}
    2520:	add    rsp,0x18
    2524:	ret
    2525:	nop    DWORD PTR [rax]
  JSON_Token token = {0};
    2528:	xor    eax,eax
    252a:	xor    edx,edx
    252c:	jmp    248e <get_json_token+0x4e>
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2531:	mov    rdi,QWORD PTR [rsi+0x10]
    2535:	cmp    rdi,rdx
    2538:	jae    122f <get_json_token.cold>
    253e:	sub    rdx,rdi
        usize digit_count = 0;
    2541:	xor    eax,eax
    2543:	lea    r8,[rcx+rdi*1]
        while (is_numeric(*parser_at(parser)))
    2547:	movzx  ecx,BYTE PTR [r8+rax*1]
  switch (ch)
    254c:	cmp    cl,0x2e
    254f:	ja     2697 <get_json_token+0x257>
    2555:	cmp    cl,0x2c
    2558:	ja     26a3 <get_json_token+0x263>
        token.type  = JSON_TOKEN_NUMBER;
    255e:	mov    edx,0x8
      break;
    2563:	jmp    2512 <get_json_token+0xd2>
  parser->at += advance;
    2565:	add    r8,0x1
        token.value.count = 1;
    2569:	mov    eax,0x1
        token.type = JSON_TOKEN_COMMA;
    256e:	mov    edx,0x5
  parser->at += advance;
    2573:	mov    QWORD PTR [rsi+0x10],r8
}
    2577:	jmp    2512 <get_json_token+0xd2>
  parser->at += advance;
    2579:	add    r8,0x1
        token.value.count = 1;
    257d:	mov    eax,0x1
        token.type = JSON_TOKEN_COLON;
    2582:	mov    edx,0x6
  parser->at += advance;
    2587:	mov    QWORD PTR [rsi+0x10],r8
}
    258b:	jmp    2512 <get_json_token+0xd2>
  parser->at += advance;
    258d:	add    r8,0x1
        token.value.count = 1;
    2591:	mov    eax,0x1
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2596:	mov    edx,0x3
  parser->at += advance;
    259b:	mov    QWORD PTR [rsi+0x10],r8
}
    259f:	jmp    2512 <get_json_token+0xd2>
  parser->at += advance;
    25a4:	add    r8,0x1
        token.value.count = 1;
    25a8:	mov    eax,0x1
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    25ad:	mov    edx,0x4
  parser->at += advance;
    25b2:	mov    QWORD PTR [rsi+0x10],r8
}
    25b6:	jmp    2512 <get_json_token+0xd2>
        if (parser_token_is_literal(parser, string))
    25bb:	cmp    DWORD PTR [r10],0x6c6c756e
    25c2:	jne    26df <get_json_token+0x29f>
  parser->at += advance;
    25c8:	add    r8,0x4
  JSON_Token token = {0};
    25cc:	xor    eax,eax
          token.type  = JSON_TOKEN_NULL;
    25ce:	mov    edx,0xb
  parser->at += advance;
    25d3:	mov    QWORD PTR [rsi+0x10],r8
}
    25d7:	jmp    2512 <get_json_token+0xd2>
        if (parser_token_is_literal(parser, string))
    25dc:	cmp    DWORD PTR [r10],0x65757274
    25e3:	jne    26f9 <get_json_token+0x2b9>
  parser->at += advance;
    25e9:	add    r8,0x4
  JSON_Token token = {0};
    25ed:	xor    eax,eax
          token.type  = JSON_TOKEN_TRUE;
    25ef:	mov    edx,0x9
  parser->at += advance;
    25f4:	mov    QWORD PTR [rsi+0x10],r8
}
    25f8:	jmp    2512 <get_json_token+0xd2>
  parser->at += advance;
    25fd:	add    r8,0x1
        token.value.count = 1;
    2601:	mov    eax,0x1
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2606:	mov    edx,0x2
  parser->at += advance;
    260b:	mov    QWORD PTR [rsi+0x10],r8
}
    260f:	jmp    2512 <get_json_token+0xd2>
  parser->at += advance;
    2614:	add    r8,0x1
        token.value.count = 1;
    2618:	mov    eax,0x1
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    261d:	mov    edx,0x1
  parser->at += advance;
    2622:	mov    QWORD PTR [rsi+0x10],r8
}
    2626:	jmp    2512 <get_json_token+0xd2>
  parser->at += advance;
    262b:	lea    r10,[r8+0x1]
    262f:	mov    QWORD PTR [rsi+0x10],r10
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2633:	cmp    r10,rdx
    2636:	jae    122f <get_json_token.cold>
    263c:	mov    rdi,r10
    263f:	jmp    266d <get_json_token+0x22d>
    2641:	nop    WORD PTR [rax+rax*1+0x0]
    264a:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    2655:	data16 cs nop WORD PTR [rax+rax*1+0x0]
  parser->at += advance;
    2660:	mov    QWORD PTR [rsi+0x10],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2664:	cmp    rdi,rdx
    2667:	jae    2713 <get_json_token+0x2d3>
        while (*parser_at(parser) != '"')
    266d:	movzx  r11d,BYTE PTR [rcx+rdi*1]
    2672:	mov    rax,rdi
  parser->at += advance;
    2675:	add    rdi,0x1
        while (*parser_at(parser) != '"')
    2679:	cmp    r11b,0x22
    267d:	jne    2660 <get_json_token+0x220>
        token.value.count = string_count;
    267f:	sub    rax,r8
  parser->at += advance;
    2682:	mov    QWORD PTR [rsi+0x10],rdi
  return parser->source.data + parser->at;
    2686:	add    r10,rcx
        token.type = JSON_TOKEN_STRING;
    2689:	mov    edx,0x7
        token.value.count = string_count;
    268e:	sub    rax,0x1
}
    2692:	jmp    2512 <get_json_token+0xd2>
  switch (ch)
    2697:	sub    ecx,0x30
    269a:	cmp    cl,0x9
    269d:	ja     255e <get_json_token+0x11e>
          digit_count += 1;
    26a3:	add    rax,0x1
  parser->at += advance;
    26a7:	lea    rcx,[rdi+rax*1]
    26ab:	mov    QWORD PTR [rsi+0x10],rcx
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    26af:	cmp    rdx,rax
    26b2:	jne    2547 <get_json_token+0x107>
    26b8:	jmp    122f <get_json_token.cold>
    26bd:	nop    DWORD PTR [rax]
  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    26c0:	cmp    BYTE PTR [r10+0x4],0x65
    26c5:	jne    24dd <get_json_token+0x9d>
  parser->at += advance;
    26cb:	add    r8,0x5
  JSON_Token token = {0};
    26cf:	xor    eax,eax
          token.type  = JSON_TOKEN_FALSE;
    26d1:	mov    edx,0xa
  parser->at += advance;
    26d6:	mov    QWORD PTR [rsi+0x10],r8
}
    26da:	jmp    2512 <get_json_token+0xd2>
    26df:	mov    QWORD PTR [rsp],r10
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    26e3:	lea    rcx,[rip+0xd06]        # 33f0 <_IO_stdin_used+0x3f0>
    26ea:	mov    edx,0xfd
    26ef:	mov    QWORD PTR [rsp+0x8],r9
    26f4:	jmp    24f2 <get_json_token+0xb2>
    26f9:	mov    QWORD PTR [rsp],r10
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    26fd:	lea    rcx,[rip+0xcec]        # 33f0 <_IO_stdin_used+0x3f0>
    2704:	mov    edx,0xdf
    2709:	mov    QWORD PTR [rsp+0x8],r9
    270e:	jmp    24f2 <get_json_token+0xb2>
    2713:	jmp    122f <get_json_token.cold>
    2718:	nop    DWORD PTR [rax+rax*1+0x0]

0000000000002720 <parse_json_children>:
{
    2720:	push   r15
    2722:	push   r14
    2724:	push   r13
    2726:	push   r12
    2728:	push   rbp
    2729:	push   rbx
    272a:	sub    rsp,0xc8
    .parent_index = g_profiler.current_parent_zone,
    2731:	mov    r8,QWORD PTR [rip+0x29f0]        # 5128 <g_profiler+0x8>
    2738:	mov    QWORD PTR [rsp+0x10],rdi
    273d:	mov    r13,QWORD PTR fs:0x28
    2746:	mov    QWORD PTR [rsp+0xb8],r13
    274e:	mov    r13d,edx
  g_profiler.current_parent_zone = zone_index;
    2751:	mov    QWORD PTR [rip+0x29cc],0x2        # 5128 <g_profiler+0x8>
    275c:	rdtsc
    275e:	shl    rdx,0x20
  return pass;
    2762:	mov    QWORD PTR [rsp+0xa8],r8
    276a:	mov    QWORD PTR [rsp+0x88],0x13
    2776:	or     rax,rdx
    2779:	lea    rdx,[rip+0x1130]        # 38b0 <__func__.2>
    2780:	movq   xmm0,rax
  while (parser_incomplete(parser))
    2785:	mov    rax,QWORD PTR [rsi+0x8]
    2789:	movhps xmm0,QWORD PTR [rip+0x2a08]        # 5198 <g_profiler+0x78>
    2790:	mov    QWORD PTR [rsp+0x80],rdx
    2798:	mov    QWORD PTR [rsp+0xa0],0x2
    27a4:	movaps XMMWORD PTR [rsp+0x90],xmm0
    27ac:	cmp    QWORD PTR [rsi+0x10],rax
    27b0:	jae    29d1 <parse_json_children+0x2b1>
    27b6:	mov    DWORD PTR [rsp+0xc],ecx
    27ba:	mov    r15,rsi
  JSON_Object *current_last_child = NULL;
    27bd:	xor    r12d,r12d
  JSON_Object *first_child        = NULL;
    27c0:	xor    r14d,r14d
    27c3:	xchg   ax,ax
    27c5:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    if (has_keys)
    27d0:	mov    ecx,DWORD PTR [rsp+0xc]
    JSON_Token key_token = {0};
    27d4:	pxor   xmm0,xmm0
    27d8:	mov    QWORD PTR [rsp+0x30],0x0
    JSON_Token value_token = {0};
    27e1:	mov    QWORD PTR [rsp+0x50],0x0
    JSON_Token key_token = {0};
    27ea:	movaps XMMWORD PTR [rsp+0x20],xmm0
    JSON_Token value_token = {0};
    27ef:	movaps XMMWORD PTR [rsp+0x40],xmm0
    if (has_keys)
    27f4:	test   ecx,ecx
    27f6:	je     2948 <parse_json_children+0x228>
      key_token = get_json_token(parser);
    27fc:	lea    rdi,[rsp+0x20]
    2801:	mov    rsi,r15
    2804:	call   2440 <get_json_token>
    2809:	mov    eax,DWORD PTR [rsp+0x20]
    280d:	mov    r10,QWORD PTR [rsp+0x28]
    2812:	mov    rbx,QWORD PTR [rsp+0x30]
      if (key_token.type == JSON_TOKEN_STRING)
    2817:	cmp    eax,0x7
    281a:	je     2980 <parse_json_children+0x260>
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2820:	sub    rsp,0x8
    2824:	mov    edx,0x164
    2829:	mov    r9d,ebx
    282c:	mov    edi,0x1
    2831:	push   r10
    2833:	lea    rcx,[rip+0x2526]        # 4d60 <JSON_Token_Type_strings>
    283a:	lea    rsi,[rip+0x7c3]        # 3004 <_IO_stdin_used+0x4>
    2841:	mov    r8,QWORD PTR [rcx+rax*8]
    2845:	xor    eax,eax
    2847:	lea    rcx,[rip+0xbf2]        # 3440 <_IO_stdin_used+0x440>
    284e:	mov    QWORD PTR [rsp+0x28],r10
    2853:	call   1ff0 <log_message>
    2858:	pop    rax
    2859:	pop    rdx
    285a:	mov    r10,QWORD PTR [rsp+0x18]
    285f:	lea    rbp,[rsp+0x60]
    JSON_Token value_token = {0};
    2864:	xor    eax,eax
    2866:	cs nop WORD PTR [rax+rax*1+0x0]
    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2870:	mov    QWORD PTR [rsp+0x30],rbx
    2875:	sub    rsp,0x20
    2879:	mov    rsi,r15
    287c:	mov    QWORD PTR [rsp+0x48],r10
    2881:	mov    DWORD PTR [rsp+0x60],eax
    2885:	movdqa xmm0,XMMWORD PTR [rsp+0x60]
    288b:	mov    rax,QWORD PTR [rsp+0x70]
    2890:	mov    rdx,QWORD PTR [rsp+0x48]
    2895:	mov    rcx,QWORD PTR [rsp+0x50]
    289a:	mov    rdi,QWORD PTR [rsp+0x30]
    289f:	movups XMMWORD PTR [rsp],xmm0
    28a3:	mov    QWORD PTR [rsp+0x10],rax
    28a8:	call   2a60 <parse_json_object>
      if (!first_child)
    28ad:	add    rsp,0x20
    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    28b1:	mov    rbx,rax
      if (!first_child)
    28b4:	test   r14,r14
    28b7:	je     2970 <parse_json_children+0x250>
        current_last_child->next_sibling = object;
    28bd:	mov    QWORD PTR [r12+0x28],rax
    JSON_Token expect_comma_or_end = get_json_token(parser);
    28c2:	mov    rsi,r15
    28c5:	mov    rdi,rbp
    28c8:	call   2440 <get_json_token>
    28cd:	mov    eax,DWORD PTR [rsp+0x60]
    if (expect_comma_or_end.type == end_token)
    28d1:	cmp    r13d,eax
    28d4:	je     29e0 <parse_json_children+0x2c0>
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    28da:	cmp    eax,0x5
    28dd:	je     292c <parse_json_children+0x20c>
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    28df:	mov    r9,QWORD PTR [rsp+0x70]
    28e4:	sub    rsp,0x18
    28e8:	lea    rcx,[rip+0x2471]        # 4d60 <JSON_Token_Type_strings>
    28ef:	mov    edx,0x18b
    28f4:	movdqa xmm0,XMMWORD PTR [rsp+0x78]
    28fa:	mov    r8,QWORD PTR [rcx+rax*8]
    28fe:	mov    edi,0x1
    2903:	xor    eax,eax
    2905:	mov    QWORD PTR [rsp+0x10],r9
    290a:	lea    rcx,[rip+0xb57]        # 3468 <_IO_stdin_used+0x468>
    2911:	lea    rsi,[rip+0x6ec]        # 3004 <_IO_stdin_used+0x4>
    2918:	movups XMMWORD PTR [rsp],xmm0
    291c:	push   QWORD PTR [rsp+0x80]
    2923:	call   1ff0 <log_message>
    2928:	add    rsp,0x20
  while (parser_incomplete(parser))
    292c:	mov    rax,QWORD PTR [r15+0x8]
    2930:	cmp    QWORD PTR [r15+0x10],rax
    2934:	jae    29e0 <parse_json_children+0x2c0>
    293a:	mov    r12,rbx
    293d:	jmp    27d0 <parse_json_children+0xb0>
    2942:	nop    WORD PTR [rax+rax*1+0x0]
      value_token = get_json_token(parser);
    2948:	lea    rdi,[rsp+0x40]
    294d:	mov    rsi,r15
    JSON_Token key_token = {0};
    2950:	xor    ebx,ebx
      value_token = get_json_token(parser);
    2952:	call   2440 <get_json_token>
    2957:	mov    eax,DWORD PTR [rsp+0x40]
    JSON_Token key_token = {0};
    295b:	xor    r10d,r10d
    if (value_token.type == end_token)
    295e:	cmp    eax,r13d
    2961:	je     29e0 <parse_json_children+0x2c0>
    2963:	lea    rbp,[rsp+0x60]
    2968:	jmp    2870 <parse_json_children+0x150>
    296d:	nop    DWORD PTR [rax]
        first_child        = object;
    2970:	mov    r14,rax
    2973:	jmp    28c2 <parse_json_children+0x1a2>
    2978:	nop    DWORD PTR [rax+rax*1+0x0]
        JSON_Token expect_colon = get_json_token(parser);
    2980:	lea    rbp,[rsp+0x60]
    2985:	mov    rsi,r15
    2988:	mov    QWORD PTR [rsp+0x18],r10
    298d:	mov    rdi,rbp
    2990:	call   2440 <get_json_token>
        if (expect_colon.type == JSON_TOKEN_COLON)
    2995:	cmp    DWORD PTR [rsp+0x60],0x6
    299a:	je     2a40 <parse_json_children+0x320>
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    29a0:	mov    r9,QWORD PTR [rsp+0x18]
    29a5:	mov    r8d,ebx
    29a8:	mov    edx,0x15f
    29ad:	xor    eax,eax
    29af:	lea    rcx,[rip+0xa6a]        # 3420 <_IO_stdin_used+0x420>
    29b6:	lea    rsi,[rip+0x647]        # 3004 <_IO_stdin_used+0x4>
    29bd:	mov    edi,0x1
    29c2:	call   1ff0 <log_message>
    if (value_token.type == end_token)
    29c7:	mov    r10,QWORD PTR [rsp+0x18]
    29cc:	jmp    2864 <parse_json_children+0x144>
  JSON_Object *first_child        = NULL;
    29d1:	xor    r14d,r14d
    29d4:	nop
    29d5:	data16 cs nop WORD PTR [rax+rax*1+0x0]
  profile_end_func();
    29e0:	sub    rsp,0x30
    29e4:	movdqa xmm0,XMMWORD PTR [rsp+0xb0]
    29ed:	movups XMMWORD PTR [rsp],xmm0
    29f1:	movdqa xmm0,XMMWORD PTR [rsp+0xc0]
    29fa:	movups XMMWORD PTR [rsp+0x10],xmm0
    29ff:	movdqa xmm0,XMMWORD PTR [rsp+0xd0]
    2a08:	movups XMMWORD PTR [rsp+0x20],xmm0
    2a0d:	call   1e40 <__profile_end_pass>
  return first_child;
    2a12:	add    rsp,0x30
}
    2a16:	mov    rax,QWORD PTR [rsp+0xb8]
    2a1e:	sub    rax,QWORD PTR fs:0x28
    2a27:	jne    2a5b <parse_json_children+0x33b>
    2a29:	add    rsp,0xc8
    2a30:	mov    rax,r14
    2a33:	pop    rbx
    2a34:	pop    rbp
    2a35:	pop    r12
    2a37:	pop    r13
    2a39:	pop    r14
    2a3b:	pop    r15
    2a3d:	ret
    2a3e:	xchg   ax,ax
          value_token = get_json_token(parser);
    2a40:	lea    rdi,[rsp+0x40]
    2a45:	mov    rsi,r15
    2a48:	call   2440 <get_json_token>
    2a4d:	mov    eax,DWORD PTR [rsp+0x40]
    2a51:	mov    r10,QWORD PTR [rsp+0x18]
    2a56:	jmp    295e <parse_json_children+0x23e>
}
    2a5b:	call   1060 <__stack_chk_fail@plt>

0000000000002a60 <parse_json_object>:
{
    2a60:	push   r13
    2a62:	mov    r9,rdi
    2a65:	mov    r13,rcx
    2a68:	mov    rdi,rsi
    2a6b:	push   r12
    2a6d:	mov    r12,rdx
    2a70:	push   rbx
    2a71:	sub    rsp,0x40
    .parent_index = g_profiler.current_parent_zone,
    2a75:	mov    rsi,QWORD PTR [rip+0x26ac]        # 5128 <g_profiler+0x8>
  g_profiler.current_parent_zone = zone_index;
    2a7c:	mov    QWORD PTR [rip+0x26a1],0x1        # 5128 <g_profiler+0x8>
    2a87:	mov    ecx,DWORD PTR [rsp+0x60]
    2a8b:	rdtsc
  return pass;
    2a8d:	lea    rbx,[rip+0xe3c]        # 38d0 <__func__.3>
    2a94:	shl    rdx,0x20
    2a98:	mov    QWORD PTR [rsp+0x10],rbx
    2a9d:	or     rax,rdx
    2aa0:	mov    QWORD PTR [rsp+0x38],rsi
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    2aa5:	mov    edx,0x2
    2aaa:	mov    QWORD PTR [rsp+0x18],0x11
    2ab3:	movq   xmm0,rax
    2ab8:	movhps xmm0,QWORD PTR [rip+0x26b1]        # 5170 <g_profiler+0x50>
    2abf:	mov    QWORD PTR [rsp+0x30],0x1
    2ac8:	movaps XMMWORD PTR [rsp+0x20],xmm0
  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2acd:	cmp    ecx,0x1
    2ad0:	je     2ba7 <parse_json_object+0x147>
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2ad6:	cmp    ecx,0x3
    2ad9:	je     2ba0 <parse_json_object+0x140>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2adf:	lea    eax,[rcx-0x7]
                       type == JSON_TOKEN_NULL   ||
    2ae2:	cmp    eax,0x4
    2ae5:	ja     2b58 <parse_json_object+0xf8>
  JSON_Object *first_child = NULL;
    2ae7:	xor    ebx,ebx
  JSON_Object *result  = arena_new(arena, JSON_Object);
    2ae9:	mov    rdi,r9
    2aec:	mov    edx,0x8
    2af1:	mov    esi,0x30
    2af6:	call   2270 <arena_alloc>
  result->value        = token.value;
    2afb:	movdqu xmm0,XMMWORD PTR [rsp+0x68]
  profile_end_func();
    2b01:	sub    rsp,0x30
  result->key          = key;
    2b05:	mov    QWORD PTR [rax],r12
  JSON_Object *result  = arena_new(arena, JSON_Object);
    2b08:	mov    r9,rax
  result->value        = token.value;
    2b0b:	movups XMMWORD PTR [rax+0x10],xmm0
  profile_end_func();
    2b0f:	movdqa xmm0,XMMWORD PTR [rsp+0x40]
  result->key          = key;
    2b15:	mov    QWORD PTR [rax+0x8],r13
  result->first_child  = first_child;
    2b19:	mov    QWORD PTR [rax+0x20],rbx
  result->next_sibling = NULL;
    2b1d:	mov    QWORD PTR [rax+0x28],0x0
  profile_end_func();
    2b25:	movups XMMWORD PTR [rsp],xmm0
    2b29:	movdqa xmm0,XMMWORD PTR [rsp+0x50]
    2b2f:	movups XMMWORD PTR [rsp+0x10],xmm0
    2b34:	movdqa xmm0,XMMWORD PTR [rsp+0x60]
    2b3a:	movups XMMWORD PTR [rsp+0x20],xmm0
    2b3f:	call   1e40 <__profile_end_pass>
}
    2b44:	add    rsp,0x70
    2b48:	mov    rax,r9
    2b4b:	pop    rbx
    2b4c:	pop    r12
    2b4e:	pop    r13
    2b50:	ret
    2b51:	nop    DWORD PTR [rax+0x0]
    2b58:	mov    QWORD PTR [rsp+0x8],r9
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2b5d:	lea    rax,[rip+0x21fc]        # 4d60 <JSON_Token_Type_strings>
    2b64:	mov    edx,0x134
    2b69:	lea    rsi,[rip+0x494]        # 3004 <_IO_stdin_used+0x4>
    2b70:	push   QWORD PTR [rsp+0x70]
    2b74:	mov    r8,QWORD PTR [rax+rcx*8]
    2b78:	mov    edi,0x1
    2b7d:	xor    eax,eax
    2b7f:	push   QWORD PTR [rsp+0x70]
    2b83:	lea    rcx,[rip+0x91e]        # 34a8 <_IO_stdin_used+0x4a8>
    2b8a:	call   1ff0 <log_message>
    2b8f:	pop    rax
    2b90:	pop    rdx
    2b91:	mov    r9,QWORD PTR [rsp+0x8]
    2b96:	jmp    2ae7 <parse_json_object+0x87>
    2b9b:	nop    DWORD PTR [rax+rax*1+0x0]
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2ba0:	xor    ecx,ecx
    2ba2:	mov    edx,0x4
    2ba7:	mov    rsi,rdi
    2baa:	mov    rdi,r9
    2bad:	mov    QWORD PTR [rsp+0x8],r9
    2bb2:	call   2720 <parse_json_children>
    2bb7:	mov    r9,QWORD PTR [rsp+0x8]
    2bbc:	mov    rbx,rax
    2bbf:	jmp    2ae9 <parse_json_object+0x89>
    2bc4:	nop
    2bc5:	data16 cs nop WORD PTR [rax+rax*1+0x0]

0000000000002bd0 <json_token_type_is_value_type>:
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2bd0:	sub    edi,0x7
                       type == JSON_TOKEN_NULL   ||
    2bd3:	xor    eax,eax
    2bd5:	cmp    edi,0x4
    2bd8:	setbe  al
}
    2bdb:	ret
    2bdc:	nop    DWORD PTR [rax+0x0]

0000000000002be0 <json_object_to_f64>:
  ASSERT(object, "Must pass valid object to f64 conversion");
    2be0:	test   rdi,rdi
    2be3:	je     1234 <json_object_to_f64.cold>

  String val = object->value;
    2be9:	mov    rcx,QWORD PTR [rdi+0x18]
  // Get sign.
  usize at = 0;

  f64 sign = 1.0;
  if (val.count > at && val.data[at] == '-')
    2bed:	pxor   xmm0,xmm0
    2bf1:	test   rcx,rcx
    2bf4:	je     2c7f <json_object_to_f64+0x9f>
  String val = object->value;
    2bfa:	mov    rsi,QWORD PTR [rdi+0x10]
  if (val.count > at && val.data[at] == '-')
    2bfe:	cmp    BYTE PTR [rsi],0x2d
    2c01:	je     2c80 <json_object_to_f64+0xa0>
  f64 sign = 1.0;
    2c03:	movsd  xmm4,QWORD PTR [rip+0xd65]        # 3970 <__PRETTY_FUNCTION__.9+0x20>
  usize at = 0;
    2c0b:	xor    edx,edx
  {
    u8 digit = val.data[at] - (u8)'0';
    if (digit < 10)
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    2c0d:	movsd  xmm2,QWORD PTR [rip+0xd73]        # 3988 <__PRETTY_FUNCTION__.9+0x38>
  f64 result = 0.0;
    2c15:	pxor   xmm0,xmm0
    2c19:	jmp    2c5c <json_object_to_f64+0x7c>
    2c1b:	nop    DWORD PTR [rax+0x0]
    2c1f:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    2c2a:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    2c35:	data16 cs nop WORD PTR [rax+rax*1+0x0]
      result = 10 * result + (f64)digit;
    2c40:	mulsd  xmm0,xmm2
    2c44:	movzx  eax,al
    2c47:	pxor   xmm1,xmm1
      at += 1;
    2c4b:	add    rdx,0x1
      result = 10 * result + (f64)digit;
    2c4f:	cvtsi2sd xmm1,eax
    2c53:	addsd  xmm0,xmm1
  while (at < val.count)
    2c57:	cmp    rdx,rcx
    2c5a:	jae    2c72 <json_object_to_f64+0x92>
    u8 digit = val.data[at] - (u8)'0';
    2c5c:	movzx  eax,BYTE PTR [rsi+rdx*1]
    2c60:	sub    eax,0x30
    if (digit < 10)
    2c63:	cmp    al,0x9
    2c65:	jbe    2c40 <json_object_to_f64+0x60>
      break;
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    2c67:	cmp    rdx,rcx
    2c6a:	jae    2c72 <json_object_to_f64+0x92>
    2c6c:	cmp    BYTE PTR [rsi+rdx*1],0x2e
    2c70:	je     2ca0 <json_object_to_f64+0xc0>
        break;
      }
    }
  }

  return sign * result;
    2c72:	mulsd  xmm0,xmm4
    2c76:	ret
  while (at < val.count)
    2c77:	movsd  xmm0,QWORD PTR [rip+0xd01]        # 3980 <__PRETTY_FUNCTION__.9+0x30>
}
    2c7f:	ret
  while (at < val.count)
    2c80:	cmp    rcx,0x1
    2c84:	je     2c77 <json_object_to_f64+0x97>
    2c86:	movsd  xmm4,QWORD PTR [rip+0xcda]        # 3968 <__PRETTY_FUNCTION__.9+0x18>
    2c8e:	mov    edx,0x1
    2c93:	jmp    2c0d <json_object_to_f64+0x2d>
    2c98:	nop    DWORD PTR [rax+rax*1+0x0]
    at += 1;
    2ca0:	add    rdx,0x1
    while (at < val.count)
    2ca4:	cmp    rdx,rcx
    2ca7:	jae    2c72 <json_object_to_f64+0x92>
    f64 factor = 1.0 / 10.0;
    2ca9:	movsd  xmm3,QWORD PTR [rip+0xcc7]        # 3978 <__PRETTY_FUNCTION__.9+0x28>
    2cb1:	movapd xmm2,xmm3
    2cb5:	jmp    2ce0 <json_object_to_f64+0x100>
    2cb7:	nop    WORD PTR [rax+rax*1+0x0]
        result = result + factor * (f64)digit;
    2cc0:	movzx  eax,al
    2cc3:	pxor   xmm1,xmm1
        at += 1;
    2cc7:	add    rdx,0x1
        result = result + factor * (f64)digit;
    2ccb:	cvtsi2sd xmm1,eax
    2ccf:	mulsd  xmm1,xmm2
        factor *= 1.0 / 10.0;
    2cd3:	mulsd  xmm2,xmm3
        result = result + factor * (f64)digit;
    2cd7:	addsd  xmm0,xmm1
    while (at < val.count)
    2cdb:	cmp    rdx,rcx
    2cde:	jae    2c72 <json_object_to_f64+0x92>
      u8 digit = val.data[at] - (u8)'0';
    2ce0:	movzx  eax,BYTE PTR [rsi+rdx*1]
    2ce4:	sub    eax,0x30
      if (digit < 10)
    2ce7:	cmp    al,0x9
    2ce9:	jbe    2cc0 <json_object_to_f64+0xe0>
    2ceb:	jmp    2c72 <json_object_to_f64+0x92>

Disassembly of section .fini:

0000000000002cf0 <_fini>:
    2cf0:	endbr64
    2cf4:	sub    rsp,0x8
    2cf8:	add    rsp,0x8
    2cfc:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x3fb9]        # 4fc8 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x3fca]        # 4ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x3fcc]        # 4ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x3fca]        # 5000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x3fc2]        # 5008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x3fba]        # 5010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x3fb2]        # 5018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x3faa]        # 5020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x3fa2]        # 5028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x3f9a]        # 5030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x3f92]        # 5038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x3f8a]        # 5040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x3f82]        # 5048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x3f7a]        # 5050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x3f72]        # 5058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x3f6a]        # 5060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x3f62]        # 5068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x3f5a]        # 5070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x3f52]        # 5078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x3f4a]        # 5080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x3f42]        # 5088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x3f3a]        # 5090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x3f32]        # 5098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001180 <parser_at.part.0>:
  String source;
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
    1180:	push   rax
{
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    1181:	lea    rcx,[rip+0x2790]        # 3918 <__PRETTY_FUNCTION__.6>
    1188:	mov    edx,0x2f
    118d:	lea    rsi,[rip+0x1e70]        # 3004 <_IO_stdin_used+0x4>
    1194:	lea    rdi,[rip+0x2075]        # 3210 <_IO_stdin_used+0x210>
    119b:	call   1090 <__assert_fail@plt>

00000000000011a0 <arena_pop_to.part.0>:
  arena->next_offset = aligned_offset + size;

  return ptr;
}

void arena_pop_to(Arena *arena, isize offset)
    11a0:	push   rax
{
  ASSERT(offset < arena->next_offset,
    11a1:	lea    rcx,[rip+0x2780]        # 3928 <__PRETTY_FUNCTION__.7>
    11a8:	mov    edx,0x217
    11ad:	lea    rsi,[rip+0x1e61]        # 3015 <_IO_stdin_used+0x15>
    11b4:	lea    rdi,[rip+0x20a5]        # 3260 <_IO_stdin_used+0x260>
    11bb:	call   1090 <__assert_fail@plt>

00000000000011c0 <arena_make_backed.cold>:
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    11c0:	lea    rcx,[rip+0x2789]        # 3950 <__PRETTY_FUNCTION__.9>
    11c7:	mov    edx,0x1e5
    11cc:	lea    rsi,[rip+0x1e42]        # 3015 <_IO_stdin_used+0x15>
    11d3:	lea    rdi,[rip+0x2106]        # 32e0 <_IO_stdin_used+0x2e0>
    11da:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    11df:	lea    rcx,[rip+0x276a]        # 3950 <__PRETTY_FUNCTION__.9>
    11e6:	mov    edx,0x1e6
    11eb:	lea    rsi,[rip+0x1e23]        # 3015 <_IO_stdin_used+0x15>
    11f2:	lea    rdi,[rip+0x2137]        # 3330 <_IO_stdin_used+0x330>
    11f9:	call   1090 <__assert_fail@plt>

00000000000011fe <arena_alloc.cold>:
  ASSERT(arena->base != NULL, "Arena memory is null");
    11fe:	lea    rcx,[rip+0x2733]        # 3938 <__PRETTY_FUNCTION__.8>
    1205:	mov    edx,0x1fe
    120a:	lea    rsi,[rip+0x1e04]        # 3015 <_IO_stdin_used+0x15>
    1211:	lea    rdi,[rip+0x2160]        # 3378 <_IO_stdin_used+0x378>
    1218:	call   1090 <__assert_fail@plt>

000000000000121d <arena_pop_to.cold>:
{
    121d:	push   rax
    121e:	call   11a0 <arena_pop_to.part.0>

0000000000001223 <arena_pop.cold>:
  // Should we zero out the memory?
  arena->next_offset = offset;
}

void arena_pop(Arena *arena, isize size)
{
    1223:	push   rax
    1224:	call   11a0 <arena_pop_to.part.0>

0000000000001229 <scratch_end.cold>:
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
  return scratch;
}

void scratch_end(Scratch *scratch)
{
    1229:	push   rax
    122a:	call   11a0 <arena_pop_to.part.0>

000000000000122f <get_json_token.cold>:
    122f:	call   1180 <parser_at.part.0>

0000000000001234 <json_object_to_f64.cold>:

  return result;
}

f64 json_object_to_f64(JSON_Object *object)
{
    1234:	push   rax
  ASSERT(object, "Must pass valid object to f64 conversion");
    1235:	lea    rcx,[rip+0x26c4]        # 3900 <__PRETTY_FUNCTION__.5>
    123c:	mov    edx,0x1c2
    1241:	lea    rsi,[rip+0x1dbc]        # 3004 <_IO_stdin_used+0x4>
    1248:	lea    rdi,[rip+0x22a9]        # 34f8 <_IO_stdin_used+0x4f8>
    124f:	call   1090 <__assert_fail@plt>
    1254:	cs nop WORD PTR [rax+rax*1+0x0]
    125e:	xchg   ax,ax

0000000000001260 <main>:

  return (fabs(a) - fabs(b)) <= epsilon;
}

int main(int args_count, char **args)
{
    1260:	push   r15
    1262:	push   r14
    1264:	push   r13
    1266:	push   r12
    1268:	push   rbp
    1269:	push   rbx
    126a:	sub    rsp,0x208
    1271:	mov    QWORD PTR [rsp+0x30],rsi
    1276:	mov    rax,QWORD PTR fs:0x28
    127f:	mov    QWORD PTR [rsp+0x1f8],rax
    1287:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    1289:	cmp    edi,0x3
    128c:	je     12cd <main+0x6d>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    128e:	mov    rsi,QWORD PTR [rsi]
    1291:	lea    rdi,[rip+0x2298]        # 3530 <_IO_stdin_used+0x530>
    1298:	xor    eax,eax
    129a:	call   1070 <printf@plt>
    return 1;
    129f:	mov    eax,0x1
  {
    arena_free(&arena);
  }

  end_profiling();
}
    12a4:	mov    rdx,QWORD PTR [rsp+0x1f8]
    12ac:	sub    rdx,QWORD PTR fs:0x28
    12b5:	jne    1d6d <main+0xb0d>
    12bb:	add    rsp,0x208
    12c2:	pop    rbx
    12c3:	pop    rbp
    12c4:	pop    r12
    12c6:	pop    r13
    12c8:	pop    r14
    12ca:	pop    r15
    12cc:	ret
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    12cd:	rdtsc
static Profiler g_profiler;

static
void begin_profiling()
{
  g_profiler = (Profiler)
    12cf:	xor    esi,esi
    12d1:	lea    rdi,[rip+0x3e48]        # 5120 <g_profiler>
    12d8:	shl    rdx,0x20
    12dc:	mov    rbx,rax
    12df:	or     rbx,rdx
    12e2:	mov    edx,0x30010
    12e7:	call   10a0 <memset@plt>
  Arena arena = {0};
    12ec:	xor    eax,eax
    12ee:	mov    ecx,0x8
    12f3:	lea    rdi,[rsp+0xa0]
    12fb:	rep stos DWORD PTR [rdi],eax
  arena = arena_make(GB(4));
    12fd:	mov    esi,0x1
    1302:	lea    rdi,[rsp+0x50]
    1307:	mov    QWORD PTR [rip+0x3e12],rbx        # 5120 <g_profiler>
    130e:	shl    rsi,0x20
    1312:	call   21e0 <arena_make>
    1317:	movdqu xmm0,XMMWORD PTR [rsp+0x50]
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    131d:	mov    QWORD PTR [rip+0x3e00],0x5        # 5128 <g_profiler+0x8>
    1328:	movaps XMMWORD PTR [rsp+0xa0],xmm0
    1330:	movdqu xmm0,XMMWORD PTR [rsp+0x60]
    1336:	movaps XMMWORD PTR [rsp+0xb0],xmm0
    133e:	rdtsc

  // Last!
  pass.start = read_cpu_timer();

  return pass;
    1340:	xor    r9d,r9d
    1343:	xor    r8d,r8d
    1346:	lea    rcx,[rip+0x1d33]        # 3080 <_IO_stdin_used+0x80>
    134d:	shl    rdx,0x20
    source = read_file_to_arena(&arena, args[1]);
    1351:	lea    r15,[rsp+0xa0]
    1359:	mov    QWORD PTR [rsp+0xc0],rcx
    1361:	or     rax,rdx
    1364:	mov    rdi,r15
    1367:	mov    QWORD PTR [rsp+0xc8],0x4
    1373:	mov    QWORD PTR [rsp+0xd0],rax
    137b:	mov    rax,QWORD PTR [rsp+0x30]
    1380:	mov    QWORD PTR [rsp+0xd8],r8
    1388:	mov    rsi,QWORD PTR [rax+0x8]
    138c:	mov    QWORD PTR [rsp+0xe8],r9
    1394:	mov    QWORD PTR [rsp+0xe0],0x5
    13a0:	mov    QWORD PTR [rsp+0xf0],r9
    13a8:	mov    QWORD PTR [rsp+0x38],r15
    13ad:	call   2340 <read_file_to_arena>
  PROFILE_SCOPE("read")
    13b2:	sub    rsp,0x40
    13b6:	mov    ecx,0xe
    13bb:	lea    rsi,[rsp+0x100]
    13c3:	mov    rdi,rsp
    source = read_file_to_arena(&arena, args[1]);
    13c6:	mov    rbx,rax
    13c9:	mov    rbp,rdx
  PROFILE_SCOPE("read")
    13cc:	rep movs DWORD PTR [rdi],DWORD PTR [rsi]
    13ce:	call   1e80 <__profile_end_pass.constprop.0>
    .parent_index = g_profiler.current_parent_zone,
    13d3:	mov    rcx,QWORD PTR [rip+0x3d4e]        # 5128 <g_profiler+0x8>
  g_profiler.current_parent_zone = zone_index;
    13da:	mov    QWORD PTR [rip+0x3d43],0x6        # 5128 <g_profiler+0x8>
    13e5:	rdtsc
  return pass;
    13e7:	xor    r10d,r10d
    13ea:	lea    rdi,[rip+0x1c94]        # 3085 <_IO_stdin_used+0x85>
    13f1:	shl    rdx,0x20
    13f5:	mov    QWORD PTR [rsp+0x168],rcx
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    13fd:	mov    ecx,0x18
    1402:	or     rax,rdx
    1405:	xor    edx,edx
    1407:	mov    QWORD PTR [rsp+0x140],rdi
    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    140f:	mov    rdi,r15
    1412:	movq   xmm0,rax
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    1417:	mov    rax,rbp
    141a:	mov    QWORD PTR [rsp+0x170],r10
    1422:	movhps xmm0,QWORD PTR [rip+0x3e3f]        # 5268 <g_profiler+0x148>
    1429:	div    rcx
    142c:	movaps XMMWORD PTR [rsp+0x150],xmm0
    1434:	mov    QWORD PTR [rsp+0x148],0xf
    1440:	mov    QWORD PTR [rsp+0x160],0x6
    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    144c:	mov    edx,0x8
    1451:	add    rsp,0x40
    1455:	mov    rsi,rax
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    1458:	mov    r12,rax
    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    145b:	shl    rsi,0x5
    145f:	call   22c0 <arena_alloc>
  PROFILE_SCOPE("haversine alloc")
    1464:	mov    ecx,0xe
    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    1469:	mov    QWORD PTR [rsp+0x20],rax
  PROFILE_SCOPE("haversine alloc")
    146e:	sub    rsp,0x40
    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    1472:	mov    r14,rax
  PROFILE_SCOPE("haversine alloc")
    1475:	lea    rsi,[rsp+0x140]
    147d:	mov    rdi,rsp
    1480:	rep movs DWORD PTR [rdi],DWORD PTR [rsi]
    1482:	call   1e80 <__profile_end_pass.constprop.0>
    .parent_index = g_profiler.current_parent_zone,
    1487:	mov    rcx,QWORD PTR [rip+0x3c9a]        # 5128 <g_profiler+0x8>
  g_profiler.current_parent_zone = zone_index;
    148e:	mov    QWORD PTR [rip+0x3c8f],0x3        # 5128 <g_profiler+0x8>
    1499:	rdtsc
  return pass;
    149b:	xor    r11d,r11d
    149e:	lea    rdi,[rip+0x2443]        # 38e8 <__func__.4>
    14a5:	shl    rdx,0x20
  JSON_Parser parser =
    14a9:	mov    QWORD PTR [rsp+0x1c0],rbx
    14b1:	xor    ebx,ebx
    14b3:	or     rax,rdx
    14b6:	mov    QWORD PTR [rsp+0x230],r11
    14be:	mov    QWORD PTR [rsp+0x200],rdi
    14c6:	movq   xmm0,rax
  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    14cb:	lea    rdi,[rsp+0xc0]
    14d3:	movhps xmm0,QWORD PTR [rip+0x3cfe]        # 51d8 <g_profiler+0xb8>
    14da:	mov    QWORD PTR [rsp+0x228],rcx
  JSON_Parser parser =
    14e2:	mov    QWORD PTR [rsp+0x1d0],rbx
    14ea:	movaps XMMWORD PTR [rsp+0x210],xmm0
    14f2:	mov    QWORD PTR [rsp+0x208],0xa
    14fe:	mov    QWORD PTR [rsp+0x220],0x3
    150a:	mov    QWORD PTR [rsp+0x1c8],rbp
  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    1512:	add    rsp,0x40
    1516:	lea    rbx,[rsp+0x180]
    151e:	mov    rsi,rbx
    1521:	mov    QWORD PTR [rsp+0x40],rbx
    1526:	call   2490 <get_json_token>
    152b:	sub    rsp,0x20
    152f:	xor    edx,edx
    1531:	mov    rsi,rbx
    1534:	movdqa xmm0,XMMWORD PTR [rsp+0xa0]
    153d:	mov    rax,QWORD PTR [rsp+0xb0]
    1545:	xor    ecx,ecx
    1547:	mov    rdi,r15
    154a:	movups XMMWORD PTR [rsp],xmm0
    154e:	mov    QWORD PTR [rsp+0x10],rax
    1553:	call   2ab0 <parse_json_object>
  profile_end_func();
    1558:	sub    rsp,0x20
    155c:	mov    ecx,0xe
    1561:	lea    rsi,[rsp+0x200]
    1569:	mov    rdi,rsp
  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    156c:	mov    r10,rax
  profile_end_func();
    156f:	mov    QWORD PTR [rsp+0x88],rsi
    1577:	rep movs DWORD PTR [rdi],DWORD PTR [rsi]
    1579:	call   1e80 <__profile_end_pass.constprop.0>
  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    157e:	add    rsp,0x40
    1582:	mov    edx,0x5
    1587:	mov    rdi,r10
    158a:	lea    rsi,[rip+0x1b04]        # 3095 <_IO_stdin_used+0x95>
    1591:	call   1ef0 <lookup_json_object>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    1596:	mov    rbx,QWORD PTR [rax+0x20]
    159a:	test   rbx,rbx
    159d:	je     1ceb <main+0xa8b>
    15a3:	cmp    rbp,0x17
    15a7:	jbe    1ceb <main+0xa8b>
    15ad:	mov    rbp,r14
    15b0:	mov    r15d,0x1
    15b6:	lea    r13,[rip+0x1ade]        # 309b <_IO_stdin_used+0x9b>
    15bd:	nop    DWORD PTR [rax]
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    15c0:	lea    rax,[rip+0x3b59]        # 5120 <g_profiler>
    15c7:	mov    rcx,QWORD PTR [rax+0x178]
    .parent_index = g_profiler.current_parent_zone,
    15ce:	mov    rsi,QWORD PTR [rax+0x8]
  g_profiler.current_parent_zone = zone_index;
    15d2:	mov    QWORD PTR [rip+0x3b4b],0x7        # 5128 <g_profiler+0x8>
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    15dd:	mov    QWORD PTR [rsp+0x8],rcx
    15e2:	rdtsc
    15e4:	shl    rdx,0x20
  return pass;
    15e8:	mov    QWORD PTR [rsp+0x1e8],rsi
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    15f0:	mov    rdi,rbx
    15f3:	lea    rsi,[rip+0x1aaf]        # 30a9 <_IO_stdin_used+0xa9>
    15fa:	or     rax,rdx
    15fd:	mov    edx,0x2
    1602:	mov    QWORD PTR [rsp+0x1c0],r13
    160a:	mov    QWORD PTR [rsp+0x1c8],0xd
    1616:	movq   xmm0,rax
    161b:	movhps xmm0,QWORD PTR [rsp+0x8]
    1620:	mov    QWORD PTR [rsp+0x1e0],0x7
    162c:	movaps XMMWORD PTR [rsp+0x1d0],xmm0
    1634:	mov    QWORD PTR [rsp+0x1f0],0x0
    1640:	call   1ef0 <lookup_json_object>
    1645:	mov    rdi,rax
    1648:	call   2c50 <json_object_to_f64>
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    164d:	lea    rsi,[rip+0x1a58]        # 30ac <_IO_stdin_used+0xac>
    1654:	mov    edx,0x2
    1659:	mov    rdi,rbx
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    165c:	movsd  QWORD PTR [rsp+0x8],xmm0
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    1662:	call   1ef0 <lookup_json_object>
    1667:	mov    rdi,rax
    166a:	call   2c50 <json_object_to_f64>
    166f:	movsd  xmm1,QWORD PTR [rsp+0x8]
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    1675:	mov    edx,0x2
    167a:	mov    rdi,rbx
    167d:	lea    rsi,[rip+0x1a2b]        # 30af <_IO_stdin_used+0xaf>
    1684:	unpcklpd xmm1,xmm0
    1688:	movaps XMMWORD PTR [rsp+0x10],xmm1
    168d:	call   1ef0 <lookup_json_object>
    1692:	mov    rdi,rax
    1695:	call   2c50 <json_object_to_f64>
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    169a:	lea    rsi,[rip+0x1a11]        # 30b2 <_IO_stdin_used+0xb2>
    16a1:	mov    edx,0x2
    16a6:	mov    rdi,rbx
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    16a9:	movsd  QWORD PTR [rsp+0x8],xmm0
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    16af:	call   1ef0 <lookup_json_object>
    16b4:	mov    rdi,rax
    16b7:	call   2c50 <json_object_to_f64>
        pairs[pair_count] = pair;
    16bc:	movsd  xmm4,QWORD PTR [rsp+0x8]
    16c2:	movapd xmm1,XMMWORD PTR [rsp+0x10]
      PROFILE_SCOPE("child convert")
    16c8:	sub    rsp,0x40
    16cc:	mov    rax,QWORD PTR [rsp+0x230]
        pairs[pair_count] = pair;
    16d4:	unpcklpd xmm4,xmm0
    16d8:	movups XMMWORD PTR [rbp+0x0],xmm1
      PROFILE_SCOPE("child convert")
    16dc:	movdqa xmm0,XMMWORD PTR [rsp+0x200]
        pairs[pair_count] = pair;
    16e5:	movups XMMWORD PTR [rbp+0x10],xmm4
      PROFILE_SCOPE("child convert")
    16e9:	movups XMMWORD PTR [rsp],xmm0
    16ed:	movdqa xmm0,XMMWORD PTR [rsp+0x210]
    16f6:	mov    QWORD PTR [rsp+0x30],rax
    16fb:	movups XMMWORD PTR [rsp+0x10],xmm0
    1700:	movdqa xmm0,XMMWORD PTR [rsp+0x220]
    1709:	movups XMMWORD PTR [rsp+0x20],xmm0
    170e:	call   1e80 <__profile_end_pass.constprop.0>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    1713:	mov    rbx,QWORD PTR [rbx+0x28]
    1717:	add    rsp,0x40
    171b:	mov    rsi,r15
    171e:	test   rbx,rbx
    1721:	setne  dl
    1724:	cmp    r15,r12
    1727:	setb   al
    172a:	add    r15,0x1
    172e:	add    rbp,0x20
    1732:	test   dl,al
    1734:	jne    15c0 <main+0x360>
    .parent_index = g_profiler.current_parent_zone,
    173a:	mov    rdi,QWORD PTR [rip+0x39e7]        # 5128 <g_profiler+0x8>
        pair_count += 1;
    1741:	mov    ebx,esi
  g_profiler.current_parent_zone = zone_index;
    1743:	mov    QWORD PTR [rip+0x39da],0x8        # 5128 <g_profiler+0x8>
    174e:	rdtsc
  return pass;
    1750:	lea    rcx,[rip+0x195e]        # 30b5 <_IO_stdin_used+0xb5>
    1757:	mov    rbp,QWORD PTR [rsp+0x20]
    175c:	mov    QWORD PTR [rsp+0x168],rdi
    1764:	xor    edi,edi
    1766:	shl    rdx,0x20
    176a:	mov    QWORD PTR [rsp+0x140],rcx
    1772:	or     rax,rdx
    1775:	shl    rsi,0x5
    1779:	mov    QWORD PTR [rsp+0x170],rdi
    1781:	movq   xmm0,rax
    1786:	add    rbp,rsi
    1789:	movhps xmm0,QWORD PTR [rip+0x3b38]        # 52c8 <g_profiler+0x1a8>
    1790:	mov    QWORD PTR [rsp+0x148],0x3
    179c:	mov    QWORD PTR [rsp+0x160],0x8
  f64 sum = 0.0;
    17a8:	mov    QWORD PTR [rsp+0x8],0x0
    17b1:	movaps XMMWORD PTR [rsp+0x150],xmm0
    17b9:	nop    DWORD PTR [rax+0x0]
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    17c0:	movsd  xmm1,QWORD PTR [r14+0x18]
    17c6:	movsd  xmm3,QWORD PTR [r14+0x8]
  f64 lat1 = y0;
  f64 lat2 = y1;
  f64 lon1 = x0;
  f64 lon2 = x1;

  f64 d_lat = to_radians(lat2 - lat1);
    17cc:	movapd xmm0,xmm1
    17d0:	movsd  QWORD PTR [rsp+0x20],xmm1
    17d6:	subsd  xmm0,xmm3
  return degrees / PI;
    17da:	divsd  xmm0,QWORD PTR [rip+0x21ae]        # 3990 <__PRETTY_FUNCTION__.9+0x40>
  f64 d_lat = to_radians(lat2 - lat1);
    17e2:	movsd  QWORD PTR [rsp+0x10],xmm3
  f64 d_lon = to_radians(lon2 - lon1);
  lat1 = to_radians(lat1);
  lat2 = to_radians(lat2);

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    17e8:	mulsd  xmm0,QWORD PTR [rip+0x21a8]        # 3998 <__PRETTY_FUNCTION__.9+0x48>
    17f0:	call   1130 <sin@plt>
  return degrees / PI;
    17f5:	movsd  xmm3,QWORD PTR [rsp+0x10]
    17fb:	divsd  xmm3,QWORD PTR [rip+0x218d]        # 3990 <__PRETTY_FUNCTION__.9+0x40>
  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    1803:	movsd  QWORD PTR [rsp+0x28],xmm0
  return degrees / PI;
    1809:	movapd xmm0,xmm3
  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    180d:	call   10b0 <cos@plt>
  return degrees / PI;
    1812:	movsd  xmm1,QWORD PTR [rsp+0x20]
    1818:	divsd  xmm1,QWORD PTR [rip+0x2170]        # 3990 <__PRETTY_FUNCTION__.9+0x40>
  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    1820:	movsd  QWORD PTR [rsp+0x10],xmm0
  return degrees / PI;
    1826:	movapd xmm0,xmm1
  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    182a:	call   10b0 <cos@plt>
    182f:	movsd  QWORD PTR [rsp+0x20],xmm0
  f64 d_lon = to_radians(lon2 - lon1);
    1835:	movsd  xmm0,QWORD PTR [r14+0x10]
    183b:	subsd  xmm0,QWORD PTR [r14]
  return degrees / PI;
    1840:	divsd  xmm0,QWORD PTR [rip+0x2148]        # 3990 <__PRETTY_FUNCTION__.9+0x40>
  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    1848:	mulsd  xmm0,QWORD PTR [rip+0x2148]        # 3998 <__PRETTY_FUNCTION__.9+0x48>
    1850:	call   1130 <sin@plt>
    1855:	movsd  xmm1,QWORD PTR [rsp+0x10]
    185b:	mulsd  xmm1,QWORD PTR [rsp+0x20]
    1861:	pxor   xmm7,xmm7
  return x * x;
    1865:	mulsd  xmm0,xmm0
    1869:	movsd  xmm2,QWORD PTR [rsp+0x28]
    186f:	mulsd  xmm2,xmm2
  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    1873:	mulsd  xmm0,xmm1
    1877:	addsd  xmm0,xmm2
  f64 c = 2.0 * asin(sqrt(a));
    187b:	ucomisd xmm7,xmm0
    187f:	ja     1d63 <main+0xb03>
    1885:	sqrtsd xmm0,xmm0
    1889:	call   1140 <asin@plt>
    for (usize i = 0; i < pair_count; i++)
    188e:	add    r14,0x20
    1892:	addsd  xmm0,xmm0

  f64 result = sphere_radius * c;
    1896:	mulsd  xmm0,QWORD PTR [rip+0x2102]        # 39a0 <__PRETTY_FUNCTION__.9+0x50>
      sum += result;
    189e:	addsd  xmm0,QWORD PTR [rsp+0x8]
    18a4:	movsd  QWORD PTR [rsp+0x8],xmm0
    for (usize i = 0; i < pair_count; i++)
    18aa:	cmp    rbp,r14
    18ad:	jne    17c0 <main+0x560>
  PROFILE_SCOPE("sum")
    18b3:	sub    rsp,0x40
    18b7:	mov    ecx,0xe
    18bc:	lea    rsi,[rsp+0x180]
    18c4:	mov    rdi,rsp
    18c7:	rep movs DWORD PTR [rdi],DWORD PTR [rsi]
    18c9:	call   1e80 <__profile_end_pass.constprop.0>
    .parent_index = g_profiler.current_parent_zone,
    18ce:	mov    rcx,QWORD PTR [rip+0x3853]        # 5128 <g_profiler+0x8>
  g_profiler.current_parent_zone = zone_index;
    18d5:	mov    QWORD PTR [rip+0x3848],0x9        # 5128 <g_profiler+0x8>
    18e0:	rdtsc
  return pass;
    18e2:	lea    rdi,[rip+0x17d0]        # 30b9 <_IO_stdin_used+0xb9>
    18e9:	shl    rdx,0x20
    18ed:	mov    QWORD PTR [rsp+0x1e8],rcx
    18f5:	xor    ecx,ecx
    18f7:	or     rax,rdx
    18fa:	mov    QWORD PTR [rsp+0x1c0],rdi
    1902:	mov    QWORD PTR [rsp+0x1f0],rcx
    190a:	movq   xmm0,rax
    190f:	movhps xmm0,QWORD PTR [rip+0x39e2]        # 52f8 <g_profiler+0x1d8>
    1916:	mov    QWORD PTR [rsp+0x1c8],0x5
    1922:	mov    QWORD PTR [rsp+0x1e0],0x9
    192e:	movaps XMMWORD PTR [rsp+0x1d0],xmm0
    String solution_dump = read_file_to_arena(&arena, args[2]);
    1936:	mov    rax,QWORD PTR [rsp+0x70]
    193b:	add    rsp,0x40
    193f:	mov    rdi,QWORD PTR [rsp+0x38]
    1944:	mov    rsi,QWORD PTR [rax+0x10]
    1948:	call   2340 <read_file_to_arena>
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    194d:	cmp    rdx,0xb
    1951:	jbe    1c79 <main+0xa19>
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    1957:	mov    r8d,DWORD PTR [rax+0x8]
      if (solution_pairs == pair_count)
    195b:	cmp    r8d,ebx
    195e:	jne    1c9d <main+0xa3d>
    sum /= pair_count;
    1964:	movsd  xmm1,QWORD PTR [rsp+0x8]
    196a:	pxor   xmm0,xmm0
      f64 solution_sum   = *(f64 *)solution_dump.data;
    196e:	movsd  xmm2,QWORD PTR [rax]
    sum /= pair_count;
    1972:	cvtsi2sd xmm0,ebx
    1976:	divsd  xmm1,xmm0
  return (fabs(a) - fabs(b)) <= epsilon;
    197a:	movapd xmm0,xmm2
    197e:	andpd  xmm0,XMMWORD PTR [rip+0x203a]        # 39c0 <__PRETTY_FUNCTION__.9+0x70>
    1986:	movapd xmm3,xmm1
    198a:	andpd  xmm3,XMMWORD PTR [rip+0x202e]        # 39c0 <__PRETTY_FUNCTION__.9+0x70>
    1992:	subsd  xmm0,xmm3
        if (epsilon_equal(solution_sum, sum))
    1996:	movsd  xmm3,QWORD PTR [rip+0x200a]        # 39a8 <__PRETTY_FUNCTION__.9+0x58>
    199e:	comisd xmm3,xmm0
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    19a2:	movapd xmm0,xmm2
        if (epsilon_equal(solution_sum, sum))
    19a6:	jae    1c03 <main+0x9a3>
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    19ac:	mov    edx,0x68
    19b1:	mov    edi,0x1
    19b6:	mov    eax,0x2
    19bb:	lea    rcx,[rip+0x1c26]        # 35e8 <_IO_stdin_used+0x5e8>
    19c2:	lea    rsi,[rip+0x16f6]        # 30bf <_IO_stdin_used+0xbf>
    19c9:	call   2040 <log_message>
  PROFILE_SCOPE("check")
    19ce:	sub    rsp,0x40
    19d2:	mov    ecx,0xe
    19d7:	mov    rsi,QWORD PTR [rsp+0x80]
    19df:	mov    rdi,rsp
    19e2:	rep movs DWORD PTR [rdi],DWORD PTR [rsi]
    19e4:	call   1e80 <__profile_end_pass.constprop.0>
    .parent_index = g_profiler.current_parent_zone,
    19e9:	mov    rcx,QWORD PTR [rip+0x3738]        # 5128 <g_profiler+0x8>
  g_profiler.current_parent_zone = zone_index;
    19f0:	mov    QWORD PTR [rip+0x372d],0xa        # 5128 <g_profiler+0x8>
    19fb:	rdtsc
  return pass;
    19fd:	lea    rdi,[rip+0x16d0]        # 30d4 <_IO_stdin_used+0xd4>
    1a04:	shl    rdx,0x20
    1a08:	mov    QWORD PTR [rsp+0x228],rcx
    1a10:	or     rax,rdx
    1a13:	xor    edx,edx
    1a15:	mov    QWORD PTR [rsp+0x200],rdi
    1a1d:	mov    QWORD PTR [rsp+0x230],rdx
    1a25:	movq   xmm0,rax
    1a2a:	movhps xmm0,QWORD PTR [rip+0x38f7]        # 5328 <g_profiler+0x208>
    1a31:	mov    QWORD PTR [rsp+0x208],0x4
    1a3d:	movaps XMMWORD PTR [rsp+0x210],xmm0
    1a45:	mov    QWORD PTR [rsp+0x220],0xa
    arena_free(&arena);
    1a51:	add    rsp,0x40
    1a55:	mov    rdi,QWORD PTR [rsp+0x38]
    1a5a:	call   2280 <arena_free>
  PROFILE_SCOPE("free")
    1a5f:	sub    rsp,0x40
    1a63:	mov    ecx,0xe
    1a68:	mov    rsi,QWORD PTR [rsp+0x88]
    1a70:	mov    rdi,rsp
    1a73:	rep movs DWORD PTR [rdi],DWORD PTR [rsi]
    1a75:	call   1e80 <__profile_end_pass.constprop.0>
    1a7a:	rdtsc
    1a7c:	shl    rdx,0x20
  if (total_delta)
    1a80:	add    rsp,0x40
    1a84:	or     rax,rdx
    1a87:	sub    rax,QWORD PTR [rip+0x3692]        # 5120 <g_profiler>
    1a8e:	mov    rbx,rax
    1a91:	jne    1a9a <main+0x83a>
    1a93:	xor    eax,eax
    1a95:	jmp    12a4 <main+0x44>
    1a9a:	rdtsc
  gettimeofday(&value, 0);
    1a9c:	xor    esi,esi
    1a9e:	lea    r12,[rsp+0x70]
    1aa3:	mov    r13,rax
    1aa6:	shl    rdx,0x20
    1aaa:	mov    rdi,r12
    1aad:	or     r13,rdx
    1ab0:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1ab5:	imul   rbp,QWORD PTR [rsp+0x70],0xf4240
    1abe:	add    rbp,QWORD PTR [rsp+0x78]
  while (os_delta < os_wait_time)
    1ac3:	xchg   ax,ax
    1ac5:	data16 cs nop WORD PTR [rax+rax*1+0x0]
  gettimeofday(&value, 0);
    1ad0:	xor    esi,esi
    1ad2:	mov    rdi,r12
    1ad5:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1ada:	imul   rcx,QWORD PTR [rsp+0x70],0xf4240
    1ae3:	add    rcx,QWORD PTR [rsp+0x78]
    os_delta = os_end - os_start;
    1ae8:	sub    rcx,rbp
  while (os_delta < os_wait_time)
    1aeb:	cmp    rcx,0x1869f
    1af2:	jbe    1ad0 <main+0x870>
    1af4:	rdtsc
    1af6:	shl    rdx,0x20
    1afa:	or     rax,rdx
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1afd:	xor    edx,edx
  u64 cpu_delta = cpu_end - cpu_start;
    1aff:	sub    rax,r13
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b02:	imul   rax,rax,0xf4240
    1b09:	div    rcx
    printf("[PROFILE] Total duration: %lu (%fms @ CPU Frequency: %u)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1b0c:	test   rbx,rbx
    1b0f:	js     1cc4 <main+0xa64>
    1b15:	pxor   xmm5,xmm5
    1b19:	cvtsi2sd xmm5,rbx
    1b1e:	movsd  QWORD PTR [rsp+0x8],xmm5
    1b24:	movsd  xmm0,QWORD PTR [rsp+0x8]
    1b2a:	pxor   xmm1,xmm1
    1b2e:	mov    rdx,rax
    1b31:	mov    rsi,rbx
    1b34:	cvtsi2sd xmm1,rax
    1b39:	lea    rdi,[rip+0x1b18]        # 3658 <_IO_stdin_used+0x658>
    1b40:	mov    eax,0x1
    1b45:	lea    rbx,[rip+0x35e4]        # 5130 <g_profiler+0x10>
    1b4c:	divsd  xmm0,xmm1
    1b50:	lea    rbp,[rbx+0x30000]
    1b57:	mulsd  xmm0,QWORD PTR [rip+0x1e51]        # 39b0 <__PRETTY_FUNCTION__.9+0x60>
    1b5f:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1b64:	jmp    1b7d <main+0x91d>
    1b66:	cs nop WORD PTR [rax+rax*1+0x0]
    1b70:	add    rbx,0x30
    1b74:	cmp    rbx,rbp
    1b77:	je     1a93 <main+0x833>
      if (zone->elapsed_inclusive)
    1b7d:	cmp    QWORD PTR [rbx+0x18],0x0
    1b82:	je     1b70 <main+0x910>
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1b84:	mov    r8,QWORD PTR [rbx+0x10]
    1b88:	test   r8,r8
    1b8b:	js     1c30 <main+0x9d0>
    1b91:	pxor   xmm0,xmm0
    1b95:	cvtsi2sd xmm0,r8
    1b9a:	divsd  xmm0,QWORD PTR [rsp+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1ba0:	mov    esi,DWORD PTR [rbx+0x8]
    1ba3:	mov    rcx,QWORD PTR [rbx+0x20]
    1ba7:	lea    rdi,[rip+0x1aea]        # 3698 <_IO_stdin_used+0x698>
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1bae:	mulsd  xmm0,QWORD PTR [rip+0x1e02]        # 39b8 <__PRETTY_FUNCTION__.9+0x68>
        printf("[PROFILE] Zone '%.*s':\n"
    1bb6:	mov    rdx,QWORD PTR [rbx]
    1bb9:	mov    eax,0x1
    1bbe:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1bc3:	mov    rsi,QWORD PTR [rbx+0x18]
    1bc7:	cmp    QWORD PTR [rbx+0x10],rsi
    1bcb:	je     1b70 <main+0x910>
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1bcd:	test   rsi,rsi
    1bd0:	js     1c58 <main+0x9f8>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rsi
    1bdf:	divsd  xmm0,QWORD PTR [rsp+0x8]
    1be5:	mulsd  xmm0,QWORD PTR [rip+0x1dcb]        # 39b8 <__PRETTY_FUNCTION__.9+0x68>
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1bed:	mov    eax,0x1
    1bf2:	lea    rdi,[rip+0x1af7]        # 36f0 <_IO_stdin_used+0x6f0>
    1bf9:	call   1070 <printf@plt>
    1bfe:	jmp    1b70 <main+0x910>
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    1c03:	mov    edx,0x64
    1c08:	mov    edi,0x3
    1c0d:	mov    eax,0x2
    1c12:	lea    rcx,[rip+0x1a07]        # 3620 <_IO_stdin_used+0x620>
    1c19:	lea    rsi,[rip+0x149f]        # 30bf <_IO_stdin_used+0xbf>
    1c20:	call   2040 <log_message>
    1c25:	jmp    19ce <main+0x76e>
    1c2a:	nop    WORD PTR [rax+rax*1+0x0]
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1c30:	mov    rax,r8
    1c33:	mov    rdx,r8
    1c36:	pxor   xmm0,xmm0
    1c3a:	shr    rax,1
    1c3d:	and    edx,0x1
    1c40:	or     rax,rdx
    1c43:	cvtsi2sd xmm0,rax
    1c48:	addsd  xmm0,xmm0
    1c4c:	jmp    1b9a <main+0x93a>
    1c51:	nop    DWORD PTR [rax+0x0]
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1c58:	mov    rax,rsi
    1c5b:	mov    rdx,rsi
    1c5e:	pxor   xmm0,xmm0
    1c62:	shr    rax,1
    1c65:	and    edx,0x1
    1c68:	or     rax,rdx
    1c6b:	cvtsi2sd xmm0,rax
    1c70:	addsd  xmm0,xmm0
    1c74:	jmp    1bdf <main+0x97f>
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    1c79:	lea    rcx,[rip+0x18e0]        # 3560 <_IO_stdin_used+0x560>
    1c80:	mov    edx,0x72
    1c85:	lea    rsi,[rip+0x1433]        # 30bf <_IO_stdin_used+0xbf>
    1c8c:	xor    eax,eax
    1c8e:	mov    edi,0x1
    1c93:	call   2040 <log_message>
    1c98:	jmp    19ce <main+0x76e>
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    1c9d:	mov    r9d,ebx
    1ca0:	mov    edx,0x6d
    1ca5:	mov    edi,0x1
    1caa:	xor    eax,eax
    1cac:	lea    rcx,[rip+0x18ed]        # 35a0 <_IO_stdin_used+0x5a0>
    1cb3:	lea    rsi,[rip+0x1405]        # 30bf <_IO_stdin_used+0xbf>
    1cba:	call   2040 <log_message>
    1cbf:	jmp    19ce <main+0x76e>
    printf("[PROFILE] Total duration: %lu (%fms @ CPU Frequency: %u)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1cc4:	mov    rdx,rbx
    1cc7:	mov    rcx,rbx
    1cca:	pxor   xmm0,xmm0
    1cce:	shr    rdx,1
    1cd1:	and    ecx,0x1
    1cd4:	or     rdx,rcx
    1cd7:	cvtsi2sd xmm0,rdx
    1cdc:	addsd  xmm0,xmm0
    1ce0:	movsd  QWORD PTR [rsp+0x8],xmm0
    1ce6:	jmp    1b24 <main+0x8c4>
    .parent_index = g_profiler.current_parent_zone,
    1ceb:	mov    rcx,QWORD PTR [rip+0x3436]        # 5128 <g_profiler+0x8>
  g_profiler.current_parent_zone = zone_index;
    1cf2:	mov    QWORD PTR [rip+0x342b],0x8        # 5128 <g_profiler+0x8>
    1cfd:	rdtsc
  return pass;
    1cff:	lea    rdi,[rip+0x13af]        # 30b5 <_IO_stdin_used+0xb5>
    1d06:	xor    ebx,ebx
    1d08:	shl    rdx,0x20
    1d0c:	mov    QWORD PTR [rsp+0x140],rdi
    1d14:	or     rax,rdx
    1d17:	mov    QWORD PTR [rsp+0x168],rcx
  f64 sum = 0.0;
    1d1f:	mov    QWORD PTR [rsp+0x8],0x0
    1d28:	movq   xmm0,rax
    1d2d:	xor    eax,eax
    1d2f:	movhps xmm0,QWORD PTR [rip+0x3592]        # 52c8 <g_profiler+0x1a8>
    1d36:	mov    QWORD PTR [rsp+0x148],0x3
    1d42:	mov    QWORD PTR [rsp+0x160],0x8
    1d4e:	mov    QWORD PTR [rsp+0x170],rax
    1d56:	movaps XMMWORD PTR [rsp+0x150],xmm0
    1d5e:	jmp    18b3 <main+0x653>
  f64 c = 2.0 * asin(sqrt(a));
    1d63:	call   1160 <sqrt@plt>
    1d68:	jmp    1889 <main+0x629>
}
    1d6d:	call   1060 <__stack_chk_fail@plt>
    1d72:	cs nop WORD PTR [rax+rax*1+0x0]
    1d7c:	nop    DWORD PTR [rax+0x0]

0000000000001d80 <_start>:
    1d80:	endbr64
    1d84:	xor    ebp,ebp
    1d86:	mov    r9,rdx
    1d89:	pop    rsi
    1d8a:	mov    rdx,rsp
    1d8d:	and    rsp,0xfffffffffffffff0
    1d91:	push   rax
    1d92:	push   rsp
    1d93:	xor    r8d,r8d
    1d96:	xor    ecx,ecx
    1d98:	lea    rdi,[rip+0xfffffffffffff4c1]        # 1260 <main>
    1d9f:	call   QWORD PTR [rip+0x3213]        # 4fb8 <__libc_start_main@GLIBC_2.34>
    1da5:	hlt
    1da6:	cs nop WORD PTR [rax+rax*1+0x0]
    1db0:	lea    rdi,[rip+0x3329]        # 50e0 <stdout@GLIBC_2.2.5>
    1db7:	lea    rax,[rip+0x3322]        # 50e0 <stdout@GLIBC_2.2.5>
    1dbe:	cmp    rax,rdi
    1dc1:	je     1dd8 <_start+0x58>
    1dc3:	mov    rax,QWORD PTR [rip+0x31f6]        # 4fc0 <_ITM_deregisterTMCloneTable@Base>
    1dca:	test   rax,rax
    1dcd:	je     1dd8 <_start+0x58>
    1dcf:	jmp    rax
    1dd1:	nop    DWORD PTR [rax+0x0]
    1dd8:	ret
    1dd9:	nop    DWORD PTR [rax+0x0]
    1de0:	lea    rdi,[rip+0x32f9]        # 50e0 <stdout@GLIBC_2.2.5>
    1de7:	lea    rsi,[rip+0x32f2]        # 50e0 <stdout@GLIBC_2.2.5>
    1dee:	sub    rsi,rdi
    1df1:	mov    rax,rsi
    1df4:	shr    rsi,0x3f
    1df8:	sar    rax,0x3
    1dfc:	add    rsi,rax
    1dff:	sar    rsi,1
    1e02:	je     1e18 <_start+0x98>
    1e04:	mov    rax,QWORD PTR [rip+0x31c5]        # 4fd0 <_ITM_registerTMCloneTable@Base>
    1e0b:	test   rax,rax
    1e0e:	je     1e18 <_start+0x98>
    1e10:	jmp    rax
    1e12:	nop    WORD PTR [rax+rax*1+0x0]
    1e18:	ret
    1e19:	nop    DWORD PTR [rax+0x0]
    1e20:	endbr64
    1e24:	cmp    BYTE PTR [rip+0x32dd],0x0        # 5108 <stderr@GLIBC_2.2.5+0x8>
    1e2b:	jne    1e60 <_start+0xe0>
    1e2d:	push   rbp
    1e2e:	cmp    QWORD PTR [rip+0x31a2],0x0        # 4fd8 <__cxa_finalize@GLIBC_2.2.5>
    1e36:	mov    rbp,rsp
    1e39:	je     1e48 <_start+0xc8>
    1e3b:	mov    rdi,QWORD PTR [rip+0x3266]        # 50a8 <__dso_handle>
    1e42:	call   QWORD PTR [rip+0x3190]        # 4fd8 <__cxa_finalize@GLIBC_2.2.5>
    1e48:	call   1db0 <_start+0x30>
    1e4d:	mov    BYTE PTR [rip+0x32b4],0x1        # 5108 <stderr@GLIBC_2.2.5+0x8>
    1e54:	pop    rbp
    1e55:	ret
    1e56:	cs nop WORD PTR [rax+rax*1+0x0]
    1e60:	ret
    1e61:	nop    DWORD PTR [rax+0x0]
    1e65:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1e70:	endbr64
    1e74:	jmp    1de0 <_start+0x60>
    1e79:	nop    DWORD PTR [rax+0x0]

0000000000001e80 <__profile_end_pass.constprop.0>:
}

static
void __profile_end_pass(Profile_Pass pass)
    1e80:	mov    r9,QWORD PTR [rsp+0x30]
    1e85:	rdtsc
{
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    1e87:	lea    rcx,[rip+0x3292]        # 5120 <g_profiler>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    1e8e:	mov    r8,QWORD PTR [rsp+0x28]
  u64 elapsed = read_cpu_timer() - pass.start;
    1e93:	mov    rsi,QWORD PTR [rsp+0x18]
  current->elapsed_exclusive += elapsed;
  current->hit_count += 1;
  current->name = pass.name; // Stupid...
    1e98:	movdqu xmm0,XMMWORD PTR [rsp+0x8]
    1e9e:	shl    rdx,0x20
  g_profiler.current_parent_zone = pass.parent_index;
    1ea2:	mov    QWORD PTR [rip+0x327f],r9        # 5128 <g_profiler+0x8>
    1ea9:	or     rax,rdx
  current->elapsed_exclusive += elapsed;
    1eac:	lea    rdx,[r8+r8*2]
  current->hit_count += 1;
    1eb0:	lea    r8,[r8+r8*2+0x3]
  current->elapsed_exclusive += elapsed;
    1eb5:	shl    rdx,0x4
  u64 elapsed = read_cpu_timer() - pass.start;
    1eb9:	mov    rdi,rax
  current->hit_count += 1;
    1ebc:	shl    r8,0x4
  u64 elapsed = read_cpu_timer() - pass.start;
    1ec0:	sub    rdi,rsi
  current->elapsed_exclusive += elapsed;
    1ec3:	add    QWORD PTR [rcx+rdx*1+0x20],rdi
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    1ec8:	add    rdi,QWORD PTR [rsp+0x20]
  current->bytes_processed += pass.bytes_processed;

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
  parent->elapsed_exclusive -= elapsed;
    1ecd:	sub    rsi,rax
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    1ed0:	mov    QWORD PTR [rcx+rdx*1+0x28],rdi
  current->name = pass.name; // Stupid...
    1ed5:	movaps XMMWORD PTR [rcx+rdx*1+0x10],xmm0
  parent->elapsed_exclusive -= elapsed;
    1eda:	lea    rdx,[r9+r9*2]
    1ede:	shl    rdx,0x4
  current->hit_count += 1;
    1ee2:	add    QWORD PTR [rcx+r8*1],0x1
  parent->elapsed_exclusive -= elapsed;
    1ee7:	add    QWORD PTR [rcx+rdx*1+0x20],rsi
}
    1eec:	ret
    1eed:	nop    DWORD PTR [rax]

0000000000001ef0 <lookup_json_object>:
{
    1ef0:	push   r12
    1ef2:	push   rbp
    1ef3:	mov    rbp,rdx
    1ef6:	push   rbx
    1ef7:	sub    rsp,0x40
    .parent_index = g_profiler.current_parent_zone,
    1efb:	mov    rcx,QWORD PTR [rip+0x3226]        # 5128 <g_profiler+0x8>
  g_profiler.current_parent_zone = zone_index;
    1f02:	mov    QWORD PTR [rip+0x321b],0x4        # 5128 <g_profiler+0x8>
    1f0d:	rdtsc
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    1f0f:	mov    rbx,QWORD PTR [rdi+0x20]
    1f13:	shl    rdx,0x20
  return pass;
    1f17:	mov    QWORD PTR [rsp+0x28],rcx
    1f1c:	mov    QWORD PTR [rsp+0x8],0x12
    1f25:	or     rax,rdx
    1f28:	lea    rdx,[rip+0x1961]        # 3890 <__func__.1>
    1f2f:	movq   xmm0,rax
    1f34:	mov    QWORD PTR [rsp],rdx
    1f38:	movhps xmm0,QWORD PTR [rip+0x32c9]        # 5208 <g_profiler+0xe8>
    1f3f:	mov    QWORD PTR [rsp+0x20],0x4
    1f48:	mov    QWORD PTR [rsp+0x30],0x0
    1f51:	movaps XMMWORD PTR [rsp+0x10],xmm0
    1f56:	test   rbx,rbx
    1f59:	je     1f81 <lookup_json_object+0x91>
    1f5b:	mov    r12,rsi
    1f5e:	jmp    1f69 <lookup_json_object+0x79>
    1f60:	mov    rbx,QWORD PTR [rbx+0x28]
    1f64:	test   rbx,rbx
    1f67:	je     1f81 <lookup_json_object+0x91>
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1f69:	cmp    rbp,QWORD PTR [rbx+0x8]
    1f6d:	jne    1f60 <lookup_json_object+0x70>
    1f6f:	mov    rsi,QWORD PTR [rbx]
    1f72:	mov    rdx,rbp
    1f75:	mov    rdi,r12
    1f78:	call   10d0 <memcmp@plt>
    1f7d:	test   eax,eax
    1f7f:	jne    1f60 <lookup_json_object+0x70>
  profile_end_func();
    1f81:	sub    rsp,0x40
    1f85:	movdqa xmm0,XMMWORD PTR [rsp+0x40]
    1f8b:	mov    rax,QWORD PTR [rsp+0x70]
    1f90:	movups XMMWORD PTR [rsp],xmm0
    1f94:	movdqa xmm0,XMMWORD PTR [rsp+0x50]
    1f9a:	mov    QWORD PTR [rsp+0x30],rax
    1f9f:	movups XMMWORD PTR [rsp+0x10],xmm0
    1fa4:	movdqa xmm0,XMMWORD PTR [rsp+0x60]
    1faa:	movups XMMWORD PTR [rsp+0x20],xmm0
    1faf:	call   1e80 <__profile_end_pass.constprop.0>
}
    1fb4:	sub    rsp,0xffffffffffffff80
    1fb8:	mov    rax,rbx
    1fbb:	pop    rbx
    1fbc:	pop    rbp
    1fbd:	pop    r12
    1fbf:	ret

0000000000001fc0 <file_size>:
{
    1fc0:	sub    rsp,0xa8
  stat(name, &stats);
    1fc7:	mov    rsi,QWORD PTR fs:0x28
    1fd0:	mov    QWORD PTR [rsp+0x98],rsi
    1fd8:	mov    rsi,rsp
    1fdb:	call   1100 <stat@plt>
  return stats.st_size;
    1fe0:	mov    rax,QWORD PTR [rsp+0x30]
}
    1fe5:	mov    rdx,QWORD PTR [rsp+0x98]
    1fed:	sub    rdx,QWORD PTR fs:0x28
    1ff6:	jne    2000 <file_size+0x40>
    1ff8:	add    rsp,0xa8
    1fff:	ret
    2000:	call   1060 <__stack_chk_fail@plt>
    2005:	data16 cs nop WORD PTR [rax+rax*1+0x0]

0000000000002010 <strings_equal>:
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    2010:	cmp    rsi,rcx
    2013:	je     2020 <strings_equal+0x10>
    2015:	xor    eax,eax
}
    2017:	ret
    2018:	nop    DWORD PTR [rax+rax*1+0x0]
    2020:	mov    rax,rdx
{
    2023:	sub    rsp,0x8
    2027:	mov    rdx,rsi
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    202a:	mov    rsi,rax
    202d:	call   10d0 <memcmp@plt>
    2032:	test   eax,eax
    2034:	sete   al
}
    2037:	add    rsp,0x8
    203b:	ret
    203c:	nop    DWORD PTR [rax+0x0]

0000000000002040 <log_message>:
{
    2040:	push   rbp
    2041:	mov    r10,rdx
    2044:	mov    rbp,rcx
    2047:	push   rbx
    2048:	sub    rsp,0xd8
    204f:	mov    QWORD PTR [rsp+0x40],r8
    2054:	mov    QWORD PTR [rsp+0x48],r9
    2059:	test   al,al
    205b:	je     2094 <log_message+0x54>
    205d:	movaps XMMWORD PTR [rsp+0x50],xmm0
    2062:	movaps XMMWORD PTR [rsp+0x60],xmm1
    2067:	movaps XMMWORD PTR [rsp+0x70],xmm2
    206c:	movaps XMMWORD PTR [rsp+0x80],xmm3
    2074:	movaps XMMWORD PTR [rsp+0x90],xmm4
    207c:	movaps XMMWORD PTR [rsp+0xa0],xmm5
    2084:	movaps XMMWORD PTR [rsp+0xb0],xmm6
    208c:	movaps XMMWORD PTR [rsp+0xc0],xmm7
  FILE *stream = stderr;
    2094:	mov    rbx,QWORD PTR fs:0x28
    209d:	mov    QWORD PTR [rsp+0x18],rbx
    20a2:	mov    rbx,QWORD PTR [rip+0x3057]        # 5100 <stderr@GLIBC_2.2.5>
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    20a9:	mov    eax,edi
    20ab:	lea    rcx,[rip+0x300e]        # 50c0 <level_strings>
    20b2:	mov    rdx,QWORD PTR [rcx+rax*8]
  if (level <= LOG_ERROR)
    20b6:	cmp    edi,0x1
    20b9:	jbe    2138 <log_message+0xf8>
      stream = stdout;
    20bb:	cmp    edi,0x3
    20be:	cmove  rbx,QWORD PTR [rip+0x301a]        # 50e0 <stdout@GLIBC_2.2.5>
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    20c6:	xor    eax,eax
    20c8:	lea    rsi,[rip+0xf6a]        # 3039 <_IO_stdin_used+0x39>
    20cf:	mov    rdi,rbx
    20d2:	call   10f0 <fprintf@plt>
  vfprintf(stream, message, args);
    20d7:	mov    rsi,rbp
    20da:	mov    rdi,rbx
    20dd:	mov    rdx,rsp
  va_start(args, message);
    20e0:	mov    DWORD PTR [rsp],0x20
    20e7:	lea    rax,[rsp+0xf0]
    20ef:	mov    DWORD PTR [rsp+0x4],0x30
    20f7:	mov    QWORD PTR [rsp+0x8],rax
    20fc:	lea    rax,[rsp+0x20]
    2101:	mov    QWORD PTR [rsp+0x10],rax
  vfprintf(stream, message, args);
    2106:	call   1120 <vfprintf@plt>
  fprintf(stream, "\n");
    210b:	mov    rsi,rbx
    210e:	mov    edi,0xa
    2113:	call   10c0 <fputc@plt>
}
    2118:	mov    rax,QWORD PTR [rsp+0x18]
    211d:	sub    rax,QWORD PTR fs:0x28
    2126:	jne    2151 <log_message+0x111>
    2128:	add    rsp,0xd8
    212f:	pop    rbx
    2130:	pop    rbp
    2131:	ret
    2132:	nop    WORD PTR [rax+rax*1+0x0]
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    2138:	mov    rcx,rsi
    213b:	mov    r8,r10
    213e:	lea    rsi,[rip+0xedd]        # 3022 <_IO_stdin_used+0x22>
    2145:	mov    rdi,rbx
    2148:	xor    eax,eax
    214a:	call   10f0 <fprintf@plt>
    214f:	jmp    20d7 <log_message+0x97>
}
    2151:	call   1060 <__stack_chk_fail@plt>
    2156:	cs nop WORD PTR [rax+rax*1+0x0]

0000000000002160 <read_file_to_memory>:
{
    2160:	push   r12
    2162:	mov    r12,rsi
  FILE *file = fopen(name, "rb");
    2165:	lea    rsi,[rip+0xedb]        # 3047 <_IO_stdin_used+0x47>
{
    216c:	push   rbp
    216d:	push   rbx
    216e:	mov    rbx,rdi
    2171:	sub    rsp,0x10
    2175:	mov    QWORD PTR [rsp+0x8],rdx
  FILE *file = fopen(name, "rb");
    217a:	call   1110 <fopen@plt>
  if (file == NULL)
    217f:	mov    rdx,QWORD PTR [rsp+0x8]
    2184:	test   rax,rax
    2187:	je     21b3 <read_file_to_memory+0x53>
    2189:	mov    rbp,rax
  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    218c:	mov    rdi,r12
    218f:	mov    rcx,rax
    2192:	mov    esi,0x1
    2197:	call   1040 <fread@plt>
  fclose(file);
    219c:	mov    rdi,rbp
  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    219f:	mov    rbx,rax
  fclose(file);
    21a2:	call   1050 <fclose@plt>
}
    21a7:	add    rsp,0x10
    21ab:	mov    rax,rbx
    21ae:	pop    rbx
    21af:	pop    rbp
    21b0:	pop    r12
    21b2:	ret
    LOG_ERROR("Unable to open file: %s", name);
    21b3:	mov    r8,rbx
    21b6:	lea    rcx,[rip+0xe8d]        # 304a <_IO_stdin_used+0x4a>
    21bd:	xor    eax,eax
    21bf:	xor    ebx,ebx
    21c1:	mov    edx,0x17b
    21c6:	lea    rsi,[rip+0xe48]        # 3015 <_IO_stdin_used+0x15>
    21cd:	mov    edi,0x1
    21d2:	call   2040 <log_message>
    return 0;
    21d7:	jmp    21a7 <read_file_to_memory+0x47>
    21d9:	nop    DWORD PTR [rax+0x0]

00000000000021e0 <arena_make>:
{
    21e0:	push   rbp
    21e1:	mov    rbp,rdi
    21e4:	push   rbx
    21e5:	mov    rbx,rsi
  arena.base = (u8 *)calloc(reserve_size, 1);
    21e8:	mov    esi,0x1
    21ed:	mov    rdi,rbx
{
    21f0:	sub    rsp,0x8
  arena.base = (u8 *)calloc(reserve_size, 1);
    21f4:	call   10e0 <calloc@plt>
  if (arena.base == NULL)
    21f9:	test   rax,rax
    21fc:	je     221c <arena_make+0x3c>
  return arena;
    21fe:	movq   xmm0,rbx
    2203:	mov    QWORD PTR [rbp+0x0],rax
}
    2207:	mov    rax,rbp
  return arena;
    220a:	mov    DWORD PTR [rbp+0x18],0x0
    2211:	movups XMMWORD PTR [rbp+0x8],xmm0
}
    2215:	add    rsp,0x8
    2219:	pop    rbx
    221a:	pop    rbp
    221b:	ret
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    221c:	xor    edi,edi
    221e:	lea    rcx,[rip+0x109b]        # 32c0 <_IO_stdin_used+0x2c0>
    2225:	mov    edx,0x1d9
    222a:	lea    rsi,[rip+0xde4]        # 3015 <_IO_stdin_used+0x15>
    2231:	call   2040 <log_message>
    2236:	mov    edi,0xffffffff
    223b:	call   1150 <exit@plt>

0000000000002240 <arena_make_backed>:
{
    2240:	sub    rsp,0x8
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    2244:	test   rsi,rsi
    2247:	je     11c0 <arena_make_backed.cold>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    224d:	test   rdx,rdx
    2250:	je     11df <arena_make_backed.cold+0x1f>
    2256:	movq   xmm0,rdx
  return arena;
    225b:	mov    QWORD PTR [rdi],rsi
    225e:	mov    rax,rdi
    2261:	mov    DWORD PTR [rdi+0x18],0x1
    2268:	movups XMMWORD PTR [rdi+0x8],xmm0
}
    226c:	add    rsp,0x8
    2270:	ret
    2271:	nop    DWORD PTR [rax+0x0]
    2275:	data16 cs nop WORD PTR [rax+rax*1+0x0]

0000000000002280 <arena_free>:
{
    2280:	mov    rax,rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    2283:	test   BYTE PTR [rdi+0x18],0x1
    2287:	je     2298 <arena_free+0x18>
  ZERO_STRUCT(arena);
    2289:	pxor   xmm0,xmm0
    228d:	movups XMMWORD PTR [rdi],xmm0
    2290:	movups XMMWORD PTR [rdi+0x10],xmm0
    2294:	ret
    2295:	nop    DWORD PTR [rax]
{
    2298:	sub    rsp,0x18
    free(arena->base);
    229c:	mov    rdi,QWORD PTR [rdi]
    229f:	mov    QWORD PTR [rsp+0x8],rax
    22a4:	call   1030 <free@plt>
    22a9:	mov    rax,QWORD PTR [rsp+0x8]
  ZERO_STRUCT(arena);
    22ae:	pxor   xmm0,xmm0
    22b2:	movups XMMWORD PTR [rax],xmm0
    22b5:	movups XMMWORD PTR [rax+0x10],xmm0
}
    22b9:	add    rsp,0x18
    22bd:	ret
    22be:	xchg   ax,ax

00000000000022c0 <arena_alloc>:
void *arena_alloc(Arena *arena, isize size, isize alignment) {
    22c0:	push   rbp
    22c1:	push   rbx
    22c2:	sub    rsp,0x8
  ASSERT(arena->base != NULL, "Arena memory is null");
    22c6:	mov    rax,QWORD PTR [rdi]
    22c9:	test   rax,rax
    22cc:	je     11fe <arena_alloc.cold>
    22d2:	mov    rcx,rdx
  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    22d5:	mov    rdx,QWORD PTR [rdi+0x10]
  if ((aligned_offset + size) > arena->capacity)
    22d9:	mov    r9,QWORD PTR [rdi+0x8]
    22dd:	mov    rbx,rdi
  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    22e0:	lea    rdx,[rdx+rcx*1-0x1]
    22e5:	neg    rcx
    22e8:	and    rdx,rcx
  if ((aligned_offset + size) > arena->capacity)
    22eb:	lea    rbp,[rdx+rsi*1]
    22ef:	cmp    rbp,r9
    22f2:	jg     230d <arena_alloc+0x4d>
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    22f4:	lea    rdi,[rax+rdx*1]
    22f8:	mov    rdx,rsi
    22fb:	xor    esi,esi
    22fd:	call   10a0 <memset@plt>
  arena->next_offset = aligned_offset + size;
    2302:	mov    QWORD PTR [rbx+0x10],rbp
}
    2306:	add    rsp,0x8
    230a:	pop    rbx
    230b:	pop    rbp
    230c:	ret
    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    230d:	xor    edi,edi
    230f:	mov    r8,rbp
    2312:	lea    rcx,[rip+0x1097]        # 33b0 <_IO_stdin_used+0x3b0>
    2319:	xor    eax,eax
    231b:	mov    edx,0x207
    2320:	lea    rsi,[rip+0xcee]        # 3015 <_IO_stdin_used+0x15>
    2327:	call   2040 <log_message>
    232c:	mov    edi,0xffffffff
    2331:	call   1150 <exit@plt>
    2336:	cs nop WORD PTR [rax+rax*1+0x0]

0000000000002340 <read_file_to_arena>:
{
    2340:	push   r15
    2342:	push   r14
    2344:	push   r13
    2346:	push   r12
    2348:	push   rbp
    2349:	mov    rbp,rdi
    234c:	push   rbx
    234d:	sub    rsp,0xb8
    2354:	mov    r12,QWORD PTR fs:0x28
    235d:	mov    QWORD PTR [rsp+0xa8],r12
    2365:	mov    r12,rsi
  stat(name, &stats);
    2368:	lea    rsi,[rsp+0x10]
    236d:	mov    rdi,r12
    2370:	call   1100 <stat@plt>
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    2375:	mov    rdi,rbp
  Arena save = *arena;
    2378:	mov    r15,QWORD PTR [rbp+0x0]
    237c:	mov    r14d,DWORD PTR [rbp+0x18]
  return stats.st_size;
    2380:	mov    rbx,QWORD PTR [rsp+0x40]
  Arena save = *arena;
    2385:	movdqu xmm0,XMMWORD PTR [rbp+0x8]
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    238a:	mov    edx,0x1
    238f:	mov    rsi,rbx
  Arena save = *arena;
    2392:	movaps XMMWORD PTR [rsp],xmm0
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    2396:	call   22c0 <arena_alloc>
  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    239b:	mov    rdx,rbx
    239e:	mov    rdi,r12
    23a1:	mov    rsi,rax
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    23a4:	mov    r13,rax
  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    23a7:	call   2160 <read_file_to_memory>
    23ac:	cmp    rax,rbx
    23af:	je     23e4 <read_file_to_arena+0xa4>
    LOG_ERROR("Unable to read file: %s", name);
    23b1:	mov    r8,r12
    23b4:	mov    edx,0x19d
    23b9:	mov    edi,0x1
    23be:	xor    eax,eax
    23c0:	lea    rcx,[rip+0xc9b]        # 3062 <_IO_stdin_used+0x62>
    23c7:	lea    rsi,[rip+0xc47]        # 3015 <_IO_stdin_used+0x15>
    23ce:	call   2040 <log_message>
    *arena = save; // Rollback allocation
    23d3:	movdqa xmm0,XMMWORD PTR [rsp]
    23d8:	mov    QWORD PTR [rbp+0x0],r15
    23dc:	mov    DWORD PTR [rbp+0x18],r14d
    23e0:	movups XMMWORD PTR [rbp+0x8],xmm0
  return result;
    23e4:	mov    rax,r13
    23e7:	mov    rdx,rbx
}
    23ea:	mov    rcx,QWORD PTR [rsp+0xa8]
    23f2:	sub    rcx,QWORD PTR fs:0x28
    23fb:	jne    240f <read_file_to_arena+0xcf>
    23fd:	add    rsp,0xb8
    2404:	pop    rbx
    2405:	pop    rbp
    2406:	pop    r12
    2408:	pop    r13
    240a:	pop    r14
    240c:	pop    r15
    240e:	ret
    240f:	call   1060 <__stack_chk_fail@plt>
    2414:	nop
    2415:	data16 cs nop WORD PTR [rax+rax*1+0x0]

0000000000002420 <arena_pop_to>:
  ASSERT(offset < arena->next_offset,
    2420:	cmp    QWORD PTR [rdi+0x10],rsi
    2424:	jle    121d <arena_pop_to.cold>
  arena->next_offset = offset;
    242a:	mov    QWORD PTR [rdi+0x10],rsi
    242e:	ret
    242f:	nop

0000000000002430 <arena_pop>:
  arena_pop_to(arena, arena->next_offset - size);
    2430:	mov    rdx,QWORD PTR [rdi+0x10]
    2434:	mov    rax,rdx
    2437:	sub    rax,rsi
  ASSERT(offset < arena->next_offset,
    243a:	cmp    rdx,rax
    243d:	jle    1223 <arena_pop.cold>
  arena->next_offset = offset;
    2443:	mov    QWORD PTR [rdi+0x10],rax
    2447:	ret
    2448:	nop    DWORD PTR [rax+rax*1+0x0]

0000000000002450 <arena_clear>:
  arena->next_offset = 0;
    2450:	mov    QWORD PTR [rdi+0x10],0x0
}
    2458:	ret
    2459:	nop    DWORD PTR [rax+0x0]

0000000000002460 <scratch_begin>:
  return scratch;
    2460:	mov    rdx,QWORD PTR [rdi+0x10]
    2464:	mov    rax,rdi
}
    2467:	ret
    2468:	nop    DWORD PTR [rax+rax*1+0x0]

0000000000002470 <scratch_end>:
  arena_pop_to(scratch->arena, scratch->offset_save);
    2470:	mov    rax,QWORD PTR [rdi]
    2473:	mov    rdx,QWORD PTR [rdi+0x8]
  ASSERT(offset < arena->next_offset,
    2477:	cmp    rdx,QWORD PTR [rax+0x10]
    247b:	jge    1229 <scratch_end.cold>
  ZERO_STRUCT(scratch);
    2481:	pxor   xmm0,xmm0
  arena->next_offset = offset;
    2485:	mov    QWORD PTR [rax+0x10],rdx
  ZERO_STRUCT(scratch);
    2489:	movups XMMWORD PTR [rdi],xmm0
    248c:	ret
    248d:	nop    DWORD PTR [rax]

0000000000002490 <get_json_token>:
  return parser->at < parser->source.count;
    2490:	mov    r8,QWORD PTR [rsi+0x10]
    2494:	mov    rdx,QWORD PTR [rsi+0x8]
{
    2498:	mov    r9,rdi
  while (parser_incomplete(parser)  &&
    249b:	cmp    r8,rdx
    249e:	jae    251b <get_json_token+0x8b>
  return parser->source.data + parser->at;
    24a0:	mov    rcx,QWORD PTR [rsi]
    24a3:	mov    edi,0x800013
    24a8:	nop    DWORD PTR [rax+rax*1+0x0]
    24b0:	movzx  eax,BYTE PTR [rcx+r8*1]
    24b5:	sub    eax,0x9
    24b8:	cmp    al,0x17
    24ba:	ja     24f0 <get_json_token+0x60>
    24bc:	bt     rdi,rax
    24c0:	jae    24f0 <get_json_token+0x60>
  parser->at += advance;
    24c2:	add    r8,0x1
    24c6:	mov    QWORD PTR [rsi+0x10],r8
  while (parser_incomplete(parser)  &&
    24ca:	cmp    r8,rdx
    24cd:	jne    24b0 <get_json_token+0x20>
  parser->at += advance;
    24cf:	add    rdx,0x1
  JSON_Token token = {0};
    24d3:	xor    eax,eax
    24d5:	xor    r10d,r10d
  parser->at += advance;
    24d8:	mov    QWORD PTR [rsi+0x10],rdx
  JSON_Token token = {0};
    24dc:	xor    edx,edx
  return token;
    24de:	mov    QWORD PTR [r9+0x10],rax
}
    24e2:	mov    rax,r9
  return token;
    24e5:	mov    DWORD PTR [r9],edx
    24e8:	mov    QWORD PTR [r9+0x8],r10
}
    24ec:	ret
    24ed:	nop    DWORD PTR [rax]
  if (parser_incomplete(parser)) // If we've not reached the end of file
    24f0:	cmp    r8,rdx
    24f3:	jae    251b <get_json_token+0x8b>
  return parser->source.data + parser->at;
    24f5:	lea    r10,[rcx+r8*1]
    switch (*parser_at(parser))
    24f9:	movzx  eax,BYTE PTR [r10]
    24fd:	sub    eax,0x22
    2500:	cmp    al,0x5b
    2502:	ja     2578 <get_json_token+0xe8>
    2504:	lea    rdi,[rip+0x1215]        # 3720 <_IO_stdin_used+0x720>
    250b:	movzx  eax,al
{
    250e:	sub    rsp,0x18
    switch (*parser_at(parser))
    2512:	movsxd rax,DWORD PTR [rdi+rax*4]
    2516:	add    rax,rdi
    2519:	jmp    rax
    251b:	mov    rdx,r8
    251e:	jmp    24cf <get_json_token+0x3f>
  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    2520:	cmp    DWORD PTR [r10],0x736c6166
    2527:	je     2700 <get_json_token+0x270>
    252d:	mov    QWORD PTR [rsp],r10
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2531:	lea    rcx,[rip+0xeb8]        # 33f0 <_IO_stdin_used+0x3f0>
    2538:	mov    edx,0xee
    253d:	mov    QWORD PTR [rsp+0x8],r9
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2542:	lea    rsi,[rip+0xabb]        # 3004 <_IO_stdin_used+0x4>
    2549:	mov    edi,0x1
    254e:	xor    eax,eax
    2550:	call   2040 <log_message>
    2555:	mov    r10,QWORD PTR [rsp]
    2559:	mov    r9,QWORD PTR [rsp+0x8]
  JSON_Token token = {0};
    255e:	xor    eax,eax
    2560:	xor    edx,edx
  return token;
    2562:	mov    QWORD PTR [r9+0x10],rax
}
    2566:	mov    rax,r9
  return token;
    2569:	mov    DWORD PTR [r9],edx
    256c:	mov    QWORD PTR [r9+0x8],r10
}
    2570:	add    rsp,0x18
    2574:	ret
    2575:	nop    DWORD PTR [rax]
  JSON_Token token = {0};
    2578:	xor    eax,eax
    257a:	xor    edx,edx
    257c:	jmp    24de <get_json_token+0x4e>
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2581:	mov    rdi,QWORD PTR [rsi+0x10]
    2585:	cmp    rdi,rdx
    2588:	jae    122f <get_json_token.cold>
    258e:	sub    rdx,rdi
        usize digit_count = 0;
    2591:	xor    eax,eax
    2593:	lea    r8,[rcx+rdi*1]
        while (is_numeric(*parser_at(parser)))
    2597:	movzx  ecx,BYTE PTR [r8+rax*1]
  switch (ch)
    259c:	cmp    cl,0x2e
    259f:	ja     26d7 <get_json_token+0x247>
    25a5:	cmp    cl,0x2c
    25a8:	ja     26e3 <get_json_token+0x253>
        token.type  = JSON_TOKEN_NUMBER;
    25ae:	mov    edx,0x8
      break;
    25b3:	jmp    2562 <get_json_token+0xd2>
  parser->at += advance;
    25b5:	add    r8,0x1
        token.value.count = 1;
    25b9:	mov    eax,0x1
        token.type = JSON_TOKEN_COMMA;
    25be:	mov    edx,0x5
  parser->at += advance;
    25c3:	mov    QWORD PTR [rsi+0x10],r8
}
    25c7:	jmp    2562 <get_json_token+0xd2>
  parser->at += advance;
    25c9:	add    r8,0x1
        token.value.count = 1;
    25cd:	mov    eax,0x1
        token.type = JSON_TOKEN_COLON;
    25d2:	mov    edx,0x6
  parser->at += advance;
    25d7:	mov    QWORD PTR [rsi+0x10],r8
}
    25db:	jmp    2562 <get_json_token+0xd2>
  parser->at += advance;
    25dd:	add    r8,0x1
        token.value.count = 1;
    25e1:	mov    eax,0x1
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    25e6:	mov    edx,0x3
  parser->at += advance;
    25eb:	mov    QWORD PTR [rsi+0x10],r8
}
    25ef:	jmp    2562 <get_json_token+0xd2>
  parser->at += advance;
    25f4:	add    r8,0x1
        token.value.count = 1;
    25f8:	mov    eax,0x1
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    25fd:	mov    edx,0x4
  parser->at += advance;
    2602:	mov    QWORD PTR [rsi+0x10],r8
}
    2606:	jmp    2562 <get_json_token+0xd2>
        if (parser_token_is_literal(parser, string))
    260b:	cmp    DWORD PTR [r10],0x6c6c756e
    2612:	jne    271f <get_json_token+0x28f>
  parser->at += advance;
    2618:	add    r8,0x4
  JSON_Token token = {0};
    261c:	xor    eax,eax
          token.type  = JSON_TOKEN_NULL;
    261e:	mov    edx,0xb
  parser->at += advance;
    2623:	mov    QWORD PTR [rsi+0x10],r8
}
    2627:	jmp    2562 <get_json_token+0xd2>
        if (parser_token_is_literal(parser, string))
    262c:	cmp    DWORD PTR [r10],0x65757274
    2633:	jne    2739 <get_json_token+0x2a9>
  parser->at += advance;
    2639:	add    r8,0x4
  JSON_Token token = {0};
    263d:	xor    eax,eax
          token.type  = JSON_TOKEN_TRUE;
    263f:	mov    edx,0x9
  parser->at += advance;
    2644:	mov    QWORD PTR [rsi+0x10],r8
}
    2648:	jmp    2562 <get_json_token+0xd2>
  parser->at += advance;
    264d:	add    r8,0x1
        token.value.count = 1;
    2651:	mov    eax,0x1
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2656:	mov    edx,0x2
  parser->at += advance;
    265b:	mov    QWORD PTR [rsi+0x10],r8
}
    265f:	jmp    2562 <get_json_token+0xd2>
  parser->at += advance;
    2664:	add    r8,0x1
        token.value.count = 1;
    2668:	mov    eax,0x1
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    266d:	mov    edx,0x1
  parser->at += advance;
    2672:	mov    QWORD PTR [rsi+0x10],r8
}
    2676:	jmp    2562 <get_json_token+0xd2>
  parser->at += advance;
    267b:	lea    r10,[r8+0x1]
    267f:	mov    QWORD PTR [rsi+0x10],r10
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2683:	cmp    r10,rdx
    2686:	jae    122f <get_json_token.cold>
    268c:	mov    rdi,r10
    268f:	jmp    26ad <get_json_token+0x21d>
    2691:	nop    DWORD PTR [rax+0x0]
    2695:	data16 cs nop WORD PTR [rax+rax*1+0x0]
  parser->at += advance;
    26a0:	mov    QWORD PTR [rsi+0x10],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    26a4:	cmp    rdi,rdx
    26a7:	jae    2753 <get_json_token+0x2c3>
        while (*parser_at(parser) != '"')
    26ad:	movzx  r11d,BYTE PTR [rcx+rdi*1]
    26b2:	mov    rax,rdi
  parser->at += advance;
    26b5:	add    rdi,0x1
        while (*parser_at(parser) != '"')
    26b9:	cmp    r11b,0x22
    26bd:	jne    26a0 <get_json_token+0x210>
        token.value.count = string_count;
    26bf:	sub    rax,r8
  parser->at += advance;
    26c2:	mov    QWORD PTR [rsi+0x10],rdi
  return parser->source.data + parser->at;
    26c6:	add    r10,rcx
        token.type = JSON_TOKEN_STRING;
    26c9:	mov    edx,0x7
        token.value.count = string_count;
    26ce:	sub    rax,0x1
}
    26d2:	jmp    2562 <get_json_token+0xd2>
  switch (ch)
    26d7:	sub    ecx,0x30
    26da:	cmp    cl,0x9
    26dd:	ja     25ae <get_json_token+0x11e>
          digit_count += 1;
    26e3:	add    rax,0x1
  parser->at += advance;
    26e7:	lea    rcx,[rdi+rax*1]
    26eb:	mov    QWORD PTR [rsi+0x10],rcx
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    26ef:	cmp    rdx,rax
    26f2:	jne    2597 <get_json_token+0x107>
    26f8:	jmp    122f <get_json_token.cold>
    26fd:	nop    DWORD PTR [rax]
  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    2700:	cmp    BYTE PTR [r10+0x4],0x65
    2705:	jne    252d <get_json_token+0x9d>
  parser->at += advance;
    270b:	add    r8,0x5
  JSON_Token token = {0};
    270f:	xor    eax,eax
          token.type  = JSON_TOKEN_FALSE;
    2711:	mov    edx,0xa
  parser->at += advance;
    2716:	mov    QWORD PTR [rsi+0x10],r8
}
    271a:	jmp    2562 <get_json_token+0xd2>
    271f:	mov    QWORD PTR [rsp],r10
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2723:	lea    rcx,[rip+0xcc6]        # 33f0 <_IO_stdin_used+0x3f0>
    272a:	mov    edx,0xfd
    272f:	mov    QWORD PTR [rsp+0x8],r9
    2734:	jmp    2542 <get_json_token+0xb2>
    2739:	mov    QWORD PTR [rsp],r10
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    273d:	lea    rcx,[rip+0xcac]        # 33f0 <_IO_stdin_used+0x3f0>
    2744:	mov    edx,0xdf
    2749:	mov    QWORD PTR [rsp+0x8],r9
    274e:	jmp    2542 <get_json_token+0xb2>
    2753:	jmp    122f <get_json_token.cold>
    2758:	nop    DWORD PTR [rax+rax*1+0x0]

0000000000002760 <parse_json_children>:
{
    2760:	push   r15
    2762:	push   r14
    2764:	push   r13
    2766:	push   r12
    2768:	push   rbp
    2769:	push   rbx
    276a:	sub    rsp,0xc8
    .parent_index = g_profiler.current_parent_zone,
    2771:	mov    r8,QWORD PTR [rip+0x29b0]        # 5128 <g_profiler+0x8>
    2778:	mov    QWORD PTR [rsp+0x10],rdi
    277d:	mov    r13,QWORD PTR fs:0x28
    2786:	mov    QWORD PTR [rsp+0xb8],r13
    278e:	mov    r13d,edx
  g_profiler.current_parent_zone = zone_index;
    2791:	mov    QWORD PTR [rip+0x298c],0x2        # 5128 <g_profiler+0x8>
    279c:	rdtsc
    279e:	shl    rdx,0x20
  return pass;
    27a2:	mov    QWORD PTR [rsp+0xa8],r8
    27aa:	mov    QWORD PTR [rsp+0x88],0x13
    27b6:	or     rax,rdx
    27b9:	lea    rdx,[rip+0x10f0]        # 38b0 <__func__.2>
    27c0:	movq   xmm0,rax
  while (parser_incomplete(parser))
    27c5:	mov    rax,QWORD PTR [rsi+0x8]
    27c9:	movhps xmm0,QWORD PTR [rip+0x29d8]        # 51a8 <g_profiler+0x88>
    27d0:	mov    QWORD PTR [rsp+0x80],rdx
    27d8:	mov    QWORD PTR [rsp+0xa0],0x2
    27e4:	mov    QWORD PTR [rsp+0xb0],0x0
    27f0:	movaps XMMWORD PTR [rsp+0x90],xmm0
    27f8:	cmp    QWORD PTR [rsi+0x10],rax
    27fc:	jae    2a11 <parse_json_children+0x2b1>
    2802:	mov    DWORD PTR [rsp+0xc],ecx
    2806:	mov    r15,rsi
  JSON_Object *current_last_child = NULL;
    2809:	xor    r12d,r12d
  JSON_Object *first_child        = NULL;
    280c:	xor    r14d,r14d
    280f:	nop
    if (has_keys)
    2810:	mov    ecx,DWORD PTR [rsp+0xc]
    JSON_Token key_token = {0};
    2814:	pxor   xmm0,xmm0
    2818:	mov    QWORD PTR [rsp+0x30],0x0
    JSON_Token value_token = {0};
    2821:	mov    QWORD PTR [rsp+0x50],0x0
    JSON_Token key_token = {0};
    282a:	movaps XMMWORD PTR [rsp+0x20],xmm0
    JSON_Token value_token = {0};
    282f:	movaps XMMWORD PTR [rsp+0x40],xmm0
    if (has_keys)
    2834:	test   ecx,ecx
    2836:	je     2988 <parse_json_children+0x228>
      key_token = get_json_token(parser);
    283c:	lea    rdi,[rsp+0x20]
    2841:	mov    rsi,r15
    2844:	call   2490 <get_json_token>
    2849:	mov    eax,DWORD PTR [rsp+0x20]
    284d:	mov    r10,QWORD PTR [rsp+0x28]
    2852:	mov    rbx,QWORD PTR [rsp+0x30]
      if (key_token.type == JSON_TOKEN_STRING)
    2857:	cmp    eax,0x7
    285a:	je     29c0 <parse_json_children+0x260>
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2860:	sub    rsp,0x8
    2864:	mov    edx,0x164
    2869:	mov    r9d,ebx
    286c:	mov    edi,0x1
    2871:	push   r10
    2873:	lea    rcx,[rip+0x24e6]        # 4d60 <JSON_Token_Type_strings>
    287a:	lea    rsi,[rip+0x783]        # 3004 <_IO_stdin_used+0x4>
    2881:	mov    r8,QWORD PTR [rcx+rax*8]
    2885:	xor    eax,eax
    2887:	lea    rcx,[rip+0xbb2]        # 3440 <_IO_stdin_used+0x440>
    288e:	mov    QWORD PTR [rsp+0x28],r10
    2893:	call   2040 <log_message>
    2898:	pop    rax
    2899:	pop    rdx
    289a:	mov    r10,QWORD PTR [rsp+0x18]
    289f:	lea    rbp,[rsp+0x60]
    JSON_Token value_token = {0};
    28a4:	xor    eax,eax
    28a6:	cs nop WORD PTR [rax+rax*1+0x0]
    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    28b0:	mov    QWORD PTR [rsp+0x30],rbx
    28b5:	sub    rsp,0x20
    28b9:	mov    rsi,r15
    28bc:	mov    QWORD PTR [rsp+0x48],r10
    28c1:	mov    DWORD PTR [rsp+0x60],eax
    28c5:	movdqa xmm0,XMMWORD PTR [rsp+0x60]
    28cb:	mov    rax,QWORD PTR [rsp+0x70]
    28d0:	mov    rdx,QWORD PTR [rsp+0x48]
    28d5:	mov    rcx,QWORD PTR [rsp+0x50]
    28da:	mov    rdi,QWORD PTR [rsp+0x30]
    28df:	movups XMMWORD PTR [rsp],xmm0
    28e3:	mov    QWORD PTR [rsp+0x10],rax
    28e8:	call   2ab0 <parse_json_object>
      if (!first_child)
    28ed:	add    rsp,0x20
    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    28f1:	mov    rbx,rax
      if (!first_child)
    28f4:	test   r14,r14
    28f7:	je     29b0 <parse_json_children+0x250>
        current_last_child->next_sibling = object;
    28fd:	mov    QWORD PTR [r12+0x28],rax
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2902:	mov    rsi,r15
    2905:	mov    rdi,rbp
    2908:	call   2490 <get_json_token>
    290d:	mov    eax,DWORD PTR [rsp+0x60]
    if (expect_comma_or_end.type == end_token)
    2911:	cmp    r13d,eax
    2914:	je     2a20 <parse_json_children+0x2c0>
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    291a:	cmp    eax,0x5
    291d:	je     296c <parse_json_children+0x20c>
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    291f:	mov    r9,QWORD PTR [rsp+0x70]
    2924:	sub    rsp,0x18
    2928:	lea    rcx,[rip+0x2431]        # 4d60 <JSON_Token_Type_strings>
    292f:	mov    edx,0x18b
    2934:	movdqa xmm0,XMMWORD PTR [rsp+0x78]
    293a:	mov    r8,QWORD PTR [rcx+rax*8]
    293e:	mov    edi,0x1
    2943:	xor    eax,eax
    2945:	mov    QWORD PTR [rsp+0x10],r9
    294a:	lea    rcx,[rip+0xb17]        # 3468 <_IO_stdin_used+0x468>
    2951:	lea    rsi,[rip+0x6ac]        # 3004 <_IO_stdin_used+0x4>
    2958:	movups XMMWORD PTR [rsp],xmm0
    295c:	push   QWORD PTR [rsp+0x80]
    2963:	call   2040 <log_message>
    2968:	add    rsp,0x20
  while (parser_incomplete(parser))
    296c:	mov    rax,QWORD PTR [r15+0x8]
    2970:	cmp    QWORD PTR [r15+0x10],rax
    2974:	jae    2a20 <parse_json_children+0x2c0>
    297a:	mov    r12,rbx
    297d:	jmp    2810 <parse_json_children+0xb0>
    2982:	nop    WORD PTR [rax+rax*1+0x0]
      value_token = get_json_token(parser);
    2988:	lea    rdi,[rsp+0x40]
    298d:	mov    rsi,r15
    JSON_Token key_token = {0};
    2990:	xor    ebx,ebx
      value_token = get_json_token(parser);
    2992:	call   2490 <get_json_token>
    2997:	mov    eax,DWORD PTR [rsp+0x40]
    JSON_Token key_token = {0};
    299b:	xor    r10d,r10d
    if (value_token.type == end_token)
    299e:	cmp    eax,r13d
    29a1:	je     2a20 <parse_json_children+0x2c0>
    29a3:	lea    rbp,[rsp+0x60]
    29a8:	jmp    28b0 <parse_json_children+0x150>
    29ad:	nop    DWORD PTR [rax]
        first_child        = object;
    29b0:	mov    r14,rax
    29b3:	jmp    2902 <parse_json_children+0x1a2>
    29b8:	nop    DWORD PTR [rax+rax*1+0x0]
        JSON_Token expect_colon = get_json_token(parser);
    29c0:	lea    rbp,[rsp+0x60]
    29c5:	mov    rsi,r15
    29c8:	mov    QWORD PTR [rsp+0x18],r10
    29cd:	mov    rdi,rbp
    29d0:	call   2490 <get_json_token>
        if (expect_colon.type == JSON_TOKEN_COLON)
    29d5:	cmp    DWORD PTR [rsp+0x60],0x6
    29da:	je     2a90 <parse_json_children+0x330>
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    29e0:	mov    r9,QWORD PTR [rsp+0x18]
    29e5:	mov    r8d,ebx
    29e8:	mov    edx,0x15f
    29ed:	xor    eax,eax
    29ef:	lea    rcx,[rip+0xa2a]        # 3420 <_IO_stdin_used+0x420>
    29f6:	lea    rsi,[rip+0x607]        # 3004 <_IO_stdin_used+0x4>
    29fd:	mov    edi,0x1
    2a02:	call   2040 <log_message>
    if (value_token.type == end_token)
    2a07:	mov    r10,QWORD PTR [rsp+0x18]
    2a0c:	jmp    28a4 <parse_json_children+0x144>
  JSON_Object *first_child        = NULL;
    2a11:	xor    r14d,r14d
    2a14:	nop
    2a15:	data16 cs nop WORD PTR [rax+rax*1+0x0]
  profile_end_func();
    2a20:	sub    rsp,0x40
    2a24:	movdqa xmm0,XMMWORD PTR [rsp+0xc0]
    2a2d:	mov    rax,QWORD PTR [rsp+0xf0]
    2a35:	movups XMMWORD PTR [rsp],xmm0
    2a39:	movdqa xmm0,XMMWORD PTR [rsp+0xd0]
    2a42:	mov    QWORD PTR [rsp+0x30],rax
    2a47:	movups XMMWORD PTR [rsp+0x10],xmm0
    2a4c:	movdqa xmm0,XMMWORD PTR [rsp+0xe0]
    2a55:	movups XMMWORD PTR [rsp+0x20],xmm0
    2a5a:	call   1e80 <__profile_end_pass.constprop.0>
  return first_child;
    2a5f:	add    rsp,0x40
}
    2a63:	mov    rax,QWORD PTR [rsp+0xb8]
    2a6b:	sub    rax,QWORD PTR fs:0x28
    2a74:	jne    2aab <parse_json_children+0x34b>
    2a76:	add    rsp,0xc8
    2a7d:	mov    rax,r14
    2a80:	pop    rbx
    2a81:	pop    rbp
    2a82:	pop    r12
    2a84:	pop    r13
    2a86:	pop    r14
    2a88:	pop    r15
    2a8a:	ret
    2a8b:	nop    DWORD PTR [rax+rax*1+0x0]
          value_token = get_json_token(parser);
    2a90:	lea    rdi,[rsp+0x40]
    2a95:	mov    rsi,r15
    2a98:	call   2490 <get_json_token>
    2a9d:	mov    eax,DWORD PTR [rsp+0x40]
    2aa1:	mov    r10,QWORD PTR [rsp+0x18]
    2aa6:	jmp    299e <parse_json_children+0x23e>
}
    2aab:	call   1060 <__stack_chk_fail@plt>

0000000000002ab0 <parse_json_object>:
{
    2ab0:	push   r13
    2ab2:	mov    r9,rdi
    2ab5:	mov    r13,rcx
    2ab8:	mov    rdi,rsi
    2abb:	push   r12
    2abd:	mov    r12,rdx
    2ac0:	push   rbx
    2ac1:	sub    rsp,0x50
    .parent_index = g_profiler.current_parent_zone,
    2ac5:	mov    rsi,QWORD PTR [rip+0x265c]        # 5128 <g_profiler+0x8>
  g_profiler.current_parent_zone = zone_index;
    2acc:	mov    QWORD PTR [rip+0x2651],0x1        # 5128 <g_profiler+0x8>
    2ad7:	mov    ecx,DWORD PTR [rsp+0x70]
    2adb:	rdtsc
  return pass;
    2add:	lea    rbx,[rip+0xdec]        # 38d0 <__func__.3>
    2ae4:	shl    rdx,0x20
    2ae8:	mov    QWORD PTR [rsp+0x10],rbx
    2aed:	or     rax,rdx
    2af0:	mov    QWORD PTR [rsp+0x38],rsi
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    2af5:	mov    edx,0x2
    2afa:	mov    QWORD PTR [rsp+0x18],0x11
    2b03:	movq   xmm0,rax
    2b08:	movhps xmm0,QWORD PTR [rip+0x2669]        # 5178 <g_profiler+0x58>
    2b0f:	mov    QWORD PTR [rsp+0x30],0x1
    2b18:	mov    QWORD PTR [rsp+0x40],0x0
    2b21:	movaps XMMWORD PTR [rsp+0x20],xmm0
  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2b26:	cmp    ecx,0x1
    2b29:	je     2c17 <parse_json_object+0x167>
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2b2f:	cmp    ecx,0x3
    2b32:	je     2c10 <parse_json_object+0x160>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2b38:	lea    eax,[rcx-0x7]
                       type == JSON_TOKEN_NULL   ||
    2b3b:	cmp    eax,0x4
    2b3e:	ja     2bc0 <parse_json_object+0x110>
  JSON_Object *first_child = NULL;
    2b44:	xor    ebx,ebx
  JSON_Object *result  = arena_new(arena, JSON_Object);
    2b46:	mov    edx,0x8
    2b4b:	mov    esi,0x30
    2b50:	mov    rdi,r9
    2b53:	call   22c0 <arena_alloc>
  result->value        = token.value;
    2b58:	movdqu xmm0,XMMWORD PTR [rsp+0x78]
  profile_end_func();
    2b5e:	sub    rsp,0x40
  result->key          = key;
    2b62:	mov    QWORD PTR [rax],r12
  JSON_Object *result  = arena_new(arena, JSON_Object);
    2b65:	mov    r10,rax
  result->value        = token.value;
    2b68:	movups XMMWORD PTR [rax+0x10],xmm0
  profile_end_func();
    2b6c:	movdqa xmm0,XMMWORD PTR [rsp+0x50]
  result->key          = key;
    2b72:	mov    QWORD PTR [rax+0x8],r13
  result->first_child  = first_child;
    2b76:	mov    QWORD PTR [rax+0x20],rbx
  result->next_sibling = NULL;
    2b7a:	mov    QWORD PTR [rax+0x28],0x0
  profile_end_func();
    2b82:	mov    rax,QWORD PTR [rsp+0x80]
    2b8a:	movups XMMWORD PTR [rsp],xmm0
    2b8e:	movdqa xmm0,XMMWORD PTR [rsp+0x60]
    2b94:	mov    QWORD PTR [rsp+0x30],rax
    2b99:	movups XMMWORD PTR [rsp+0x10],xmm0
    2b9e:	movdqa xmm0,XMMWORD PTR [rsp+0x70]
    2ba4:	movups XMMWORD PTR [rsp+0x20],xmm0
    2ba9:	call   1e80 <__profile_end_pass.constprop.0>
}
    2bae:	add    rsp,0x90
    2bb5:	mov    rax,r10
    2bb8:	pop    rbx
    2bb9:	pop    r12
    2bbb:	pop    r13
    2bbd:	ret
    2bbe:	xchg   ax,ax
    2bc0:	mov    QWORD PTR [rsp+0x8],r9
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2bc5:	lea    rax,[rip+0x2194]        # 4d60 <JSON_Token_Type_strings>
    2bcc:	mov    edx,0x134
    2bd1:	lea    rsi,[rip+0x42c]        # 3004 <_IO_stdin_used+0x4>
    2bd8:	push   QWORD PTR [rsp+0x80]
    2bdf:	mov    r8,QWORD PTR [rax+rcx*8]
    2be3:	mov    edi,0x1
    2be8:	xor    eax,eax
    2bea:	push   QWORD PTR [rsp+0x80]
    2bf1:	lea    rcx,[rip+0x8b0]        # 34a8 <_IO_stdin_used+0x4a8>
    2bf8:	call   2040 <log_message>
    2bfd:	pop    rax
    2bfe:	pop    rdx
    2bff:	mov    r9,QWORD PTR [rsp+0x8]
    2c04:	jmp    2b44 <parse_json_object+0x94>
    2c09:	nop    DWORD PTR [rax+0x0]
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2c10:	xor    ecx,ecx
    2c12:	mov    edx,0x4
    2c17:	mov    rsi,rdi
    2c1a:	mov    rdi,r9
    2c1d:	mov    QWORD PTR [rsp+0x8],r9
    2c22:	call   2760 <parse_json_children>
    2c27:	mov    r9,QWORD PTR [rsp+0x8]
    2c2c:	mov    rbx,rax
    2c2f:	jmp    2b46 <parse_json_object+0x96>
    2c34:	nop
    2c35:	data16 cs nop WORD PTR [rax+rax*1+0x0]

0000000000002c40 <json_token_type_is_value_type>:
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2c40:	sub    edi,0x7
                       type == JSON_TOKEN_NULL   ||
    2c43:	xor    eax,eax
    2c45:	cmp    edi,0x4
    2c48:	setbe  al
}
    2c4b:	ret
    2c4c:	nop    DWORD PTR [rax+0x0]

0000000000002c50 <json_object_to_f64>:
  ASSERT(object, "Must pass valid object to f64 conversion");
    2c50:	test   rdi,rdi
    2c53:	je     1234 <json_object_to_f64.cold>

  String val = object->value;
    2c59:	mov    rcx,QWORD PTR [rdi+0x18]
  // Get sign.
  usize at = 0;

  f64 sign = 1.0;
  if (val.count > at && val.data[at] == '-')
    2c5d:	pxor   xmm0,xmm0
    2c61:	test   rcx,rcx
    2c64:	je     2cff <json_object_to_f64+0xaf>
  String val = object->value;
    2c6a:	mov    rsi,QWORD PTR [rdi+0x10]
  if (val.count > at && val.data[at] == '-')
    2c6e:	cmp    BYTE PTR [rsi],0x2d
    2c71:	je     2d00 <json_object_to_f64+0xb0>
  f64 sign = 1.0;
    2c77:	movsd  xmm4,QWORD PTR [rip+0xcf1]        # 3970 <__PRETTY_FUNCTION__.9+0x20>
  usize at = 0;
    2c7f:	xor    edx,edx
  {
    u8 digit = val.data[at] - (u8)'0';
    if (digit < 10)
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    2c81:	movsd  xmm2,QWORD PTR [rip+0xcff]        # 3988 <__PRETTY_FUNCTION__.9+0x38>
  f64 result = 0.0;
    2c89:	pxor   xmm0,xmm0
    2c8d:	jmp    2cdc <json_object_to_f64+0x8c>
    2c8f:	nop    DWORD PTR [rax+rax*1+0x0]
    2c94:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    2c9f:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    2caa:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    2cb5:	data16 cs nop WORD PTR [rax+rax*1+0x0]
      result = 10 * result + (f64)digit;
    2cc0:	mulsd  xmm0,xmm2
    2cc4:	movzx  eax,al
    2cc7:	pxor   xmm1,xmm1
      at += 1;
    2ccb:	add    rdx,0x1
      result = 10 * result + (f64)digit;
    2ccf:	cvtsi2sd xmm1,eax
    2cd3:	addsd  xmm0,xmm1
  while (at < val.count)
    2cd7:	cmp    rdx,rcx
    2cda:	jae    2cf2 <json_object_to_f64+0xa2>
    u8 digit = val.data[at] - (u8)'0';
    2cdc:	movzx  eax,BYTE PTR [rsi+rdx*1]
    2ce0:	sub    eax,0x30
    if (digit < 10)
    2ce3:	cmp    al,0x9
    2ce5:	jbe    2cc0 <json_object_to_f64+0x70>
      break;
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    2ce7:	cmp    rdx,rcx
    2cea:	jae    2cf2 <json_object_to_f64+0xa2>
    2cec:	cmp    BYTE PTR [rsi+rdx*1],0x2e
    2cf0:	je     2d20 <json_object_to_f64+0xd0>
        break;
      }
    }
  }

  return sign * result;
    2cf2:	mulsd  xmm0,xmm4
    2cf6:	ret
  while (at < val.count)
    2cf7:	movsd  xmm0,QWORD PTR [rip+0xc81]        # 3980 <__PRETTY_FUNCTION__.9+0x30>
}
    2cff:	ret
  while (at < val.count)
    2d00:	cmp    rcx,0x1
    2d04:	je     2cf7 <json_object_to_f64+0xa7>
    2d06:	movsd  xmm4,QWORD PTR [rip+0xc5a]        # 3968 <__PRETTY_FUNCTION__.9+0x18>
    2d0e:	mov    edx,0x1
    2d13:	jmp    2c81 <json_object_to_f64+0x31>
    2d18:	nop    DWORD PTR [rax+rax*1+0x0]
    at += 1;
    2d20:	add    rdx,0x1
    while (at < val.count)
    2d24:	cmp    rdx,rcx
    2d27:	jae    2cf2 <json_object_to_f64+0xa2>
    f64 factor = 1.0 / 10.0;
    2d29:	movsd  xmm3,QWORD PTR [rip+0xc47]        # 3978 <__PRETTY_FUNCTION__.9+0x28>
    2d31:	movapd xmm2,xmm3
    2d35:	jmp    2d60 <json_object_to_f64+0x110>
    2d37:	nop    WORD PTR [rax+rax*1+0x0]
        result = result + factor * (f64)digit;
    2d40:	movzx  eax,al
    2d43:	pxor   xmm1,xmm1
        at += 1;
    2d47:	add    rdx,0x1
        result = result + factor * (f64)digit;
    2d4b:	cvtsi2sd xmm1,eax
    2d4f:	mulsd  xmm1,xmm2
        factor *= 1.0 / 10.0;
    2d53:	mulsd  xmm2,xmm3
        result = result + factor * (f64)digit;
    2d57:	addsd  xmm0,xmm1
    while (at < val.count)
    2d5b:	cmp    rdx,rcx
    2d5e:	jae    2cf2 <json_object_to_f64+0xa2>
      u8 digit = val.data[at] - (u8)'0';
    2d60:	movzx  eax,BYTE PTR [rsi+rdx*1]
    2d64:	sub    eax,0x30
      if (digit < 10)
    2d67:	cmp    al,0x9
    2d69:	jbe    2d40 <json_object_to_f64+0xf0>
    2d6b:	jmp    2cf2 <json_object_to_f64+0xa2>

Disassembly of section .fini:

0000000000002d70 <_fini>:
    2d70:	endbr64
    2d74:	sub    rsp,0x8
    2d78:	add    rsp,0x8
    2d7c:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x4fc1]        # 5fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x4fca]        # 5ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x4fcc]        # 5ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x4fca]        # 6000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x4fc2]        # 6008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x4fba]        # 6010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x4fb2]        # 6018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x4faa]        # 6020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x4fa2]        # 6028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x4f9a]        # 6030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x4f92]        # 6038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x4f8a]        # 6040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x4f82]        # 6048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x4f7a]        # 6050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x4f72]        # 6058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x4f6a]        # 6060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x4f62]        # 6068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x4f5a]        # 6070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x4f52]        # 6078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x4f4a]        # 6080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x4f42]        # 6088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x4f3a]        # 6090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x4f32]        # 6098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2114]        # 32a3 <main>
    118f:	call   QWORD PTR [rip+0x4e2b]        # 5fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x4fa1]        # 6148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x4f9a]        # 6148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x4e0e]        # 5fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x4f71]        # 6148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x4f6a]        # 6148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x4ddd]        # 5fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x4f6d],0x0        # 6188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x4dba],0x0        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x4e76]        # 60a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x4da8]        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x4f44],0x1        # 6188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x4c6e]        # 6180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x4b89]        # 60c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x4be7]        # 6160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x4b2b]        # 60c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x3097]        # 4790 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x306b]        # 4790 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fae]        # 47a8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2eaf]        # 47b8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2ccd]        # 47d0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x4639]        # 61a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x4620],rbx        # 61a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x40
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x45ee]        # 61a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x28],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x28],0x0
    1bbe:	je     1e44 <end_profiling+0x2a9>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x20],rax
    printf("[PROFILE] Total duration: %lu (%fms @ CPU Frequency: %u)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x28]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x20]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c51]        # 4888 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x20]
    1c44:	mov    rax,QWORD PTR [rbp-0x28]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x38],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x30],0x0
    1c72:	jmp    1e36 <end_profiling+0x29b>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x30]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x450d]        # 61a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x18],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x18]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1e31 <end_profiling+0x296>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x18]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x28]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b77]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x10],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x18]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x18]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x18]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x18]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x10]
    1d48:	lea    rdi,[rip+0x2581]        # 42d0 <_IO_stdin_used+0x2d0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x18]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x18]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x18]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x28]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2a9f]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x8],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x18]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x8]
    1e06:	lea    rcx,[rip+0x251b]        # 4328 <_IO_stdin_used+0x328>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x38]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x10]
    1e2c:	movsd  QWORD PTR [rbp-0x38],xmm0
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1e31:	add    QWORD PTR [rbp-0x30],0x1
    1e36:	cmp    QWORD PTR [rbp-0x30],0xfff
    1e3e:	jbe    1c77 <end_profiling+0xdc>
      }
    }

  }
}
    1e44:	nop
    1e45:	leave
    1e46:	ret

0000000000001e47 <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1e47:	push   rbp
    1e48:	mov    rbp,rsp
    1e4b:	push   rbx
    1e4c:	sub    rsp,0x78
    1e50:	mov    QWORD PTR [rbp-0x58],rdi
    1e54:	mov    rax,rsi
    1e57:	mov    rsi,rdx
    1e5a:	mov    rax,rax
    1e5d:	mov    edx,0x0
    1e62:	mov    rdx,rsi
    1e65:	mov    QWORD PTR [rbp-0x70],rax
    1e69:	mov    QWORD PTR [rbp-0x68],rdx
    1e6d:	mov    QWORD PTR [rbp-0x60],rcx
    1e71:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1e75:	pxor   xmm0,xmm0
    1e79:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1e7d:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1e81:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1e85:	movq   QWORD PTR [rbp-0x20],xmm0
    1e8a:	mov    rax,QWORD PTR [rbp-0x70]
    1e8e:	mov    rdx,QWORD PTR [rbp-0x68]
    1e92:	mov    QWORD PTR [rbp-0x50],rax
    1e96:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1e9a:	mov    rdx,QWORD PTR [rbp-0x60]
    1e9e:	mov    rax,rdx
    1ea1:	add    rax,rax
    1ea4:	add    rax,rdx
    1ea7:	shl    rax,0x4
    1eab:	mov    rdx,rax
    1eae:	lea    rax,[rip+0x4313]        # 61c8 <g_profiler+0x28>
    1eb5:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1eb9:	mov    QWORD PTR [rbp-0x38],rax
    1ebd:	mov    rax,QWORD PTR [rbp-0x60]
    1ec1:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1ec5:	mov    rax,QWORD PTR [rip+0x42dc]        # 61a8 <g_profiler+0x8>
  Profile_Pass pass =
    1ecc:	mov    QWORD PTR [rbp-0x28],rax
    1ed0:	mov    rax,QWORD PTR [rbp-0x78]
    1ed4:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    1ed8:	mov    rax,QWORD PTR [rbp-0x60]
    1edc:	mov    QWORD PTR [rip+0x42c5],rax        # 61a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    1ee3:	call   1a48 <read_cpu_timer>
    1ee8:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    1eec:	mov    rax,QWORD PTR [rbp-0x58]
    1ef0:	mov    rcx,QWORD PTR [rbp-0x50]
    1ef4:	mov    rbx,QWORD PTR [rbp-0x48]
    1ef8:	mov    QWORD PTR [rax],rcx
    1efb:	mov    QWORD PTR [rax+0x8],rbx
    1eff:	mov    rcx,QWORD PTR [rbp-0x40]
    1f03:	mov    rbx,QWORD PTR [rbp-0x38]
    1f07:	mov    QWORD PTR [rax+0x10],rcx
    1f0b:	mov    QWORD PTR [rax+0x18],rbx
    1f0f:	mov    rcx,QWORD PTR [rbp-0x30]
    1f13:	mov    rbx,QWORD PTR [rbp-0x28]
    1f17:	mov    QWORD PTR [rax+0x20],rcx
    1f1b:	mov    QWORD PTR [rax+0x28],rbx
    1f1f:	mov    rdx,QWORD PTR [rbp-0x20]
    1f23:	mov    QWORD PTR [rax+0x30],rdx
}
    1f27:	mov    rax,QWORD PTR [rbp-0x58]
    1f2b:	mov    rbx,QWORD PTR [rbp-0x8]
    1f2f:	leave
    1f30:	ret

0000000000001f31 <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    1f31:	push   rbp
    1f32:	mov    rbp,rsp
    1f35:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    1f39:	call   1a48 <read_cpu_timer>
    1f3e:	mov    rdx,rax
    1f41:	mov    rax,QWORD PTR [rbp+0x20]
    1f45:	sub    rdx,rax
    1f48:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    1f4c:	mov    rax,QWORD PTR [rbp+0x38]
    1f50:	mov    QWORD PTR [rip+0x4251],rax        # 61a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    1f57:	mov    rdx,QWORD PTR [rbp+0x30]
    1f5b:	mov    rax,rdx
    1f5e:	add    rax,rax
    1f61:	add    rax,rdx
    1f64:	shl    rax,0x4
    1f68:	lea    rdx,[rax+0x10]
    1f6c:	lea    rax,[rip+0x422d]        # 61a0 <g_profiler>
    1f73:	add    rax,rdx
    1f76:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    1f7a:	mov    rax,QWORD PTR [rbp-0x10]
    1f7e:	mov    rdx,QWORD PTR [rax+0x10]
    1f82:	mov    rax,QWORD PTR [rbp-0x18]
    1f86:	add    rdx,rax
    1f89:	mov    rax,QWORD PTR [rbp-0x10]
    1f8d:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    1f91:	mov    rax,QWORD PTR [rbp-0x10]
    1f95:	mov    rax,QWORD PTR [rax+0x20]
    1f99:	lea    rdx,[rax+0x1]
    1f9d:	mov    rax,QWORD PTR [rbp-0x10]
    1fa1:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    1fa5:	mov    rcx,QWORD PTR [rbp-0x10]
    1fa9:	mov    rax,QWORD PTR [rbp+0x10]
    1fad:	mov    rdx,QWORD PTR [rbp+0x18]
    1fb1:	mov    QWORD PTR [rcx],rax
    1fb4:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    1fb8:	mov    rdx,QWORD PTR [rbp+0x28]
    1fbc:	mov    rax,QWORD PTR [rbp-0x18]
    1fc0:	add    rdx,rax
    1fc3:	mov    rax,QWORD PTR [rbp-0x10]
    1fc7:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    1fcb:	mov    rax,QWORD PTR [rbp-0x10]
    1fcf:	mov    rdx,QWORD PTR [rax+0x28]
    1fd3:	mov    rax,QWORD PTR [rbp+0x40]
    1fd7:	add    rdx,rax
    1fda:	mov    rax,QWORD PTR [rbp-0x10]
    1fde:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    1fe2:	mov    rdx,QWORD PTR [rbp+0x38]
    1fe6:	mov    rax,rdx
    1fe9:	add    rax,rax
    1fec:	add    rax,rdx
    1fef:	shl    rax,0x4
    1ff3:	lea    rdx,[rax+0x10]
    1ff7:	lea    rax,[rip+0x41a2]        # 61a0 <g_profiler>
    1ffe:	add    rax,rdx
    2001:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    2005:	mov    rax,QWORD PTR [rbp-0x8]
    2009:	mov    rax,QWORD PTR [rax+0x10]
    200d:	sub    rax,QWORD PTR [rbp-0x18]
    2011:	mov    rdx,rax
    2014:	mov    rax,QWORD PTR [rbp-0x8]
    2018:	mov    QWORD PTR [rax+0x10],rdx
}
    201c:	nop
    201d:	leave
    201e:	ret

000000000000201f <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    201f:	push   rbp
    2020:	mov    rbp,rsp
    2023:	sub    rsp,0x10
    2027:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    202b:	mov    rax,QWORD PTR [rbp-0x8]
    202f:	mov    rdx,QWORD PTR [rax+0x10]
    2033:	mov    rax,QWORD PTR [rbp-0x8]
    2037:	mov    rax,QWORD PTR [rax+0x8]
    203b:	cmp    rdx,rax
    203e:	jb     2065 <parser_at+0x46>
    2040:	lea    rdx,[rip+0x27a1]        # 47e8 <__PRETTY_FUNCTION__.5>
    2047:	lea    rsi,[rip+0x2411]        # 445f <_IO_stdin_used+0x45f>
    204e:	lea    rax,[rip+0x241b]        # 4470 <_IO_stdin_used+0x470>
    2055:	mov    rcx,rdx
    2058:	mov    edx,0x2f
    205d:	mov    rdi,rax
    2060:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    2065:	mov    rax,QWORD PTR [rbp-0x8]
    2069:	mov    rdx,QWORD PTR [rax]
    206c:	mov    rax,QWORD PTR [rbp-0x8]
    2070:	mov    rax,QWORD PTR [rax+0x10]
    2074:	add    rax,rdx
}
    2077:	leave
    2078:	ret

0000000000002079 <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    2079:	push   rbp
    207a:	mov    rbp,rsp
    207d:	sub    rsp,0x10
    2081:	mov    QWORD PTR [rbp-0x8],rdi
    2085:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    2089:	mov    rax,QWORD PTR [rbp-0x8]
    208d:	mov    rdi,rax
    2090:	call   201f <parser_at>
    2095:	mov    rdx,QWORD PTR [rbp-0x10]
    2099:	add    rax,rdx
}
    209c:	leave
    209d:	ret

000000000000209e <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    209e:	push   rbp
    209f:	mov    rbp,rsp
    20a2:	mov    QWORD PTR [rbp-0x8],rdi
    20a6:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    20aa:	mov    rax,QWORD PTR [rbp-0x8]
    20ae:	mov    rdx,QWORD PTR [rax+0x10]
    20b2:	mov    rax,QWORD PTR [rbp-0x10]
    20b6:	add    rdx,rax
    20b9:	mov    rax,QWORD PTR [rbp-0x8]
    20bd:	mov    QWORD PTR [rax+0x10],rdx
}
    20c1:	nop
    20c2:	pop    rbp
    20c3:	ret

00000000000020c4 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    20c4:	push   rbp
    20c5:	mov    rbp,rsp
    20c8:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    20cc:	mov    rax,QWORD PTR [rbp-0x8]
    20d0:	mov    rdx,QWORD PTR [rax+0x10]
    20d4:	mov    rax,QWORD PTR [rbp-0x8]
    20d8:	mov    rax,QWORD PTR [rax+0x8]
    20dc:	cmp    rdx,rax
    20df:	setb   al
}
    20e2:	pop    rbp
    20e3:	ret

00000000000020e4 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    20e4:	push   rbp
    20e5:	mov    rbp,rsp
    20e8:	push   r12
    20ea:	push   rbx
    20eb:	sub    rsp,0x20
    20ef:	mov    QWORD PTR [rbp-0x18],rdi
    20f3:	mov    rax,rsi
    20f6:	mov    rcx,rdx
    20f9:	mov    rax,rax
    20fc:	mov    edx,0x0
    2101:	mov    rdx,rcx
    2104:	mov    QWORD PTR [rbp-0x30],rax
    2108:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    210c:	mov    rax,QWORD PTR [rbp-0x28]
    2110:	mov    r12,rax
    2113:	mov    rbx,QWORD PTR [rbp-0x30]
    2117:	mov    rax,QWORD PTR [rbp-0x18]
    211b:	mov    rdi,rax
    211e:	call   201f <parser_at>
    2123:	mov    rdx,r12
    2126:	mov    rsi,rbx
    2129:	mov    rdi,rax
    212c:	call   10d0 <memcmp@plt>
    2131:	test   eax,eax
    2133:	sete   al
}
    2136:	add    rsp,0x20
    213a:	pop    rbx
    213b:	pop    r12
    213d:	pop    rbp
    213e:	ret

000000000000213f <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    213f:	push   rbp
    2140:	mov    rbp,rsp
    2143:	mov    eax,edi
    2145:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    2148:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    214c:	movzx  eax,BYTE PTR [rbp-0x14]
    2150:	cmp    eax,0x2e
    2153:	jg     215c <is_numeric+0x1d>
    2155:	cmp    eax,0x2d
    2158:	jge    2164 <is_numeric+0x25>
    215a:	jmp    2169 <is_numeric+0x2a>
    215c:	sub    eax,0x30
    215f:	cmp    eax,0x9
    2162:	ja     2169 <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2164:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    2168:	nop
  }


  return result;
    2169:	movzx  eax,BYTE PTR [rbp-0x1]
}
    216d:	pop    rbp
    216e:	ret

000000000000216f <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    216f:	push   rbp
    2170:	mov    rbp,rsp
    2173:	sub    rsp,0x50
    2177:	mov    QWORD PTR [rbp-0x48],rdi
    217b:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    217f:	pxor   xmm0,xmm0
    2183:	movaps XMMWORD PTR [rbp-0x20],xmm0
    2187:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    218c:	jmp    219f <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    218e:	mov    rax,QWORD PTR [rbp-0x50]
    2192:	mov    esi,0x1
    2197:	mov    rdi,rax
    219a:	call   209e <parser_advance>
  while (parser_incomplete(parser)  &&
    219f:	mov    rax,QWORD PTR [rbp-0x50]
    21a3:	mov    rdi,rax
    21a6:	call   20c4 <parser_incomplete>
    21ab:	test   al,al
    21ad:	je     21fb <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    21af:	mov    rax,QWORD PTR [rbp-0x50]
    21b3:	mov    rdi,rax
    21b6:	call   201f <parser_at>
    21bb:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    21be:	cmp    al,0x20
    21c0:	je     218e <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    21c2:	mov    rax,QWORD PTR [rbp-0x50]
    21c6:	mov    rdi,rax
    21c9:	call   201f <parser_at>
    21ce:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    21d1:	cmp    al,0xa
    21d3:	je     218e <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    21d5:	mov    rax,QWORD PTR [rbp-0x50]
    21d9:	mov    rdi,rax
    21dc:	call   201f <parser_at>
    21e1:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    21e4:	cmp    al,0xd
    21e6:	je     218e <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    21e8:	mov    rax,QWORD PTR [rbp-0x50]
    21ec:	mov    rdi,rax
    21ef:	call   201f <parser_at>
    21f4:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    21f7:	cmp    al,0x9
    21f9:	je     218e <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    21fb:	mov    rax,QWORD PTR [rbp-0x50]
    21ff:	mov    rdi,rax
    2202:	call   20c4 <parser_incomplete>
    2207:	test   al,al
    2209:	je     2636 <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    220f:	mov    rax,QWORD PTR [rbp-0x50]
    2213:	mov    rdi,rax
    2216:	call   201f <parser_at>
    221b:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    221f:	mov    rax,QWORD PTR [rbp-0x50]
    2223:	mov    rdi,rax
    2226:	call   201f <parser_at>
    222b:	movzx  eax,BYTE PTR [rax]
    222e:	movzx  eax,al
    2231:	cmp    eax,0x7d
    2234:	je     2321 <get_json_token+0x1b2>
    223a:	cmp    eax,0x7d
    223d:	jg     2647 <get_json_token+0x4d8>
    2243:	cmp    eax,0x7b
    2246:	je     22fc <get_json_token+0x18d>
    224c:	cmp    eax,0x7b
    224f:	jg     2647 <get_json_token+0x4d8>
    2255:	cmp    eax,0x74
    2258:	je     24a4 <get_json_token+0x335>
    225e:	cmp    eax,0x74
    2261:	jg     2647 <get_json_token+0x4d8>
    2267:	cmp    eax,0x6e
    226a:	je     25b4 <get_json_token+0x445>
    2270:	cmp    eax,0x6e
    2273:	jg     2647 <get_json_token+0x4d8>
    2279:	cmp    eax,0x66
    227c:	je     252c <get_json_token+0x3bd>
    2282:	cmp    eax,0x66
    2285:	jg     2647 <get_json_token+0x4d8>
    228b:	cmp    eax,0x5d
    228e:	je     236b <get_json_token+0x1fc>
    2294:	cmp    eax,0x5d
    2297:	jg     2647 <get_json_token+0x4d8>
    229d:	cmp    eax,0x5b
    22a0:	je     2346 <get_json_token+0x1d7>
    22a6:	cmp    eax,0x5b
    22a9:	jg     2647 <get_json_token+0x4d8>
    22af:	cmp    eax,0x3a
    22b2:	je     23b5 <get_json_token+0x246>
    22b8:	cmp    eax,0x3a
    22bb:	jg     2647 <get_json_token+0x4d8>
    22c1:	cmp    eax,0x39
    22c4:	jg     2647 <get_json_token+0x4d8>
    22ca:	cmp    eax,0x30
    22cd:	jge    2453 <get_json_token+0x2e4>
    22d3:	cmp    eax,0x2e
    22d6:	jg     2647 <get_json_token+0x4d8>
    22dc:	cmp    eax,0x2d
    22df:	jge    2453 <get_json_token+0x2e4>
    22e5:	cmp    eax,0x22
    22e8:	je     23da <get_json_token+0x26b>
    22ee:	cmp    eax,0x2c
    22f1:	je     2390 <get_json_token+0x221>
    22f7:	jmp    2647 <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    22fc:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    2303:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    230b:	mov    rax,QWORD PTR [rbp-0x50]
    230f:	mov    esi,0x1
    2314:	mov    rdi,rax
    2317:	call   209e <parser_advance>
      }
      break;
    231c:	jmp    2647 <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2321:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    2328:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2330:	mov    rax,QWORD PTR [rbp-0x50]
    2334:	mov    esi,0x1
    2339:	mov    rdi,rax
    233c:	call   209e <parser_advance>
      }
      break;
    2341:	jmp    2647 <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2346:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    234d:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2355:	mov    rax,QWORD PTR [rbp-0x50]
    2359:	mov    esi,0x1
    235e:	mov    rdi,rax
    2361:	call   209e <parser_advance>
      }
      break;
    2366:	jmp    2647 <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    236b:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    2372:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    237a:	mov    rax,QWORD PTR [rbp-0x50]
    237e:	mov    esi,0x1
    2383:	mov    rdi,rax
    2386:	call   209e <parser_advance>
      }
      break;
    238b:	jmp    2647 <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    2390:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    2397:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    239f:	mov    rax,QWORD PTR [rbp-0x50]
    23a3:	mov    esi,0x1
    23a8:	mov    rdi,rax
    23ab:	call   209e <parser_advance>
      }
      break;
    23b0:	jmp    2647 <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    23b5:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    23bc:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    23c4:	mov    rax,QWORD PTR [rbp-0x50]
    23c8:	mov    esi,0x1
    23cd:	mov    rdi,rax
    23d0:	call   209e <parser_advance>
      }
      break;
    23d5:	jmp    2647 <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    23da:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    23e1:	mov    rax,QWORD PTR [rbp-0x50]
    23e5:	mov    esi,0x1
    23ea:	mov    rdi,rax
    23ed:	call   209e <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    23f2:	mov    rax,QWORD PTR [rbp-0x50]
    23f6:	mov    rdi,rax
    23f9:	call   201f <parser_at>
    23fe:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    2402:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    240a:	jmp    2422 <get_json_token+0x2b3>
        {
          string_count += 1;
    240c:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    2411:	mov    rax,QWORD PTR [rbp-0x50]
    2415:	mov    esi,0x1
    241a:	mov    rdi,rax
    241d:	call   209e <parser_advance>
        while (*parser_at(parser) != '"')
    2422:	mov    rax,QWORD PTR [rbp-0x50]
    2426:	mov    rdi,rax
    2429:	call   201f <parser_at>
    242e:	movzx  eax,BYTE PTR [rax]
    2431:	cmp    al,0x22
    2433:	jne    240c <get_json_token+0x29d>
        }
        token.value.count = string_count;
    2435:	mov    rax,QWORD PTR [rbp-0x40]
    2439:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    243d:	mov    rax,QWORD PTR [rbp-0x50]
    2441:	mov    esi,0x1
    2446:	mov    rdi,rax
    2449:	call   209e <parser_advance>
      }
      break;
    244e:	jmp    2647 <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2453:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    245a:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2462:	jmp    247a <get_json_token+0x30b>
        {
          digit_count += 1;
    2464:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    2469:	mov    rax,QWORD PTR [rbp-0x50]
    246d:	mov    esi,0x1
    2472:	mov    rdi,rax
    2475:	call   209e <parser_advance>
        while (is_numeric(*parser_at(parser)))
    247a:	mov    rax,QWORD PTR [rbp-0x50]
    247e:	mov    rdi,rax
    2481:	call   201f <parser_at>
    2486:	movzx  eax,BYTE PTR [rax]
    2489:	movzx  eax,al
    248c:	mov    edi,eax
    248e:	call   213f <is_numeric>
    2493:	test   al,al
    2495:	jne    2464 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    2497:	mov    rax,QWORD PTR [rbp-0x38]
    249b:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    249f:	jmp    2647 <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    24a4:	lea    rax,[rip+0x2011]        # 44bc <_IO_stdin_used+0x4bc>
    24ab:	mov    QWORD PTR [rbp-0x30],rax
    24af:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    24b7:	mov    rcx,QWORD PTR [rbp-0x30]
    24bb:	mov    rdx,QWORD PTR [rbp-0x28]
    24bf:	mov    rax,QWORD PTR [rbp-0x50]
    24c3:	mov    rsi,rcx
    24c6:	mov    rdi,rax
    24c9:	call   20e4 <parser_token_is_literal>
    24ce:	test   al,al
    24d0:	je     24f4 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    24d2:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    24d9:	mov    rax,QWORD PTR [rbp-0x28]
    24dd:	mov    rdx,rax
    24e0:	mov    rax,QWORD PTR [rbp-0x50]
    24e4:	mov    rsi,rdx
    24e7:	mov    rdi,rax
    24ea:	call   209e <parser_advance>
    24ef:	jmp    2647 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    24f4:	mov    rax,QWORD PTR [rbp-0x50]
    24f8:	mov    rcx,QWORD PTR [rax+0x10]
    24fc:	lea    rdx,[rip+0x1fc5]        # 44c8 <_IO_stdin_used+0x4c8>
    2503:	lea    rax,[rip+0x1f55]        # 445f <_IO_stdin_used+0x45f>
    250a:	mov    r8,rcx
    250d:	mov    rcx,rdx
    2510:	mov    edx,0xdf
    2515:	mov    rsi,rax
    2518:	mov    edi,0x1
    251d:	mov    eax,0x0
    2522:	call   14a1 <log_message>
        }
      }
      break;
    2527:	jmp    2647 <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    252c:	lea    rax,[rip+0x1fc2]        # 44f5 <_IO_stdin_used+0x4f5>
    2533:	mov    QWORD PTR [rbp-0x30],rax
    2537:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    253f:	mov    rcx,QWORD PTR [rbp-0x30]
    2543:	mov    rdx,QWORD PTR [rbp-0x28]
    2547:	mov    rax,QWORD PTR [rbp-0x50]
    254b:	mov    rsi,rcx
    254e:	mov    rdi,rax
    2551:	call   20e4 <parser_token_is_literal>
    2556:	test   al,al
    2558:	je     257c <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    255a:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    2561:	mov    rax,QWORD PTR [rbp-0x28]
    2565:	mov    rdx,rax
    2568:	mov    rax,QWORD PTR [rbp-0x50]
    256c:	mov    rsi,rdx
    256f:	mov    rdi,rax
    2572:	call   209e <parser_advance>
    2577:	jmp    2647 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    257c:	mov    rax,QWORD PTR [rbp-0x50]
    2580:	mov    rcx,QWORD PTR [rax+0x10]
    2584:	lea    rdx,[rip+0x1f3d]        # 44c8 <_IO_stdin_used+0x4c8>
    258b:	lea    rax,[rip+0x1ecd]        # 445f <_IO_stdin_used+0x45f>
    2592:	mov    r8,rcx
    2595:	mov    rcx,rdx
    2598:	mov    edx,0xee
    259d:	mov    rsi,rax
    25a0:	mov    edi,0x1
    25a5:	mov    eax,0x0
    25aa:	call   14a1 <log_message>
        }
      }
      break;
    25af:	jmp    2647 <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    25b4:	lea    rax,[rip+0x1f40]        # 44fb <_IO_stdin_used+0x4fb>
    25bb:	mov    QWORD PTR [rbp-0x30],rax
    25bf:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25c7:	mov    rcx,QWORD PTR [rbp-0x30]
    25cb:	mov    rdx,QWORD PTR [rbp-0x28]
    25cf:	mov    rax,QWORD PTR [rbp-0x50]
    25d3:	mov    rsi,rcx
    25d6:	mov    rdi,rax
    25d9:	call   20e4 <parser_token_is_literal>
    25de:	test   al,al
    25e0:	je     2601 <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    25e2:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    25e9:	mov    rax,QWORD PTR [rbp-0x28]
    25ed:	mov    rdx,rax
    25f0:	mov    rax,QWORD PTR [rbp-0x50]
    25f4:	mov    rsi,rdx
    25f7:	mov    rdi,rax
    25fa:	call   209e <parser_advance>
    25ff:	jmp    2647 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2601:	mov    rax,QWORD PTR [rbp-0x50]
    2605:	mov    rcx,QWORD PTR [rax+0x10]
    2609:	lea    rdx,[rip+0x1eb8]        # 44c8 <_IO_stdin_used+0x4c8>
    2610:	lea    rax,[rip+0x1e48]        # 445f <_IO_stdin_used+0x45f>
    2617:	mov    r8,rcx
    261a:	mov    rcx,rdx
    261d:	mov    edx,0xfd
    2622:	mov    rsi,rax
    2625:	mov    edi,0x1
    262a:	mov    eax,0x0
    262f:	call   14a1 <log_message>
        }
      }
      break;
    2634:	jmp    2647 <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    2636:	mov    rax,QWORD PTR [rbp-0x50]
    263a:	mov    esi,0x1
    263f:	mov    rdi,rax
    2642:	call   209e <parser_advance>
  }

  return token;
    2647:	mov    rcx,QWORD PTR [rbp-0x48]
    264b:	mov    rax,QWORD PTR [rbp-0x20]
    264f:	mov    rdx,QWORD PTR [rbp-0x18]
    2653:	mov    QWORD PTR [rcx],rax
    2656:	mov    QWORD PTR [rcx+0x8],rdx
    265a:	mov    rax,QWORD PTR [rbp-0x10]
    265e:	mov    QWORD PTR [rcx+0x10],rax
}
    2662:	mov    rax,QWORD PTR [rbp-0x48]
    2666:	leave
    2667:	ret

0000000000002668 <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    2668:	push   rbp
    2669:	mov    rbp,rsp
    266c:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    266f:	cmp    DWORD PTR [rbp-0x14],0x7
    2673:	je     268d <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2675:	cmp    DWORD PTR [rbp-0x14],0x9
    2679:	je     268d <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    267b:	cmp    DWORD PTR [rbp-0x14],0xa
    267f:	je     268d <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    2681:	cmp    DWORD PTR [rbp-0x14],0xb
    2685:	je     268d <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    2687:	cmp    DWORD PTR [rbp-0x14],0x8
    268b:	jne    2694 <json_token_type_is_value_type+0x2c>
    268d:	mov    eax,0x1
    2692:	jmp    2699 <json_token_type_is_value_type+0x31>
    2694:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2699:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    269c:	mov    eax,DWORD PTR [rbp-0x4]
}
    269f:	pop    rbp
    26a0:	ret

00000000000026a1 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    26a1:	push   rbp
    26a2:	mov    rbp,rsp
    26a5:	push   rbx
    26a6:	sub    rsp,0x88
    26ad:	mov    QWORD PTR [rbp-0x78],rdi
    26b1:	mov    QWORD PTR [rbp-0x80],rsi
    26b5:	mov    QWORD PTR [rbp-0x90],rdx
    26bc:	mov    QWORD PTR [rbp-0x88],rcx
    26c3:	mov    rax,QWORD PTR fs:0x28
    26cc:	mov    QWORD PTR [rbp-0x18],rax
    26d0:	xor    eax,eax
  profile_begin_func();
    26d2:	lea    r8,[rip+0x2127]        # 4800 <__func__.4>
    26d9:	mov    r9d,0x11
    26df:	lea    rax,[rbp-0x50]
    26e3:	mov    rsi,r8
    26e6:	mov    rdx,r9
    26e9:	mov    r8d,0x0
    26ef:	mov    ecx,0x1
    26f4:	mov    rdi,rax
    26f7:	call   1e47 <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    26fc:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2704:	mov    eax,DWORD PTR [rbp+0x10]
    2707:	cmp    eax,0x1
    270a:	jne    2736 <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    270c:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    2713:	mov    edx,DWORD PTR [rbp-0x64]
    2716:	mov    rsi,QWORD PTR [rbp-0x80]
    271a:	mov    rax,QWORD PTR [rbp-0x78]
    271e:	mov    ecx,edx
    2720:	mov    edx,0x2
    2725:	mov    rdi,rax
    2728:	call   2888 <parse_json_children>
    272d:	mov    QWORD PTR [rbp-0x60],rax
    2731:	jmp    27c0 <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2736:	mov    eax,DWORD PTR [rbp+0x10]
    2739:	cmp    eax,0x3
    273c:	jne    2765 <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    273e:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2745:	mov    edx,DWORD PTR [rbp-0x68]
    2748:	mov    rsi,QWORD PTR [rbp-0x80]
    274c:	mov    rax,QWORD PTR [rbp-0x78]
    2750:	mov    ecx,edx
    2752:	mov    edx,0x4
    2757:	mov    rdi,rax
    275a:	call   2888 <parse_json_children>
    275f:	mov    QWORD PTR [rbp-0x60],rax
    2763:	jmp    27c0 <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    2765:	mov    eax,DWORD PTR [rbp+0x10]
    2768:	mov    edi,eax
    276a:	call   2668 <json_token_type_is_value_type>
    276f:	test   eax,eax
    2771:	jne    27c0 <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2773:	mov    eax,DWORD PTR [rbp+0x10]
    2776:	mov    eax,eax
    2778:	lea    rdx,[rax*8+0x0]
    2780:	lea    rax,[rip+0x3959]        # 60e0 <JSON_Token_Type_strings>
    2787:	mov    rcx,QWORD PTR [rdx+rax*1]
    278b:	lea    rdx,[rip+0x1d6e]        # 4500 <_IO_stdin_used+0x500>
    2792:	lea    rax,[rip+0x1cc6]        # 445f <_IO_stdin_used+0x45f>
    2799:	push   QWORD PTR [rbp+0x20]
    279c:	push   QWORD PTR [rbp+0x18]
    279f:	mov    r8,rcx
    27a2:	mov    rcx,rdx
    27a5:	mov    edx,0x134
    27aa:	mov    rsi,rax
    27ad:	mov    edi,0x1
    27b2:	mov    eax,0x0
    27b7:	call   14a1 <log_message>
    27bc:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    27c0:	mov    rax,QWORD PTR [rbp-0x78]
    27c4:	mov    edx,0x8
    27c9:	mov    esi,0x30
    27ce:	mov    rdi,rax
    27d1:	call   17d3 <arena_alloc>
    27d6:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    27da:	mov    rcx,QWORD PTR [rbp-0x58]
    27de:	mov    rax,QWORD PTR [rbp-0x90]
    27e5:	mov    rdx,QWORD PTR [rbp-0x88]
    27ec:	mov    QWORD PTR [rcx],rax
    27ef:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    27f3:	mov    rax,QWORD PTR [rbp-0x58]
    27f7:	mov    rdx,QWORD PTR [rbp-0x60]
    27fb:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    27ff:	mov    rax,QWORD PTR [rbp-0x58]
    2803:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    280b:	mov    rcx,QWORD PTR [rbp-0x58]
    280f:	mov    rax,QWORD PTR [rbp+0x18]
    2813:	mov    rdx,QWORD PTR [rbp+0x20]
    2817:	mov    QWORD PTR [rcx+0x10],rax
    281b:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    281f:	sub    rsp,0x8
    2823:	sub    rsp,0x38
    2827:	mov    rax,rsp
    282a:	mov    rcx,QWORD PTR [rbp-0x50]
    282e:	mov    rbx,QWORD PTR [rbp-0x48]
    2832:	mov    QWORD PTR [rax],rcx
    2835:	mov    QWORD PTR [rax+0x8],rbx
    2839:	mov    rcx,QWORD PTR [rbp-0x40]
    283d:	mov    rbx,QWORD PTR [rbp-0x38]
    2841:	mov    QWORD PTR [rax+0x10],rcx
    2845:	mov    QWORD PTR [rax+0x18],rbx
    2849:	mov    rcx,QWORD PTR [rbp-0x30]
    284d:	mov    rbx,QWORD PTR [rbp-0x28]
    2851:	mov    QWORD PTR [rax+0x20],rcx
    2855:	mov    QWORD PTR [rax+0x28],rbx
    2859:	mov    rdx,QWORD PTR [rbp-0x20]
    285d:	mov    QWORD PTR [rax+0x30],rdx
    2861:	call   1f31 <__profile_end_pass>
    2866:	add    rsp,0x40

  return result;
    286a:	mov    rax,QWORD PTR [rbp-0x58]
}
    286e:	mov    rdx,QWORD PTR [rbp-0x18]
    2872:	sub    rdx,QWORD PTR fs:0x28
    287b:	je     2882 <parse_json_object+0x1e1>
    287d:	call   1060 <__stack_chk_fail@plt>
    2882:	mov    rbx,QWORD PTR [rbp-0x8]
    2886:	leave
    2887:	ret

0000000000002888 <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    2888:	push   rbp
    2889:	mov    rbp,rsp
    288c:	push   rbx
    288d:	sub    rsp,0x108
    2894:	mov    QWORD PTR [rbp-0xd8],rdi
    289b:	mov    QWORD PTR [rbp-0xe0],rsi
    28a2:	mov    DWORD PTR [rbp-0xe4],edx
    28a8:	mov    DWORD PTR [rbp-0xe8],ecx
    28ae:	mov    rax,QWORD PTR fs:0x28
    28b7:	mov    QWORD PTR [rbp-0x18],rax
    28bb:	xor    eax,eax
  profile_begin_func();
    28bd:	lea    r8,[rip+0x1f5c]        # 4820 <__func__.3>
    28c4:	mov    r9d,0x13
    28ca:	lea    rax,[rbp-0x50]
    28ce:	mov    rsi,r8
    28d1:	mov    rdx,r9
    28d4:	mov    r8d,0x0
    28da:	mov    ecx,0x2
    28df:	mov    rdi,rax
    28e2:	call   1e47 <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    28e7:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    28f2:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    28fd:	jmp    2bd6 <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2902:	pxor   xmm0,xmm0
    2906:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    290d:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2915:	pxor   xmm0,xmm0
    2919:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2920:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2925:	cmp    DWORD PTR [rbp-0xe8],0x0
    292c:	je     2a39 <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2932:	lea    rax,[rbp-0xb0]
    2939:	mov    rdx,QWORD PTR [rbp-0xe0]
    2940:	mov    rsi,rdx
    2943:	mov    rdi,rax
    2946:	call   216f <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    294b:	mov    eax,DWORD PTR [rbp-0xb0]
    2951:	cmp    eax,0x7
    2954:	jne    29d5 <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2956:	lea    rax,[rbp-0x70]
    295a:	mov    rdx,QWORD PTR [rbp-0xe0]
    2961:	mov    rsi,rdx
    2964:	mov    rdi,rax
    2967:	call   216f <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    296c:	mov    eax,DWORD PTR [rbp-0x70]
    296f:	cmp    eax,0x6
    2972:	jne    2992 <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2974:	lea    rax,[rbp-0x90]
    297b:	mov    rdx,QWORD PTR [rbp-0xe0]
    2982:	mov    rsi,rdx
    2985:	mov    rdi,rax
    2988:	call   216f <get_json_token>
    298d:	jmp    2a79 <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2992:	mov    rcx,QWORD PTR [rbp-0xa8]
    2999:	mov    rax,QWORD PTR [rbp-0xa0]
    29a0:	mov    esi,eax
    29a2:	lea    rdx,[rip+0x1ba7]        # 4550 <_IO_stdin_used+0x550>
    29a9:	lea    rax,[rip+0x1aaf]        # 445f <_IO_stdin_used+0x45f>
    29b0:	mov    r9,rcx
    29b3:	mov    r8d,esi
    29b6:	mov    rcx,rdx
    29b9:	mov    edx,0x15f
    29be:	mov    rsi,rax
    29c1:	mov    edi,0x1
    29c6:	mov    eax,0x0
    29cb:	call   14a1 <log_message>
    29d0:	jmp    2a79 <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    29d5:	mov    rcx,QWORD PTR [rbp-0xa8]
    29dc:	mov    rax,QWORD PTR [rbp-0xa0]
    29e3:	mov    edi,eax
    29e5:	mov    eax,DWORD PTR [rbp-0xb0]
    29eb:	mov    eax,eax
    29ed:	lea    rdx,[rax*8+0x0]
    29f5:	lea    rax,[rip+0x36e4]        # 60e0 <JSON_Token_Type_strings>
    29fc:	mov    rsi,QWORD PTR [rdx+rax*1]
    2a00:	lea    rdx,[rip+0x1b69]        # 4570 <_IO_stdin_used+0x570>
    2a07:	lea    rax,[rip+0x1a51]        # 445f <_IO_stdin_used+0x45f>
    2a0e:	sub    rsp,0x8
    2a12:	push   rcx
    2a13:	mov    r9d,edi
    2a16:	mov    r8,rsi
    2a19:	mov    rcx,rdx
    2a1c:	mov    edx,0x164
    2a21:	mov    rsi,rax
    2a24:	mov    edi,0x1
    2a29:	mov    eax,0x0
    2a2e:	call   14a1 <log_message>
    2a33:	add    rsp,0x10
    2a37:	jmp    2a79 <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2a39:	lea    rax,[rbp-0x110]
    2a40:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a47:	mov    rsi,rdx
    2a4a:	mov    rdi,rax
    2a4d:	call   216f <get_json_token>
    2a52:	mov    rax,QWORD PTR [rbp-0x110]
    2a59:	mov    rdx,QWORD PTR [rbp-0x108]
    2a60:	mov    QWORD PTR [rbp-0x90],rax
    2a67:	mov    QWORD PTR [rbp-0x88],rdx
    2a6e:	mov    rax,QWORD PTR [rbp-0x100]
    2a75:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2a79:	mov    eax,DWORD PTR [rbp-0x90]
    2a7f:	cmp    DWORD PTR [rbp-0xe4],eax
    2a85:	je     2bef <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2a8b:	mov    rax,QWORD PTR [rbp-0xa8]
    2a92:	mov    rdx,QWORD PTR [rbp-0xa0]
    2a99:	mov    r8,QWORD PTR [rbp-0xe0]
    2aa0:	mov    rdi,QWORD PTR [rbp-0xd8]
    2aa7:	sub    rsp,0x8
    2aab:	sub    rsp,0x18
    2aaf:	mov    rsi,rsp
    2ab2:	mov    rcx,QWORD PTR [rbp-0x90]
    2ab9:	mov    rbx,QWORD PTR [rbp-0x88]
    2ac0:	mov    QWORD PTR [rsi],rcx
    2ac3:	mov    QWORD PTR [rsi+0x8],rbx
    2ac7:	mov    rcx,QWORD PTR [rbp-0x80]
    2acb:	mov    QWORD PTR [rsi+0x10],rcx
    2acf:	mov    rcx,rdx
    2ad2:	mov    rdx,rax
    2ad5:	mov    rsi,r8
    2ad8:	call   26a1 <parse_json_object>
    2add:	add    rsp,0x20
    2ae1:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2ae8:	cmp    QWORD PTR [rbp-0xb8],0x0
    2af0:	je     2b3a <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2af2:	cmp    QWORD PTR [rbp-0xc8],0x0
    2afa:	jne    2b1a <parse_json_children+0x292>
      {
        first_child        = object;
    2afc:	mov    rax,QWORD PTR [rbp-0xb8]
    2b03:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2b0a:	mov    rax,QWORD PTR [rbp-0xb8]
    2b11:	mov    QWORD PTR [rbp-0xc0],rax
    2b18:	jmp    2b3a <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2b1a:	mov    rax,QWORD PTR [rbp-0xc0]
    2b21:	mov    rdx,QWORD PTR [rbp-0xb8]
    2b28:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2b2c:	mov    rax,QWORD PTR [rbp-0xb8]
    2b33:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2b3a:	lea    rax,[rbp-0x70]
    2b3e:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b45:	mov    rsi,rdx
    2b48:	mov    rdi,rax
    2b4b:	call   216f <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2b50:	mov    eax,DWORD PTR [rbp-0x70]
    2b53:	cmp    DWORD PTR [rbp-0xe4],eax
    2b59:	je     2bf2 <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2b5f:	mov    eax,DWORD PTR [rbp-0x70]
    2b62:	cmp    eax,0x5
    2b65:	je     2bd6 <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2b67:	mov    r8,QWORD PTR [rbp-0x68]
    2b6b:	mov    rax,QWORD PTR [rbp-0x60]
    2b6f:	mov    r9d,eax
    2b72:	mov    eax,DWORD PTR [rbp-0x70]
    2b75:	mov    eax,eax
    2b77:	lea    rdx,[rax*8+0x0]
    2b7f:	lea    rax,[rip+0x355a]        # 60e0 <JSON_Token_Type_strings>
    2b86:	mov    r10,QWORD PTR [rdx+rax*1]
    2b8a:	lea    rdi,[rip+0x1a07]        # 4598 <_IO_stdin_used+0x598>
    2b91:	lea    rsi,[rip+0x18c7]        # 445f <_IO_stdin_used+0x45f>
    2b98:	sub    rsp,0x18
    2b9c:	mov    rcx,rsp
    2b9f:	mov    rax,QWORD PTR [rbp-0x70]
    2ba3:	mov    rdx,QWORD PTR [rbp-0x68]
    2ba7:	mov    QWORD PTR [rcx],rax
    2baa:	mov    QWORD PTR [rcx+0x8],rdx
    2bae:	mov    rax,QWORD PTR [rbp-0x60]
    2bb2:	mov    QWORD PTR [rcx+0x10],rax
    2bb6:	push   r8
    2bb8:	mov    r8,r10
    2bbb:	mov    rcx,rdi
    2bbe:	mov    edx,0x18b
    2bc3:	mov    edi,0x1
    2bc8:	mov    eax,0x0
    2bcd:	call   14a1 <log_message>
    2bd2:	add    rsp,0x20
  while (parser_incomplete(parser))
    2bd6:	mov    rax,QWORD PTR [rbp-0xe0]
    2bdd:	mov    rdi,rax
    2be0:	call   20c4 <parser_incomplete>
    2be5:	test   al,al
    2be7:	jne    2902 <parse_json_children+0x7a>
    2bed:	jmp    2bf3 <parse_json_children+0x36b>
      break;
    2bef:	nop
    2bf0:	jmp    2bf3 <parse_json_children+0x36b>
      break;
    2bf2:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2bf3:	sub    rsp,0x8
    2bf7:	sub    rsp,0x38
    2bfb:	mov    rax,rsp
    2bfe:	mov    rcx,QWORD PTR [rbp-0x50]
    2c02:	mov    rbx,QWORD PTR [rbp-0x48]
    2c06:	mov    QWORD PTR [rax],rcx
    2c09:	mov    QWORD PTR [rax+0x8],rbx
    2c0d:	mov    rcx,QWORD PTR [rbp-0x40]
    2c11:	mov    rbx,QWORD PTR [rbp-0x38]
    2c15:	mov    QWORD PTR [rax+0x10],rcx
    2c19:	mov    QWORD PTR [rax+0x18],rbx
    2c1d:	mov    rcx,QWORD PTR [rbp-0x30]
    2c21:	mov    rbx,QWORD PTR [rbp-0x28]
    2c25:	mov    QWORD PTR [rax+0x20],rcx
    2c29:	mov    QWORD PTR [rax+0x28],rbx
    2c2d:	mov    rdx,QWORD PTR [rbp-0x20]
    2c31:	mov    QWORD PTR [rax+0x30],rdx
    2c35:	call   1f31 <__profile_end_pass>
    2c3a:	add    rsp,0x40

  return first_child;
    2c3e:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2c45:	mov    rdx,QWORD PTR [rbp-0x18]
    2c49:	sub    rdx,QWORD PTR fs:0x28
    2c52:	je     2c59 <parse_json_children+0x3d1>
    2c54:	call   1060 <__stack_chk_fail@plt>
    2c59:	mov    rbx,QWORD PTR [rbp-0x8]
    2c5d:	leave
    2c5e:	ret

0000000000002c5f <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2c5f:	push   rbp
    2c60:	mov    rbp,rsp
    2c63:	push   rbx
    2c64:	sub    rsp,0xb8
    2c6b:	mov    QWORD PTR [rbp-0xa8],rdi
    2c72:	mov    rax,rsi
    2c75:	mov    rsi,rdx
    2c78:	mov    rax,rax
    2c7b:	mov    edx,0x0
    2c80:	mov    rdx,rsi
    2c83:	mov    QWORD PTR [rbp-0xc0],rax
    2c8a:	mov    QWORD PTR [rbp-0xb8],rdx
    2c91:	mov    rax,QWORD PTR fs:0x28
    2c9a:	mov    QWORD PTR [rbp-0x18],rax
    2c9e:	xor    eax,eax
  profile_begin_func();
    2ca0:	lea    rcx,[rip+0x1b91]        # 4838 <__func__.2>
    2ca7:	mov    ebx,0xa
    2cac:	lea    rax,[rbp-0x50]
    2cb0:	mov    rsi,rcx
    2cb3:	mov    rdx,rbx
    2cb6:	mov    r8d,0x0
    2cbc:	mov    ecx,0x3
    2cc1:	mov    rdi,rax
    2cc4:	call   1e47 <__profile_begin_pass>

  JSON_Parser parser =
    2cc9:	mov    rax,QWORD PTR [rbp-0xc0]
    2cd0:	mov    rdx,QWORD PTR [rbp-0xb8]
    2cd7:	mov    QWORD PTR [rbp-0x90],rax
    2cde:	mov    QWORD PTR [rbp-0x88],rdx
    2ce5:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2ced:	lea    rax,[rbp-0x70]
    2cf1:	lea    rdx,[rbp-0x90]
    2cf8:	mov    rsi,rdx
    2cfb:	mov    rdi,rax
    2cfe:	call   216f <get_json_token>
    2d03:	mov    ecx,0x0
    2d08:	mov    ebx,0x0
    2d0d:	lea    r8,[rbp-0x90]
    2d14:	mov    rdi,QWORD PTR [rbp-0xa8]
    2d1b:	sub    rsp,0x8
    2d1f:	sub    rsp,0x18
    2d23:	mov    rsi,rsp
    2d26:	mov    rax,QWORD PTR [rbp-0x70]
    2d2a:	mov    rdx,QWORD PTR [rbp-0x68]
    2d2e:	mov    QWORD PTR [rsi],rax
    2d31:	mov    QWORD PTR [rsi+0x8],rdx
    2d35:	mov    rax,QWORD PTR [rbp-0x60]
    2d39:	mov    QWORD PTR [rsi+0x10],rax
    2d3d:	mov    rdx,rcx
    2d40:	mov    rcx,rbx
    2d43:	mov    rsi,r8
    2d46:	call   26a1 <parse_json_object>
    2d4b:	add    rsp,0x20
    2d4f:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2d56:	sub    rsp,0x8
    2d5a:	sub    rsp,0x38
    2d5e:	mov    rax,rsp
    2d61:	mov    rcx,QWORD PTR [rbp-0x50]
    2d65:	mov    rbx,QWORD PTR [rbp-0x48]
    2d69:	mov    QWORD PTR [rax],rcx
    2d6c:	mov    QWORD PTR [rax+0x8],rbx
    2d70:	mov    rcx,QWORD PTR [rbp-0x40]
    2d74:	mov    rbx,QWORD PTR [rbp-0x38]
    2d78:	mov    QWORD PTR [rax+0x10],rcx
    2d7c:	mov    QWORD PTR [rax+0x18],rbx
    2d80:	mov    rcx,QWORD PTR [rbp-0x30]
    2d84:	mov    rbx,QWORD PTR [rbp-0x28]
    2d88:	mov    QWORD PTR [rax+0x20],rcx
    2d8c:	mov    QWORD PTR [rax+0x28],rbx
    2d90:	mov    rdx,QWORD PTR [rbp-0x20]
    2d94:	mov    QWORD PTR [rax+0x30],rdx
    2d98:	call   1f31 <__profile_end_pass>
    2d9d:	add    rsp,0x40

  return outer;
    2da1:	mov    rax,QWORD PTR [rbp-0x98]
}
    2da8:	mov    rdx,QWORD PTR [rbp-0x18]
    2dac:	sub    rdx,QWORD PTR fs:0x28
    2db5:	je     2dbc <parse_json+0x15d>
    2db7:	call   1060 <__stack_chk_fail@plt>
    2dbc:	mov    rbx,QWORD PTR [rbp-0x8]
    2dc0:	leave
    2dc1:	ret

0000000000002dc2 <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2dc2:	push   rbp
    2dc3:	mov    rbp,rsp
    2dc6:	push   rbx
    2dc7:	sub    rsp,0x78
    2dcb:	mov    QWORD PTR [rbp-0x68],rdi
    2dcf:	mov    rax,rsi
    2dd2:	mov    rsi,rdx
    2dd5:	mov    rax,rax
    2dd8:	mov    edx,0x0
    2ddd:	mov    rdx,rsi
    2de0:	mov    QWORD PTR [rbp-0x80],rax
    2de4:	mov    QWORD PTR [rbp-0x78],rdx
    2de8:	mov    rax,QWORD PTR fs:0x28
    2df1:	mov    QWORD PTR [rbp-0x18],rax
    2df5:	xor    eax,eax
  profile_begin_func();
    2df7:	lea    rcx,[rip+0x1a52]        # 4850 <__func__.1>
    2dfe:	mov    ebx,0x12
    2e03:	lea    rax,[rbp-0x50]
    2e07:	mov    rsi,rcx
    2e0a:	mov    rdx,rbx
    2e0d:	mov    r8d,0x0
    2e13:	mov    ecx,0x4
    2e18:	mov    rdi,rax
    2e1b:	call   1e47 <__profile_begin_pass>

  JSON_Object *result = NULL;
    2e20:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2e28:	cmp    QWORD PTR [rbp-0x68],0x0
    2e2d:	je     2e7c <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2e2f:	mov    rax,QWORD PTR [rbp-0x68]
    2e33:	mov    rax,QWORD PTR [rax+0x20]
    2e37:	mov    QWORD PTR [rbp-0x58],rax
    2e3b:	jmp    2e75 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2e3d:	mov    rax,QWORD PTR [rbp-0x58]
    2e41:	mov    rdx,QWORD PTR [rax+0x8]
    2e45:	mov    rax,QWORD PTR [rax]
    2e48:	mov    rdi,QWORD PTR [rbp-0x80]
    2e4c:	mov    rsi,QWORD PTR [rbp-0x78]
    2e50:	mov    rcx,rdx
    2e53:	mov    rdx,rax
    2e56:	call   143f <strings_equal>
    2e5b:	test   al,al
    2e5d:	je     2e69 <lookup_json_object+0xa7>
      {
        result = cursor;
    2e5f:	mov    rax,QWORD PTR [rbp-0x58]
    2e63:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2e67:	jmp    2e7c <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2e69:	mov    rax,QWORD PTR [rbp-0x58]
    2e6d:	mov    rax,QWORD PTR [rax+0x28]
    2e71:	mov    QWORD PTR [rbp-0x58],rax
    2e75:	cmp    QWORD PTR [rbp-0x58],0x0
    2e7a:	jne    2e3d <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2e7c:	sub    rsp,0x8
    2e80:	sub    rsp,0x38
    2e84:	mov    rax,rsp
    2e87:	mov    rcx,QWORD PTR [rbp-0x50]
    2e8b:	mov    rbx,QWORD PTR [rbp-0x48]
    2e8f:	mov    QWORD PTR [rax],rcx
    2e92:	mov    QWORD PTR [rax+0x8],rbx
    2e96:	mov    rcx,QWORD PTR [rbp-0x40]
    2e9a:	mov    rbx,QWORD PTR [rbp-0x38]
    2e9e:	mov    QWORD PTR [rax+0x10],rcx
    2ea2:	mov    QWORD PTR [rax+0x18],rbx
    2ea6:	mov    rcx,QWORD PTR [rbp-0x30]
    2eaa:	mov    rbx,QWORD PTR [rbp-0x28]
    2eae:	mov    QWORD PTR [rax+0x20],rcx
    2eb2:	mov    QWORD PTR [rax+0x28],rbx
    2eb6:	mov    rdx,QWORD PTR [rbp-0x20]
    2eba:	mov    QWORD PTR [rax+0x30],rdx
    2ebe:	call   1f31 <__profile_end_pass>
    2ec3:	add    rsp,0x40

  return result;
    2ec7:	mov    rax,QWORD PTR [rbp-0x60]
}
    2ecb:	mov    rdx,QWORD PTR [rbp-0x18]
    2ecf:	sub    rdx,QWORD PTR fs:0x28
    2ed8:	je     2edf <lookup_json_object+0x11d>
    2eda:	call   1060 <__stack_chk_fail@plt>
    2edf:	mov    rbx,QWORD PTR [rbp-0x8]
    2ee3:	leave
    2ee4:	ret

0000000000002ee5 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    2ee5:	push   rbp
    2ee6:	mov    rbp,rsp
    2ee9:	sub    rsp,0x50
    2eed:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    2ef1:	cmp    QWORD PTR [rbp-0x48],0x0
    2ef6:	jne    2f1d <json_object_to_f64+0x38>
    2ef8:	lea    rdx,[rip+0x1971]        # 4870 <__PRETTY_FUNCTION__.0>
    2eff:	lea    rsi,[rip+0x1559]        # 445f <_IO_stdin_used+0x45f>
    2f06:	lea    rax,[rip+0x16cb]        # 45d8 <_IO_stdin_used+0x5d8>
    2f0d:	mov    rcx,rdx
    2f10:	mov    edx,0x1c2
    2f15:	mov    rdi,rax
    2f18:	call   1090 <__assert_fail@plt>

  String val = object->value;
    2f1d:	mov    rax,QWORD PTR [rbp-0x48]
    2f21:	mov    rdx,QWORD PTR [rax+0x18]
    2f25:	mov    rax,QWORD PTR [rax+0x10]
    2f29:	mov    QWORD PTR [rbp-0x10],rax
    2f2d:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    2f31:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    2f39:	movsd  xmm0,QWORD PTR [rip+0x1957]        # 4898 <__PRETTY_FUNCTION__.0+0x28>
    2f41:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    2f46:	mov    rax,QWORD PTR [rbp-0x8]
    2f4a:	cmp    QWORD PTR [rbp-0x30],rax
    2f4e:	jae    2f74 <json_object_to_f64+0x8f>
    2f50:	mov    rdx,QWORD PTR [rbp-0x10]
    2f54:	mov    rax,QWORD PTR [rbp-0x30]
    2f58:	add    rax,rdx
    2f5b:	movzx  eax,BYTE PTR [rax]
    2f5e:	cmp    al,0x2d
    2f60:	jne    2f74 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    2f62:	movsd  xmm0,QWORD PTR [rip+0x1936]        # 48a0 <__PRETTY_FUNCTION__.0+0x30>
    2f6a:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    2f6f:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    2f74:	pxor   xmm0,xmm0
    2f78:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    2f7d:	jmp    2fc4 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    2f7f:	mov    rdx,QWORD PTR [rbp-0x10]
    2f83:	mov    rax,QWORD PTR [rbp-0x30]
    2f87:	add    rax,rdx
    2f8a:	movzx  eax,BYTE PTR [rax]
    2f8d:	sub    eax,0x30
    2f90:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    2f93:	cmp    BYTE PTR [rbp-0x32],0x9
    2f97:	ja     2fd0 <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    2f99:	movsd  xmm1,QWORD PTR [rbp-0x20]
    2f9e:	movsd  xmm0,QWORD PTR [rip+0x1902]        # 48a8 <__PRETTY_FUNCTION__.0+0x38>
    2fa6:	mulsd  xmm1,xmm0
    2faa:	movzx  eax,BYTE PTR [rbp-0x32]
    2fae:	pxor   xmm0,xmm0
    2fb2:	cvtsi2sd xmm0,eax
    2fb6:	addsd  xmm0,xmm1
    2fba:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    2fbf:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    2fc4:	mov    rax,QWORD PTR [rbp-0x8]
    2fc8:	cmp    QWORD PTR [rbp-0x30],rax
    2fcc:	jb     2f7f <json_object_to_f64+0x9a>
    2fce:	jmp    2fd1 <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    2fd0:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    2fd1:	mov    rax,QWORD PTR [rbp-0x8]
    2fd5:	cmp    QWORD PTR [rbp-0x30],rax
    2fd9:	jae    3066 <json_object_to_f64+0x181>
    2fdf:	mov    rdx,QWORD PTR [rbp-0x10]
    2fe3:	mov    rax,QWORD PTR [rbp-0x30]
    2fe7:	add    rax,rdx
    2fea:	movzx  eax,BYTE PTR [rax]
    2fed:	cmp    al,0x2e
    2fef:	jne    3066 <json_object_to_f64+0x181>
  {
    at += 1;
    2ff1:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    2ff6:	movsd  xmm0,QWORD PTR [rip+0x18b2]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    2ffe:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    3003:	jmp    3059 <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3005:	mov    rdx,QWORD PTR [rbp-0x10]
    3009:	mov    rax,QWORD PTR [rbp-0x30]
    300d:	add    rax,rdx
    3010:	movzx  eax,BYTE PTR [rax]
    3013:	sub    eax,0x30
    3016:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    3019:	cmp    BYTE PTR [rbp-0x31],0x9
    301d:	ja     3065 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    301f:	movzx  eax,BYTE PTR [rbp-0x31]
    3023:	pxor   xmm0,xmm0
    3027:	cvtsi2sd xmm0,eax
    302b:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    3030:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3035:	addsd  xmm0,xmm1
    3039:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    303e:	movsd  xmm1,QWORD PTR [rbp-0x18]
    3043:	movsd  xmm0,QWORD PTR [rip+0x1865]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    304b:	mulsd  xmm0,xmm1
    304f:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3054:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    3059:	mov    rax,QWORD PTR [rbp-0x8]
    305d:	cmp    QWORD PTR [rbp-0x30],rax
    3061:	jb     3005 <json_object_to_f64+0x120>
    3063:	jmp    3066 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    3065:	nop
      }
    }
  }

  return sign * result;
    3066:	movsd  xmm0,QWORD PTR [rbp-0x28]
    306b:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    3070:	leave
    3071:	ret

0000000000003072 <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    3072:	push   rbp
    3073:	mov    rbp,rsp
    3076:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    307b:	movsd  xmm0,QWORD PTR [rbp-0x8]
    3080:	movsd  xmm1,QWORD PTR [rip+0x1830]        # 48b8 <__PRETTY_FUNCTION__.0+0x48>
    3088:	divsd  xmm0,xmm1
}
    308c:	pop    rbp
    308d:	ret

000000000000308e <square>:

static
f64 square(f64 x)
{
    308e:	push   rbp
    308f:	mov    rbp,rsp
    3092:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    3097:	movsd  xmm0,QWORD PTR [rbp-0x8]
    309c:	mulsd  xmm0,xmm0
}
    30a0:	pop    rbp
    30a1:	ret

00000000000030a2 <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    30a2:	push   rbp
    30a3:	mov    rbp,rsp
    30a6:	sub    rsp,0x90
    30ad:	movsd  QWORD PTR [rbp-0x58],xmm0
    30b2:	movsd  QWORD PTR [rbp-0x60],xmm1
    30b7:	movsd  QWORD PTR [rbp-0x68],xmm2
    30bc:	movsd  QWORD PTR [rbp-0x70],xmm3
    30c1:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    30c6:	movsd  xmm0,QWORD PTR [rbp-0x60]
    30cb:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    30d0:	movsd  xmm0,QWORD PTR [rbp-0x70]
    30d5:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    30da:	movsd  xmm0,QWORD PTR [rbp-0x58]
    30df:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    30e4:	movsd  xmm0,QWORD PTR [rbp-0x68]
    30e9:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    30ee:	movsd  xmm0,QWORD PTR [rbp-0x40]
    30f3:	subsd  xmm0,QWORD PTR [rbp-0x48]
    30f8:	movq   rax,xmm0
    30fd:	movq   xmm0,rax
    3102:	call   3072 <to_radians>
    3107:	movq   rax,xmm0
    310c:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    3110:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3115:	subsd  xmm0,QWORD PTR [rbp-0x38]
    311a:	movq   rax,xmm0
    311f:	movq   xmm0,rax
    3124:	call   3072 <to_radians>
    3129:	movq   rax,xmm0
    312e:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    3132:	mov    rax,QWORD PTR [rbp-0x48]
    3136:	movq   xmm0,rax
    313b:	call   3072 <to_radians>
    3140:	movq   rax,xmm0
    3145:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    3149:	mov    rax,QWORD PTR [rbp-0x40]
    314d:	movq   xmm0,rax
    3152:	call   3072 <to_radians>
    3157:	movq   rax,xmm0
    315c:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    3160:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3165:	movsd  xmm1,QWORD PTR [rip+0x1753]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    316d:	divsd  xmm0,xmm1
    3171:	movq   rax,xmm0
    3176:	movq   xmm0,rax
    317b:	call   1130 <sin@plt>
    3180:	movq   rax,xmm0
    3185:	movq   xmm0,rax
    318a:	call   308e <square>
    318f:	movsd  QWORD PTR [rbp-0x80],xmm0
    3194:	mov    rax,QWORD PTR [rbp-0x48]
    3198:	movq   xmm0,rax
    319d:	call   10b0 <cos@plt>
    31a2:	movsd  QWORD PTR [rbp-0x88],xmm0
    31aa:	mov    rax,QWORD PTR [rbp-0x40]
    31ae:	movq   xmm0,rax
    31b3:	call   10b0 <cos@plt>
    31b8:	movapd xmm5,xmm0
    31bc:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    31c4:	movsd  QWORD PTR [rbp-0x88],xmm5
    31cc:	movsd  xmm0,QWORD PTR [rbp-0x20]
    31d1:	movsd  xmm1,QWORD PTR [rip+0x16e7]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    31d9:	movapd xmm6,xmm0
    31dd:	divsd  xmm6,xmm1
    31e1:	movq   rax,xmm6
    31e6:	movq   xmm0,rax
    31eb:	call   1130 <sin@plt>
    31f0:	movq   rax,xmm0
    31f5:	movq   xmm0,rax
    31fa:	call   308e <square>
    31ff:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    3207:	addsd  xmm0,QWORD PTR [rbp-0x80]
    320c:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    3211:	mov    rax,QWORD PTR [rbp-0x18]
    3215:	movq   xmm0,rax
    321a:	call   1160 <sqrt@plt>
    321f:	movq   rax,xmm0
    3224:	movq   xmm0,rax
    3229:	call   1140 <asin@plt>
    322e:	addsd  xmm0,xmm0
    3232:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    3237:	movsd  xmm0,QWORD PTR [rbp-0x78]
    323c:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    3241:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3246:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    324b:	leave
    324c:	ret

000000000000324d <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    324d:	push   rbp
    324e:	mov    rbp,rsp
    3251:	movsd  QWORD PTR [rbp-0x18],xmm0
    3256:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    325b:	movsd  xmm0,QWORD PTR [rip+0x1665]        # 48c8 <__PRETTY_FUNCTION__.0+0x58>
    3263:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    3268:	movsd  xmm0,QWORD PTR [rbp-0x18]
    326d:	movq   xmm1,QWORD PTR [rip+0x165b]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    3275:	andpd  xmm0,xmm1
    3279:	movsd  xmm1,QWORD PTR [rbp-0x20]
    327e:	movq   xmm2,QWORD PTR [rip+0x164a]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    3286:	andpd  xmm2,xmm1
    328a:	movapd xmm1,xmm0
    328e:	subsd  xmm1,xmm2
    3292:	movsd  xmm0,QWORD PTR [rbp-0x8]
    3297:	comisd xmm0,xmm1
    329b:	setae  al
    329e:	movzx  eax,al
}
    32a1:	pop    rbp
    32a2:	ret

00000000000032a3 <main>:

int main(int args_count, char **args)
{
    32a3:	push   rbp
    32a4:	mov    rbp,rsp
    32a7:	push   r15
    32a9:	push   r14
    32ab:	push   r13
    32ad:	push   r12
    32af:	push   rbx
    32b0:	sub    rsp,0x2d8
    32b7:	mov    DWORD PTR [rbp-0x244],edi
    32bd:	mov    QWORD PTR [rbp-0x250],rsi
    32c4:	mov    rax,QWORD PTR fs:0x28
    32cd:	mov    QWORD PTR [rbp-0x38],rax
    32d1:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    32d3:	cmp    DWORD PTR [rbp-0x244],0x3
    32da:	je     3307 <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    32dc:	mov    rax,QWORD PTR [rbp-0x250]
    32e3:	mov    rax,QWORD PTR [rax]
    32e6:	lea    rdx,[rip+0x1323]        # 4610 <_IO_stdin_used+0x610>
    32ed:	mov    rsi,rax
    32f0:	mov    rdi,rdx
    32f3:	mov    eax,0x0
    32f8:	call   1070 <printf@plt>
    return 1;
    32fd:	mov    eax,0x1
    3302:	jmp    3da5 <main+0xb02>
  }

  begin_profiling();
    3307:	call   1b3d <begin_profiling>

  Arena arena = {0};
    330c:	pxor   xmm0,xmm0
    3310:	movaps XMMWORD PTR [rbp-0x190],xmm0
    3317:	movaps XMMWORD PTR [rbp-0x180],xmm0
  arena = arena_make(GB(4));
    331e:	lea    rdx,[rbp-0x270]
    3325:	movabs rax,0x100000000
    332f:	mov    rsi,rax
    3332:	mov    rdi,rdx
    3335:	call   1632 <arena_make>
    333a:	mov    rax,QWORD PTR [rbp-0x270]
    3341:	mov    rdx,QWORD PTR [rbp-0x268]
    3348:	mov    QWORD PTR [rbp-0x190],rax
    334f:	mov    QWORD PTR [rbp-0x188],rdx
    3356:	mov    rax,QWORD PTR [rbp-0x260]
    335d:	mov    rdx,QWORD PTR [rbp-0x258]
    3364:	mov    QWORD PTR [rbp-0x180],rax
    336b:	mov    QWORD PTR [rbp-0x178],rdx

  String source = {0};
    3372:	mov    QWORD PTR [rbp-0x1a0],0x0
    337d:	mov    QWORD PTR [rbp-0x198],0x0
  PROFILE_SCOPE("read")
    3388:	lea    r12,[rip+0x12ad]        # 463c <_IO_stdin_used+0x63c>
    338f:	mov    r13d,0x4
    3395:	lea    rdi,[rbp-0x170]
    339c:	mov    rdx,r12
    339f:	mov    rax,r13
    33a2:	mov    r8d,0x0
    33a8:	mov    ecx,0x5
    33ad:	mov    rsi,rdx
    33b0:	mov    rdx,rax
    33b3:	call   1e47 <__profile_begin_pass>
    33b8:	mov    QWORD PTR [rbp-0x230],0x0
    33c3:	jmp    345e <main+0x1bb>
  {
    source = read_file_to_arena(&arena, args[1]);
    33c8:	mov    rax,QWORD PTR [rbp-0x250]
    33cf:	add    rax,0x8
    33d3:	mov    rdx,QWORD PTR [rax]
    33d6:	lea    rax,[rbp-0x190]
    33dd:	mov    rsi,rdx
    33e0:	mov    rdi,rax
    33e3:	call   1357 <read_file_to_arena>
    33e8:	mov    QWORD PTR [rbp-0x1a0],rax
    33ef:	mov    QWORD PTR [rbp-0x198],rdx
  PROFILE_SCOPE("read")
    33f6:	add    QWORD PTR [rbp-0x230],0x1
    33fe:	sub    rsp,0x8
    3402:	sub    rsp,0x38
    3406:	mov    rcx,rsp
    3409:	mov    rax,QWORD PTR [rbp-0x170]
    3410:	mov    rdx,QWORD PTR [rbp-0x168]
    3417:	mov    QWORD PTR [rcx],rax
    341a:	mov    QWORD PTR [rcx+0x8],rdx
    341e:	mov    rax,QWORD PTR [rbp-0x160]
    3425:	mov    rdx,QWORD PTR [rbp-0x158]
    342c:	mov    QWORD PTR [rcx+0x10],rax
    3430:	mov    QWORD PTR [rcx+0x18],rdx
    3434:	mov    rax,QWORD PTR [rbp-0x150]
    343b:	mov    rdx,QWORD PTR [rbp-0x148]
    3442:	mov    QWORD PTR [rcx+0x20],rax
    3446:	mov    QWORD PTR [rcx+0x28],rdx
    344a:	mov    rax,QWORD PTR [rbp-0x140]
    3451:	mov    QWORD PTR [rcx+0x30],rax
    3455:	call   1f31 <__profile_end_pass>
    345a:	add    rsp,0x40
    345e:	cmp    QWORD PTR [rbp-0x230],0x0
    3466:	je     33c8 <main+0x125>
  }

  Haversine_Pair *pairs = NULL;
    346c:	mov    QWORD PTR [rbp-0x228],0x0
  i32 pair_count = 0;
    3477:	mov    DWORD PTR [rbp-0x238],0x0
  usize max_pairs = 0;
    3481:	mov    QWORD PTR [rbp-0x220],0x0
  PROFILE_SCOPE("haversine alloc")
    348c:	lea    r14,[rip+0x11ae]        # 4641 <_IO_stdin_used+0x641>
    3493:	mov    r15d,0xf
    3499:	lea    rdi,[rbp-0x130]
    34a0:	mov    rdx,r14
    34a3:	mov    rax,r15
    34a6:	mov    r8d,0x0
    34ac:	mov    ecx,0x6
    34b1:	mov    rsi,rdx
    34b4:	mov    rdx,rax
    34b7:	call   1e47 <__profile_begin_pass>
    34bc:	mov    QWORD PTR [rbp-0x218],0x0
    34c7:	jmp    358f <main+0x2ec>
  {
    usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    34cc:	mov    QWORD PTR [rbp-0x1a8],0x18
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    34d7:	mov    rax,QWORD PTR [rbp-0x198]
    34de:	mov    edx,0x0
    34e3:	div    QWORD PTR [rbp-0x1a8]
    34ea:	mov    QWORD PTR [rbp-0x220],rax

    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    34f1:	mov    rax,QWORD PTR [rbp-0x220]
    34f8:	shl    rax,0x5
    34fc:	mov    rcx,rax
    34ff:	lea    rax,[rbp-0x190]
    3506:	mov    edx,0x8
    350b:	mov    rsi,rcx
    350e:	mov    rdi,rax
    3511:	call   17d3 <arena_alloc>
    3516:	mov    QWORD PTR [rbp-0x228],rax
    pair_count = 0;
    351d:	mov    DWORD PTR [rbp-0x238],0x0
  PROFILE_SCOPE("haversine alloc")
    3527:	add    QWORD PTR [rbp-0x218],0x1
    352f:	sub    rsp,0x8
    3533:	sub    rsp,0x38
    3537:	mov    rcx,rsp
    353a:	mov    rax,QWORD PTR [rbp-0x130]
    3541:	mov    rdx,QWORD PTR [rbp-0x128]
    3548:	mov    QWORD PTR [rcx],rax
    354b:	mov    QWORD PTR [rcx+0x8],rdx
    354f:	mov    rax,QWORD PTR [rbp-0x120]
    3556:	mov    rdx,QWORD PTR [rbp-0x118]
    355d:	mov    QWORD PTR [rcx+0x10],rax
    3561:	mov    QWORD PTR [rcx+0x18],rdx
    3565:	mov    rax,QWORD PTR [rbp-0x110]
    356c:	mov    rdx,QWORD PTR [rbp-0x108]
    3573:	mov    QWORD PTR [rcx+0x20],rax
    3577:	mov    QWORD PTR [rcx+0x28],rdx
    357b:	mov    rax,QWORD PTR [rbp-0x100]
    3582:	mov    QWORD PTR [rcx+0x30],rax
    3586:	call   1f31 <__profile_end_pass>
    358b:	add    rsp,0x40
    358f:	cmp    QWORD PTR [rbp-0x218],0x0
    3597:	je     34cc <main+0x229>
  }

  JSON_Object *root = NULL;
    359d:	mov    QWORD PTR [rbp-0x1d8],0x0
  root = parse_json(&arena, source);
    35a8:	mov    rcx,QWORD PTR [rbp-0x1a0]
    35af:	mov    rdx,QWORD PTR [rbp-0x198]
    35b6:	lea    rax,[rbp-0x190]
    35bd:	mov    rsi,rcx
    35c0:	mov    rdi,rax
    35c3:	call   2c5f <parse_json>
    35c8:	mov    QWORD PTR [rbp-0x1d8],rax

  f64 haversine_sum = 0.0;
    35cf:	pxor   xmm0,xmm0
    35d3:	movsd  QWORD PTR [rbp-0x1d0],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    35db:	lea    rax,[rip+0x106f]        # 4651 <_IO_stdin_used+0x651>
    35e2:	mov    QWORD PTR [rbp-0x280],rax
    35e9:	mov    QWORD PTR [rbp-0x278],0x5
    35f4:	mov    rax,QWORD PTR [rbp-0x280]
    35fb:	mov    rdx,QWORD PTR [rbp-0x278]
    3602:	mov    rcx,rax
    3605:	mov    rax,QWORD PTR [rbp-0x1d8]
    360c:	mov    rsi,rcx
    360f:	mov    rdi,rax
    3612:	call   2dc2 <lookup_json_object>
    3617:	mov    QWORD PTR [rbp-0x1c8],rax
  if (pairs)
    361e:	cmp    QWORD PTR [rbp-0x228],0x0
    3626:	je     38bb <main+0x618>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    362c:	mov    rax,QWORD PTR [rbp-0x1c8]
    3633:	mov    rax,QWORD PTR [rax+0x20]
    3637:	mov    QWORD PTR [rbp-0x210],rax
    363e:	jmp    389c <main+0x5f9>
    {
      PROFILE_SCOPE("child convert")
    3643:	lea    rax,[rip+0x100d]        # 4657 <_IO_stdin_used+0x657>
    364a:	mov    QWORD PTR [rbp-0x2c0],rax
    3651:	mov    QWORD PTR [rbp-0x2b8],0xd
    365c:	lea    rdi,[rbp-0x70]
    3660:	mov    rbx,QWORD PTR [rbp-0x2c0]
    3667:	mov    rsi,QWORD PTR [rbp-0x2b8]
    366e:	mov    rdx,rbx
    3671:	mov    rax,rsi
    3674:	mov    r8d,0x0
    367a:	mov    ecx,0x7
    367f:	mov    rsi,rdx
    3682:	mov    rdx,rax
    3685:	call   1e47 <__profile_begin_pass>
    368a:	mov    QWORD PTR [rbp-0x208],0x0
    3695:	jmp    387c <main+0x5d9>
      {
        Haversine_Pair pair =
        {
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    369a:	lea    rax,[rip+0xfc4]        # 4665 <_IO_stdin_used+0x665>
    36a1:	mov    QWORD PTR [rbp-0x2d0],rax
    36a8:	mov    QWORD PTR [rbp-0x2c8],0x2
    36b3:	mov    rbx,QWORD PTR [rbp-0x2d0]
    36ba:	mov    rsi,QWORD PTR [rbp-0x2c8]
    36c1:	mov    rax,rbx
    36c4:	mov    rdx,rsi
    36c7:	mov    rcx,QWORD PTR [rbp-0x210]
    36ce:	mov    rsi,rax
    36d1:	mov    rdi,rcx
    36d4:	call   2dc2 <lookup_json_object>
    36d9:	mov    rdi,rax
    36dc:	call   2ee5 <json_object_to_f64>
    36e1:	movq   rax,xmm0
        Haversine_Pair pair =
    36e6:	mov    QWORD PTR [rbp-0xb0],rax
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    36ed:	lea    rax,[rip+0xf74]        # 4668 <_IO_stdin_used+0x668>
    36f4:	mov    QWORD PTR [rbp-0x2e0],rax
    36fb:	mov    QWORD PTR [rbp-0x2d8],0x2
    3706:	mov    rax,QWORD PTR [rbp-0x2e0]
    370d:	mov    rdx,QWORD PTR [rbp-0x2d8]
    3714:	mov    rcx,rax
    3717:	mov    rax,QWORD PTR [rbp-0x210]
    371e:	mov    rsi,rcx
    3721:	mov    rdi,rax
    3724:	call   2dc2 <lookup_json_object>
    3729:	mov    rdi,rax
    372c:	call   2ee5 <json_object_to_f64>
    3731:	movq   rax,xmm0
        Haversine_Pair pair =
    3736:	mov    QWORD PTR [rbp-0xa8],rax
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    373d:	lea    rax,[rip+0xf27]        # 466b <_IO_stdin_used+0x66b>
    3744:	mov    QWORD PTR [rbp-0x2f0],rax
    374b:	mov    QWORD PTR [rbp-0x2e8],0x2
    3756:	mov    rax,QWORD PTR [rbp-0x2f0]
    375d:	mov    rdx,QWORD PTR [rbp-0x2e8]
    3764:	mov    rcx,rax
    3767:	mov    rax,QWORD PTR [rbp-0x210]
    376e:	mov    rsi,rcx
    3771:	mov    rdi,rax
    3774:	call   2dc2 <lookup_json_object>
    3779:	mov    rdi,rax
    377c:	call   2ee5 <json_object_to_f64>
    3781:	movq   rax,xmm0
        Haversine_Pair pair =
    3786:	mov    QWORD PTR [rbp-0xa0],rax
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    378d:	lea    rax,[rip+0xeda]        # 466e <_IO_stdin_used+0x66e>
    3794:	mov    QWORD PTR [rbp-0x300],rax
    379b:	mov    QWORD PTR [rbp-0x2f8],0x2
    37a6:	mov    rax,QWORD PTR [rbp-0x300]
    37ad:	mov    rdx,QWORD PTR [rbp-0x2f8]
    37b4:	mov    rcx,rax
    37b7:	mov    rax,QWORD PTR [rbp-0x210]
    37be:	mov    rsi,rcx
    37c1:	mov    rdi,rax
    37c4:	call   2dc2 <lookup_json_object>
    37c9:	mov    rdi,rax
    37cc:	call   2ee5 <json_object_to_f64>
    37d1:	movq   rax,xmm0
        Haversine_Pair pair =
    37d6:	mov    QWORD PTR [rbp-0x98],rax
        };

        pairs[pair_count] = pair;
    37dd:	mov    eax,DWORD PTR [rbp-0x238]
    37e3:	cdqe
    37e5:	shl    rax,0x5
    37e9:	mov    rdx,rax
    37ec:	mov    rax,QWORD PTR [rbp-0x228]
    37f3:	lea    rcx,[rdx+rax*1]
    37f7:	mov    rax,QWORD PTR [rbp-0xb0]
    37fe:	mov    rdx,QWORD PTR [rbp-0xa8]
    3805:	mov    QWORD PTR [rcx],rax
    3808:	mov    QWORD PTR [rcx+0x8],rdx
    380c:	mov    rax,QWORD PTR [rbp-0xa0]
    3813:	mov    rdx,QWORD PTR [rbp-0x98]
    381a:	mov    QWORD PTR [rcx+0x10],rax
    381e:	mov    QWORD PTR [rcx+0x18],rdx
        pair_count += 1;
    3822:	add    DWORD PTR [rbp-0x238],0x1
      PROFILE_SCOPE("child convert")
    3829:	add    QWORD PTR [rbp-0x208],0x1
    3831:	sub    rsp,0x8
    3835:	sub    rsp,0x38
    3839:	mov    rcx,rsp
    383c:	mov    rax,QWORD PTR [rbp-0x70]
    3840:	mov    rdx,QWORD PTR [rbp-0x68]
    3844:	mov    QWORD PTR [rcx],rax
    3847:	mov    QWORD PTR [rcx+0x8],rdx
    384b:	mov    rax,QWORD PTR [rbp-0x60]
    384f:	mov    rdx,QWORD PTR [rbp-0x58]
    3853:	mov    QWORD PTR [rcx+0x10],rax
    3857:	mov    QWORD PTR [rcx+0x18],rdx
    385b:	mov    rax,QWORD PTR [rbp-0x50]
    385f:	mov    rdx,QWORD PTR [rbp-0x48]
    3863:	mov    QWORD PTR [rcx+0x20],rax
    3867:	mov    QWORD PTR [rcx+0x28],rdx
    386b:	mov    rax,QWORD PTR [rbp-0x40]
    386f:	mov    QWORD PTR [rcx+0x30],rax
    3873:	call   1f31 <__profile_end_pass>
    3878:	add    rsp,0x40
    387c:	cmp    QWORD PTR [rbp-0x208],0x0
    3884:	je     369a <main+0x3f7>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    388a:	mov    rax,QWORD PTR [rbp-0x210]
    3891:	mov    rax,QWORD PTR [rax+0x28]
    3895:	mov    QWORD PTR [rbp-0x210],rax
    389c:	cmp    QWORD PTR [rbp-0x210],0x0
    38a4:	je     38bb <main+0x618>
    38a6:	mov    eax,DWORD PTR [rbp-0x238]
    38ac:	cdqe
    38ae:	cmp    rax,QWORD PTR [rbp-0x220]
    38b5:	jb     3643 <main+0x3a0>
      }
    }
  }

  f64 sum = 0.0;
    38bb:	pxor   xmm0,xmm0
    38bf:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    38c7:	lea    rax,[rip+0xda3]        # 4671 <_IO_stdin_used+0x671>
    38ce:	mov    QWORD PTR [rbp-0x290],rax
    38d5:	mov    QWORD PTR [rbp-0x288],0x3
    38e0:	lea    rax,[rbp-0xf0]
    38e7:	mov    rcx,QWORD PTR [rbp-0x290]
    38ee:	mov    rbx,QWORD PTR [rbp-0x288]
    38f5:	mov    rsi,rcx
    38f8:	mov    rdx,rbx
    38fb:	mov    r8d,0x0
    3901:	mov    ecx,0x8
    3906:	mov    rdi,rax
    3909:	call   1e47 <__profile_begin_pass>
    390e:	mov    QWORD PTR [rbp-0x1f8],0x0
    3919:	jmp    3a9b <main+0x7f8>
  {
    for (usize i = 0; i < pair_count; i++)
    391e:	mov    QWORD PTR [rbp-0x1f0],0x0
    3929:	jmp    39fe <main+0x75b>
    {
      f64 earth_radius = 6372.8;
    392e:	movsd  xmm0,QWORD PTR [rip+0xfaa]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    3936:	movsd  QWORD PTR [rbp-0x1b8],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    393e:	mov    rax,QWORD PTR [rbp-0x1f0]
    3945:	shl    rax,0x5
    3949:	mov    rdx,rax
    394c:	mov    rax,QWORD PTR [rbp-0x228]
    3953:	add    rax,rdx
    3956:	movsd  xmm2,QWORD PTR [rax+0x18]
    395b:	mov    rax,QWORD PTR [rbp-0x1f0]
    3962:	shl    rax,0x5
    3966:	mov    rdx,rax
    3969:	mov    rax,QWORD PTR [rbp-0x228]
    3970:	add    rax,rdx
    3973:	movsd  xmm1,QWORD PTR [rax+0x10]
    3978:	mov    rax,QWORD PTR [rbp-0x1f0]
    397f:	shl    rax,0x5
    3983:	mov    rdx,rax
    3986:	mov    rax,QWORD PTR [rbp-0x228]
    398d:	add    rax,rdx
    3990:	movsd  xmm0,QWORD PTR [rax+0x8]
    3995:	mov    rax,QWORD PTR [rbp-0x1f0]
    399c:	shl    rax,0x5
    39a0:	mov    rdx,rax
    39a3:	mov    rax,QWORD PTR [rbp-0x228]
    39aa:	add    rax,rdx
    39ad:	mov    rax,QWORD PTR [rax]
    39b0:	movsd  xmm3,QWORD PTR [rbp-0x1b8]
    39b8:	movapd xmm4,xmm3
    39bc:	movapd xmm3,xmm2
    39c0:	movapd xmm2,xmm1
    39c4:	movapd xmm1,xmm0
    39c8:	movq   xmm0,rax
    39cd:	call   30a2 <reference_haversine>
    39d2:	movq   rax,xmm0
    39d7:	mov    QWORD PTR [rbp-0x1b0],rax
      sum += result;
    39de:	movsd  xmm0,QWORD PTR [rbp-0x200]
    39e6:	addsd  xmm0,QWORD PTR [rbp-0x1b0]
    39ee:	movsd  QWORD PTR [rbp-0x200],xmm0
    for (usize i = 0; i < pair_count; i++)
    39f6:	add    QWORD PTR [rbp-0x1f0],0x1
    39fe:	mov    eax,DWORD PTR [rbp-0x238]
    3a04:	cdqe
    3a06:	cmp    QWORD PTR [rbp-0x1f0],rax
    3a0d:	jb     392e <main+0x68b>
    }
    sum /= pair_count;
    3a13:	pxor   xmm1,xmm1
    3a17:	cvtsi2sd xmm1,DWORD PTR [rbp-0x238]
    3a1f:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3a27:	divsd  xmm0,xmm1
    3a2b:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3a33:	add    QWORD PTR [rbp-0x1f8],0x1
    3a3b:	sub    rsp,0x8
    3a3f:	sub    rsp,0x38
    3a43:	mov    rax,rsp
    3a46:	mov    rcx,QWORD PTR [rbp-0xf0]
    3a4d:	mov    rbx,QWORD PTR [rbp-0xe8]
    3a54:	mov    QWORD PTR [rax],rcx
    3a57:	mov    QWORD PTR [rax+0x8],rbx
    3a5b:	mov    rcx,QWORD PTR [rbp-0xe0]
    3a62:	mov    rbx,QWORD PTR [rbp-0xd8]
    3a69:	mov    QWORD PTR [rax+0x10],rcx
    3a6d:	mov    QWORD PTR [rax+0x18],rbx
    3a71:	mov    rcx,QWORD PTR [rbp-0xd0]
    3a78:	mov    rbx,QWORD PTR [rbp-0xc8]
    3a7f:	mov    QWORD PTR [rax+0x20],rcx
    3a83:	mov    QWORD PTR [rax+0x28],rbx
    3a87:	mov    rdx,QWORD PTR [rbp-0xc0]
    3a8e:	mov    QWORD PTR [rax+0x30],rdx
    3a92:	call   1f31 <__profile_end_pass>
    3a97:	add    rsp,0x40
    3a9b:	cmp    QWORD PTR [rbp-0x1f8],0x0
    3aa3:	je     391e <main+0x67b>
  }

  PROFILE_SCOPE("check")
    3aa9:	lea    rax,[rip+0xbc5]        # 4675 <_IO_stdin_used+0x675>
    3ab0:	mov    QWORD PTR [rbp-0x2a0],rax
    3ab7:	mov    QWORD PTR [rbp-0x298],0x5
    3ac2:	lea    rax,[rbp-0xb0]
    3ac9:	mov    rcx,QWORD PTR [rbp-0x2a0]
    3ad0:	mov    rbx,QWORD PTR [rbp-0x298]
    3ad7:	mov    rsi,rcx
    3ada:	mov    rdx,rbx
    3add:	mov    r8d,0x0
    3ae3:	mov    ecx,0x9
    3ae8:	mov    rdi,rax
    3aeb:	call   1e47 <__profile_begin_pass>
    3af0:	mov    QWORD PTR [rbp-0x1e8],0x0
    3afb:	jmp    3cd0 <main+0xa2d>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3b00:	mov    rax,QWORD PTR [rbp-0x250]
    3b07:	add    rax,0x10
    3b0b:	mov    rdx,QWORD PTR [rax]
    3b0e:	lea    rax,[rbp-0x190]
    3b15:	mov    rsi,rdx
    3b18:	mov    rdi,rax
    3b1b:	call   1357 <read_file_to_arena>
    3b20:	mov    QWORD PTR [rbp-0x70],rax
    3b24:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3b28:	mov    rax,QWORD PTR [rbp-0x68]
    3b2c:	cmp    rax,0xb
    3b30:	jbe    3c43 <main+0x9a0>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3b36:	mov    rax,QWORD PTR [rbp-0x70]
    3b3a:	movsd  xmm0,QWORD PTR [rax]
    3b3e:	movsd  QWORD PTR [rbp-0x1c0],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3b46:	mov    rax,QWORD PTR [rbp-0x70]
    3b4a:	mov    eax,DWORD PTR [rax+0x8]
    3b4d:	mov    DWORD PTR [rbp-0x234],eax

      if (solution_pairs == pair_count)
    3b53:	mov    eax,DWORD PTR [rbp-0x234]
    3b59:	cmp    eax,DWORD PTR [rbp-0x238]
    3b5f:	jne    3c07 <main+0x964>
      {
        if (epsilon_equal(solution_sum, sum))
    3b65:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b6d:	mov    rax,QWORD PTR [rbp-0x1c0]
    3b74:	movapd xmm1,xmm0
    3b78:	movq   xmm0,rax
    3b7d:	call   324d <epsilon_equal>
    3b82:	test   eax,eax
    3b84:	je     3bc8 <main+0x925>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3b86:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b8e:	mov    rax,QWORD PTR [rbp-0x1c0]
    3b95:	lea    rdx,[rip+0xae4]        # 4680 <_IO_stdin_used+0x680>
    3b9c:	lea    rsi,[rip+0xb10]        # 46b3 <_IO_stdin_used+0x6b3>
    3ba3:	movapd xmm1,xmm0
    3ba7:	movq   xmm0,rax
    3bac:	mov    rcx,rdx
    3baf:	mov    edx,0x64
    3bb4:	mov    edi,0x3
    3bb9:	mov    eax,0x2
    3bbe:	call   14a1 <log_message>
    3bc3:	jmp    3c6b <main+0x9c8>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3bc8:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3bd0:	mov    rax,QWORD PTR [rbp-0x1c0]
    3bd7:	lea    rdx,[rip+0xaea]        # 46c8 <_IO_stdin_used+0x6c8>
    3bde:	lea    rsi,[rip+0xace]        # 46b3 <_IO_stdin_used+0x6b3>
    3be5:	movapd xmm1,xmm0
    3be9:	movq   xmm0,rax
    3bee:	mov    rcx,rdx
    3bf1:	mov    edx,0x68
    3bf6:	mov    edi,0x1
    3bfb:	mov    eax,0x2
    3c00:	call   14a1 <log_message>
    3c05:	jmp    3c6b <main+0x9c8>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3c07:	mov    esi,DWORD PTR [rbp-0x238]
    3c0d:	mov    ecx,DWORD PTR [rbp-0x234]
    3c13:	lea    rdx,[rip+0xae6]        # 4700 <_IO_stdin_used+0x700>
    3c1a:	lea    rax,[rip+0xa92]        # 46b3 <_IO_stdin_used+0x6b3>
    3c21:	mov    r9d,esi
    3c24:	mov    r8d,ecx
    3c27:	mov    rcx,rdx
    3c2a:	mov    edx,0x6d
    3c2f:	mov    rsi,rax
    3c32:	mov    edi,0x1
    3c37:	mov    eax,0x0
    3c3c:	call   14a1 <log_message>
    3c41:	jmp    3c6b <main+0x9c8>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3c43:	lea    rdx,[rip+0xafe]        # 4748 <_IO_stdin_used+0x748>
    3c4a:	lea    rax,[rip+0xa62]        # 46b3 <_IO_stdin_used+0x6b3>
    3c51:	mov    rcx,rdx
    3c54:	mov    edx,0x72
    3c59:	mov    rsi,rax
    3c5c:	mov    edi,0x1
    3c61:	mov    eax,0x0
    3c66:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3c6b:	add    QWORD PTR [rbp-0x1e8],0x1
    3c73:	sub    rsp,0x8
    3c77:	sub    rsp,0x38
    3c7b:	mov    rax,rsp
    3c7e:	mov    rcx,QWORD PTR [rbp-0xb0]
    3c85:	mov    rbx,QWORD PTR [rbp-0xa8]
    3c8c:	mov    QWORD PTR [rax],rcx
    3c8f:	mov    QWORD PTR [rax+0x8],rbx
    3c93:	mov    rcx,QWORD PTR [rbp-0xa0]
    3c9a:	mov    rbx,QWORD PTR [rbp-0x98]
    3ca1:	mov    QWORD PTR [rax+0x10],rcx
    3ca5:	mov    QWORD PTR [rax+0x18],rbx
    3ca9:	mov    rcx,QWORD PTR [rbp-0x90]
    3cb0:	mov    rbx,QWORD PTR [rbp-0x88]
    3cb7:	mov    QWORD PTR [rax+0x20],rcx
    3cbb:	mov    QWORD PTR [rax+0x28],rbx
    3cbf:	mov    rdx,QWORD PTR [rbp-0x80]
    3cc3:	mov    QWORD PTR [rax+0x30],rdx
    3cc7:	call   1f31 <__profile_end_pass>
    3ccc:	add    rsp,0x40
    3cd0:	cmp    QWORD PTR [rbp-0x1e8],0x0
    3cd8:	je     3b00 <main+0x85d>
    }
  }

  PROFILE_SCOPE("free")
    3cde:	lea    rax,[rip+0xa9e]        # 4783 <_IO_stdin_used+0x783>
    3ce5:	mov    QWORD PTR [rbp-0x2b0],rax
    3cec:	mov    QWORD PTR [rbp-0x2a8],0x4
    3cf7:	lea    rax,[rbp-0x70]
    3cfb:	mov    rcx,QWORD PTR [rbp-0x2b0]
    3d02:	mov    rbx,QWORD PTR [rbp-0x2a8]
    3d09:	mov    rsi,rcx
    3d0c:	mov    rdx,rbx
    3d0f:	mov    r8d,0x0
    3d15:	mov    ecx,0xa
    3d1a:	mov    rdi,rax
    3d1d:	call   1e47 <__profile_begin_pass>
    3d22:	mov    QWORD PTR [rbp-0x1e0],0x0
    3d2d:	jmp    3d91 <main+0xaee>
  {
    arena_free(&arena);
    3d2f:	lea    rax,[rbp-0x190]
    3d36:	mov    rdi,rax
    3d39:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3d3e:	add    QWORD PTR [rbp-0x1e0],0x1
    3d46:	sub    rsp,0x8
    3d4a:	sub    rsp,0x38
    3d4e:	mov    rax,rsp
    3d51:	mov    rcx,QWORD PTR [rbp-0x70]
    3d55:	mov    rbx,QWORD PTR [rbp-0x68]
    3d59:	mov    QWORD PTR [rax],rcx
    3d5c:	mov    QWORD PTR [rax+0x8],rbx
    3d60:	mov    rcx,QWORD PTR [rbp-0x60]
    3d64:	mov    rbx,QWORD PTR [rbp-0x58]
    3d68:	mov    QWORD PTR [rax+0x10],rcx
    3d6c:	mov    QWORD PTR [rax+0x18],rbx
    3d70:	mov    rcx,QWORD PTR [rbp-0x50]
    3d74:	mov    rbx,QWORD PTR [rbp-0x48]
    3d78:	mov    QWORD PTR [rax+0x20],rcx
    3d7c:	mov    QWORD PTR [rax+0x28],rbx
    3d80:	mov    rdx,QWORD PTR [rbp-0x40]
    3d84:	mov    QWORD PTR [rax+0x30],rdx
    3d88:	call   1f31 <__profile_end_pass>
    3d8d:	add    rsp,0x40
    3d91:	cmp    QWORD PTR [rbp-0x1e0],0x0
    3d99:	je     3d2f <main+0xa8c>
  }

  end_profiling();
    3d9b:	call   1b9b <end_profiling>
    3da0:	mov    eax,0x0
}
    3da5:	mov    rdx,QWORD PTR [rbp-0x38]
    3da9:	sub    rdx,QWORD PTR fs:0x28
    3db2:	je     3db9 <main+0xb16>
    3db4:	call   1060 <__stack_chk_fail@plt>
    3db9:	lea    rsp,[rbp-0x28]
    3dbd:	pop    rbx
    3dbe:	pop    r12
    3dc0:	pop    r13
    3dc2:	pop    r14
    3dc4:	pop    r15
    3dc6:	pop    rbp
    3dc7:	ret

Disassembly of section .fini:

0000000000003dc8 <_fini>:
    3dc8:	endbr64
    3dcc:	sub    rsp,0x8
    3dd0:	add    rsp,0x8
    3dd4:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x4fc1]        # 5fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x4fca]        # 5ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x4fcc]        # 5ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x4fca]        # 6000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x4fc2]        # 6008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x4fba]        # 6010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x4fb2]        # 6018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x4faa]        # 6020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x4fa2]        # 6028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x4f9a]        # 6030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x4f92]        # 6038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x4f8a]        # 6040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x4f82]        # 6048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x4f7a]        # 6050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x4f72]        # 6058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x4f6a]        # 6060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x4f62]        # 6068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x4f5a]        # 6070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x4f52]        # 6078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x4f4a]        # 6080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x4f42]        # 6088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x4f3a]        # 6090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x4f32]        # 6098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2114]        # 32a3 <main>
    118f:	call   QWORD PTR [rip+0x4e2b]        # 5fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x4fa1]        # 6148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x4f9a]        # 6148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x4e0e]        # 5fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x4f71]        # 6148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x4f6a]        # 6148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x4ddd]        # 5fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x4f6d],0x0        # 6188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x4dba],0x0        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x4e76]        # 60a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x4da8]        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x4f44],0x1        # 6188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x4c6e]        # 6180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x4b89]        # 60c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x4be7]        # 6160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x4b2b]        # 60c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x3097]        # 4790 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x306b]        # 4790 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fae]        # 47a8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2eaf]        # 47b8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2ccd]        # 47d0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x4639]        # 61a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x4620],rbx        # 61a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x40
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x45ee]        # 61a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x28],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x28],0x0
    1bbe:	je     1e44 <end_profiling+0x2a9>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x20],rax
    printf("[PROFILE] Total duration: %lu (%fms @ CPU Frequency: %u)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x28]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x20]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c51]        # 4888 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x20]
    1c44:	mov    rax,QWORD PTR [rbp-0x28]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x38],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x30],0x0
    1c72:	jmp    1e36 <end_profiling+0x29b>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x30]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x450d]        # 61a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x18],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x18]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1e31 <end_profiling+0x296>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x18]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x28]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b77]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x10],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x18]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x18]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x18]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x18]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x10]
    1d48:	lea    rdi,[rip+0x2581]        # 42d0 <_IO_stdin_used+0x2d0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x18]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x18]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x18]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x28]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2a9f]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x8],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x18]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x8]
    1e06:	lea    rcx,[rip+0x251b]        # 4328 <_IO_stdin_used+0x328>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x38]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x10]
    1e2c:	movsd  QWORD PTR [rbp-0x38],xmm0
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1e31:	add    QWORD PTR [rbp-0x30],0x1
    1e36:	cmp    QWORD PTR [rbp-0x30],0xfff
    1e3e:	jbe    1c77 <end_profiling+0xdc>
      }
    }

  }
}
    1e44:	nop
    1e45:	leave
    1e46:	ret

0000000000001e47 <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1e47:	push   rbp
    1e48:	mov    rbp,rsp
    1e4b:	push   rbx
    1e4c:	sub    rsp,0x78
    1e50:	mov    QWORD PTR [rbp-0x58],rdi
    1e54:	mov    rax,rsi
    1e57:	mov    rsi,rdx
    1e5a:	mov    rax,rax
    1e5d:	mov    edx,0x0
    1e62:	mov    rdx,rsi
    1e65:	mov    QWORD PTR [rbp-0x70],rax
    1e69:	mov    QWORD PTR [rbp-0x68],rdx
    1e6d:	mov    QWORD PTR [rbp-0x60],rcx
    1e71:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1e75:	pxor   xmm0,xmm0
    1e79:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1e7d:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1e81:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1e85:	movq   QWORD PTR [rbp-0x20],xmm0
    1e8a:	mov    rax,QWORD PTR [rbp-0x70]
    1e8e:	mov    rdx,QWORD PTR [rbp-0x68]
    1e92:	mov    QWORD PTR [rbp-0x50],rax
    1e96:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1e9a:	mov    rdx,QWORD PTR [rbp-0x60]
    1e9e:	mov    rax,rdx
    1ea1:	add    rax,rax
    1ea4:	add    rax,rdx
    1ea7:	shl    rax,0x4
    1eab:	mov    rdx,rax
    1eae:	lea    rax,[rip+0x4313]        # 61c8 <g_profiler+0x28>
    1eb5:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1eb9:	mov    QWORD PTR [rbp-0x38],rax
    1ebd:	mov    rax,QWORD PTR [rbp-0x60]
    1ec1:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1ec5:	mov    rax,QWORD PTR [rip+0x42dc]        # 61a8 <g_profiler+0x8>
  Profile_Pass pass =
    1ecc:	mov    QWORD PTR [rbp-0x28],rax
    1ed0:	mov    rax,QWORD PTR [rbp-0x78]
    1ed4:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    1ed8:	mov    rax,QWORD PTR [rbp-0x60]
    1edc:	mov    QWORD PTR [rip+0x42c5],rax        # 61a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    1ee3:	call   1a48 <read_cpu_timer>
    1ee8:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    1eec:	mov    rax,QWORD PTR [rbp-0x58]
    1ef0:	mov    rcx,QWORD PTR [rbp-0x50]
    1ef4:	mov    rbx,QWORD PTR [rbp-0x48]
    1ef8:	mov    QWORD PTR [rax],rcx
    1efb:	mov    QWORD PTR [rax+0x8],rbx
    1eff:	mov    rcx,QWORD PTR [rbp-0x40]
    1f03:	mov    rbx,QWORD PTR [rbp-0x38]
    1f07:	mov    QWORD PTR [rax+0x10],rcx
    1f0b:	mov    QWORD PTR [rax+0x18],rbx
    1f0f:	mov    rcx,QWORD PTR [rbp-0x30]
    1f13:	mov    rbx,QWORD PTR [rbp-0x28]
    1f17:	mov    QWORD PTR [rax+0x20],rcx
    1f1b:	mov    QWORD PTR [rax+0x28],rbx
    1f1f:	mov    rdx,QWORD PTR [rbp-0x20]
    1f23:	mov    QWORD PTR [rax+0x30],rdx
}
    1f27:	mov    rax,QWORD PTR [rbp-0x58]
    1f2b:	mov    rbx,QWORD PTR [rbp-0x8]
    1f2f:	leave
    1f30:	ret

0000000000001f31 <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    1f31:	push   rbp
    1f32:	mov    rbp,rsp
    1f35:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    1f39:	call   1a48 <read_cpu_timer>
    1f3e:	mov    rdx,rax
    1f41:	mov    rax,QWORD PTR [rbp+0x20]
    1f45:	sub    rdx,rax
    1f48:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    1f4c:	mov    rax,QWORD PTR [rbp+0x38]
    1f50:	mov    QWORD PTR [rip+0x4251],rax        # 61a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    1f57:	mov    rdx,QWORD PTR [rbp+0x30]
    1f5b:	mov    rax,rdx
    1f5e:	add    rax,rax
    1f61:	add    rax,rdx
    1f64:	shl    rax,0x4
    1f68:	lea    rdx,[rax+0x10]
    1f6c:	lea    rax,[rip+0x422d]        # 61a0 <g_profiler>
    1f73:	add    rax,rdx
    1f76:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    1f7a:	mov    rax,QWORD PTR [rbp-0x10]
    1f7e:	mov    rdx,QWORD PTR [rax+0x10]
    1f82:	mov    rax,QWORD PTR [rbp-0x18]
    1f86:	add    rdx,rax
    1f89:	mov    rax,QWORD PTR [rbp-0x10]
    1f8d:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    1f91:	mov    rax,QWORD PTR [rbp-0x10]
    1f95:	mov    rax,QWORD PTR [rax+0x20]
    1f99:	lea    rdx,[rax+0x1]
    1f9d:	mov    rax,QWORD PTR [rbp-0x10]
    1fa1:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    1fa5:	mov    rcx,QWORD PTR [rbp-0x10]
    1fa9:	mov    rax,QWORD PTR [rbp+0x10]
    1fad:	mov    rdx,QWORD PTR [rbp+0x18]
    1fb1:	mov    QWORD PTR [rcx],rax
    1fb4:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    1fb8:	mov    rdx,QWORD PTR [rbp+0x28]
    1fbc:	mov    rax,QWORD PTR [rbp-0x18]
    1fc0:	add    rdx,rax
    1fc3:	mov    rax,QWORD PTR [rbp-0x10]
    1fc7:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    1fcb:	mov    rax,QWORD PTR [rbp-0x10]
    1fcf:	mov    rdx,QWORD PTR [rax+0x28]
    1fd3:	mov    rax,QWORD PTR [rbp+0x40]
    1fd7:	add    rdx,rax
    1fda:	mov    rax,QWORD PTR [rbp-0x10]
    1fde:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    1fe2:	mov    rdx,QWORD PTR [rbp+0x38]
    1fe6:	mov    rax,rdx
    1fe9:	add    rax,rax
    1fec:	add    rax,rdx
    1fef:	shl    rax,0x4
    1ff3:	lea    rdx,[rax+0x10]
    1ff7:	lea    rax,[rip+0x41a2]        # 61a0 <g_profiler>
    1ffe:	add    rax,rdx
    2001:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    2005:	mov    rax,QWORD PTR [rbp-0x8]
    2009:	mov    rax,QWORD PTR [rax+0x10]
    200d:	sub    rax,QWORD PTR [rbp-0x18]
    2011:	mov    rdx,rax
    2014:	mov    rax,QWORD PTR [rbp-0x8]
    2018:	mov    QWORD PTR [rax+0x10],rdx
}
    201c:	nop
    201d:	leave
    201e:	ret

000000000000201f <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    201f:	push   rbp
    2020:	mov    rbp,rsp
    2023:	sub    rsp,0x10
    2027:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    202b:	mov    rax,QWORD PTR [rbp-0x8]
    202f:	mov    rdx,QWORD PTR [rax+0x10]
    2033:	mov    rax,QWORD PTR [rbp-0x8]
    2037:	mov    rax,QWORD PTR [rax+0x8]
    203b:	cmp    rdx,rax
    203e:	jb     2065 <parser_at+0x46>
    2040:	lea    rdx,[rip+0x27a1]        # 47e8 <__PRETTY_FUNCTION__.5>
    2047:	lea    rsi,[rip+0x2411]        # 445f <_IO_stdin_used+0x45f>
    204e:	lea    rax,[rip+0x241b]        # 4470 <_IO_stdin_used+0x470>
    2055:	mov    rcx,rdx
    2058:	mov    edx,0x2f
    205d:	mov    rdi,rax
    2060:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    2065:	mov    rax,QWORD PTR [rbp-0x8]
    2069:	mov    rdx,QWORD PTR [rax]
    206c:	mov    rax,QWORD PTR [rbp-0x8]
    2070:	mov    rax,QWORD PTR [rax+0x10]
    2074:	add    rax,rdx
}
    2077:	leave
    2078:	ret

0000000000002079 <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    2079:	push   rbp
    207a:	mov    rbp,rsp
    207d:	sub    rsp,0x10
    2081:	mov    QWORD PTR [rbp-0x8],rdi
    2085:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    2089:	mov    rax,QWORD PTR [rbp-0x8]
    208d:	mov    rdi,rax
    2090:	call   201f <parser_at>
    2095:	mov    rdx,QWORD PTR [rbp-0x10]
    2099:	add    rax,rdx
}
    209c:	leave
    209d:	ret

000000000000209e <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    209e:	push   rbp
    209f:	mov    rbp,rsp
    20a2:	mov    QWORD PTR [rbp-0x8],rdi
    20a6:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    20aa:	mov    rax,QWORD PTR [rbp-0x8]
    20ae:	mov    rdx,QWORD PTR [rax+0x10]
    20b2:	mov    rax,QWORD PTR [rbp-0x10]
    20b6:	add    rdx,rax
    20b9:	mov    rax,QWORD PTR [rbp-0x8]
    20bd:	mov    QWORD PTR [rax+0x10],rdx
}
    20c1:	nop
    20c2:	pop    rbp
    20c3:	ret

00000000000020c4 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    20c4:	push   rbp
    20c5:	mov    rbp,rsp
    20c8:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    20cc:	mov    rax,QWORD PTR [rbp-0x8]
    20d0:	mov    rdx,QWORD PTR [rax+0x10]
    20d4:	mov    rax,QWORD PTR [rbp-0x8]
    20d8:	mov    rax,QWORD PTR [rax+0x8]
    20dc:	cmp    rdx,rax
    20df:	setb   al
}
    20e2:	pop    rbp
    20e3:	ret

00000000000020e4 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    20e4:	push   rbp
    20e5:	mov    rbp,rsp
    20e8:	push   r12
    20ea:	push   rbx
    20eb:	sub    rsp,0x20
    20ef:	mov    QWORD PTR [rbp-0x18],rdi
    20f3:	mov    rax,rsi
    20f6:	mov    rcx,rdx
    20f9:	mov    rax,rax
    20fc:	mov    edx,0x0
    2101:	mov    rdx,rcx
    2104:	mov    QWORD PTR [rbp-0x30],rax
    2108:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    210c:	mov    rax,QWORD PTR [rbp-0x28]
    2110:	mov    r12,rax
    2113:	mov    rbx,QWORD PTR [rbp-0x30]
    2117:	mov    rax,QWORD PTR [rbp-0x18]
    211b:	mov    rdi,rax
    211e:	call   201f <parser_at>
    2123:	mov    rdx,r12
    2126:	mov    rsi,rbx
    2129:	mov    rdi,rax
    212c:	call   10d0 <memcmp@plt>
    2131:	test   eax,eax
    2133:	sete   al
}
    2136:	add    rsp,0x20
    213a:	pop    rbx
    213b:	pop    r12
    213d:	pop    rbp
    213e:	ret

000000000000213f <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    213f:	push   rbp
    2140:	mov    rbp,rsp
    2143:	mov    eax,edi
    2145:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    2148:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    214c:	movzx  eax,BYTE PTR [rbp-0x14]
    2150:	cmp    eax,0x2e
    2153:	jg     215c <is_numeric+0x1d>
    2155:	cmp    eax,0x2d
    2158:	jge    2164 <is_numeric+0x25>
    215a:	jmp    2169 <is_numeric+0x2a>
    215c:	sub    eax,0x30
    215f:	cmp    eax,0x9
    2162:	ja     2169 <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2164:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    2168:	nop
  }


  return result;
    2169:	movzx  eax,BYTE PTR [rbp-0x1]
}
    216d:	pop    rbp
    216e:	ret

000000000000216f <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    216f:	push   rbp
    2170:	mov    rbp,rsp
    2173:	sub    rsp,0x50
    2177:	mov    QWORD PTR [rbp-0x48],rdi
    217b:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    217f:	pxor   xmm0,xmm0
    2183:	movaps XMMWORD PTR [rbp-0x20],xmm0
    2187:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    218c:	jmp    219f <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    218e:	mov    rax,QWORD PTR [rbp-0x50]
    2192:	mov    esi,0x1
    2197:	mov    rdi,rax
    219a:	call   209e <parser_advance>
  while (parser_incomplete(parser)  &&
    219f:	mov    rax,QWORD PTR [rbp-0x50]
    21a3:	mov    rdi,rax
    21a6:	call   20c4 <parser_incomplete>
    21ab:	test   al,al
    21ad:	je     21fb <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    21af:	mov    rax,QWORD PTR [rbp-0x50]
    21b3:	mov    rdi,rax
    21b6:	call   201f <parser_at>
    21bb:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    21be:	cmp    al,0x20
    21c0:	je     218e <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    21c2:	mov    rax,QWORD PTR [rbp-0x50]
    21c6:	mov    rdi,rax
    21c9:	call   201f <parser_at>
    21ce:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    21d1:	cmp    al,0xa
    21d3:	je     218e <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    21d5:	mov    rax,QWORD PTR [rbp-0x50]
    21d9:	mov    rdi,rax
    21dc:	call   201f <parser_at>
    21e1:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    21e4:	cmp    al,0xd
    21e6:	je     218e <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    21e8:	mov    rax,QWORD PTR [rbp-0x50]
    21ec:	mov    rdi,rax
    21ef:	call   201f <parser_at>
    21f4:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    21f7:	cmp    al,0x9
    21f9:	je     218e <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    21fb:	mov    rax,QWORD PTR [rbp-0x50]
    21ff:	mov    rdi,rax
    2202:	call   20c4 <parser_incomplete>
    2207:	test   al,al
    2209:	je     2636 <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    220f:	mov    rax,QWORD PTR [rbp-0x50]
    2213:	mov    rdi,rax
    2216:	call   201f <parser_at>
    221b:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    221f:	mov    rax,QWORD PTR [rbp-0x50]
    2223:	mov    rdi,rax
    2226:	call   201f <parser_at>
    222b:	movzx  eax,BYTE PTR [rax]
    222e:	movzx  eax,al
    2231:	cmp    eax,0x7d
    2234:	je     2321 <get_json_token+0x1b2>
    223a:	cmp    eax,0x7d
    223d:	jg     2647 <get_json_token+0x4d8>
    2243:	cmp    eax,0x7b
    2246:	je     22fc <get_json_token+0x18d>
    224c:	cmp    eax,0x7b
    224f:	jg     2647 <get_json_token+0x4d8>
    2255:	cmp    eax,0x74
    2258:	je     24a4 <get_json_token+0x335>
    225e:	cmp    eax,0x74
    2261:	jg     2647 <get_json_token+0x4d8>
    2267:	cmp    eax,0x6e
    226a:	je     25b4 <get_json_token+0x445>
    2270:	cmp    eax,0x6e
    2273:	jg     2647 <get_json_token+0x4d8>
    2279:	cmp    eax,0x66
    227c:	je     252c <get_json_token+0x3bd>
    2282:	cmp    eax,0x66
    2285:	jg     2647 <get_json_token+0x4d8>
    228b:	cmp    eax,0x5d
    228e:	je     236b <get_json_token+0x1fc>
    2294:	cmp    eax,0x5d
    2297:	jg     2647 <get_json_token+0x4d8>
    229d:	cmp    eax,0x5b
    22a0:	je     2346 <get_json_token+0x1d7>
    22a6:	cmp    eax,0x5b
    22a9:	jg     2647 <get_json_token+0x4d8>
    22af:	cmp    eax,0x3a
    22b2:	je     23b5 <get_json_token+0x246>
    22b8:	cmp    eax,0x3a
    22bb:	jg     2647 <get_json_token+0x4d8>
    22c1:	cmp    eax,0x39
    22c4:	jg     2647 <get_json_token+0x4d8>
    22ca:	cmp    eax,0x30
    22cd:	jge    2453 <get_json_token+0x2e4>
    22d3:	cmp    eax,0x2e
    22d6:	jg     2647 <get_json_token+0x4d8>
    22dc:	cmp    eax,0x2d
    22df:	jge    2453 <get_json_token+0x2e4>
    22e5:	cmp    eax,0x22
    22e8:	je     23da <get_json_token+0x26b>
    22ee:	cmp    eax,0x2c
    22f1:	je     2390 <get_json_token+0x221>
    22f7:	jmp    2647 <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    22fc:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    2303:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    230b:	mov    rax,QWORD PTR [rbp-0x50]
    230f:	mov    esi,0x1
    2314:	mov    rdi,rax
    2317:	call   209e <parser_advance>
      }
      break;
    231c:	jmp    2647 <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2321:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    2328:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2330:	mov    rax,QWORD PTR [rbp-0x50]
    2334:	mov    esi,0x1
    2339:	mov    rdi,rax
    233c:	call   209e <parser_advance>
      }
      break;
    2341:	jmp    2647 <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2346:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    234d:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2355:	mov    rax,QWORD PTR [rbp-0x50]
    2359:	mov    esi,0x1
    235e:	mov    rdi,rax
    2361:	call   209e <parser_advance>
      }
      break;
    2366:	jmp    2647 <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    236b:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    2372:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    237a:	mov    rax,QWORD PTR [rbp-0x50]
    237e:	mov    esi,0x1
    2383:	mov    rdi,rax
    2386:	call   209e <parser_advance>
      }
      break;
    238b:	jmp    2647 <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    2390:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    2397:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    239f:	mov    rax,QWORD PTR [rbp-0x50]
    23a3:	mov    esi,0x1
    23a8:	mov    rdi,rax
    23ab:	call   209e <parser_advance>
      }
      break;
    23b0:	jmp    2647 <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    23b5:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    23bc:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    23c4:	mov    rax,QWORD PTR [rbp-0x50]
    23c8:	mov    esi,0x1
    23cd:	mov    rdi,rax
    23d0:	call   209e <parser_advance>
      }
      break;
    23d5:	jmp    2647 <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    23da:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    23e1:	mov    rax,QWORD PTR [rbp-0x50]
    23e5:	mov    esi,0x1
    23ea:	mov    rdi,rax
    23ed:	call   209e <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    23f2:	mov    rax,QWORD PTR [rbp-0x50]
    23f6:	mov    rdi,rax
    23f9:	call   201f <parser_at>
    23fe:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    2402:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    240a:	jmp    2422 <get_json_token+0x2b3>
        {
          string_count += 1;
    240c:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    2411:	mov    rax,QWORD PTR [rbp-0x50]
    2415:	mov    esi,0x1
    241a:	mov    rdi,rax
    241d:	call   209e <parser_advance>
        while (*parser_at(parser) != '"')
    2422:	mov    rax,QWORD PTR [rbp-0x50]
    2426:	mov    rdi,rax
    2429:	call   201f <parser_at>
    242e:	movzx  eax,BYTE PTR [rax]
    2431:	cmp    al,0x22
    2433:	jne    240c <get_json_token+0x29d>
        }
        token.value.count = string_count;
    2435:	mov    rax,QWORD PTR [rbp-0x40]
    2439:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    243d:	mov    rax,QWORD PTR [rbp-0x50]
    2441:	mov    esi,0x1
    2446:	mov    rdi,rax
    2449:	call   209e <parser_advance>
      }
      break;
    244e:	jmp    2647 <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2453:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    245a:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2462:	jmp    247a <get_json_token+0x30b>
        {
          digit_count += 1;
    2464:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    2469:	mov    rax,QWORD PTR [rbp-0x50]
    246d:	mov    esi,0x1
    2472:	mov    rdi,rax
    2475:	call   209e <parser_advance>
        while (is_numeric(*parser_at(parser)))
    247a:	mov    rax,QWORD PTR [rbp-0x50]
    247e:	mov    rdi,rax
    2481:	call   201f <parser_at>
    2486:	movzx  eax,BYTE PTR [rax]
    2489:	movzx  eax,al
    248c:	mov    edi,eax
    248e:	call   213f <is_numeric>
    2493:	test   al,al
    2495:	jne    2464 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    2497:	mov    rax,QWORD PTR [rbp-0x38]
    249b:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    249f:	jmp    2647 <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    24a4:	lea    rax,[rip+0x2011]        # 44bc <_IO_stdin_used+0x4bc>
    24ab:	mov    QWORD PTR [rbp-0x30],rax
    24af:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    24b7:	mov    rcx,QWORD PTR [rbp-0x30]
    24bb:	mov    rdx,QWORD PTR [rbp-0x28]
    24bf:	mov    rax,QWORD PTR [rbp-0x50]
    24c3:	mov    rsi,rcx
    24c6:	mov    rdi,rax
    24c9:	call   20e4 <parser_token_is_literal>
    24ce:	test   al,al
    24d0:	je     24f4 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    24d2:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    24d9:	mov    rax,QWORD PTR [rbp-0x28]
    24dd:	mov    rdx,rax
    24e0:	mov    rax,QWORD PTR [rbp-0x50]
    24e4:	mov    rsi,rdx
    24e7:	mov    rdi,rax
    24ea:	call   209e <parser_advance>
    24ef:	jmp    2647 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    24f4:	mov    rax,QWORD PTR [rbp-0x50]
    24f8:	mov    rcx,QWORD PTR [rax+0x10]
    24fc:	lea    rdx,[rip+0x1fc5]        # 44c8 <_IO_stdin_used+0x4c8>
    2503:	lea    rax,[rip+0x1f55]        # 445f <_IO_stdin_used+0x45f>
    250a:	mov    r8,rcx
    250d:	mov    rcx,rdx
    2510:	mov    edx,0xdf
    2515:	mov    rsi,rax
    2518:	mov    edi,0x1
    251d:	mov    eax,0x0
    2522:	call   14a1 <log_message>
        }
      }
      break;
    2527:	jmp    2647 <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    252c:	lea    rax,[rip+0x1fc2]        # 44f5 <_IO_stdin_used+0x4f5>
    2533:	mov    QWORD PTR [rbp-0x30],rax
    2537:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    253f:	mov    rcx,QWORD PTR [rbp-0x30]
    2543:	mov    rdx,QWORD PTR [rbp-0x28]
    2547:	mov    rax,QWORD PTR [rbp-0x50]
    254b:	mov    rsi,rcx
    254e:	mov    rdi,rax
    2551:	call   20e4 <parser_token_is_literal>
    2556:	test   al,al
    2558:	je     257c <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    255a:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    2561:	mov    rax,QWORD PTR [rbp-0x28]
    2565:	mov    rdx,rax
    2568:	mov    rax,QWORD PTR [rbp-0x50]
    256c:	mov    rsi,rdx
    256f:	mov    rdi,rax
    2572:	call   209e <parser_advance>
    2577:	jmp    2647 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    257c:	mov    rax,QWORD PTR [rbp-0x50]
    2580:	mov    rcx,QWORD PTR [rax+0x10]
    2584:	lea    rdx,[rip+0x1f3d]        # 44c8 <_IO_stdin_used+0x4c8>
    258b:	lea    rax,[rip+0x1ecd]        # 445f <_IO_stdin_used+0x45f>
    2592:	mov    r8,rcx
    2595:	mov    rcx,rdx
    2598:	mov    edx,0xee
    259d:	mov    rsi,rax
    25a0:	mov    edi,0x1
    25a5:	mov    eax,0x0
    25aa:	call   14a1 <log_message>
        }
      }
      break;
    25af:	jmp    2647 <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    25b4:	lea    rax,[rip+0x1f40]        # 44fb <_IO_stdin_used+0x4fb>
    25bb:	mov    QWORD PTR [rbp-0x30],rax
    25bf:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25c7:	mov    rcx,QWORD PTR [rbp-0x30]
    25cb:	mov    rdx,QWORD PTR [rbp-0x28]
    25cf:	mov    rax,QWORD PTR [rbp-0x50]
    25d3:	mov    rsi,rcx
    25d6:	mov    rdi,rax
    25d9:	call   20e4 <parser_token_is_literal>
    25de:	test   al,al
    25e0:	je     2601 <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    25e2:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    25e9:	mov    rax,QWORD PTR [rbp-0x28]
    25ed:	mov    rdx,rax
    25f0:	mov    rax,QWORD PTR [rbp-0x50]
    25f4:	mov    rsi,rdx
    25f7:	mov    rdi,rax
    25fa:	call   209e <parser_advance>
    25ff:	jmp    2647 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2601:	mov    rax,QWORD PTR [rbp-0x50]
    2605:	mov    rcx,QWORD PTR [rax+0x10]
    2609:	lea    rdx,[rip+0x1eb8]        # 44c8 <_IO_stdin_used+0x4c8>
    2610:	lea    rax,[rip+0x1e48]        # 445f <_IO_stdin_used+0x45f>
    2617:	mov    r8,rcx
    261a:	mov    rcx,rdx
    261d:	mov    edx,0xfd
    2622:	mov    rsi,rax
    2625:	mov    edi,0x1
    262a:	mov    eax,0x0
    262f:	call   14a1 <log_message>
        }
      }
      break;
    2634:	jmp    2647 <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    2636:	mov    rax,QWORD PTR [rbp-0x50]
    263a:	mov    esi,0x1
    263f:	mov    rdi,rax
    2642:	call   209e <parser_advance>
  }

  return token;
    2647:	mov    rcx,QWORD PTR [rbp-0x48]
    264b:	mov    rax,QWORD PTR [rbp-0x20]
    264f:	mov    rdx,QWORD PTR [rbp-0x18]
    2653:	mov    QWORD PTR [rcx],rax
    2656:	mov    QWORD PTR [rcx+0x8],rdx
    265a:	mov    rax,QWORD PTR [rbp-0x10]
    265e:	mov    QWORD PTR [rcx+0x10],rax
}
    2662:	mov    rax,QWORD PTR [rbp-0x48]
    2666:	leave
    2667:	ret

0000000000002668 <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    2668:	push   rbp
    2669:	mov    rbp,rsp
    266c:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    266f:	cmp    DWORD PTR [rbp-0x14],0x7
    2673:	je     268d <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2675:	cmp    DWORD PTR [rbp-0x14],0x9
    2679:	je     268d <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    267b:	cmp    DWORD PTR [rbp-0x14],0xa
    267f:	je     268d <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    2681:	cmp    DWORD PTR [rbp-0x14],0xb
    2685:	je     268d <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    2687:	cmp    DWORD PTR [rbp-0x14],0x8
    268b:	jne    2694 <json_token_type_is_value_type+0x2c>
    268d:	mov    eax,0x1
    2692:	jmp    2699 <json_token_type_is_value_type+0x31>
    2694:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2699:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    269c:	mov    eax,DWORD PTR [rbp-0x4]
}
    269f:	pop    rbp
    26a0:	ret

00000000000026a1 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    26a1:	push   rbp
    26a2:	mov    rbp,rsp
    26a5:	push   rbx
    26a6:	sub    rsp,0x88
    26ad:	mov    QWORD PTR [rbp-0x78],rdi
    26b1:	mov    QWORD PTR [rbp-0x80],rsi
    26b5:	mov    QWORD PTR [rbp-0x90],rdx
    26bc:	mov    QWORD PTR [rbp-0x88],rcx
    26c3:	mov    rax,QWORD PTR fs:0x28
    26cc:	mov    QWORD PTR [rbp-0x18],rax
    26d0:	xor    eax,eax
  profile_begin_func();
    26d2:	lea    r8,[rip+0x2127]        # 4800 <__func__.4>
    26d9:	mov    r9d,0x11
    26df:	lea    rax,[rbp-0x50]
    26e3:	mov    rsi,r8
    26e6:	mov    rdx,r9
    26e9:	mov    r8d,0x0
    26ef:	mov    ecx,0x1
    26f4:	mov    rdi,rax
    26f7:	call   1e47 <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    26fc:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2704:	mov    eax,DWORD PTR [rbp+0x10]
    2707:	cmp    eax,0x1
    270a:	jne    2736 <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    270c:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    2713:	mov    edx,DWORD PTR [rbp-0x64]
    2716:	mov    rsi,QWORD PTR [rbp-0x80]
    271a:	mov    rax,QWORD PTR [rbp-0x78]
    271e:	mov    ecx,edx
    2720:	mov    edx,0x2
    2725:	mov    rdi,rax
    2728:	call   2888 <parse_json_children>
    272d:	mov    QWORD PTR [rbp-0x60],rax
    2731:	jmp    27c0 <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2736:	mov    eax,DWORD PTR [rbp+0x10]
    2739:	cmp    eax,0x3
    273c:	jne    2765 <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    273e:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2745:	mov    edx,DWORD PTR [rbp-0x68]
    2748:	mov    rsi,QWORD PTR [rbp-0x80]
    274c:	mov    rax,QWORD PTR [rbp-0x78]
    2750:	mov    ecx,edx
    2752:	mov    edx,0x4
    2757:	mov    rdi,rax
    275a:	call   2888 <parse_json_children>
    275f:	mov    QWORD PTR [rbp-0x60],rax
    2763:	jmp    27c0 <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    2765:	mov    eax,DWORD PTR [rbp+0x10]
    2768:	mov    edi,eax
    276a:	call   2668 <json_token_type_is_value_type>
    276f:	test   eax,eax
    2771:	jne    27c0 <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2773:	mov    eax,DWORD PTR [rbp+0x10]
    2776:	mov    eax,eax
    2778:	lea    rdx,[rax*8+0x0]
    2780:	lea    rax,[rip+0x3959]        # 60e0 <JSON_Token_Type_strings>
    2787:	mov    rcx,QWORD PTR [rdx+rax*1]
    278b:	lea    rdx,[rip+0x1d6e]        # 4500 <_IO_stdin_used+0x500>
    2792:	lea    rax,[rip+0x1cc6]        # 445f <_IO_stdin_used+0x45f>
    2799:	push   QWORD PTR [rbp+0x20]
    279c:	push   QWORD PTR [rbp+0x18]
    279f:	mov    r8,rcx
    27a2:	mov    rcx,rdx
    27a5:	mov    edx,0x134
    27aa:	mov    rsi,rax
    27ad:	mov    edi,0x1
    27b2:	mov    eax,0x0
    27b7:	call   14a1 <log_message>
    27bc:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    27c0:	mov    rax,QWORD PTR [rbp-0x78]
    27c4:	mov    edx,0x8
    27c9:	mov    esi,0x30
    27ce:	mov    rdi,rax
    27d1:	call   17d3 <arena_alloc>
    27d6:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    27da:	mov    rcx,QWORD PTR [rbp-0x58]
    27de:	mov    rax,QWORD PTR [rbp-0x90]
    27e5:	mov    rdx,QWORD PTR [rbp-0x88]
    27ec:	mov    QWORD PTR [rcx],rax
    27ef:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    27f3:	mov    rax,QWORD PTR [rbp-0x58]
    27f7:	mov    rdx,QWORD PTR [rbp-0x60]
    27fb:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    27ff:	mov    rax,QWORD PTR [rbp-0x58]
    2803:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    280b:	mov    rcx,QWORD PTR [rbp-0x58]
    280f:	mov    rax,QWORD PTR [rbp+0x18]
    2813:	mov    rdx,QWORD PTR [rbp+0x20]
    2817:	mov    QWORD PTR [rcx+0x10],rax
    281b:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    281f:	sub    rsp,0x8
    2823:	sub    rsp,0x38
    2827:	mov    rax,rsp
    282a:	mov    rcx,QWORD PTR [rbp-0x50]
    282e:	mov    rbx,QWORD PTR [rbp-0x48]
    2832:	mov    QWORD PTR [rax],rcx
    2835:	mov    QWORD PTR [rax+0x8],rbx
    2839:	mov    rcx,QWORD PTR [rbp-0x40]
    283d:	mov    rbx,QWORD PTR [rbp-0x38]
    2841:	mov    QWORD PTR [rax+0x10],rcx
    2845:	mov    QWORD PTR [rax+0x18],rbx
    2849:	mov    rcx,QWORD PTR [rbp-0x30]
    284d:	mov    rbx,QWORD PTR [rbp-0x28]
    2851:	mov    QWORD PTR [rax+0x20],rcx
    2855:	mov    QWORD PTR [rax+0x28],rbx
    2859:	mov    rdx,QWORD PTR [rbp-0x20]
    285d:	mov    QWORD PTR [rax+0x30],rdx
    2861:	call   1f31 <__profile_end_pass>
    2866:	add    rsp,0x40

  return result;
    286a:	mov    rax,QWORD PTR [rbp-0x58]
}
    286e:	mov    rdx,QWORD PTR [rbp-0x18]
    2872:	sub    rdx,QWORD PTR fs:0x28
    287b:	je     2882 <parse_json_object+0x1e1>
    287d:	call   1060 <__stack_chk_fail@plt>
    2882:	mov    rbx,QWORD PTR [rbp-0x8]
    2886:	leave
    2887:	ret

0000000000002888 <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    2888:	push   rbp
    2889:	mov    rbp,rsp
    288c:	push   rbx
    288d:	sub    rsp,0x108
    2894:	mov    QWORD PTR [rbp-0xd8],rdi
    289b:	mov    QWORD PTR [rbp-0xe0],rsi
    28a2:	mov    DWORD PTR [rbp-0xe4],edx
    28a8:	mov    DWORD PTR [rbp-0xe8],ecx
    28ae:	mov    rax,QWORD PTR fs:0x28
    28b7:	mov    QWORD PTR [rbp-0x18],rax
    28bb:	xor    eax,eax
  profile_begin_func();
    28bd:	lea    r8,[rip+0x1f5c]        # 4820 <__func__.3>
    28c4:	mov    r9d,0x13
    28ca:	lea    rax,[rbp-0x50]
    28ce:	mov    rsi,r8
    28d1:	mov    rdx,r9
    28d4:	mov    r8d,0x0
    28da:	mov    ecx,0x2
    28df:	mov    rdi,rax
    28e2:	call   1e47 <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    28e7:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    28f2:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    28fd:	jmp    2bd6 <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2902:	pxor   xmm0,xmm0
    2906:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    290d:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2915:	pxor   xmm0,xmm0
    2919:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2920:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2925:	cmp    DWORD PTR [rbp-0xe8],0x0
    292c:	je     2a39 <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2932:	lea    rax,[rbp-0xb0]
    2939:	mov    rdx,QWORD PTR [rbp-0xe0]
    2940:	mov    rsi,rdx
    2943:	mov    rdi,rax
    2946:	call   216f <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    294b:	mov    eax,DWORD PTR [rbp-0xb0]
    2951:	cmp    eax,0x7
    2954:	jne    29d5 <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2956:	lea    rax,[rbp-0x70]
    295a:	mov    rdx,QWORD PTR [rbp-0xe0]
    2961:	mov    rsi,rdx
    2964:	mov    rdi,rax
    2967:	call   216f <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    296c:	mov    eax,DWORD PTR [rbp-0x70]
    296f:	cmp    eax,0x6
    2972:	jne    2992 <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2974:	lea    rax,[rbp-0x90]
    297b:	mov    rdx,QWORD PTR [rbp-0xe0]
    2982:	mov    rsi,rdx
    2985:	mov    rdi,rax
    2988:	call   216f <get_json_token>
    298d:	jmp    2a79 <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2992:	mov    rcx,QWORD PTR [rbp-0xa8]
    2999:	mov    rax,QWORD PTR [rbp-0xa0]
    29a0:	mov    esi,eax
    29a2:	lea    rdx,[rip+0x1ba7]        # 4550 <_IO_stdin_used+0x550>
    29a9:	lea    rax,[rip+0x1aaf]        # 445f <_IO_stdin_used+0x45f>
    29b0:	mov    r9,rcx
    29b3:	mov    r8d,esi
    29b6:	mov    rcx,rdx
    29b9:	mov    edx,0x15f
    29be:	mov    rsi,rax
    29c1:	mov    edi,0x1
    29c6:	mov    eax,0x0
    29cb:	call   14a1 <log_message>
    29d0:	jmp    2a79 <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    29d5:	mov    rcx,QWORD PTR [rbp-0xa8]
    29dc:	mov    rax,QWORD PTR [rbp-0xa0]
    29e3:	mov    edi,eax
    29e5:	mov    eax,DWORD PTR [rbp-0xb0]
    29eb:	mov    eax,eax
    29ed:	lea    rdx,[rax*8+0x0]
    29f5:	lea    rax,[rip+0x36e4]        # 60e0 <JSON_Token_Type_strings>
    29fc:	mov    rsi,QWORD PTR [rdx+rax*1]
    2a00:	lea    rdx,[rip+0x1b69]        # 4570 <_IO_stdin_used+0x570>
    2a07:	lea    rax,[rip+0x1a51]        # 445f <_IO_stdin_used+0x45f>
    2a0e:	sub    rsp,0x8
    2a12:	push   rcx
    2a13:	mov    r9d,edi
    2a16:	mov    r8,rsi
    2a19:	mov    rcx,rdx
    2a1c:	mov    edx,0x164
    2a21:	mov    rsi,rax
    2a24:	mov    edi,0x1
    2a29:	mov    eax,0x0
    2a2e:	call   14a1 <log_message>
    2a33:	add    rsp,0x10
    2a37:	jmp    2a79 <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2a39:	lea    rax,[rbp-0x110]
    2a40:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a47:	mov    rsi,rdx
    2a4a:	mov    rdi,rax
    2a4d:	call   216f <get_json_token>
    2a52:	mov    rax,QWORD PTR [rbp-0x110]
    2a59:	mov    rdx,QWORD PTR [rbp-0x108]
    2a60:	mov    QWORD PTR [rbp-0x90],rax
    2a67:	mov    QWORD PTR [rbp-0x88],rdx
    2a6e:	mov    rax,QWORD PTR [rbp-0x100]
    2a75:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2a79:	mov    eax,DWORD PTR [rbp-0x90]
    2a7f:	cmp    DWORD PTR [rbp-0xe4],eax
    2a85:	je     2bef <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2a8b:	mov    rax,QWORD PTR [rbp-0xa8]
    2a92:	mov    rdx,QWORD PTR [rbp-0xa0]
    2a99:	mov    r8,QWORD PTR [rbp-0xe0]
    2aa0:	mov    rdi,QWORD PTR [rbp-0xd8]
    2aa7:	sub    rsp,0x8
    2aab:	sub    rsp,0x18
    2aaf:	mov    rsi,rsp
    2ab2:	mov    rcx,QWORD PTR [rbp-0x90]
    2ab9:	mov    rbx,QWORD PTR [rbp-0x88]
    2ac0:	mov    QWORD PTR [rsi],rcx
    2ac3:	mov    QWORD PTR [rsi+0x8],rbx
    2ac7:	mov    rcx,QWORD PTR [rbp-0x80]
    2acb:	mov    QWORD PTR [rsi+0x10],rcx
    2acf:	mov    rcx,rdx
    2ad2:	mov    rdx,rax
    2ad5:	mov    rsi,r8
    2ad8:	call   26a1 <parse_json_object>
    2add:	add    rsp,0x20
    2ae1:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2ae8:	cmp    QWORD PTR [rbp-0xb8],0x0
    2af0:	je     2b3a <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2af2:	cmp    QWORD PTR [rbp-0xc8],0x0
    2afa:	jne    2b1a <parse_json_children+0x292>
      {
        first_child        = object;
    2afc:	mov    rax,QWORD PTR [rbp-0xb8]
    2b03:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2b0a:	mov    rax,QWORD PTR [rbp-0xb8]
    2b11:	mov    QWORD PTR [rbp-0xc0],rax
    2b18:	jmp    2b3a <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2b1a:	mov    rax,QWORD PTR [rbp-0xc0]
    2b21:	mov    rdx,QWORD PTR [rbp-0xb8]
    2b28:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2b2c:	mov    rax,QWORD PTR [rbp-0xb8]
    2b33:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2b3a:	lea    rax,[rbp-0x70]
    2b3e:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b45:	mov    rsi,rdx
    2b48:	mov    rdi,rax
    2b4b:	call   216f <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2b50:	mov    eax,DWORD PTR [rbp-0x70]
    2b53:	cmp    DWORD PTR [rbp-0xe4],eax
    2b59:	je     2bf2 <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2b5f:	mov    eax,DWORD PTR [rbp-0x70]
    2b62:	cmp    eax,0x5
    2b65:	je     2bd6 <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2b67:	mov    r8,QWORD PTR [rbp-0x68]
    2b6b:	mov    rax,QWORD PTR [rbp-0x60]
    2b6f:	mov    r9d,eax
    2b72:	mov    eax,DWORD PTR [rbp-0x70]
    2b75:	mov    eax,eax
    2b77:	lea    rdx,[rax*8+0x0]
    2b7f:	lea    rax,[rip+0x355a]        # 60e0 <JSON_Token_Type_strings>
    2b86:	mov    r10,QWORD PTR [rdx+rax*1]
    2b8a:	lea    rdi,[rip+0x1a07]        # 4598 <_IO_stdin_used+0x598>
    2b91:	lea    rsi,[rip+0x18c7]        # 445f <_IO_stdin_used+0x45f>
    2b98:	sub    rsp,0x18
    2b9c:	mov    rcx,rsp
    2b9f:	mov    rax,QWORD PTR [rbp-0x70]
    2ba3:	mov    rdx,QWORD PTR [rbp-0x68]
    2ba7:	mov    QWORD PTR [rcx],rax
    2baa:	mov    QWORD PTR [rcx+0x8],rdx
    2bae:	mov    rax,QWORD PTR [rbp-0x60]
    2bb2:	mov    QWORD PTR [rcx+0x10],rax
    2bb6:	push   r8
    2bb8:	mov    r8,r10
    2bbb:	mov    rcx,rdi
    2bbe:	mov    edx,0x18b
    2bc3:	mov    edi,0x1
    2bc8:	mov    eax,0x0
    2bcd:	call   14a1 <log_message>
    2bd2:	add    rsp,0x20
  while (parser_incomplete(parser))
    2bd6:	mov    rax,QWORD PTR [rbp-0xe0]
    2bdd:	mov    rdi,rax
    2be0:	call   20c4 <parser_incomplete>
    2be5:	test   al,al
    2be7:	jne    2902 <parse_json_children+0x7a>
    2bed:	jmp    2bf3 <parse_json_children+0x36b>
      break;
    2bef:	nop
    2bf0:	jmp    2bf3 <parse_json_children+0x36b>
      break;
    2bf2:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2bf3:	sub    rsp,0x8
    2bf7:	sub    rsp,0x38
    2bfb:	mov    rax,rsp
    2bfe:	mov    rcx,QWORD PTR [rbp-0x50]
    2c02:	mov    rbx,QWORD PTR [rbp-0x48]
    2c06:	mov    QWORD PTR [rax],rcx
    2c09:	mov    QWORD PTR [rax+0x8],rbx
    2c0d:	mov    rcx,QWORD PTR [rbp-0x40]
    2c11:	mov    rbx,QWORD PTR [rbp-0x38]
    2c15:	mov    QWORD PTR [rax+0x10],rcx
    2c19:	mov    QWORD PTR [rax+0x18],rbx
    2c1d:	mov    rcx,QWORD PTR [rbp-0x30]
    2c21:	mov    rbx,QWORD PTR [rbp-0x28]
    2c25:	mov    QWORD PTR [rax+0x20],rcx
    2c29:	mov    QWORD PTR [rax+0x28],rbx
    2c2d:	mov    rdx,QWORD PTR [rbp-0x20]
    2c31:	mov    QWORD PTR [rax+0x30],rdx
    2c35:	call   1f31 <__profile_end_pass>
    2c3a:	add    rsp,0x40

  return first_child;
    2c3e:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2c45:	mov    rdx,QWORD PTR [rbp-0x18]
    2c49:	sub    rdx,QWORD PTR fs:0x28
    2c52:	je     2c59 <parse_json_children+0x3d1>
    2c54:	call   1060 <__stack_chk_fail@plt>
    2c59:	mov    rbx,QWORD PTR [rbp-0x8]
    2c5d:	leave
    2c5e:	ret

0000000000002c5f <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2c5f:	push   rbp
    2c60:	mov    rbp,rsp
    2c63:	push   rbx
    2c64:	sub    rsp,0xb8
    2c6b:	mov    QWORD PTR [rbp-0xa8],rdi
    2c72:	mov    rax,rsi
    2c75:	mov    rsi,rdx
    2c78:	mov    rax,rax
    2c7b:	mov    edx,0x0
    2c80:	mov    rdx,rsi
    2c83:	mov    QWORD PTR [rbp-0xc0],rax
    2c8a:	mov    QWORD PTR [rbp-0xb8],rdx
    2c91:	mov    rax,QWORD PTR fs:0x28
    2c9a:	mov    QWORD PTR [rbp-0x18],rax
    2c9e:	xor    eax,eax
  profile_begin_func();
    2ca0:	lea    rcx,[rip+0x1b91]        # 4838 <__func__.2>
    2ca7:	mov    ebx,0xa
    2cac:	lea    rax,[rbp-0x50]
    2cb0:	mov    rsi,rcx
    2cb3:	mov    rdx,rbx
    2cb6:	mov    r8d,0x0
    2cbc:	mov    ecx,0x3
    2cc1:	mov    rdi,rax
    2cc4:	call   1e47 <__profile_begin_pass>

  JSON_Parser parser =
    2cc9:	mov    rax,QWORD PTR [rbp-0xc0]
    2cd0:	mov    rdx,QWORD PTR [rbp-0xb8]
    2cd7:	mov    QWORD PTR [rbp-0x90],rax
    2cde:	mov    QWORD PTR [rbp-0x88],rdx
    2ce5:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2ced:	lea    rax,[rbp-0x70]
    2cf1:	lea    rdx,[rbp-0x90]
    2cf8:	mov    rsi,rdx
    2cfb:	mov    rdi,rax
    2cfe:	call   216f <get_json_token>
    2d03:	mov    ecx,0x0
    2d08:	mov    ebx,0x0
    2d0d:	lea    r8,[rbp-0x90]
    2d14:	mov    rdi,QWORD PTR [rbp-0xa8]
    2d1b:	sub    rsp,0x8
    2d1f:	sub    rsp,0x18
    2d23:	mov    rsi,rsp
    2d26:	mov    rax,QWORD PTR [rbp-0x70]
    2d2a:	mov    rdx,QWORD PTR [rbp-0x68]
    2d2e:	mov    QWORD PTR [rsi],rax
    2d31:	mov    QWORD PTR [rsi+0x8],rdx
    2d35:	mov    rax,QWORD PTR [rbp-0x60]
    2d39:	mov    QWORD PTR [rsi+0x10],rax
    2d3d:	mov    rdx,rcx
    2d40:	mov    rcx,rbx
    2d43:	mov    rsi,r8
    2d46:	call   26a1 <parse_json_object>
    2d4b:	add    rsp,0x20
    2d4f:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2d56:	sub    rsp,0x8
    2d5a:	sub    rsp,0x38
    2d5e:	mov    rax,rsp
    2d61:	mov    rcx,QWORD PTR [rbp-0x50]
    2d65:	mov    rbx,QWORD PTR [rbp-0x48]
    2d69:	mov    QWORD PTR [rax],rcx
    2d6c:	mov    QWORD PTR [rax+0x8],rbx
    2d70:	mov    rcx,QWORD PTR [rbp-0x40]
    2d74:	mov    rbx,QWORD PTR [rbp-0x38]
    2d78:	mov    QWORD PTR [rax+0x10],rcx
    2d7c:	mov    QWORD PTR [rax+0x18],rbx
    2d80:	mov    rcx,QWORD PTR [rbp-0x30]
    2d84:	mov    rbx,QWORD PTR [rbp-0x28]
    2d88:	mov    QWORD PTR [rax+0x20],rcx
    2d8c:	mov    QWORD PTR [rax+0x28],rbx
    2d90:	mov    rdx,QWORD PTR [rbp-0x20]
    2d94:	mov    QWORD PTR [rax+0x30],rdx
    2d98:	call   1f31 <__profile_end_pass>
    2d9d:	add    rsp,0x40

  return outer;
    2da1:	mov    rax,QWORD PTR [rbp-0x98]
}
    2da8:	mov    rdx,QWORD PTR [rbp-0x18]
    2dac:	sub    rdx,QWORD PTR fs:0x28
    2db5:	je     2dbc <parse_json+0x15d>
    2db7:	call   1060 <__stack_chk_fail@plt>
    2dbc:	mov    rbx,QWORD PTR [rbp-0x8]
    2dc0:	leave
    2dc1:	ret

0000000000002dc2 <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2dc2:	push   rbp
    2dc3:	mov    rbp,rsp
    2dc6:	push   rbx
    2dc7:	sub    rsp,0x78
    2dcb:	mov    QWORD PTR [rbp-0x68],rdi
    2dcf:	mov    rax,rsi
    2dd2:	mov    rsi,rdx
    2dd5:	mov    rax,rax
    2dd8:	mov    edx,0x0
    2ddd:	mov    rdx,rsi
    2de0:	mov    QWORD PTR [rbp-0x80],rax
    2de4:	mov    QWORD PTR [rbp-0x78],rdx
    2de8:	mov    rax,QWORD PTR fs:0x28
    2df1:	mov    QWORD PTR [rbp-0x18],rax
    2df5:	xor    eax,eax
  profile_begin_func();
    2df7:	lea    rcx,[rip+0x1a52]        # 4850 <__func__.1>
    2dfe:	mov    ebx,0x12
    2e03:	lea    rax,[rbp-0x50]
    2e07:	mov    rsi,rcx
    2e0a:	mov    rdx,rbx
    2e0d:	mov    r8d,0x0
    2e13:	mov    ecx,0x4
    2e18:	mov    rdi,rax
    2e1b:	call   1e47 <__profile_begin_pass>

  JSON_Object *result = NULL;
    2e20:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2e28:	cmp    QWORD PTR [rbp-0x68],0x0
    2e2d:	je     2e7c <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2e2f:	mov    rax,QWORD PTR [rbp-0x68]
    2e33:	mov    rax,QWORD PTR [rax+0x20]
    2e37:	mov    QWORD PTR [rbp-0x58],rax
    2e3b:	jmp    2e75 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2e3d:	mov    rax,QWORD PTR [rbp-0x58]
    2e41:	mov    rdx,QWORD PTR [rax+0x8]
    2e45:	mov    rax,QWORD PTR [rax]
    2e48:	mov    rdi,QWORD PTR [rbp-0x80]
    2e4c:	mov    rsi,QWORD PTR [rbp-0x78]
    2e50:	mov    rcx,rdx
    2e53:	mov    rdx,rax
    2e56:	call   143f <strings_equal>
    2e5b:	test   al,al
    2e5d:	je     2e69 <lookup_json_object+0xa7>
      {
        result = cursor;
    2e5f:	mov    rax,QWORD PTR [rbp-0x58]
    2e63:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2e67:	jmp    2e7c <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2e69:	mov    rax,QWORD PTR [rbp-0x58]
    2e6d:	mov    rax,QWORD PTR [rax+0x28]
    2e71:	mov    QWORD PTR [rbp-0x58],rax
    2e75:	cmp    QWORD PTR [rbp-0x58],0x0
    2e7a:	jne    2e3d <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2e7c:	sub    rsp,0x8
    2e80:	sub    rsp,0x38
    2e84:	mov    rax,rsp
    2e87:	mov    rcx,QWORD PTR [rbp-0x50]
    2e8b:	mov    rbx,QWORD PTR [rbp-0x48]
    2e8f:	mov    QWORD PTR [rax],rcx
    2e92:	mov    QWORD PTR [rax+0x8],rbx
    2e96:	mov    rcx,QWORD PTR [rbp-0x40]
    2e9a:	mov    rbx,QWORD PTR [rbp-0x38]
    2e9e:	mov    QWORD PTR [rax+0x10],rcx
    2ea2:	mov    QWORD PTR [rax+0x18],rbx
    2ea6:	mov    rcx,QWORD PTR [rbp-0x30]
    2eaa:	mov    rbx,QWORD PTR [rbp-0x28]
    2eae:	mov    QWORD PTR [rax+0x20],rcx
    2eb2:	mov    QWORD PTR [rax+0x28],rbx
    2eb6:	mov    rdx,QWORD PTR [rbp-0x20]
    2eba:	mov    QWORD PTR [rax+0x30],rdx
    2ebe:	call   1f31 <__profile_end_pass>
    2ec3:	add    rsp,0x40

  return result;
    2ec7:	mov    rax,QWORD PTR [rbp-0x60]
}
    2ecb:	mov    rdx,QWORD PTR [rbp-0x18]
    2ecf:	sub    rdx,QWORD PTR fs:0x28
    2ed8:	je     2edf <lookup_json_object+0x11d>
    2eda:	call   1060 <__stack_chk_fail@plt>
    2edf:	mov    rbx,QWORD PTR [rbp-0x8]
    2ee3:	leave
    2ee4:	ret

0000000000002ee5 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    2ee5:	push   rbp
    2ee6:	mov    rbp,rsp
    2ee9:	sub    rsp,0x50
    2eed:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    2ef1:	cmp    QWORD PTR [rbp-0x48],0x0
    2ef6:	jne    2f1d <json_object_to_f64+0x38>
    2ef8:	lea    rdx,[rip+0x1971]        # 4870 <__PRETTY_FUNCTION__.0>
    2eff:	lea    rsi,[rip+0x1559]        # 445f <_IO_stdin_used+0x45f>
    2f06:	lea    rax,[rip+0x16cb]        # 45d8 <_IO_stdin_used+0x5d8>
    2f0d:	mov    rcx,rdx
    2f10:	mov    edx,0x1c2
    2f15:	mov    rdi,rax
    2f18:	call   1090 <__assert_fail@plt>

  String val = object->value;
    2f1d:	mov    rax,QWORD PTR [rbp-0x48]
    2f21:	mov    rdx,QWORD PTR [rax+0x18]
    2f25:	mov    rax,QWORD PTR [rax+0x10]
    2f29:	mov    QWORD PTR [rbp-0x10],rax
    2f2d:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    2f31:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    2f39:	movsd  xmm0,QWORD PTR [rip+0x1957]        # 4898 <__PRETTY_FUNCTION__.0+0x28>
    2f41:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    2f46:	mov    rax,QWORD PTR [rbp-0x8]
    2f4a:	cmp    QWORD PTR [rbp-0x30],rax
    2f4e:	jae    2f74 <json_object_to_f64+0x8f>
    2f50:	mov    rdx,QWORD PTR [rbp-0x10]
    2f54:	mov    rax,QWORD PTR [rbp-0x30]
    2f58:	add    rax,rdx
    2f5b:	movzx  eax,BYTE PTR [rax]
    2f5e:	cmp    al,0x2d
    2f60:	jne    2f74 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    2f62:	movsd  xmm0,QWORD PTR [rip+0x1936]        # 48a0 <__PRETTY_FUNCTION__.0+0x30>
    2f6a:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    2f6f:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    2f74:	pxor   xmm0,xmm0
    2f78:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    2f7d:	jmp    2fc4 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    2f7f:	mov    rdx,QWORD PTR [rbp-0x10]
    2f83:	mov    rax,QWORD PTR [rbp-0x30]
    2f87:	add    rax,rdx
    2f8a:	movzx  eax,BYTE PTR [rax]
    2f8d:	sub    eax,0x30
    2f90:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    2f93:	cmp    BYTE PTR [rbp-0x32],0x9
    2f97:	ja     2fd0 <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    2f99:	movsd  xmm1,QWORD PTR [rbp-0x20]
    2f9e:	movsd  xmm0,QWORD PTR [rip+0x1902]        # 48a8 <__PRETTY_FUNCTION__.0+0x38>
    2fa6:	mulsd  xmm1,xmm0
    2faa:	movzx  eax,BYTE PTR [rbp-0x32]
    2fae:	pxor   xmm0,xmm0
    2fb2:	cvtsi2sd xmm0,eax
    2fb6:	addsd  xmm0,xmm1
    2fba:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    2fbf:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    2fc4:	mov    rax,QWORD PTR [rbp-0x8]
    2fc8:	cmp    QWORD PTR [rbp-0x30],rax
    2fcc:	jb     2f7f <json_object_to_f64+0x9a>
    2fce:	jmp    2fd1 <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    2fd0:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    2fd1:	mov    rax,QWORD PTR [rbp-0x8]
    2fd5:	cmp    QWORD PTR [rbp-0x30],rax
    2fd9:	jae    3066 <json_object_to_f64+0x181>
    2fdf:	mov    rdx,QWORD PTR [rbp-0x10]
    2fe3:	mov    rax,QWORD PTR [rbp-0x30]
    2fe7:	add    rax,rdx
    2fea:	movzx  eax,BYTE PTR [rax]
    2fed:	cmp    al,0x2e
    2fef:	jne    3066 <json_object_to_f64+0x181>
  {
    at += 1;
    2ff1:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    2ff6:	movsd  xmm0,QWORD PTR [rip+0x18b2]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    2ffe:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    3003:	jmp    3059 <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3005:	mov    rdx,QWORD PTR [rbp-0x10]
    3009:	mov    rax,QWORD PTR [rbp-0x30]
    300d:	add    rax,rdx
    3010:	movzx  eax,BYTE PTR [rax]
    3013:	sub    eax,0x30
    3016:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    3019:	cmp    BYTE PTR [rbp-0x31],0x9
    301d:	ja     3065 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    301f:	movzx  eax,BYTE PTR [rbp-0x31]
    3023:	pxor   xmm0,xmm0
    3027:	cvtsi2sd xmm0,eax
    302b:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    3030:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3035:	addsd  xmm0,xmm1
    3039:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    303e:	movsd  xmm1,QWORD PTR [rbp-0x18]
    3043:	movsd  xmm0,QWORD PTR [rip+0x1865]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    304b:	mulsd  xmm0,xmm1
    304f:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3054:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    3059:	mov    rax,QWORD PTR [rbp-0x8]
    305d:	cmp    QWORD PTR [rbp-0x30],rax
    3061:	jb     3005 <json_object_to_f64+0x120>
    3063:	jmp    3066 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    3065:	nop
      }
    }
  }

  return sign * result;
    3066:	movsd  xmm0,QWORD PTR [rbp-0x28]
    306b:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    3070:	leave
    3071:	ret

0000000000003072 <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    3072:	push   rbp
    3073:	mov    rbp,rsp
    3076:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    307b:	movsd  xmm0,QWORD PTR [rbp-0x8]
    3080:	movsd  xmm1,QWORD PTR [rip+0x1830]        # 48b8 <__PRETTY_FUNCTION__.0+0x48>
    3088:	divsd  xmm0,xmm1
}
    308c:	pop    rbp
    308d:	ret

000000000000308e <square>:

static
f64 square(f64 x)
{
    308e:	push   rbp
    308f:	mov    rbp,rsp
    3092:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    3097:	movsd  xmm0,QWORD PTR [rbp-0x8]
    309c:	mulsd  xmm0,xmm0
}
    30a0:	pop    rbp
    30a1:	ret

00000000000030a2 <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    30a2:	push   rbp
    30a3:	mov    rbp,rsp
    30a6:	sub    rsp,0x90
    30ad:	movsd  QWORD PTR [rbp-0x58],xmm0
    30b2:	movsd  QWORD PTR [rbp-0x60],xmm1
    30b7:	movsd  QWORD PTR [rbp-0x68],xmm2
    30bc:	movsd  QWORD PTR [rbp-0x70],xmm3
    30c1:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    30c6:	movsd  xmm0,QWORD PTR [rbp-0x60]
    30cb:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    30d0:	movsd  xmm0,QWORD PTR [rbp-0x70]
    30d5:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    30da:	movsd  xmm0,QWORD PTR [rbp-0x58]
    30df:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    30e4:	movsd  xmm0,QWORD PTR [rbp-0x68]
    30e9:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    30ee:	movsd  xmm0,QWORD PTR [rbp-0x40]
    30f3:	subsd  xmm0,QWORD PTR [rbp-0x48]
    30f8:	movq   rax,xmm0
    30fd:	movq   xmm0,rax
    3102:	call   3072 <to_radians>
    3107:	movq   rax,xmm0
    310c:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    3110:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3115:	subsd  xmm0,QWORD PTR [rbp-0x38]
    311a:	movq   rax,xmm0
    311f:	movq   xmm0,rax
    3124:	call   3072 <to_radians>
    3129:	movq   rax,xmm0
    312e:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    3132:	mov    rax,QWORD PTR [rbp-0x48]
    3136:	movq   xmm0,rax
    313b:	call   3072 <to_radians>
    3140:	movq   rax,xmm0
    3145:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    3149:	mov    rax,QWORD PTR [rbp-0x40]
    314d:	movq   xmm0,rax
    3152:	call   3072 <to_radians>
    3157:	movq   rax,xmm0
    315c:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    3160:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3165:	movsd  xmm1,QWORD PTR [rip+0x1753]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    316d:	divsd  xmm0,xmm1
    3171:	movq   rax,xmm0
    3176:	movq   xmm0,rax
    317b:	call   1130 <sin@plt>
    3180:	movq   rax,xmm0
    3185:	movq   xmm0,rax
    318a:	call   308e <square>
    318f:	movsd  QWORD PTR [rbp-0x80],xmm0
    3194:	mov    rax,QWORD PTR [rbp-0x48]
    3198:	movq   xmm0,rax
    319d:	call   10b0 <cos@plt>
    31a2:	movsd  QWORD PTR [rbp-0x88],xmm0
    31aa:	mov    rax,QWORD PTR [rbp-0x40]
    31ae:	movq   xmm0,rax
    31b3:	call   10b0 <cos@plt>
    31b8:	movapd xmm5,xmm0
    31bc:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    31c4:	movsd  QWORD PTR [rbp-0x88],xmm5
    31cc:	movsd  xmm0,QWORD PTR [rbp-0x20]
    31d1:	movsd  xmm1,QWORD PTR [rip+0x16e7]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    31d9:	movapd xmm6,xmm0
    31dd:	divsd  xmm6,xmm1
    31e1:	movq   rax,xmm6
    31e6:	movq   xmm0,rax
    31eb:	call   1130 <sin@plt>
    31f0:	movq   rax,xmm0
    31f5:	movq   xmm0,rax
    31fa:	call   308e <square>
    31ff:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    3207:	addsd  xmm0,QWORD PTR [rbp-0x80]
    320c:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    3211:	mov    rax,QWORD PTR [rbp-0x18]
    3215:	movq   xmm0,rax
    321a:	call   1160 <sqrt@plt>
    321f:	movq   rax,xmm0
    3224:	movq   xmm0,rax
    3229:	call   1140 <asin@plt>
    322e:	addsd  xmm0,xmm0
    3232:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    3237:	movsd  xmm0,QWORD PTR [rbp-0x78]
    323c:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    3241:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3246:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    324b:	leave
    324c:	ret

000000000000324d <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    324d:	push   rbp
    324e:	mov    rbp,rsp
    3251:	movsd  QWORD PTR [rbp-0x18],xmm0
    3256:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    325b:	movsd  xmm0,QWORD PTR [rip+0x1665]        # 48c8 <__PRETTY_FUNCTION__.0+0x58>
    3263:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    3268:	movsd  xmm0,QWORD PTR [rbp-0x18]
    326d:	movq   xmm1,QWORD PTR [rip+0x165b]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    3275:	andpd  xmm0,xmm1
    3279:	movsd  xmm1,QWORD PTR [rbp-0x20]
    327e:	movq   xmm2,QWORD PTR [rip+0x164a]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    3286:	andpd  xmm2,xmm1
    328a:	movapd xmm1,xmm0
    328e:	subsd  xmm1,xmm2
    3292:	movsd  xmm0,QWORD PTR [rbp-0x8]
    3297:	comisd xmm0,xmm1
    329b:	setae  al
    329e:	movzx  eax,al
}
    32a1:	pop    rbp
    32a2:	ret

00000000000032a3 <main>:

int main(int args_count, char **args)
{
    32a3:	push   rbp
    32a4:	mov    rbp,rsp
    32a7:	push   r15
    32a9:	push   r14
    32ab:	push   r13
    32ad:	push   r12
    32af:	push   rbx
    32b0:	sub    rsp,0x2d8
    32b7:	mov    DWORD PTR [rbp-0x244],edi
    32bd:	mov    QWORD PTR [rbp-0x250],rsi
    32c4:	mov    rax,QWORD PTR fs:0x28
    32cd:	mov    QWORD PTR [rbp-0x38],rax
    32d1:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    32d3:	cmp    DWORD PTR [rbp-0x244],0x3
    32da:	je     3307 <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    32dc:	mov    rax,QWORD PTR [rbp-0x250]
    32e3:	mov    rax,QWORD PTR [rax]
    32e6:	lea    rdx,[rip+0x1323]        # 4610 <_IO_stdin_used+0x610>
    32ed:	mov    rsi,rax
    32f0:	mov    rdi,rdx
    32f3:	mov    eax,0x0
    32f8:	call   1070 <printf@plt>
    return 1;
    32fd:	mov    eax,0x1
    3302:	jmp    3da5 <main+0xb02>
  }

  begin_profiling();
    3307:	call   1b3d <begin_profiling>

  Arena arena = {0};
    330c:	pxor   xmm0,xmm0
    3310:	movaps XMMWORD PTR [rbp-0x190],xmm0
    3317:	movaps XMMWORD PTR [rbp-0x180],xmm0
  arena = arena_make(GB(4));
    331e:	lea    rdx,[rbp-0x270]
    3325:	movabs rax,0x100000000
    332f:	mov    rsi,rax
    3332:	mov    rdi,rdx
    3335:	call   1632 <arena_make>
    333a:	mov    rax,QWORD PTR [rbp-0x270]
    3341:	mov    rdx,QWORD PTR [rbp-0x268]
    3348:	mov    QWORD PTR [rbp-0x190],rax
    334f:	mov    QWORD PTR [rbp-0x188],rdx
    3356:	mov    rax,QWORD PTR [rbp-0x260]
    335d:	mov    rdx,QWORD PTR [rbp-0x258]
    3364:	mov    QWORD PTR [rbp-0x180],rax
    336b:	mov    QWORD PTR [rbp-0x178],rdx

  String source = {0};
    3372:	mov    QWORD PTR [rbp-0x1a0],0x0
    337d:	mov    QWORD PTR [rbp-0x198],0x0
  PROFILE_SCOPE("read")
    3388:	lea    r12,[rip+0x12ad]        # 463c <_IO_stdin_used+0x63c>
    338f:	mov    r13d,0x4
    3395:	lea    rdi,[rbp-0x170]
    339c:	mov    rdx,r12
    339f:	mov    rax,r13
    33a2:	mov    r8d,0x0
    33a8:	mov    ecx,0x5
    33ad:	mov    rsi,rdx
    33b0:	mov    rdx,rax
    33b3:	call   1e47 <__profile_begin_pass>
    33b8:	mov    QWORD PTR [rbp-0x230],0x0
    33c3:	jmp    345e <main+0x1bb>
  {
    source = read_file_to_arena(&arena, args[1]);
    33c8:	mov    rax,QWORD PTR [rbp-0x250]
    33cf:	add    rax,0x8
    33d3:	mov    rdx,QWORD PTR [rax]
    33d6:	lea    rax,[rbp-0x190]
    33dd:	mov    rsi,rdx
    33e0:	mov    rdi,rax
    33e3:	call   1357 <read_file_to_arena>
    33e8:	mov    QWORD PTR [rbp-0x1a0],rax
    33ef:	mov    QWORD PTR [rbp-0x198],rdx
  PROFILE_SCOPE("read")
    33f6:	add    QWORD PTR [rbp-0x230],0x1
    33fe:	sub    rsp,0x8
    3402:	sub    rsp,0x38
    3406:	mov    rcx,rsp
    3409:	mov    rax,QWORD PTR [rbp-0x170]
    3410:	mov    rdx,QWORD PTR [rbp-0x168]
    3417:	mov    QWORD PTR [rcx],rax
    341a:	mov    QWORD PTR [rcx+0x8],rdx
    341e:	mov    rax,QWORD PTR [rbp-0x160]
    3425:	mov    rdx,QWORD PTR [rbp-0x158]
    342c:	mov    QWORD PTR [rcx+0x10],rax
    3430:	mov    QWORD PTR [rcx+0x18],rdx
    3434:	mov    rax,QWORD PTR [rbp-0x150]
    343b:	mov    rdx,QWORD PTR [rbp-0x148]
    3442:	mov    QWORD PTR [rcx+0x20],rax
    3446:	mov    QWORD PTR [rcx+0x28],rdx
    344a:	mov    rax,QWORD PTR [rbp-0x140]
    3451:	mov    QWORD PTR [rcx+0x30],rax
    3455:	call   1f31 <__profile_end_pass>
    345a:	add    rsp,0x40
    345e:	cmp    QWORD PTR [rbp-0x230],0x0
    3466:	je     33c8 <main+0x125>
  }

  Haversine_Pair *pairs = NULL;
    346c:	mov    QWORD PTR [rbp-0x228],0x0
  i32 pair_count = 0;
    3477:	mov    DWORD PTR [rbp-0x238],0x0
  usize max_pairs = 0;
    3481:	mov    QWORD PTR [rbp-0x220],0x0
  PROFILE_SCOPE("haversine alloc")
    348c:	lea    r14,[rip+0x11ae]        # 4641 <_IO_stdin_used+0x641>
    3493:	mov    r15d,0xf
    3499:	lea    rdi,[rbp-0x130]
    34a0:	mov    rdx,r14
    34a3:	mov    rax,r15
    34a6:	mov    r8d,0x0
    34ac:	mov    ecx,0x6
    34b1:	mov    rsi,rdx
    34b4:	mov    rdx,rax
    34b7:	call   1e47 <__profile_begin_pass>
    34bc:	mov    QWORD PTR [rbp-0x218],0x0
    34c7:	jmp    358f <main+0x2ec>
  {
    usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    34cc:	mov    QWORD PTR [rbp-0x1a8],0x18
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    34d7:	mov    rax,QWORD PTR [rbp-0x198]
    34de:	mov    edx,0x0
    34e3:	div    QWORD PTR [rbp-0x1a8]
    34ea:	mov    QWORD PTR [rbp-0x220],rax

    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    34f1:	mov    rax,QWORD PTR [rbp-0x220]
    34f8:	shl    rax,0x5
    34fc:	mov    rcx,rax
    34ff:	lea    rax,[rbp-0x190]
    3506:	mov    edx,0x8
    350b:	mov    rsi,rcx
    350e:	mov    rdi,rax
    3511:	call   17d3 <arena_alloc>
    3516:	mov    QWORD PTR [rbp-0x228],rax
    pair_count = 0;
    351d:	mov    DWORD PTR [rbp-0x238],0x0
  PROFILE_SCOPE("haversine alloc")
    3527:	add    QWORD PTR [rbp-0x218],0x1
    352f:	sub    rsp,0x8
    3533:	sub    rsp,0x38
    3537:	mov    rcx,rsp
    353a:	mov    rax,QWORD PTR [rbp-0x130]
    3541:	mov    rdx,QWORD PTR [rbp-0x128]
    3548:	mov    QWORD PTR [rcx],rax
    354b:	mov    QWORD PTR [rcx+0x8],rdx
    354f:	mov    rax,QWORD PTR [rbp-0x120]
    3556:	mov    rdx,QWORD PTR [rbp-0x118]
    355d:	mov    QWORD PTR [rcx+0x10],rax
    3561:	mov    QWORD PTR [rcx+0x18],rdx
    3565:	mov    rax,QWORD PTR [rbp-0x110]
    356c:	mov    rdx,QWORD PTR [rbp-0x108]
    3573:	mov    QWORD PTR [rcx+0x20],rax
    3577:	mov    QWORD PTR [rcx+0x28],rdx
    357b:	mov    rax,QWORD PTR [rbp-0x100]
    3582:	mov    QWORD PTR [rcx+0x30],rax
    3586:	call   1f31 <__profile_end_pass>
    358b:	add    rsp,0x40
    358f:	cmp    QWORD PTR [rbp-0x218],0x0
    3597:	je     34cc <main+0x229>
  }

  JSON_Object *root = NULL;
    359d:	mov    QWORD PTR [rbp-0x1d8],0x0
  root = parse_json(&arena, source);
    35a8:	mov    rcx,QWORD PTR [rbp-0x1a0]
    35af:	mov    rdx,QWORD PTR [rbp-0x198]
    35b6:	lea    rax,[rbp-0x190]
    35bd:	mov    rsi,rcx
    35c0:	mov    rdi,rax
    35c3:	call   2c5f <parse_json>
    35c8:	mov    QWORD PTR [rbp-0x1d8],rax

  f64 haversine_sum = 0.0;
    35cf:	pxor   xmm0,xmm0
    35d3:	movsd  QWORD PTR [rbp-0x1d0],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    35db:	lea    rax,[rip+0x106f]        # 4651 <_IO_stdin_used+0x651>
    35e2:	mov    QWORD PTR [rbp-0x280],rax
    35e9:	mov    QWORD PTR [rbp-0x278],0x5
    35f4:	mov    rax,QWORD PTR [rbp-0x280]
    35fb:	mov    rdx,QWORD PTR [rbp-0x278]
    3602:	mov    rcx,rax
    3605:	mov    rax,QWORD PTR [rbp-0x1d8]
    360c:	mov    rsi,rcx
    360f:	mov    rdi,rax
    3612:	call   2dc2 <lookup_json_object>
    3617:	mov    QWORD PTR [rbp-0x1c8],rax
  if (pairs)
    361e:	cmp    QWORD PTR [rbp-0x228],0x0
    3626:	je     38bb <main+0x618>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    362c:	mov    rax,QWORD PTR [rbp-0x1c8]
    3633:	mov    rax,QWORD PTR [rax+0x20]
    3637:	mov    QWORD PTR [rbp-0x210],rax
    363e:	jmp    389c <main+0x5f9>
    {
      PROFILE_SCOPE("child convert")
    3643:	lea    rax,[rip+0x100d]        # 4657 <_IO_stdin_used+0x657>
    364a:	mov    QWORD PTR [rbp-0x2c0],rax
    3651:	mov    QWORD PTR [rbp-0x2b8],0xd
    365c:	lea    rdi,[rbp-0x70]
    3660:	mov    rbx,QWORD PTR [rbp-0x2c0]
    3667:	mov    rsi,QWORD PTR [rbp-0x2b8]
    366e:	mov    rdx,rbx
    3671:	mov    rax,rsi
    3674:	mov    r8d,0x0
    367a:	mov    ecx,0x7
    367f:	mov    rsi,rdx
    3682:	mov    rdx,rax
    3685:	call   1e47 <__profile_begin_pass>
    368a:	mov    QWORD PTR [rbp-0x208],0x0
    3695:	jmp    387c <main+0x5d9>
      {
        Haversine_Pair pair =
        {
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    369a:	lea    rax,[rip+0xfc4]        # 4665 <_IO_stdin_used+0x665>
    36a1:	mov    QWORD PTR [rbp-0x2d0],rax
    36a8:	mov    QWORD PTR [rbp-0x2c8],0x2
    36b3:	mov    rbx,QWORD PTR [rbp-0x2d0]
    36ba:	mov    rsi,QWORD PTR [rbp-0x2c8]
    36c1:	mov    rax,rbx
    36c4:	mov    rdx,rsi
    36c7:	mov    rcx,QWORD PTR [rbp-0x210]
    36ce:	mov    rsi,rax
    36d1:	mov    rdi,rcx
    36d4:	call   2dc2 <lookup_json_object>
    36d9:	mov    rdi,rax
    36dc:	call   2ee5 <json_object_to_f64>
    36e1:	movq   rax,xmm0
        Haversine_Pair pair =
    36e6:	mov    QWORD PTR [rbp-0xb0],rax
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    36ed:	lea    rax,[rip+0xf74]        # 4668 <_IO_stdin_used+0x668>
    36f4:	mov    QWORD PTR [rbp-0x2e0],rax
    36fb:	mov    QWORD PTR [rbp-0x2d8],0x2
    3706:	mov    rax,QWORD PTR [rbp-0x2e0]
    370d:	mov    rdx,QWORD PTR [rbp-0x2d8]
    3714:	mov    rcx,rax
    3717:	mov    rax,QWORD PTR [rbp-0x210]
    371e:	mov    rsi,rcx
    3721:	mov    rdi,rax
    3724:	call   2dc2 <lookup_json_object>
    3729:	mov    rdi,rax
    372c:	call   2ee5 <json_object_to_f64>
    3731:	movq   rax,xmm0
        Haversine_Pair pair =
    3736:	mov    QWORD PTR [rbp-0xa8],rax
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    373d:	lea    rax,[rip+0xf27]        # 466b <_IO_stdin_used+0x66b>
    3744:	mov    QWORD PTR [rbp-0x2f0],rax
    374b:	mov    QWORD PTR [rbp-0x2e8],0x2
    3756:	mov    rax,QWORD PTR [rbp-0x2f0]
    375d:	mov    rdx,QWORD PTR [rbp-0x2e8]
    3764:	mov    rcx,rax
    3767:	mov    rax,QWORD PTR [rbp-0x210]
    376e:	mov    rsi,rcx
    3771:	mov    rdi,rax
    3774:	call   2dc2 <lookup_json_object>
    3779:	mov    rdi,rax
    377c:	call   2ee5 <json_object_to_f64>
    3781:	movq   rax,xmm0
        Haversine_Pair pair =
    3786:	mov    QWORD PTR [rbp-0xa0],rax
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    378d:	lea    rax,[rip+0xeda]        # 466e <_IO_stdin_used+0x66e>
    3794:	mov    QWORD PTR [rbp-0x300],rax
    379b:	mov    QWORD PTR [rbp-0x2f8],0x2
    37a6:	mov    rax,QWORD PTR [rbp-0x300]
    37ad:	mov    rdx,QWORD PTR [rbp-0x2f8]
    37b4:	mov    rcx,rax
    37b7:	mov    rax,QWORD PTR [rbp-0x210]
    37be:	mov    rsi,rcx
    37c1:	mov    rdi,rax
    37c4:	call   2dc2 <lookup_json_object>
    37c9:	mov    rdi,rax
    37cc:	call   2ee5 <json_object_to_f64>
    37d1:	movq   rax,xmm0
        Haversine_Pair pair =
    37d6:	mov    QWORD PTR [rbp-0x98],rax
        };

        pairs[pair_count] = pair;
    37dd:	mov    eax,DWORD PTR [rbp-0x238]
    37e3:	cdqe
    37e5:	shl    rax,0x5
    37e9:	mov    rdx,rax
    37ec:	mov    rax,QWORD PTR [rbp-0x228]
    37f3:	lea    rcx,[rdx+rax*1]
    37f7:	mov    rax,QWORD PTR [rbp-0xb0]
    37fe:	mov    rdx,QWORD PTR [rbp-0xa8]
    3805:	mov    QWORD PTR [rcx],rax
    3808:	mov    QWORD PTR [rcx+0x8],rdx
    380c:	mov    rax,QWORD PTR [rbp-0xa0]
    3813:	mov    rdx,QWORD PTR [rbp-0x98]
    381a:	mov    QWORD PTR [rcx+0x10],rax
    381e:	mov    QWORD PTR [rcx+0x18],rdx
        pair_count += 1;
    3822:	add    DWORD PTR [rbp-0x238],0x1
      PROFILE_SCOPE("child convert")
    3829:	add    QWORD PTR [rbp-0x208],0x1
    3831:	sub    rsp,0x8
    3835:	sub    rsp,0x38
    3839:	mov    rcx,rsp
    383c:	mov    rax,QWORD PTR [rbp-0x70]
    3840:	mov    rdx,QWORD PTR [rbp-0x68]
    3844:	mov    QWORD PTR [rcx],rax
    3847:	mov    QWORD PTR [rcx+0x8],rdx
    384b:	mov    rax,QWORD PTR [rbp-0x60]
    384f:	mov    rdx,QWORD PTR [rbp-0x58]
    3853:	mov    QWORD PTR [rcx+0x10],rax
    3857:	mov    QWORD PTR [rcx+0x18],rdx
    385b:	mov    rax,QWORD PTR [rbp-0x50]
    385f:	mov    rdx,QWORD PTR [rbp-0x48]
    3863:	mov    QWORD PTR [rcx+0x20],rax
    3867:	mov    QWORD PTR [rcx+0x28],rdx
    386b:	mov    rax,QWORD PTR [rbp-0x40]
    386f:	mov    QWORD PTR [rcx+0x30],rax
    3873:	call   1f31 <__profile_end_pass>
    3878:	add    rsp,0x40
    387c:	cmp    QWORD PTR [rbp-0x208],0x0
    3884:	je     369a <main+0x3f7>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    388a:	mov    rax,QWORD PTR [rbp-0x210]
    3891:	mov    rax,QWORD PTR [rax+0x28]
    3895:	mov    QWORD PTR [rbp-0x210],rax
    389c:	cmp    QWORD PTR [rbp-0x210],0x0
    38a4:	je     38bb <main+0x618>
    38a6:	mov    eax,DWORD PTR [rbp-0x238]
    38ac:	cdqe
    38ae:	cmp    rax,QWORD PTR [rbp-0x220]
    38b5:	jb     3643 <main+0x3a0>
      }
    }
  }

  f64 sum = 0.0;
    38bb:	pxor   xmm0,xmm0
    38bf:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    38c7:	lea    rax,[rip+0xda3]        # 4671 <_IO_stdin_used+0x671>
    38ce:	mov    QWORD PTR [rbp-0x290],rax
    38d5:	mov    QWORD PTR [rbp-0x288],0x3
    38e0:	lea    rax,[rbp-0xf0]
    38e7:	mov    rcx,QWORD PTR [rbp-0x290]
    38ee:	mov    rbx,QWORD PTR [rbp-0x288]
    38f5:	mov    rsi,rcx
    38f8:	mov    rdx,rbx
    38fb:	mov    r8d,0x0
    3901:	mov    ecx,0x8
    3906:	mov    rdi,rax
    3909:	call   1e47 <__profile_begin_pass>
    390e:	mov    QWORD PTR [rbp-0x1f8],0x0
    3919:	jmp    3a9b <main+0x7f8>
  {
    for (usize i = 0; i < pair_count; i++)
    391e:	mov    QWORD PTR [rbp-0x1f0],0x0
    3929:	jmp    39fe <main+0x75b>
    {
      f64 earth_radius = 6372.8;
    392e:	movsd  xmm0,QWORD PTR [rip+0xfaa]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    3936:	movsd  QWORD PTR [rbp-0x1b8],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    393e:	mov    rax,QWORD PTR [rbp-0x1f0]
    3945:	shl    rax,0x5
    3949:	mov    rdx,rax
    394c:	mov    rax,QWORD PTR [rbp-0x228]
    3953:	add    rax,rdx
    3956:	movsd  xmm2,QWORD PTR [rax+0x18]
    395b:	mov    rax,QWORD PTR [rbp-0x1f0]
    3962:	shl    rax,0x5
    3966:	mov    rdx,rax
    3969:	mov    rax,QWORD PTR [rbp-0x228]
    3970:	add    rax,rdx
    3973:	movsd  xmm1,QWORD PTR [rax+0x10]
    3978:	mov    rax,QWORD PTR [rbp-0x1f0]
    397f:	shl    rax,0x5
    3983:	mov    rdx,rax
    3986:	mov    rax,QWORD PTR [rbp-0x228]
    398d:	add    rax,rdx
    3990:	movsd  xmm0,QWORD PTR [rax+0x8]
    3995:	mov    rax,QWORD PTR [rbp-0x1f0]
    399c:	shl    rax,0x5
    39a0:	mov    rdx,rax
    39a3:	mov    rax,QWORD PTR [rbp-0x228]
    39aa:	add    rax,rdx
    39ad:	mov    rax,QWORD PTR [rax]
    39b0:	movsd  xmm3,QWORD PTR [rbp-0x1b8]
    39b8:	movapd xmm4,xmm3
    39bc:	movapd xmm3,xmm2
    39c0:	movapd xmm2,xmm1
    39c4:	movapd xmm1,xmm0
    39c8:	movq   xmm0,rax
    39cd:	call   30a2 <reference_haversine>
    39d2:	movq   rax,xmm0
    39d7:	mov    QWORD PTR [rbp-0x1b0],rax
      sum += result;
    39de:	movsd  xmm0,QWORD PTR [rbp-0x200]
    39e6:	addsd  xmm0,QWORD PTR [rbp-0x1b0]
    39ee:	movsd  QWORD PTR [rbp-0x200],xmm0
    for (usize i = 0; i < pair_count; i++)
    39f6:	add    QWORD PTR [rbp-0x1f0],0x1
    39fe:	mov    eax,DWORD PTR [rbp-0x238]
    3a04:	cdqe
    3a06:	cmp    QWORD PTR [rbp-0x1f0],rax
    3a0d:	jb     392e <main+0x68b>
    }
    sum /= pair_count;
    3a13:	pxor   xmm1,xmm1
    3a17:	cvtsi2sd xmm1,DWORD PTR [rbp-0x238]
    3a1f:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3a27:	divsd  xmm0,xmm1
    3a2b:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3a33:	add    QWORD PTR [rbp-0x1f8],0x1
    3a3b:	sub    rsp,0x8
    3a3f:	sub    rsp,0x38
    3a43:	mov    rax,rsp
    3a46:	mov    rcx,QWORD PTR [rbp-0xf0]
    3a4d:	mov    rbx,QWORD PTR [rbp-0xe8]
    3a54:	mov    QWORD PTR [rax],rcx
    3a57:	mov    QWORD PTR [rax+0x8],rbx
    3a5b:	mov    rcx,QWORD PTR [rbp-0xe0]
    3a62:	mov    rbx,QWORD PTR [rbp-0xd8]
    3a69:	mov    QWORD PTR [rax+0x10],rcx
    3a6d:	mov    QWORD PTR [rax+0x18],rbx
    3a71:	mov    rcx,QWORD PTR [rbp-0xd0]
    3a78:	mov    rbx,QWORD PTR [rbp-0xc8]
    3a7f:	mov    QWORD PTR [rax+0x20],rcx
    3a83:	mov    QWORD PTR [rax+0x28],rbx
    3a87:	mov    rdx,QWORD PTR [rbp-0xc0]
    3a8e:	mov    QWORD PTR [rax+0x30],rdx
    3a92:	call   1f31 <__profile_end_pass>
    3a97:	add    rsp,0x40
    3a9b:	cmp    QWORD PTR [rbp-0x1f8],0x0
    3aa3:	je     391e <main+0x67b>
  }

  PROFILE_SCOPE("check")
    3aa9:	lea    rax,[rip+0xbc5]        # 4675 <_IO_stdin_used+0x675>
    3ab0:	mov    QWORD PTR [rbp-0x2a0],rax
    3ab7:	mov    QWORD PTR [rbp-0x298],0x5
    3ac2:	lea    rax,[rbp-0xb0]
    3ac9:	mov    rcx,QWORD PTR [rbp-0x2a0]
    3ad0:	mov    rbx,QWORD PTR [rbp-0x298]
    3ad7:	mov    rsi,rcx
    3ada:	mov    rdx,rbx
    3add:	mov    r8d,0x0
    3ae3:	mov    ecx,0x9
    3ae8:	mov    rdi,rax
    3aeb:	call   1e47 <__profile_begin_pass>
    3af0:	mov    QWORD PTR [rbp-0x1e8],0x0
    3afb:	jmp    3cd0 <main+0xa2d>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3b00:	mov    rax,QWORD PTR [rbp-0x250]
    3b07:	add    rax,0x10
    3b0b:	mov    rdx,QWORD PTR [rax]
    3b0e:	lea    rax,[rbp-0x190]
    3b15:	mov    rsi,rdx
    3b18:	mov    rdi,rax
    3b1b:	call   1357 <read_file_to_arena>
    3b20:	mov    QWORD PTR [rbp-0x70],rax
    3b24:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3b28:	mov    rax,QWORD PTR [rbp-0x68]
    3b2c:	cmp    rax,0xb
    3b30:	jbe    3c43 <main+0x9a0>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3b36:	mov    rax,QWORD PTR [rbp-0x70]
    3b3a:	movsd  xmm0,QWORD PTR [rax]
    3b3e:	movsd  QWORD PTR [rbp-0x1c0],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3b46:	mov    rax,QWORD PTR [rbp-0x70]
    3b4a:	mov    eax,DWORD PTR [rax+0x8]
    3b4d:	mov    DWORD PTR [rbp-0x234],eax

      if (solution_pairs == pair_count)
    3b53:	mov    eax,DWORD PTR [rbp-0x234]
    3b59:	cmp    eax,DWORD PTR [rbp-0x238]
    3b5f:	jne    3c07 <main+0x964>
      {
        if (epsilon_equal(solution_sum, sum))
    3b65:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b6d:	mov    rax,QWORD PTR [rbp-0x1c0]
    3b74:	movapd xmm1,xmm0
    3b78:	movq   xmm0,rax
    3b7d:	call   324d <epsilon_equal>
    3b82:	test   eax,eax
    3b84:	je     3bc8 <main+0x925>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3b86:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b8e:	mov    rax,QWORD PTR [rbp-0x1c0]
    3b95:	lea    rdx,[rip+0xae4]        # 4680 <_IO_stdin_used+0x680>
    3b9c:	lea    rsi,[rip+0xb10]        # 46b3 <_IO_stdin_used+0x6b3>
    3ba3:	movapd xmm1,xmm0
    3ba7:	movq   xmm0,rax
    3bac:	mov    rcx,rdx
    3baf:	mov    edx,0x64
    3bb4:	mov    edi,0x3
    3bb9:	mov    eax,0x2
    3bbe:	call   14a1 <log_message>
    3bc3:	jmp    3c6b <main+0x9c8>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3bc8:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3bd0:	mov    rax,QWORD PTR [rbp-0x1c0]
    3bd7:	lea    rdx,[rip+0xaea]        # 46c8 <_IO_stdin_used+0x6c8>
    3bde:	lea    rsi,[rip+0xace]        # 46b3 <_IO_stdin_used+0x6b3>
    3be5:	movapd xmm1,xmm0
    3be9:	movq   xmm0,rax
    3bee:	mov    rcx,rdx
    3bf1:	mov    edx,0x68
    3bf6:	mov    edi,0x1
    3bfb:	mov    eax,0x2
    3c00:	call   14a1 <log_message>
    3c05:	jmp    3c6b <main+0x9c8>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3c07:	mov    esi,DWORD PTR [rbp-0x238]
    3c0d:	mov    ecx,DWORD PTR [rbp-0x234]
    3c13:	lea    rdx,[rip+0xae6]        # 4700 <_IO_stdin_used+0x700>
    3c1a:	lea    rax,[rip+0xa92]        # 46b3 <_IO_stdin_used+0x6b3>
    3c21:	mov    r9d,esi
    3c24:	mov    r8d,ecx
    3c27:	mov    rcx,rdx
    3c2a:	mov    edx,0x6d
    3c2f:	mov    rsi,rax
    3c32:	mov    edi,0x1
    3c37:	mov    eax,0x0
    3c3c:	call   14a1 <log_message>
    3c41:	jmp    3c6b <main+0x9c8>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3c43:	lea    rdx,[rip+0xafe]        # 4748 <_IO_stdin_used+0x748>
    3c4a:	lea    rax,[rip+0xa62]        # 46b3 <_IO_stdin_used+0x6b3>
    3c51:	mov    rcx,rdx
    3c54:	mov    edx,0x72
    3c59:	mov    rsi,rax
    3c5c:	mov    edi,0x1
    3c61:	mov    eax,0x0
    3c66:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3c6b:	add    QWORD PTR [rbp-0x1e8],0x1
    3c73:	sub    rsp,0x8
    3c77:	sub    rsp,0x38
    3c7b:	mov    rax,rsp
    3c7e:	mov    rcx,QWORD PTR [rbp-0xb0]
    3c85:	mov    rbx,QWORD PTR [rbp-0xa8]
    3c8c:	mov    QWORD PTR [rax],rcx
    3c8f:	mov    QWORD PTR [rax+0x8],rbx
    3c93:	mov    rcx,QWORD PTR [rbp-0xa0]
    3c9a:	mov    rbx,QWORD PTR [rbp-0x98]
    3ca1:	mov    QWORD PTR [rax+0x10],rcx
    3ca5:	mov    QWORD PTR [rax+0x18],rbx
    3ca9:	mov    rcx,QWORD PTR [rbp-0x90]
    3cb0:	mov    rbx,QWORD PTR [rbp-0x88]
    3cb7:	mov    QWORD PTR [rax+0x20],rcx
    3cbb:	mov    QWORD PTR [rax+0x28],rbx
    3cbf:	mov    rdx,QWORD PTR [rbp-0x80]
    3cc3:	mov    QWORD PTR [rax+0x30],rdx
    3cc7:	call   1f31 <__profile_end_pass>
    3ccc:	add    rsp,0x40
    3cd0:	cmp    QWORD PTR [rbp-0x1e8],0x0
    3cd8:	je     3b00 <main+0x85d>
    }
  }

  PROFILE_SCOPE("free")
    3cde:	lea    rax,[rip+0xa9e]        # 4783 <_IO_stdin_used+0x783>
    3ce5:	mov    QWORD PTR [rbp-0x2b0],rax
    3cec:	mov    QWORD PTR [rbp-0x2a8],0x4
    3cf7:	lea    rax,[rbp-0x70]
    3cfb:	mov    rcx,QWORD PTR [rbp-0x2b0]
    3d02:	mov    rbx,QWORD PTR [rbp-0x2a8]
    3d09:	mov    rsi,rcx
    3d0c:	mov    rdx,rbx
    3d0f:	mov    r8d,0x0
    3d15:	mov    ecx,0xa
    3d1a:	mov    rdi,rax
    3d1d:	call   1e47 <__profile_begin_pass>
    3d22:	mov    QWORD PTR [rbp-0x1e0],0x0
    3d2d:	jmp    3d91 <main+0xaee>
  {
    arena_free(&arena);
    3d2f:	lea    rax,[rbp-0x190]
    3d36:	mov    rdi,rax
    3d39:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3d3e:	add    QWORD PTR [rbp-0x1e0],0x1
    3d46:	sub    rsp,0x8
    3d4a:	sub    rsp,0x38
    3d4e:	mov    rax,rsp
    3d51:	mov    rcx,QWORD PTR [rbp-0x70]
    3d55:	mov    rbx,QWORD PTR [rbp-0x68]
    3d59:	mov    QWORD PTR [rax],rcx
    3d5c:	mov    QWORD PTR [rax+0x8],rbx
    3d60:	mov    rcx,QWORD PTR [rbp-0x60]
    3d64:	mov    rbx,QWORD PTR [rbp-0x58]
    3d68:	mov    QWORD PTR [rax+0x10],rcx
    3d6c:	mov    QWORD PTR [rax+0x18],rbx
    3d70:	mov    rcx,QWORD PTR [rbp-0x50]
    3d74:	mov    rbx,QWORD PTR [rbp-0x48]
    3d78:	mov    QWORD PTR [rax+0x20],rcx
    3d7c:	mov    QWORD PTR [rax+0x28],rbx
    3d80:	mov    rdx,QWORD PTR [rbp-0x40]
    3d84:	mov    QWORD PTR [rax+0x30],rdx
    3d88:	call   1f31 <__profile_end_pass>
    3d8d:	add    rsp,0x40
    3d91:	cmp    QWORD PTR [rbp-0x1e0],0x0
    3d99:	je     3d2f <main+0xa8c>
  }

  end_profiling();
    3d9b:	call   1b9b <end_profiling>
    3da0:	mov    eax,0x0
}
    3da5:	mov    rdx,QWORD PTR [rbp-0x38]
    3da9:	sub    rdx,QWORD PTR fs:0x28
    3db2:	je     3db9 <main+0xb16>
    3db4:	call   1060 <__stack_chk_fail@plt>
    3db9:	lea    rsp,[rbp-0x28]
    3dbd:	pop    rbx
    3dbe:	pop    r12
    3dc0:	pop    r13
    3dc2:	pop    r14
    3dc4:	pop    r15
    3dc6:	pop    rbp
    3dc7:	ret

Disassembly of section .fini:

0000000000003dc8 <_fini>:
    3dc8:	endbr64
    3dcc:	sub    rsp,0x8
    3dd0:	add    rsp,0x8
    3dd4:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x4fc1]        # 5fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x4fca]        # 5ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x4fcc]        # 5ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x4fca]        # 6000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x4fc2]        # 6008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x4fba]        # 6010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x4fb2]        # 6018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x4faa]        # 6020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x4fa2]        # 6028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x4f9a]        # 6030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x4f92]        # 6038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x4f8a]        # 6040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x4f82]        # 6048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x4f7a]        # 6050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x4f72]        # 6058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x4f6a]        # 6060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x4f62]        # 6068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x4f5a]        # 6070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x4f52]        # 6078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x4f4a]        # 6080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x4f42]        # 6088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x4f3a]        # 6090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x4f32]        # 6098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2114]        # 32a3 <main>
    118f:	call   QWORD PTR [rip+0x4e2b]        # 5fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x4fa1]        # 6148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x4f9a]        # 6148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x4e0e]        # 5fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x4f71]        # 6148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x4f6a]        # 6148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x4ddd]        # 5fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x4f6d],0x0        # 6188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x4dba],0x0        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x4e76]        # 60a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x4da8]        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x4f44],0x1        # 6188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x4c6e]        # 6180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x4b89]        # 60c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x4be7]        # 6160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x4b2b]        # 60c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x3097]        # 4790 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x306b]        # 4790 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fae]        # 47a8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2eaf]        # 47b8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2ccd]        # 47d0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x4639]        # 61a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x4620],rbx        # 61a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x40
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x45ee]        # 61a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x28],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x28],0x0
    1bbe:	je     1e44 <end_profiling+0x2a9>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x20],rax
    printf("[PROFILE] Total duration: %lu (%fms @ CPU Frequency: %u)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x28]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x20]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c51]        # 4888 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x20]
    1c44:	mov    rax,QWORD PTR [rbp-0x28]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x38],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x30],0x0
    1c72:	jmp    1e36 <end_profiling+0x29b>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x30]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x450d]        # 61a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x18],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x18]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1e31 <end_profiling+0x296>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x18]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x28]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b77]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x10],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x18]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x18]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x18]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x18]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x10]
    1d48:	lea    rdi,[rip+0x2581]        # 42d0 <_IO_stdin_used+0x2d0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x18]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x18]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x18]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x28]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2a9f]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x8],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x18]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x8]
    1e06:	lea    rcx,[rip+0x251b]        # 4328 <_IO_stdin_used+0x328>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x38]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x10]
    1e2c:	movsd  QWORD PTR [rbp-0x38],xmm0
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1e31:	add    QWORD PTR [rbp-0x30],0x1
    1e36:	cmp    QWORD PTR [rbp-0x30],0xfff
    1e3e:	jbe    1c77 <end_profiling+0xdc>
      }
    }

  }
}
    1e44:	nop
    1e45:	leave
    1e46:	ret

0000000000001e47 <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1e47:	push   rbp
    1e48:	mov    rbp,rsp
    1e4b:	push   rbx
    1e4c:	sub    rsp,0x78
    1e50:	mov    QWORD PTR [rbp-0x58],rdi
    1e54:	mov    rax,rsi
    1e57:	mov    rsi,rdx
    1e5a:	mov    rax,rax
    1e5d:	mov    edx,0x0
    1e62:	mov    rdx,rsi
    1e65:	mov    QWORD PTR [rbp-0x70],rax
    1e69:	mov    QWORD PTR [rbp-0x68],rdx
    1e6d:	mov    QWORD PTR [rbp-0x60],rcx
    1e71:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1e75:	pxor   xmm0,xmm0
    1e79:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1e7d:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1e81:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1e85:	movq   QWORD PTR [rbp-0x20],xmm0
    1e8a:	mov    rax,QWORD PTR [rbp-0x70]
    1e8e:	mov    rdx,QWORD PTR [rbp-0x68]
    1e92:	mov    QWORD PTR [rbp-0x50],rax
    1e96:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1e9a:	mov    rdx,QWORD PTR [rbp-0x60]
    1e9e:	mov    rax,rdx
    1ea1:	add    rax,rax
    1ea4:	add    rax,rdx
    1ea7:	shl    rax,0x4
    1eab:	mov    rdx,rax
    1eae:	lea    rax,[rip+0x4313]        # 61c8 <g_profiler+0x28>
    1eb5:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1eb9:	mov    QWORD PTR [rbp-0x38],rax
    1ebd:	mov    rax,QWORD PTR [rbp-0x60]
    1ec1:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1ec5:	mov    rax,QWORD PTR [rip+0x42dc]        # 61a8 <g_profiler+0x8>
  Profile_Pass pass =
    1ecc:	mov    QWORD PTR [rbp-0x28],rax
    1ed0:	mov    rax,QWORD PTR [rbp-0x78]
    1ed4:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    1ed8:	mov    rax,QWORD PTR [rbp-0x60]
    1edc:	mov    QWORD PTR [rip+0x42c5],rax        # 61a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    1ee3:	call   1a48 <read_cpu_timer>
    1ee8:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    1eec:	mov    rax,QWORD PTR [rbp-0x58]
    1ef0:	mov    rcx,QWORD PTR [rbp-0x50]
    1ef4:	mov    rbx,QWORD PTR [rbp-0x48]
    1ef8:	mov    QWORD PTR [rax],rcx
    1efb:	mov    QWORD PTR [rax+0x8],rbx
    1eff:	mov    rcx,QWORD PTR [rbp-0x40]
    1f03:	mov    rbx,QWORD PTR [rbp-0x38]
    1f07:	mov    QWORD PTR [rax+0x10],rcx
    1f0b:	mov    QWORD PTR [rax+0x18],rbx
    1f0f:	mov    rcx,QWORD PTR [rbp-0x30]
    1f13:	mov    rbx,QWORD PTR [rbp-0x28]
    1f17:	mov    QWORD PTR [rax+0x20],rcx
    1f1b:	mov    QWORD PTR [rax+0x28],rbx
    1f1f:	mov    rdx,QWORD PTR [rbp-0x20]
    1f23:	mov    QWORD PTR [rax+0x30],rdx
}
    1f27:	mov    rax,QWORD PTR [rbp-0x58]
    1f2b:	mov    rbx,QWORD PTR [rbp-0x8]
    1f2f:	leave
    1f30:	ret

0000000000001f31 <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    1f31:	push   rbp
    1f32:	mov    rbp,rsp
    1f35:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    1f39:	call   1a48 <read_cpu_timer>
    1f3e:	mov    rdx,rax
    1f41:	mov    rax,QWORD PTR [rbp+0x20]
    1f45:	sub    rdx,rax
    1f48:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    1f4c:	mov    rax,QWORD PTR [rbp+0x38]
    1f50:	mov    QWORD PTR [rip+0x4251],rax        # 61a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    1f57:	mov    rdx,QWORD PTR [rbp+0x30]
    1f5b:	mov    rax,rdx
    1f5e:	add    rax,rax
    1f61:	add    rax,rdx
    1f64:	shl    rax,0x4
    1f68:	lea    rdx,[rax+0x10]
    1f6c:	lea    rax,[rip+0x422d]        # 61a0 <g_profiler>
    1f73:	add    rax,rdx
    1f76:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    1f7a:	mov    rax,QWORD PTR [rbp-0x10]
    1f7e:	mov    rdx,QWORD PTR [rax+0x10]
    1f82:	mov    rax,QWORD PTR [rbp-0x18]
    1f86:	add    rdx,rax
    1f89:	mov    rax,QWORD PTR [rbp-0x10]
    1f8d:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    1f91:	mov    rax,QWORD PTR [rbp-0x10]
    1f95:	mov    rax,QWORD PTR [rax+0x20]
    1f99:	lea    rdx,[rax+0x1]
    1f9d:	mov    rax,QWORD PTR [rbp-0x10]
    1fa1:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    1fa5:	mov    rcx,QWORD PTR [rbp-0x10]
    1fa9:	mov    rax,QWORD PTR [rbp+0x10]
    1fad:	mov    rdx,QWORD PTR [rbp+0x18]
    1fb1:	mov    QWORD PTR [rcx],rax
    1fb4:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    1fb8:	mov    rdx,QWORD PTR [rbp+0x28]
    1fbc:	mov    rax,QWORD PTR [rbp-0x18]
    1fc0:	add    rdx,rax
    1fc3:	mov    rax,QWORD PTR [rbp-0x10]
    1fc7:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    1fcb:	mov    rax,QWORD PTR [rbp-0x10]
    1fcf:	mov    rdx,QWORD PTR [rax+0x28]
    1fd3:	mov    rax,QWORD PTR [rbp+0x40]
    1fd7:	add    rdx,rax
    1fda:	mov    rax,QWORD PTR [rbp-0x10]
    1fde:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    1fe2:	mov    rdx,QWORD PTR [rbp+0x38]
    1fe6:	mov    rax,rdx
    1fe9:	add    rax,rax
    1fec:	add    rax,rdx
    1fef:	shl    rax,0x4
    1ff3:	lea    rdx,[rax+0x10]
    1ff7:	lea    rax,[rip+0x41a2]        # 61a0 <g_profiler>
    1ffe:	add    rax,rdx
    2001:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    2005:	mov    rax,QWORD PTR [rbp-0x8]
    2009:	mov    rax,QWORD PTR [rax+0x10]
    200d:	sub    rax,QWORD PTR [rbp-0x18]
    2011:	mov    rdx,rax
    2014:	mov    rax,QWORD PTR [rbp-0x8]
    2018:	mov    QWORD PTR [rax+0x10],rdx
}
    201c:	nop
    201d:	leave
    201e:	ret

000000000000201f <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    201f:	push   rbp
    2020:	mov    rbp,rsp
    2023:	sub    rsp,0x10
    2027:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    202b:	mov    rax,QWORD PTR [rbp-0x8]
    202f:	mov    rdx,QWORD PTR [rax+0x10]
    2033:	mov    rax,QWORD PTR [rbp-0x8]
    2037:	mov    rax,QWORD PTR [rax+0x8]
    203b:	cmp    rdx,rax
    203e:	jb     2065 <parser_at+0x46>
    2040:	lea    rdx,[rip+0x27a1]        # 47e8 <__PRETTY_FUNCTION__.5>
    2047:	lea    rsi,[rip+0x2411]        # 445f <_IO_stdin_used+0x45f>
    204e:	lea    rax,[rip+0x241b]        # 4470 <_IO_stdin_used+0x470>
    2055:	mov    rcx,rdx
    2058:	mov    edx,0x2f
    205d:	mov    rdi,rax
    2060:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    2065:	mov    rax,QWORD PTR [rbp-0x8]
    2069:	mov    rdx,QWORD PTR [rax]
    206c:	mov    rax,QWORD PTR [rbp-0x8]
    2070:	mov    rax,QWORD PTR [rax+0x10]
    2074:	add    rax,rdx
}
    2077:	leave
    2078:	ret

0000000000002079 <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    2079:	push   rbp
    207a:	mov    rbp,rsp
    207d:	sub    rsp,0x10
    2081:	mov    QWORD PTR [rbp-0x8],rdi
    2085:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    2089:	mov    rax,QWORD PTR [rbp-0x8]
    208d:	mov    rdi,rax
    2090:	call   201f <parser_at>
    2095:	mov    rdx,QWORD PTR [rbp-0x10]
    2099:	add    rax,rdx
}
    209c:	leave
    209d:	ret

000000000000209e <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    209e:	push   rbp
    209f:	mov    rbp,rsp
    20a2:	mov    QWORD PTR [rbp-0x8],rdi
    20a6:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    20aa:	mov    rax,QWORD PTR [rbp-0x8]
    20ae:	mov    rdx,QWORD PTR [rax+0x10]
    20b2:	mov    rax,QWORD PTR [rbp-0x10]
    20b6:	add    rdx,rax
    20b9:	mov    rax,QWORD PTR [rbp-0x8]
    20bd:	mov    QWORD PTR [rax+0x10],rdx
}
    20c1:	nop
    20c2:	pop    rbp
    20c3:	ret

00000000000020c4 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    20c4:	push   rbp
    20c5:	mov    rbp,rsp
    20c8:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    20cc:	mov    rax,QWORD PTR [rbp-0x8]
    20d0:	mov    rdx,QWORD PTR [rax+0x10]
    20d4:	mov    rax,QWORD PTR [rbp-0x8]
    20d8:	mov    rax,QWORD PTR [rax+0x8]
    20dc:	cmp    rdx,rax
    20df:	setb   al
}
    20e2:	pop    rbp
    20e3:	ret

00000000000020e4 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    20e4:	push   rbp
    20e5:	mov    rbp,rsp
    20e8:	push   r12
    20ea:	push   rbx
    20eb:	sub    rsp,0x20
    20ef:	mov    QWORD PTR [rbp-0x18],rdi
    20f3:	mov    rax,rsi
    20f6:	mov    rcx,rdx
    20f9:	mov    rax,rax
    20fc:	mov    edx,0x0
    2101:	mov    rdx,rcx
    2104:	mov    QWORD PTR [rbp-0x30],rax
    2108:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    210c:	mov    rax,QWORD PTR [rbp-0x28]
    2110:	mov    r12,rax
    2113:	mov    rbx,QWORD PTR [rbp-0x30]
    2117:	mov    rax,QWORD PTR [rbp-0x18]
    211b:	mov    rdi,rax
    211e:	call   201f <parser_at>
    2123:	mov    rdx,r12
    2126:	mov    rsi,rbx
    2129:	mov    rdi,rax
    212c:	call   10d0 <memcmp@plt>
    2131:	test   eax,eax
    2133:	sete   al
}
    2136:	add    rsp,0x20
    213a:	pop    rbx
    213b:	pop    r12
    213d:	pop    rbp
    213e:	ret

000000000000213f <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    213f:	push   rbp
    2140:	mov    rbp,rsp
    2143:	mov    eax,edi
    2145:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    2148:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    214c:	movzx  eax,BYTE PTR [rbp-0x14]
    2150:	cmp    eax,0x2e
    2153:	jg     215c <is_numeric+0x1d>
    2155:	cmp    eax,0x2d
    2158:	jge    2164 <is_numeric+0x25>
    215a:	jmp    2169 <is_numeric+0x2a>
    215c:	sub    eax,0x30
    215f:	cmp    eax,0x9
    2162:	ja     2169 <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2164:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    2168:	nop
  }


  return result;
    2169:	movzx  eax,BYTE PTR [rbp-0x1]
}
    216d:	pop    rbp
    216e:	ret

000000000000216f <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    216f:	push   rbp
    2170:	mov    rbp,rsp
    2173:	sub    rsp,0x50
    2177:	mov    QWORD PTR [rbp-0x48],rdi
    217b:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    217f:	pxor   xmm0,xmm0
    2183:	movaps XMMWORD PTR [rbp-0x20],xmm0
    2187:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    218c:	jmp    219f <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    218e:	mov    rax,QWORD PTR [rbp-0x50]
    2192:	mov    esi,0x1
    2197:	mov    rdi,rax
    219a:	call   209e <parser_advance>
  while (parser_incomplete(parser)  &&
    219f:	mov    rax,QWORD PTR [rbp-0x50]
    21a3:	mov    rdi,rax
    21a6:	call   20c4 <parser_incomplete>
    21ab:	test   al,al
    21ad:	je     21fb <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    21af:	mov    rax,QWORD PTR [rbp-0x50]
    21b3:	mov    rdi,rax
    21b6:	call   201f <parser_at>
    21bb:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    21be:	cmp    al,0x20
    21c0:	je     218e <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    21c2:	mov    rax,QWORD PTR [rbp-0x50]
    21c6:	mov    rdi,rax
    21c9:	call   201f <parser_at>
    21ce:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    21d1:	cmp    al,0xa
    21d3:	je     218e <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    21d5:	mov    rax,QWORD PTR [rbp-0x50]
    21d9:	mov    rdi,rax
    21dc:	call   201f <parser_at>
    21e1:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    21e4:	cmp    al,0xd
    21e6:	je     218e <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    21e8:	mov    rax,QWORD PTR [rbp-0x50]
    21ec:	mov    rdi,rax
    21ef:	call   201f <parser_at>
    21f4:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    21f7:	cmp    al,0x9
    21f9:	je     218e <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    21fb:	mov    rax,QWORD PTR [rbp-0x50]
    21ff:	mov    rdi,rax
    2202:	call   20c4 <parser_incomplete>
    2207:	test   al,al
    2209:	je     2636 <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    220f:	mov    rax,QWORD PTR [rbp-0x50]
    2213:	mov    rdi,rax
    2216:	call   201f <parser_at>
    221b:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    221f:	mov    rax,QWORD PTR [rbp-0x50]
    2223:	mov    rdi,rax
    2226:	call   201f <parser_at>
    222b:	movzx  eax,BYTE PTR [rax]
    222e:	movzx  eax,al
    2231:	cmp    eax,0x7d
    2234:	je     2321 <get_json_token+0x1b2>
    223a:	cmp    eax,0x7d
    223d:	jg     2647 <get_json_token+0x4d8>
    2243:	cmp    eax,0x7b
    2246:	je     22fc <get_json_token+0x18d>
    224c:	cmp    eax,0x7b
    224f:	jg     2647 <get_json_token+0x4d8>
    2255:	cmp    eax,0x74
    2258:	je     24a4 <get_json_token+0x335>
    225e:	cmp    eax,0x74
    2261:	jg     2647 <get_json_token+0x4d8>
    2267:	cmp    eax,0x6e
    226a:	je     25b4 <get_json_token+0x445>
    2270:	cmp    eax,0x6e
    2273:	jg     2647 <get_json_token+0x4d8>
    2279:	cmp    eax,0x66
    227c:	je     252c <get_json_token+0x3bd>
    2282:	cmp    eax,0x66
    2285:	jg     2647 <get_json_token+0x4d8>
    228b:	cmp    eax,0x5d
    228e:	je     236b <get_json_token+0x1fc>
    2294:	cmp    eax,0x5d
    2297:	jg     2647 <get_json_token+0x4d8>
    229d:	cmp    eax,0x5b
    22a0:	je     2346 <get_json_token+0x1d7>
    22a6:	cmp    eax,0x5b
    22a9:	jg     2647 <get_json_token+0x4d8>
    22af:	cmp    eax,0x3a
    22b2:	je     23b5 <get_json_token+0x246>
    22b8:	cmp    eax,0x3a
    22bb:	jg     2647 <get_json_token+0x4d8>
    22c1:	cmp    eax,0x39
    22c4:	jg     2647 <get_json_token+0x4d8>
    22ca:	cmp    eax,0x30
    22cd:	jge    2453 <get_json_token+0x2e4>
    22d3:	cmp    eax,0x2e
    22d6:	jg     2647 <get_json_token+0x4d8>
    22dc:	cmp    eax,0x2d
    22df:	jge    2453 <get_json_token+0x2e4>
    22e5:	cmp    eax,0x22
    22e8:	je     23da <get_json_token+0x26b>
    22ee:	cmp    eax,0x2c
    22f1:	je     2390 <get_json_token+0x221>
    22f7:	jmp    2647 <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    22fc:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    2303:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    230b:	mov    rax,QWORD PTR [rbp-0x50]
    230f:	mov    esi,0x1
    2314:	mov    rdi,rax
    2317:	call   209e <parser_advance>
      }
      break;
    231c:	jmp    2647 <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2321:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    2328:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2330:	mov    rax,QWORD PTR [rbp-0x50]
    2334:	mov    esi,0x1
    2339:	mov    rdi,rax
    233c:	call   209e <parser_advance>
      }
      break;
    2341:	jmp    2647 <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2346:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    234d:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2355:	mov    rax,QWORD PTR [rbp-0x50]
    2359:	mov    esi,0x1
    235e:	mov    rdi,rax
    2361:	call   209e <parser_advance>
      }
      break;
    2366:	jmp    2647 <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    236b:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    2372:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    237a:	mov    rax,QWORD PTR [rbp-0x50]
    237e:	mov    esi,0x1
    2383:	mov    rdi,rax
    2386:	call   209e <parser_advance>
      }
      break;
    238b:	jmp    2647 <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    2390:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    2397:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    239f:	mov    rax,QWORD PTR [rbp-0x50]
    23a3:	mov    esi,0x1
    23a8:	mov    rdi,rax
    23ab:	call   209e <parser_advance>
      }
      break;
    23b0:	jmp    2647 <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    23b5:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    23bc:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    23c4:	mov    rax,QWORD PTR [rbp-0x50]
    23c8:	mov    esi,0x1
    23cd:	mov    rdi,rax
    23d0:	call   209e <parser_advance>
      }
      break;
    23d5:	jmp    2647 <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    23da:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    23e1:	mov    rax,QWORD PTR [rbp-0x50]
    23e5:	mov    esi,0x1
    23ea:	mov    rdi,rax
    23ed:	call   209e <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    23f2:	mov    rax,QWORD PTR [rbp-0x50]
    23f6:	mov    rdi,rax
    23f9:	call   201f <parser_at>
    23fe:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    2402:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    240a:	jmp    2422 <get_json_token+0x2b3>
        {
          string_count += 1;
    240c:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    2411:	mov    rax,QWORD PTR [rbp-0x50]
    2415:	mov    esi,0x1
    241a:	mov    rdi,rax
    241d:	call   209e <parser_advance>
        while (*parser_at(parser) != '"')
    2422:	mov    rax,QWORD PTR [rbp-0x50]
    2426:	mov    rdi,rax
    2429:	call   201f <parser_at>
    242e:	movzx  eax,BYTE PTR [rax]
    2431:	cmp    al,0x22
    2433:	jne    240c <get_json_token+0x29d>
        }
        token.value.count = string_count;
    2435:	mov    rax,QWORD PTR [rbp-0x40]
    2439:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    243d:	mov    rax,QWORD PTR [rbp-0x50]
    2441:	mov    esi,0x1
    2446:	mov    rdi,rax
    2449:	call   209e <parser_advance>
      }
      break;
    244e:	jmp    2647 <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2453:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    245a:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2462:	jmp    247a <get_json_token+0x30b>
        {
          digit_count += 1;
    2464:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    2469:	mov    rax,QWORD PTR [rbp-0x50]
    246d:	mov    esi,0x1
    2472:	mov    rdi,rax
    2475:	call   209e <parser_advance>
        while (is_numeric(*parser_at(parser)))
    247a:	mov    rax,QWORD PTR [rbp-0x50]
    247e:	mov    rdi,rax
    2481:	call   201f <parser_at>
    2486:	movzx  eax,BYTE PTR [rax]
    2489:	movzx  eax,al
    248c:	mov    edi,eax
    248e:	call   213f <is_numeric>
    2493:	test   al,al
    2495:	jne    2464 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    2497:	mov    rax,QWORD PTR [rbp-0x38]
    249b:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    249f:	jmp    2647 <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    24a4:	lea    rax,[rip+0x2011]        # 44bc <_IO_stdin_used+0x4bc>
    24ab:	mov    QWORD PTR [rbp-0x30],rax
    24af:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    24b7:	mov    rcx,QWORD PTR [rbp-0x30]
    24bb:	mov    rdx,QWORD PTR [rbp-0x28]
    24bf:	mov    rax,QWORD PTR [rbp-0x50]
    24c3:	mov    rsi,rcx
    24c6:	mov    rdi,rax
    24c9:	call   20e4 <parser_token_is_literal>
    24ce:	test   al,al
    24d0:	je     24f4 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    24d2:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    24d9:	mov    rax,QWORD PTR [rbp-0x28]
    24dd:	mov    rdx,rax
    24e0:	mov    rax,QWORD PTR [rbp-0x50]
    24e4:	mov    rsi,rdx
    24e7:	mov    rdi,rax
    24ea:	call   209e <parser_advance>
    24ef:	jmp    2647 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    24f4:	mov    rax,QWORD PTR [rbp-0x50]
    24f8:	mov    rcx,QWORD PTR [rax+0x10]
    24fc:	lea    rdx,[rip+0x1fc5]        # 44c8 <_IO_stdin_used+0x4c8>
    2503:	lea    rax,[rip+0x1f55]        # 445f <_IO_stdin_used+0x45f>
    250a:	mov    r8,rcx
    250d:	mov    rcx,rdx
    2510:	mov    edx,0xdf
    2515:	mov    rsi,rax
    2518:	mov    edi,0x1
    251d:	mov    eax,0x0
    2522:	call   14a1 <log_message>
        }
      }
      break;
    2527:	jmp    2647 <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    252c:	lea    rax,[rip+0x1fc2]        # 44f5 <_IO_stdin_used+0x4f5>
    2533:	mov    QWORD PTR [rbp-0x30],rax
    2537:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    253f:	mov    rcx,QWORD PTR [rbp-0x30]
    2543:	mov    rdx,QWORD PTR [rbp-0x28]
    2547:	mov    rax,QWORD PTR [rbp-0x50]
    254b:	mov    rsi,rcx
    254e:	mov    rdi,rax
    2551:	call   20e4 <parser_token_is_literal>
    2556:	test   al,al
    2558:	je     257c <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    255a:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    2561:	mov    rax,QWORD PTR [rbp-0x28]
    2565:	mov    rdx,rax
    2568:	mov    rax,QWORD PTR [rbp-0x50]
    256c:	mov    rsi,rdx
    256f:	mov    rdi,rax
    2572:	call   209e <parser_advance>
    2577:	jmp    2647 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    257c:	mov    rax,QWORD PTR [rbp-0x50]
    2580:	mov    rcx,QWORD PTR [rax+0x10]
    2584:	lea    rdx,[rip+0x1f3d]        # 44c8 <_IO_stdin_used+0x4c8>
    258b:	lea    rax,[rip+0x1ecd]        # 445f <_IO_stdin_used+0x45f>
    2592:	mov    r8,rcx
    2595:	mov    rcx,rdx
    2598:	mov    edx,0xee
    259d:	mov    rsi,rax
    25a0:	mov    edi,0x1
    25a5:	mov    eax,0x0
    25aa:	call   14a1 <log_message>
        }
      }
      break;
    25af:	jmp    2647 <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    25b4:	lea    rax,[rip+0x1f40]        # 44fb <_IO_stdin_used+0x4fb>
    25bb:	mov    QWORD PTR [rbp-0x30],rax
    25bf:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25c7:	mov    rcx,QWORD PTR [rbp-0x30]
    25cb:	mov    rdx,QWORD PTR [rbp-0x28]
    25cf:	mov    rax,QWORD PTR [rbp-0x50]
    25d3:	mov    rsi,rcx
    25d6:	mov    rdi,rax
    25d9:	call   20e4 <parser_token_is_literal>
    25de:	test   al,al
    25e0:	je     2601 <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    25e2:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    25e9:	mov    rax,QWORD PTR [rbp-0x28]
    25ed:	mov    rdx,rax
    25f0:	mov    rax,QWORD PTR [rbp-0x50]
    25f4:	mov    rsi,rdx
    25f7:	mov    rdi,rax
    25fa:	call   209e <parser_advance>
    25ff:	jmp    2647 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2601:	mov    rax,QWORD PTR [rbp-0x50]
    2605:	mov    rcx,QWORD PTR [rax+0x10]
    2609:	lea    rdx,[rip+0x1eb8]        # 44c8 <_IO_stdin_used+0x4c8>
    2610:	lea    rax,[rip+0x1e48]        # 445f <_IO_stdin_used+0x45f>
    2617:	mov    r8,rcx
    261a:	mov    rcx,rdx
    261d:	mov    edx,0xfd
    2622:	mov    rsi,rax
    2625:	mov    edi,0x1
    262a:	mov    eax,0x0
    262f:	call   14a1 <log_message>
        }
      }
      break;
    2634:	jmp    2647 <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    2636:	mov    rax,QWORD PTR [rbp-0x50]
    263a:	mov    esi,0x1
    263f:	mov    rdi,rax
    2642:	call   209e <parser_advance>
  }

  return token;
    2647:	mov    rcx,QWORD PTR [rbp-0x48]
    264b:	mov    rax,QWORD PTR [rbp-0x20]
    264f:	mov    rdx,QWORD PTR [rbp-0x18]
    2653:	mov    QWORD PTR [rcx],rax
    2656:	mov    QWORD PTR [rcx+0x8],rdx
    265a:	mov    rax,QWORD PTR [rbp-0x10]
    265e:	mov    QWORD PTR [rcx+0x10],rax
}
    2662:	mov    rax,QWORD PTR [rbp-0x48]
    2666:	leave
    2667:	ret

0000000000002668 <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    2668:	push   rbp
    2669:	mov    rbp,rsp
    266c:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    266f:	cmp    DWORD PTR [rbp-0x14],0x7
    2673:	je     268d <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2675:	cmp    DWORD PTR [rbp-0x14],0x9
    2679:	je     268d <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    267b:	cmp    DWORD PTR [rbp-0x14],0xa
    267f:	je     268d <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    2681:	cmp    DWORD PTR [rbp-0x14],0xb
    2685:	je     268d <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    2687:	cmp    DWORD PTR [rbp-0x14],0x8
    268b:	jne    2694 <json_token_type_is_value_type+0x2c>
    268d:	mov    eax,0x1
    2692:	jmp    2699 <json_token_type_is_value_type+0x31>
    2694:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2699:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    269c:	mov    eax,DWORD PTR [rbp-0x4]
}
    269f:	pop    rbp
    26a0:	ret

00000000000026a1 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    26a1:	push   rbp
    26a2:	mov    rbp,rsp
    26a5:	push   rbx
    26a6:	sub    rsp,0x88
    26ad:	mov    QWORD PTR [rbp-0x78],rdi
    26b1:	mov    QWORD PTR [rbp-0x80],rsi
    26b5:	mov    QWORD PTR [rbp-0x90],rdx
    26bc:	mov    QWORD PTR [rbp-0x88],rcx
    26c3:	mov    rax,QWORD PTR fs:0x28
    26cc:	mov    QWORD PTR [rbp-0x18],rax
    26d0:	xor    eax,eax
  profile_begin_func();
    26d2:	lea    r8,[rip+0x2127]        # 4800 <__func__.4>
    26d9:	mov    r9d,0x11
    26df:	lea    rax,[rbp-0x50]
    26e3:	mov    rsi,r8
    26e6:	mov    rdx,r9
    26e9:	mov    r8d,0x0
    26ef:	mov    ecx,0x1
    26f4:	mov    rdi,rax
    26f7:	call   1e47 <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    26fc:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2704:	mov    eax,DWORD PTR [rbp+0x10]
    2707:	cmp    eax,0x1
    270a:	jne    2736 <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    270c:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    2713:	mov    edx,DWORD PTR [rbp-0x64]
    2716:	mov    rsi,QWORD PTR [rbp-0x80]
    271a:	mov    rax,QWORD PTR [rbp-0x78]
    271e:	mov    ecx,edx
    2720:	mov    edx,0x2
    2725:	mov    rdi,rax
    2728:	call   2888 <parse_json_children>
    272d:	mov    QWORD PTR [rbp-0x60],rax
    2731:	jmp    27c0 <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2736:	mov    eax,DWORD PTR [rbp+0x10]
    2739:	cmp    eax,0x3
    273c:	jne    2765 <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    273e:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2745:	mov    edx,DWORD PTR [rbp-0x68]
    2748:	mov    rsi,QWORD PTR [rbp-0x80]
    274c:	mov    rax,QWORD PTR [rbp-0x78]
    2750:	mov    ecx,edx
    2752:	mov    edx,0x4
    2757:	mov    rdi,rax
    275a:	call   2888 <parse_json_children>
    275f:	mov    QWORD PTR [rbp-0x60],rax
    2763:	jmp    27c0 <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    2765:	mov    eax,DWORD PTR [rbp+0x10]
    2768:	mov    edi,eax
    276a:	call   2668 <json_token_type_is_value_type>
    276f:	test   eax,eax
    2771:	jne    27c0 <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2773:	mov    eax,DWORD PTR [rbp+0x10]
    2776:	mov    eax,eax
    2778:	lea    rdx,[rax*8+0x0]
    2780:	lea    rax,[rip+0x3959]        # 60e0 <JSON_Token_Type_strings>
    2787:	mov    rcx,QWORD PTR [rdx+rax*1]
    278b:	lea    rdx,[rip+0x1d6e]        # 4500 <_IO_stdin_used+0x500>
    2792:	lea    rax,[rip+0x1cc6]        # 445f <_IO_stdin_used+0x45f>
    2799:	push   QWORD PTR [rbp+0x20]
    279c:	push   QWORD PTR [rbp+0x18]
    279f:	mov    r8,rcx
    27a2:	mov    rcx,rdx
    27a5:	mov    edx,0x134
    27aa:	mov    rsi,rax
    27ad:	mov    edi,0x1
    27b2:	mov    eax,0x0
    27b7:	call   14a1 <log_message>
    27bc:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    27c0:	mov    rax,QWORD PTR [rbp-0x78]
    27c4:	mov    edx,0x8
    27c9:	mov    esi,0x30
    27ce:	mov    rdi,rax
    27d1:	call   17d3 <arena_alloc>
    27d6:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    27da:	mov    rcx,QWORD PTR [rbp-0x58]
    27de:	mov    rax,QWORD PTR [rbp-0x90]
    27e5:	mov    rdx,QWORD PTR [rbp-0x88]
    27ec:	mov    QWORD PTR [rcx],rax
    27ef:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    27f3:	mov    rax,QWORD PTR [rbp-0x58]
    27f7:	mov    rdx,QWORD PTR [rbp-0x60]
    27fb:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    27ff:	mov    rax,QWORD PTR [rbp-0x58]
    2803:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    280b:	mov    rcx,QWORD PTR [rbp-0x58]
    280f:	mov    rax,QWORD PTR [rbp+0x18]
    2813:	mov    rdx,QWORD PTR [rbp+0x20]
    2817:	mov    QWORD PTR [rcx+0x10],rax
    281b:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    281f:	sub    rsp,0x8
    2823:	sub    rsp,0x38
    2827:	mov    rax,rsp
    282a:	mov    rcx,QWORD PTR [rbp-0x50]
    282e:	mov    rbx,QWORD PTR [rbp-0x48]
    2832:	mov    QWORD PTR [rax],rcx
    2835:	mov    QWORD PTR [rax+0x8],rbx
    2839:	mov    rcx,QWORD PTR [rbp-0x40]
    283d:	mov    rbx,QWORD PTR [rbp-0x38]
    2841:	mov    QWORD PTR [rax+0x10],rcx
    2845:	mov    QWORD PTR [rax+0x18],rbx
    2849:	mov    rcx,QWORD PTR [rbp-0x30]
    284d:	mov    rbx,QWORD PTR [rbp-0x28]
    2851:	mov    QWORD PTR [rax+0x20],rcx
    2855:	mov    QWORD PTR [rax+0x28],rbx
    2859:	mov    rdx,QWORD PTR [rbp-0x20]
    285d:	mov    QWORD PTR [rax+0x30],rdx
    2861:	call   1f31 <__profile_end_pass>
    2866:	add    rsp,0x40

  return result;
    286a:	mov    rax,QWORD PTR [rbp-0x58]
}
    286e:	mov    rdx,QWORD PTR [rbp-0x18]
    2872:	sub    rdx,QWORD PTR fs:0x28
    287b:	je     2882 <parse_json_object+0x1e1>
    287d:	call   1060 <__stack_chk_fail@plt>
    2882:	mov    rbx,QWORD PTR [rbp-0x8]
    2886:	leave
    2887:	ret

0000000000002888 <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    2888:	push   rbp
    2889:	mov    rbp,rsp
    288c:	push   rbx
    288d:	sub    rsp,0x108
    2894:	mov    QWORD PTR [rbp-0xd8],rdi
    289b:	mov    QWORD PTR [rbp-0xe0],rsi
    28a2:	mov    DWORD PTR [rbp-0xe4],edx
    28a8:	mov    DWORD PTR [rbp-0xe8],ecx
    28ae:	mov    rax,QWORD PTR fs:0x28
    28b7:	mov    QWORD PTR [rbp-0x18],rax
    28bb:	xor    eax,eax
  profile_begin_func();
    28bd:	lea    r8,[rip+0x1f5c]        # 4820 <__func__.3>
    28c4:	mov    r9d,0x13
    28ca:	lea    rax,[rbp-0x50]
    28ce:	mov    rsi,r8
    28d1:	mov    rdx,r9
    28d4:	mov    r8d,0x0
    28da:	mov    ecx,0x2
    28df:	mov    rdi,rax
    28e2:	call   1e47 <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    28e7:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    28f2:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    28fd:	jmp    2bd6 <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2902:	pxor   xmm0,xmm0
    2906:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    290d:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2915:	pxor   xmm0,xmm0
    2919:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2920:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2925:	cmp    DWORD PTR [rbp-0xe8],0x0
    292c:	je     2a39 <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2932:	lea    rax,[rbp-0xb0]
    2939:	mov    rdx,QWORD PTR [rbp-0xe0]
    2940:	mov    rsi,rdx
    2943:	mov    rdi,rax
    2946:	call   216f <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    294b:	mov    eax,DWORD PTR [rbp-0xb0]
    2951:	cmp    eax,0x7
    2954:	jne    29d5 <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2956:	lea    rax,[rbp-0x70]
    295a:	mov    rdx,QWORD PTR [rbp-0xe0]
    2961:	mov    rsi,rdx
    2964:	mov    rdi,rax
    2967:	call   216f <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    296c:	mov    eax,DWORD PTR [rbp-0x70]
    296f:	cmp    eax,0x6
    2972:	jne    2992 <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2974:	lea    rax,[rbp-0x90]
    297b:	mov    rdx,QWORD PTR [rbp-0xe0]
    2982:	mov    rsi,rdx
    2985:	mov    rdi,rax
    2988:	call   216f <get_json_token>
    298d:	jmp    2a79 <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2992:	mov    rcx,QWORD PTR [rbp-0xa8]
    2999:	mov    rax,QWORD PTR [rbp-0xa0]
    29a0:	mov    esi,eax
    29a2:	lea    rdx,[rip+0x1ba7]        # 4550 <_IO_stdin_used+0x550>
    29a9:	lea    rax,[rip+0x1aaf]        # 445f <_IO_stdin_used+0x45f>
    29b0:	mov    r9,rcx
    29b3:	mov    r8d,esi
    29b6:	mov    rcx,rdx
    29b9:	mov    edx,0x15f
    29be:	mov    rsi,rax
    29c1:	mov    edi,0x1
    29c6:	mov    eax,0x0
    29cb:	call   14a1 <log_message>
    29d0:	jmp    2a79 <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    29d5:	mov    rcx,QWORD PTR [rbp-0xa8]
    29dc:	mov    rax,QWORD PTR [rbp-0xa0]
    29e3:	mov    edi,eax
    29e5:	mov    eax,DWORD PTR [rbp-0xb0]
    29eb:	mov    eax,eax
    29ed:	lea    rdx,[rax*8+0x0]
    29f5:	lea    rax,[rip+0x36e4]        # 60e0 <JSON_Token_Type_strings>
    29fc:	mov    rsi,QWORD PTR [rdx+rax*1]
    2a00:	lea    rdx,[rip+0x1b69]        # 4570 <_IO_stdin_used+0x570>
    2a07:	lea    rax,[rip+0x1a51]        # 445f <_IO_stdin_used+0x45f>
    2a0e:	sub    rsp,0x8
    2a12:	push   rcx
    2a13:	mov    r9d,edi
    2a16:	mov    r8,rsi
    2a19:	mov    rcx,rdx
    2a1c:	mov    edx,0x164
    2a21:	mov    rsi,rax
    2a24:	mov    edi,0x1
    2a29:	mov    eax,0x0
    2a2e:	call   14a1 <log_message>
    2a33:	add    rsp,0x10
    2a37:	jmp    2a79 <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2a39:	lea    rax,[rbp-0x110]
    2a40:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a47:	mov    rsi,rdx
    2a4a:	mov    rdi,rax
    2a4d:	call   216f <get_json_token>
    2a52:	mov    rax,QWORD PTR [rbp-0x110]
    2a59:	mov    rdx,QWORD PTR [rbp-0x108]
    2a60:	mov    QWORD PTR [rbp-0x90],rax
    2a67:	mov    QWORD PTR [rbp-0x88],rdx
    2a6e:	mov    rax,QWORD PTR [rbp-0x100]
    2a75:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2a79:	mov    eax,DWORD PTR [rbp-0x90]
    2a7f:	cmp    DWORD PTR [rbp-0xe4],eax
    2a85:	je     2bef <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2a8b:	mov    rax,QWORD PTR [rbp-0xa8]
    2a92:	mov    rdx,QWORD PTR [rbp-0xa0]
    2a99:	mov    r8,QWORD PTR [rbp-0xe0]
    2aa0:	mov    rdi,QWORD PTR [rbp-0xd8]
    2aa7:	sub    rsp,0x8
    2aab:	sub    rsp,0x18
    2aaf:	mov    rsi,rsp
    2ab2:	mov    rcx,QWORD PTR [rbp-0x90]
    2ab9:	mov    rbx,QWORD PTR [rbp-0x88]
    2ac0:	mov    QWORD PTR [rsi],rcx
    2ac3:	mov    QWORD PTR [rsi+0x8],rbx
    2ac7:	mov    rcx,QWORD PTR [rbp-0x80]
    2acb:	mov    QWORD PTR [rsi+0x10],rcx
    2acf:	mov    rcx,rdx
    2ad2:	mov    rdx,rax
    2ad5:	mov    rsi,r8
    2ad8:	call   26a1 <parse_json_object>
    2add:	add    rsp,0x20
    2ae1:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2ae8:	cmp    QWORD PTR [rbp-0xb8],0x0
    2af0:	je     2b3a <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2af2:	cmp    QWORD PTR [rbp-0xc8],0x0
    2afa:	jne    2b1a <parse_json_children+0x292>
      {
        first_child        = object;
    2afc:	mov    rax,QWORD PTR [rbp-0xb8]
    2b03:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2b0a:	mov    rax,QWORD PTR [rbp-0xb8]
    2b11:	mov    QWORD PTR [rbp-0xc0],rax
    2b18:	jmp    2b3a <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2b1a:	mov    rax,QWORD PTR [rbp-0xc0]
    2b21:	mov    rdx,QWORD PTR [rbp-0xb8]
    2b28:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2b2c:	mov    rax,QWORD PTR [rbp-0xb8]
    2b33:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2b3a:	lea    rax,[rbp-0x70]
    2b3e:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b45:	mov    rsi,rdx
    2b48:	mov    rdi,rax
    2b4b:	call   216f <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2b50:	mov    eax,DWORD PTR [rbp-0x70]
    2b53:	cmp    DWORD PTR [rbp-0xe4],eax
    2b59:	je     2bf2 <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2b5f:	mov    eax,DWORD PTR [rbp-0x70]
    2b62:	cmp    eax,0x5
    2b65:	je     2bd6 <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2b67:	mov    r8,QWORD PTR [rbp-0x68]
    2b6b:	mov    rax,QWORD PTR [rbp-0x60]
    2b6f:	mov    r9d,eax
    2b72:	mov    eax,DWORD PTR [rbp-0x70]
    2b75:	mov    eax,eax
    2b77:	lea    rdx,[rax*8+0x0]
    2b7f:	lea    rax,[rip+0x355a]        # 60e0 <JSON_Token_Type_strings>
    2b86:	mov    r10,QWORD PTR [rdx+rax*1]
    2b8a:	lea    rdi,[rip+0x1a07]        # 4598 <_IO_stdin_used+0x598>
    2b91:	lea    rsi,[rip+0x18c7]        # 445f <_IO_stdin_used+0x45f>
    2b98:	sub    rsp,0x18
    2b9c:	mov    rcx,rsp
    2b9f:	mov    rax,QWORD PTR [rbp-0x70]
    2ba3:	mov    rdx,QWORD PTR [rbp-0x68]
    2ba7:	mov    QWORD PTR [rcx],rax
    2baa:	mov    QWORD PTR [rcx+0x8],rdx
    2bae:	mov    rax,QWORD PTR [rbp-0x60]
    2bb2:	mov    QWORD PTR [rcx+0x10],rax
    2bb6:	push   r8
    2bb8:	mov    r8,r10
    2bbb:	mov    rcx,rdi
    2bbe:	mov    edx,0x18b
    2bc3:	mov    edi,0x1
    2bc8:	mov    eax,0x0
    2bcd:	call   14a1 <log_message>
    2bd2:	add    rsp,0x20
  while (parser_incomplete(parser))
    2bd6:	mov    rax,QWORD PTR [rbp-0xe0]
    2bdd:	mov    rdi,rax
    2be0:	call   20c4 <parser_incomplete>
    2be5:	test   al,al
    2be7:	jne    2902 <parse_json_children+0x7a>
    2bed:	jmp    2bf3 <parse_json_children+0x36b>
      break;
    2bef:	nop
    2bf0:	jmp    2bf3 <parse_json_children+0x36b>
      break;
    2bf2:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2bf3:	sub    rsp,0x8
    2bf7:	sub    rsp,0x38
    2bfb:	mov    rax,rsp
    2bfe:	mov    rcx,QWORD PTR [rbp-0x50]
    2c02:	mov    rbx,QWORD PTR [rbp-0x48]
    2c06:	mov    QWORD PTR [rax],rcx
    2c09:	mov    QWORD PTR [rax+0x8],rbx
    2c0d:	mov    rcx,QWORD PTR [rbp-0x40]
    2c11:	mov    rbx,QWORD PTR [rbp-0x38]
    2c15:	mov    QWORD PTR [rax+0x10],rcx
    2c19:	mov    QWORD PTR [rax+0x18],rbx
    2c1d:	mov    rcx,QWORD PTR [rbp-0x30]
    2c21:	mov    rbx,QWORD PTR [rbp-0x28]
    2c25:	mov    QWORD PTR [rax+0x20],rcx
    2c29:	mov    QWORD PTR [rax+0x28],rbx
    2c2d:	mov    rdx,QWORD PTR [rbp-0x20]
    2c31:	mov    QWORD PTR [rax+0x30],rdx
    2c35:	call   1f31 <__profile_end_pass>
    2c3a:	add    rsp,0x40

  return first_child;
    2c3e:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2c45:	mov    rdx,QWORD PTR [rbp-0x18]
    2c49:	sub    rdx,QWORD PTR fs:0x28
    2c52:	je     2c59 <parse_json_children+0x3d1>
    2c54:	call   1060 <__stack_chk_fail@plt>
    2c59:	mov    rbx,QWORD PTR [rbp-0x8]
    2c5d:	leave
    2c5e:	ret

0000000000002c5f <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2c5f:	push   rbp
    2c60:	mov    rbp,rsp
    2c63:	push   rbx
    2c64:	sub    rsp,0xb8
    2c6b:	mov    QWORD PTR [rbp-0xa8],rdi
    2c72:	mov    rax,rsi
    2c75:	mov    rsi,rdx
    2c78:	mov    rax,rax
    2c7b:	mov    edx,0x0
    2c80:	mov    rdx,rsi
    2c83:	mov    QWORD PTR [rbp-0xc0],rax
    2c8a:	mov    QWORD PTR [rbp-0xb8],rdx
    2c91:	mov    rax,QWORD PTR fs:0x28
    2c9a:	mov    QWORD PTR [rbp-0x18],rax
    2c9e:	xor    eax,eax
  profile_begin_func();
    2ca0:	lea    rcx,[rip+0x1b91]        # 4838 <__func__.2>
    2ca7:	mov    ebx,0xa
    2cac:	lea    rax,[rbp-0x50]
    2cb0:	mov    rsi,rcx
    2cb3:	mov    rdx,rbx
    2cb6:	mov    r8d,0x0
    2cbc:	mov    ecx,0x3
    2cc1:	mov    rdi,rax
    2cc4:	call   1e47 <__profile_begin_pass>

  JSON_Parser parser =
    2cc9:	mov    rax,QWORD PTR [rbp-0xc0]
    2cd0:	mov    rdx,QWORD PTR [rbp-0xb8]
    2cd7:	mov    QWORD PTR [rbp-0x90],rax
    2cde:	mov    QWORD PTR [rbp-0x88],rdx
    2ce5:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2ced:	lea    rax,[rbp-0x70]
    2cf1:	lea    rdx,[rbp-0x90]
    2cf8:	mov    rsi,rdx
    2cfb:	mov    rdi,rax
    2cfe:	call   216f <get_json_token>
    2d03:	mov    ecx,0x0
    2d08:	mov    ebx,0x0
    2d0d:	lea    r8,[rbp-0x90]
    2d14:	mov    rdi,QWORD PTR [rbp-0xa8]
    2d1b:	sub    rsp,0x8
    2d1f:	sub    rsp,0x18
    2d23:	mov    rsi,rsp
    2d26:	mov    rax,QWORD PTR [rbp-0x70]
    2d2a:	mov    rdx,QWORD PTR [rbp-0x68]
    2d2e:	mov    QWORD PTR [rsi],rax
    2d31:	mov    QWORD PTR [rsi+0x8],rdx
    2d35:	mov    rax,QWORD PTR [rbp-0x60]
    2d39:	mov    QWORD PTR [rsi+0x10],rax
    2d3d:	mov    rdx,rcx
    2d40:	mov    rcx,rbx
    2d43:	mov    rsi,r8
    2d46:	call   26a1 <parse_json_object>
    2d4b:	add    rsp,0x20
    2d4f:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2d56:	sub    rsp,0x8
    2d5a:	sub    rsp,0x38
    2d5e:	mov    rax,rsp
    2d61:	mov    rcx,QWORD PTR [rbp-0x50]
    2d65:	mov    rbx,QWORD PTR [rbp-0x48]
    2d69:	mov    QWORD PTR [rax],rcx
    2d6c:	mov    QWORD PTR [rax+0x8],rbx
    2d70:	mov    rcx,QWORD PTR [rbp-0x40]
    2d74:	mov    rbx,QWORD PTR [rbp-0x38]
    2d78:	mov    QWORD PTR [rax+0x10],rcx
    2d7c:	mov    QWORD PTR [rax+0x18],rbx
    2d80:	mov    rcx,QWORD PTR [rbp-0x30]
    2d84:	mov    rbx,QWORD PTR [rbp-0x28]
    2d88:	mov    QWORD PTR [rax+0x20],rcx
    2d8c:	mov    QWORD PTR [rax+0x28],rbx
    2d90:	mov    rdx,QWORD PTR [rbp-0x20]
    2d94:	mov    QWORD PTR [rax+0x30],rdx
    2d98:	call   1f31 <__profile_end_pass>
    2d9d:	add    rsp,0x40

  return outer;
    2da1:	mov    rax,QWORD PTR [rbp-0x98]
}
    2da8:	mov    rdx,QWORD PTR [rbp-0x18]
    2dac:	sub    rdx,QWORD PTR fs:0x28
    2db5:	je     2dbc <parse_json+0x15d>
    2db7:	call   1060 <__stack_chk_fail@plt>
    2dbc:	mov    rbx,QWORD PTR [rbp-0x8]
    2dc0:	leave
    2dc1:	ret

0000000000002dc2 <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2dc2:	push   rbp
    2dc3:	mov    rbp,rsp
    2dc6:	push   rbx
    2dc7:	sub    rsp,0x78
    2dcb:	mov    QWORD PTR [rbp-0x68],rdi
    2dcf:	mov    rax,rsi
    2dd2:	mov    rsi,rdx
    2dd5:	mov    rax,rax
    2dd8:	mov    edx,0x0
    2ddd:	mov    rdx,rsi
    2de0:	mov    QWORD PTR [rbp-0x80],rax
    2de4:	mov    QWORD PTR [rbp-0x78],rdx
    2de8:	mov    rax,QWORD PTR fs:0x28
    2df1:	mov    QWORD PTR [rbp-0x18],rax
    2df5:	xor    eax,eax
  profile_begin_func();
    2df7:	lea    rcx,[rip+0x1a52]        # 4850 <__func__.1>
    2dfe:	mov    ebx,0x12
    2e03:	lea    rax,[rbp-0x50]
    2e07:	mov    rsi,rcx
    2e0a:	mov    rdx,rbx
    2e0d:	mov    r8d,0x0
    2e13:	mov    ecx,0x4
    2e18:	mov    rdi,rax
    2e1b:	call   1e47 <__profile_begin_pass>

  JSON_Object *result = NULL;
    2e20:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2e28:	cmp    QWORD PTR [rbp-0x68],0x0
    2e2d:	je     2e7c <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2e2f:	mov    rax,QWORD PTR [rbp-0x68]
    2e33:	mov    rax,QWORD PTR [rax+0x20]
    2e37:	mov    QWORD PTR [rbp-0x58],rax
    2e3b:	jmp    2e75 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2e3d:	mov    rax,QWORD PTR [rbp-0x58]
    2e41:	mov    rdx,QWORD PTR [rax+0x8]
    2e45:	mov    rax,QWORD PTR [rax]
    2e48:	mov    rdi,QWORD PTR [rbp-0x80]
    2e4c:	mov    rsi,QWORD PTR [rbp-0x78]
    2e50:	mov    rcx,rdx
    2e53:	mov    rdx,rax
    2e56:	call   143f <strings_equal>
    2e5b:	test   al,al
    2e5d:	je     2e69 <lookup_json_object+0xa7>
      {
        result = cursor;
    2e5f:	mov    rax,QWORD PTR [rbp-0x58]
    2e63:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2e67:	jmp    2e7c <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2e69:	mov    rax,QWORD PTR [rbp-0x58]
    2e6d:	mov    rax,QWORD PTR [rax+0x28]
    2e71:	mov    QWORD PTR [rbp-0x58],rax
    2e75:	cmp    QWORD PTR [rbp-0x58],0x0
    2e7a:	jne    2e3d <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2e7c:	sub    rsp,0x8
    2e80:	sub    rsp,0x38
    2e84:	mov    rax,rsp
    2e87:	mov    rcx,QWORD PTR [rbp-0x50]
    2e8b:	mov    rbx,QWORD PTR [rbp-0x48]
    2e8f:	mov    QWORD PTR [rax],rcx
    2e92:	mov    QWORD PTR [rax+0x8],rbx
    2e96:	mov    rcx,QWORD PTR [rbp-0x40]
    2e9a:	mov    rbx,QWORD PTR [rbp-0x38]
    2e9e:	mov    QWORD PTR [rax+0x10],rcx
    2ea2:	mov    QWORD PTR [rax+0x18],rbx
    2ea6:	mov    rcx,QWORD PTR [rbp-0x30]
    2eaa:	mov    rbx,QWORD PTR [rbp-0x28]
    2eae:	mov    QWORD PTR [rax+0x20],rcx
    2eb2:	mov    QWORD PTR [rax+0x28],rbx
    2eb6:	mov    rdx,QWORD PTR [rbp-0x20]
    2eba:	mov    QWORD PTR [rax+0x30],rdx
    2ebe:	call   1f31 <__profile_end_pass>
    2ec3:	add    rsp,0x40

  return result;
    2ec7:	mov    rax,QWORD PTR [rbp-0x60]
}
    2ecb:	mov    rdx,QWORD PTR [rbp-0x18]
    2ecf:	sub    rdx,QWORD PTR fs:0x28
    2ed8:	je     2edf <lookup_json_object+0x11d>
    2eda:	call   1060 <__stack_chk_fail@plt>
    2edf:	mov    rbx,QWORD PTR [rbp-0x8]
    2ee3:	leave
    2ee4:	ret

0000000000002ee5 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    2ee5:	push   rbp
    2ee6:	mov    rbp,rsp
    2ee9:	sub    rsp,0x50
    2eed:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    2ef1:	cmp    QWORD PTR [rbp-0x48],0x0
    2ef6:	jne    2f1d <json_object_to_f64+0x38>
    2ef8:	lea    rdx,[rip+0x1971]        # 4870 <__PRETTY_FUNCTION__.0>
    2eff:	lea    rsi,[rip+0x1559]        # 445f <_IO_stdin_used+0x45f>
    2f06:	lea    rax,[rip+0x16cb]        # 45d8 <_IO_stdin_used+0x5d8>
    2f0d:	mov    rcx,rdx
    2f10:	mov    edx,0x1c2
    2f15:	mov    rdi,rax
    2f18:	call   1090 <__assert_fail@plt>

  String val = object->value;
    2f1d:	mov    rax,QWORD PTR [rbp-0x48]
    2f21:	mov    rdx,QWORD PTR [rax+0x18]
    2f25:	mov    rax,QWORD PTR [rax+0x10]
    2f29:	mov    QWORD PTR [rbp-0x10],rax
    2f2d:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    2f31:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    2f39:	movsd  xmm0,QWORD PTR [rip+0x1957]        # 4898 <__PRETTY_FUNCTION__.0+0x28>
    2f41:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    2f46:	mov    rax,QWORD PTR [rbp-0x8]
    2f4a:	cmp    QWORD PTR [rbp-0x30],rax
    2f4e:	jae    2f74 <json_object_to_f64+0x8f>
    2f50:	mov    rdx,QWORD PTR [rbp-0x10]
    2f54:	mov    rax,QWORD PTR [rbp-0x30]
    2f58:	add    rax,rdx
    2f5b:	movzx  eax,BYTE PTR [rax]
    2f5e:	cmp    al,0x2d
    2f60:	jne    2f74 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    2f62:	movsd  xmm0,QWORD PTR [rip+0x1936]        # 48a0 <__PRETTY_FUNCTION__.0+0x30>
    2f6a:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    2f6f:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    2f74:	pxor   xmm0,xmm0
    2f78:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    2f7d:	jmp    2fc4 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    2f7f:	mov    rdx,QWORD PTR [rbp-0x10]
    2f83:	mov    rax,QWORD PTR [rbp-0x30]
    2f87:	add    rax,rdx
    2f8a:	movzx  eax,BYTE PTR [rax]
    2f8d:	sub    eax,0x30
    2f90:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    2f93:	cmp    BYTE PTR [rbp-0x32],0x9
    2f97:	ja     2fd0 <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    2f99:	movsd  xmm1,QWORD PTR [rbp-0x20]
    2f9e:	movsd  xmm0,QWORD PTR [rip+0x1902]        # 48a8 <__PRETTY_FUNCTION__.0+0x38>
    2fa6:	mulsd  xmm1,xmm0
    2faa:	movzx  eax,BYTE PTR [rbp-0x32]
    2fae:	pxor   xmm0,xmm0
    2fb2:	cvtsi2sd xmm0,eax
    2fb6:	addsd  xmm0,xmm1
    2fba:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    2fbf:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    2fc4:	mov    rax,QWORD PTR [rbp-0x8]
    2fc8:	cmp    QWORD PTR [rbp-0x30],rax
    2fcc:	jb     2f7f <json_object_to_f64+0x9a>
    2fce:	jmp    2fd1 <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    2fd0:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    2fd1:	mov    rax,QWORD PTR [rbp-0x8]
    2fd5:	cmp    QWORD PTR [rbp-0x30],rax
    2fd9:	jae    3066 <json_object_to_f64+0x181>
    2fdf:	mov    rdx,QWORD PTR [rbp-0x10]
    2fe3:	mov    rax,QWORD PTR [rbp-0x30]
    2fe7:	add    rax,rdx
    2fea:	movzx  eax,BYTE PTR [rax]
    2fed:	cmp    al,0x2e
    2fef:	jne    3066 <json_object_to_f64+0x181>
  {
    at += 1;
    2ff1:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    2ff6:	movsd  xmm0,QWORD PTR [rip+0x18b2]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    2ffe:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    3003:	jmp    3059 <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3005:	mov    rdx,QWORD PTR [rbp-0x10]
    3009:	mov    rax,QWORD PTR [rbp-0x30]
    300d:	add    rax,rdx
    3010:	movzx  eax,BYTE PTR [rax]
    3013:	sub    eax,0x30
    3016:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    3019:	cmp    BYTE PTR [rbp-0x31],0x9
    301d:	ja     3065 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    301f:	movzx  eax,BYTE PTR [rbp-0x31]
    3023:	pxor   xmm0,xmm0
    3027:	cvtsi2sd xmm0,eax
    302b:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    3030:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3035:	addsd  xmm0,xmm1
    3039:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    303e:	movsd  xmm1,QWORD PTR [rbp-0x18]
    3043:	movsd  xmm0,QWORD PTR [rip+0x1865]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    304b:	mulsd  xmm0,xmm1
    304f:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3054:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    3059:	mov    rax,QWORD PTR [rbp-0x8]
    305d:	cmp    QWORD PTR [rbp-0x30],rax
    3061:	jb     3005 <json_object_to_f64+0x120>
    3063:	jmp    3066 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    3065:	nop
      }
    }
  }

  return sign * result;
    3066:	movsd  xmm0,QWORD PTR [rbp-0x28]
    306b:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    3070:	leave
    3071:	ret

0000000000003072 <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    3072:	push   rbp
    3073:	mov    rbp,rsp
    3076:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    307b:	movsd  xmm0,QWORD PTR [rbp-0x8]
    3080:	movsd  xmm1,QWORD PTR [rip+0x1830]        # 48b8 <__PRETTY_FUNCTION__.0+0x48>
    3088:	divsd  xmm0,xmm1
}
    308c:	pop    rbp
    308d:	ret

000000000000308e <square>:

static
f64 square(f64 x)
{
    308e:	push   rbp
    308f:	mov    rbp,rsp
    3092:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    3097:	movsd  xmm0,QWORD PTR [rbp-0x8]
    309c:	mulsd  xmm0,xmm0
}
    30a0:	pop    rbp
    30a1:	ret

00000000000030a2 <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    30a2:	push   rbp
    30a3:	mov    rbp,rsp
    30a6:	sub    rsp,0x90
    30ad:	movsd  QWORD PTR [rbp-0x58],xmm0
    30b2:	movsd  QWORD PTR [rbp-0x60],xmm1
    30b7:	movsd  QWORD PTR [rbp-0x68],xmm2
    30bc:	movsd  QWORD PTR [rbp-0x70],xmm3
    30c1:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    30c6:	movsd  xmm0,QWORD PTR [rbp-0x60]
    30cb:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    30d0:	movsd  xmm0,QWORD PTR [rbp-0x70]
    30d5:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    30da:	movsd  xmm0,QWORD PTR [rbp-0x58]
    30df:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    30e4:	movsd  xmm0,QWORD PTR [rbp-0x68]
    30e9:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    30ee:	movsd  xmm0,QWORD PTR [rbp-0x40]
    30f3:	subsd  xmm0,QWORD PTR [rbp-0x48]
    30f8:	movq   rax,xmm0
    30fd:	movq   xmm0,rax
    3102:	call   3072 <to_radians>
    3107:	movq   rax,xmm0
    310c:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    3110:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3115:	subsd  xmm0,QWORD PTR [rbp-0x38]
    311a:	movq   rax,xmm0
    311f:	movq   xmm0,rax
    3124:	call   3072 <to_radians>
    3129:	movq   rax,xmm0
    312e:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    3132:	mov    rax,QWORD PTR [rbp-0x48]
    3136:	movq   xmm0,rax
    313b:	call   3072 <to_radians>
    3140:	movq   rax,xmm0
    3145:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    3149:	mov    rax,QWORD PTR [rbp-0x40]
    314d:	movq   xmm0,rax
    3152:	call   3072 <to_radians>
    3157:	movq   rax,xmm0
    315c:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    3160:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3165:	movsd  xmm1,QWORD PTR [rip+0x1753]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    316d:	divsd  xmm0,xmm1
    3171:	movq   rax,xmm0
    3176:	movq   xmm0,rax
    317b:	call   1130 <sin@plt>
    3180:	movq   rax,xmm0
    3185:	movq   xmm0,rax
    318a:	call   308e <square>
    318f:	movsd  QWORD PTR [rbp-0x80],xmm0
    3194:	mov    rax,QWORD PTR [rbp-0x48]
    3198:	movq   xmm0,rax
    319d:	call   10b0 <cos@plt>
    31a2:	movsd  QWORD PTR [rbp-0x88],xmm0
    31aa:	mov    rax,QWORD PTR [rbp-0x40]
    31ae:	movq   xmm0,rax
    31b3:	call   10b0 <cos@plt>
    31b8:	movapd xmm5,xmm0
    31bc:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    31c4:	movsd  QWORD PTR [rbp-0x88],xmm5
    31cc:	movsd  xmm0,QWORD PTR [rbp-0x20]
    31d1:	movsd  xmm1,QWORD PTR [rip+0x16e7]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    31d9:	movapd xmm6,xmm0
    31dd:	divsd  xmm6,xmm1
    31e1:	movq   rax,xmm6
    31e6:	movq   xmm0,rax
    31eb:	call   1130 <sin@plt>
    31f0:	movq   rax,xmm0
    31f5:	movq   xmm0,rax
    31fa:	call   308e <square>
    31ff:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    3207:	addsd  xmm0,QWORD PTR [rbp-0x80]
    320c:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    3211:	mov    rax,QWORD PTR [rbp-0x18]
    3215:	movq   xmm0,rax
    321a:	call   1160 <sqrt@plt>
    321f:	movq   rax,xmm0
    3224:	movq   xmm0,rax
    3229:	call   1140 <asin@plt>
    322e:	addsd  xmm0,xmm0
    3232:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    3237:	movsd  xmm0,QWORD PTR [rbp-0x78]
    323c:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    3241:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3246:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    324b:	leave
    324c:	ret

000000000000324d <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    324d:	push   rbp
    324e:	mov    rbp,rsp
    3251:	movsd  QWORD PTR [rbp-0x18],xmm0
    3256:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    325b:	movsd  xmm0,QWORD PTR [rip+0x1665]        # 48c8 <__PRETTY_FUNCTION__.0+0x58>
    3263:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    3268:	movsd  xmm0,QWORD PTR [rbp-0x18]
    326d:	movq   xmm1,QWORD PTR [rip+0x165b]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    3275:	andpd  xmm0,xmm1
    3279:	movsd  xmm1,QWORD PTR [rbp-0x20]
    327e:	movq   xmm2,QWORD PTR [rip+0x164a]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    3286:	andpd  xmm2,xmm1
    328a:	movapd xmm1,xmm0
    328e:	subsd  xmm1,xmm2
    3292:	movsd  xmm0,QWORD PTR [rbp-0x8]
    3297:	comisd xmm0,xmm1
    329b:	setae  al
    329e:	movzx  eax,al
}
    32a1:	pop    rbp
    32a2:	ret

00000000000032a3 <main>:

int main(int args_count, char **args)
{
    32a3:	push   rbp
    32a4:	mov    rbp,rsp
    32a7:	push   r15
    32a9:	push   r14
    32ab:	push   r13
    32ad:	push   r12
    32af:	push   rbx
    32b0:	sub    rsp,0x2d8
    32b7:	mov    DWORD PTR [rbp-0x244],edi
    32bd:	mov    QWORD PTR [rbp-0x250],rsi
    32c4:	mov    rax,QWORD PTR fs:0x28
    32cd:	mov    QWORD PTR [rbp-0x38],rax
    32d1:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    32d3:	cmp    DWORD PTR [rbp-0x244],0x3
    32da:	je     3307 <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    32dc:	mov    rax,QWORD PTR [rbp-0x250]
    32e3:	mov    rax,QWORD PTR [rax]
    32e6:	lea    rdx,[rip+0x1323]        # 4610 <_IO_stdin_used+0x610>
    32ed:	mov    rsi,rax
    32f0:	mov    rdi,rdx
    32f3:	mov    eax,0x0
    32f8:	call   1070 <printf@plt>
    return 1;
    32fd:	mov    eax,0x1
    3302:	jmp    3da5 <main+0xb02>
  }

  begin_profiling();
    3307:	call   1b3d <begin_profiling>

  Arena arena = {0};
    330c:	pxor   xmm0,xmm0
    3310:	movaps XMMWORD PTR [rbp-0x190],xmm0
    3317:	movaps XMMWORD PTR [rbp-0x180],xmm0
  arena = arena_make(GB(4));
    331e:	lea    rdx,[rbp-0x270]
    3325:	movabs rax,0x100000000
    332f:	mov    rsi,rax
    3332:	mov    rdi,rdx
    3335:	call   1632 <arena_make>
    333a:	mov    rax,QWORD PTR [rbp-0x270]
    3341:	mov    rdx,QWORD PTR [rbp-0x268]
    3348:	mov    QWORD PTR [rbp-0x190],rax
    334f:	mov    QWORD PTR [rbp-0x188],rdx
    3356:	mov    rax,QWORD PTR [rbp-0x260]
    335d:	mov    rdx,QWORD PTR [rbp-0x258]
    3364:	mov    QWORD PTR [rbp-0x180],rax
    336b:	mov    QWORD PTR [rbp-0x178],rdx

  String source = {0};
    3372:	mov    QWORD PTR [rbp-0x1a0],0x0
    337d:	mov    QWORD PTR [rbp-0x198],0x0
  PROFILE_SCOPE("read")
    3388:	lea    r12,[rip+0x12ad]        # 463c <_IO_stdin_used+0x63c>
    338f:	mov    r13d,0x4
    3395:	lea    rdi,[rbp-0x170]
    339c:	mov    rdx,r12
    339f:	mov    rax,r13
    33a2:	mov    r8d,0x0
    33a8:	mov    ecx,0x5
    33ad:	mov    rsi,rdx
    33b0:	mov    rdx,rax
    33b3:	call   1e47 <__profile_begin_pass>
    33b8:	mov    QWORD PTR [rbp-0x230],0x0
    33c3:	jmp    345e <main+0x1bb>
  {
    source = read_file_to_arena(&arena, args[1]);
    33c8:	mov    rax,QWORD PTR [rbp-0x250]
    33cf:	add    rax,0x8
    33d3:	mov    rdx,QWORD PTR [rax]
    33d6:	lea    rax,[rbp-0x190]
    33dd:	mov    rsi,rdx
    33e0:	mov    rdi,rax
    33e3:	call   1357 <read_file_to_arena>
    33e8:	mov    QWORD PTR [rbp-0x1a0],rax
    33ef:	mov    QWORD PTR [rbp-0x198],rdx
  PROFILE_SCOPE("read")
    33f6:	add    QWORD PTR [rbp-0x230],0x1
    33fe:	sub    rsp,0x8
    3402:	sub    rsp,0x38
    3406:	mov    rcx,rsp
    3409:	mov    rax,QWORD PTR [rbp-0x170]
    3410:	mov    rdx,QWORD PTR [rbp-0x168]
    3417:	mov    QWORD PTR [rcx],rax
    341a:	mov    QWORD PTR [rcx+0x8],rdx
    341e:	mov    rax,QWORD PTR [rbp-0x160]
    3425:	mov    rdx,QWORD PTR [rbp-0x158]
    342c:	mov    QWORD PTR [rcx+0x10],rax
    3430:	mov    QWORD PTR [rcx+0x18],rdx
    3434:	mov    rax,QWORD PTR [rbp-0x150]
    343b:	mov    rdx,QWORD PTR [rbp-0x148]
    3442:	mov    QWORD PTR [rcx+0x20],rax
    3446:	mov    QWORD PTR [rcx+0x28],rdx
    344a:	mov    rax,QWORD PTR [rbp-0x140]
    3451:	mov    QWORD PTR [rcx+0x30],rax
    3455:	call   1f31 <__profile_end_pass>
    345a:	add    rsp,0x40
    345e:	cmp    QWORD PTR [rbp-0x230],0x0
    3466:	je     33c8 <main+0x125>
  }

  Haversine_Pair *pairs = NULL;
    346c:	mov    QWORD PTR [rbp-0x228],0x0
  i32 pair_count = 0;
    3477:	mov    DWORD PTR [rbp-0x238],0x0
  usize max_pairs = 0;
    3481:	mov    QWORD PTR [rbp-0x220],0x0
  PROFILE_SCOPE("haversine alloc")
    348c:	lea    r14,[rip+0x11ae]        # 4641 <_IO_stdin_used+0x641>
    3493:	mov    r15d,0xf
    3499:	lea    rdi,[rbp-0x130]
    34a0:	mov    rdx,r14
    34a3:	mov    rax,r15
    34a6:	mov    r8d,0x0
    34ac:	mov    ecx,0x6
    34b1:	mov    rsi,rdx
    34b4:	mov    rdx,rax
    34b7:	call   1e47 <__profile_begin_pass>
    34bc:	mov    QWORD PTR [rbp-0x218],0x0
    34c7:	jmp    358f <main+0x2ec>
  {
    usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    34cc:	mov    QWORD PTR [rbp-0x1a8],0x18
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    34d7:	mov    rax,QWORD PTR [rbp-0x198]
    34de:	mov    edx,0x0
    34e3:	div    QWORD PTR [rbp-0x1a8]
    34ea:	mov    QWORD PTR [rbp-0x220],rax

    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    34f1:	mov    rax,QWORD PTR [rbp-0x220]
    34f8:	shl    rax,0x5
    34fc:	mov    rcx,rax
    34ff:	lea    rax,[rbp-0x190]
    3506:	mov    edx,0x8
    350b:	mov    rsi,rcx
    350e:	mov    rdi,rax
    3511:	call   17d3 <arena_alloc>
    3516:	mov    QWORD PTR [rbp-0x228],rax
    pair_count = 0;
    351d:	mov    DWORD PTR [rbp-0x238],0x0
  PROFILE_SCOPE("haversine alloc")
    3527:	add    QWORD PTR [rbp-0x218],0x1
    352f:	sub    rsp,0x8
    3533:	sub    rsp,0x38
    3537:	mov    rcx,rsp
    353a:	mov    rax,QWORD PTR [rbp-0x130]
    3541:	mov    rdx,QWORD PTR [rbp-0x128]
    3548:	mov    QWORD PTR [rcx],rax
    354b:	mov    QWORD PTR [rcx+0x8],rdx
    354f:	mov    rax,QWORD PTR [rbp-0x120]
    3556:	mov    rdx,QWORD PTR [rbp-0x118]
    355d:	mov    QWORD PTR [rcx+0x10],rax
    3561:	mov    QWORD PTR [rcx+0x18],rdx
    3565:	mov    rax,QWORD PTR [rbp-0x110]
    356c:	mov    rdx,QWORD PTR [rbp-0x108]
    3573:	mov    QWORD PTR [rcx+0x20],rax
    3577:	mov    QWORD PTR [rcx+0x28],rdx
    357b:	mov    rax,QWORD PTR [rbp-0x100]
    3582:	mov    QWORD PTR [rcx+0x30],rax
    3586:	call   1f31 <__profile_end_pass>
    358b:	add    rsp,0x40
    358f:	cmp    QWORD PTR [rbp-0x218],0x0
    3597:	je     34cc <main+0x229>
  }

  JSON_Object *root = NULL;
    359d:	mov    QWORD PTR [rbp-0x1d8],0x0
  root = parse_json(&arena, source);
    35a8:	mov    rcx,QWORD PTR [rbp-0x1a0]
    35af:	mov    rdx,QWORD PTR [rbp-0x198]
    35b6:	lea    rax,[rbp-0x190]
    35bd:	mov    rsi,rcx
    35c0:	mov    rdi,rax
    35c3:	call   2c5f <parse_json>
    35c8:	mov    QWORD PTR [rbp-0x1d8],rax

  f64 haversine_sum = 0.0;
    35cf:	pxor   xmm0,xmm0
    35d3:	movsd  QWORD PTR [rbp-0x1d0],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    35db:	lea    rax,[rip+0x106f]        # 4651 <_IO_stdin_used+0x651>
    35e2:	mov    QWORD PTR [rbp-0x280],rax
    35e9:	mov    QWORD PTR [rbp-0x278],0x5
    35f4:	mov    rax,QWORD PTR [rbp-0x280]
    35fb:	mov    rdx,QWORD PTR [rbp-0x278]
    3602:	mov    rcx,rax
    3605:	mov    rax,QWORD PTR [rbp-0x1d8]
    360c:	mov    rsi,rcx
    360f:	mov    rdi,rax
    3612:	call   2dc2 <lookup_json_object>
    3617:	mov    QWORD PTR [rbp-0x1c8],rax
  if (pairs)
    361e:	cmp    QWORD PTR [rbp-0x228],0x0
    3626:	je     38bb <main+0x618>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    362c:	mov    rax,QWORD PTR [rbp-0x1c8]
    3633:	mov    rax,QWORD PTR [rax+0x20]
    3637:	mov    QWORD PTR [rbp-0x210],rax
    363e:	jmp    389c <main+0x5f9>
    {
      PROFILE_SCOPE("child convert")
    3643:	lea    rax,[rip+0x100d]        # 4657 <_IO_stdin_used+0x657>
    364a:	mov    QWORD PTR [rbp-0x2c0],rax
    3651:	mov    QWORD PTR [rbp-0x2b8],0xd
    365c:	lea    rdi,[rbp-0x70]
    3660:	mov    rbx,QWORD PTR [rbp-0x2c0]
    3667:	mov    rsi,QWORD PTR [rbp-0x2b8]
    366e:	mov    rdx,rbx
    3671:	mov    rax,rsi
    3674:	mov    r8d,0x0
    367a:	mov    ecx,0x7
    367f:	mov    rsi,rdx
    3682:	mov    rdx,rax
    3685:	call   1e47 <__profile_begin_pass>
    368a:	mov    QWORD PTR [rbp-0x208],0x0
    3695:	jmp    387c <main+0x5d9>
      {
        Haversine_Pair pair =
        {
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    369a:	lea    rax,[rip+0xfc4]        # 4665 <_IO_stdin_used+0x665>
    36a1:	mov    QWORD PTR [rbp-0x2d0],rax
    36a8:	mov    QWORD PTR [rbp-0x2c8],0x2
    36b3:	mov    rbx,QWORD PTR [rbp-0x2d0]
    36ba:	mov    rsi,QWORD PTR [rbp-0x2c8]
    36c1:	mov    rax,rbx
    36c4:	mov    rdx,rsi
    36c7:	mov    rcx,QWORD PTR [rbp-0x210]
    36ce:	mov    rsi,rax
    36d1:	mov    rdi,rcx
    36d4:	call   2dc2 <lookup_json_object>
    36d9:	mov    rdi,rax
    36dc:	call   2ee5 <json_object_to_f64>
    36e1:	movq   rax,xmm0
        Haversine_Pair pair =
    36e6:	mov    QWORD PTR [rbp-0xb0],rax
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    36ed:	lea    rax,[rip+0xf74]        # 4668 <_IO_stdin_used+0x668>
    36f4:	mov    QWORD PTR [rbp-0x2e0],rax
    36fb:	mov    QWORD PTR [rbp-0x2d8],0x2
    3706:	mov    rax,QWORD PTR [rbp-0x2e0]
    370d:	mov    rdx,QWORD PTR [rbp-0x2d8]
    3714:	mov    rcx,rax
    3717:	mov    rax,QWORD PTR [rbp-0x210]
    371e:	mov    rsi,rcx
    3721:	mov    rdi,rax
    3724:	call   2dc2 <lookup_json_object>
    3729:	mov    rdi,rax
    372c:	call   2ee5 <json_object_to_f64>
    3731:	movq   rax,xmm0
        Haversine_Pair pair =
    3736:	mov    QWORD PTR [rbp-0xa8],rax
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    373d:	lea    rax,[rip+0xf27]        # 466b <_IO_stdin_used+0x66b>
    3744:	mov    QWORD PTR [rbp-0x2f0],rax
    374b:	mov    QWORD PTR [rbp-0x2e8],0x2
    3756:	mov    rax,QWORD PTR [rbp-0x2f0]
    375d:	mov    rdx,QWORD PTR [rbp-0x2e8]
    3764:	mov    rcx,rax
    3767:	mov    rax,QWORD PTR [rbp-0x210]
    376e:	mov    rsi,rcx
    3771:	mov    rdi,rax
    3774:	call   2dc2 <lookup_json_object>
    3779:	mov    rdi,rax
    377c:	call   2ee5 <json_object_to_f64>
    3781:	movq   rax,xmm0
        Haversine_Pair pair =
    3786:	mov    QWORD PTR [rbp-0xa0],rax
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    378d:	lea    rax,[rip+0xeda]        # 466e <_IO_stdin_used+0x66e>
    3794:	mov    QWORD PTR [rbp-0x300],rax
    379b:	mov    QWORD PTR [rbp-0x2f8],0x2
    37a6:	mov    rax,QWORD PTR [rbp-0x300]
    37ad:	mov    rdx,QWORD PTR [rbp-0x2f8]
    37b4:	mov    rcx,rax
    37b7:	mov    rax,QWORD PTR [rbp-0x210]
    37be:	mov    rsi,rcx
    37c1:	mov    rdi,rax
    37c4:	call   2dc2 <lookup_json_object>
    37c9:	mov    rdi,rax
    37cc:	call   2ee5 <json_object_to_f64>
    37d1:	movq   rax,xmm0
        Haversine_Pair pair =
    37d6:	mov    QWORD PTR [rbp-0x98],rax
        };

        pairs[pair_count] = pair;
    37dd:	mov    eax,DWORD PTR [rbp-0x238]
    37e3:	cdqe
    37e5:	shl    rax,0x5
    37e9:	mov    rdx,rax
    37ec:	mov    rax,QWORD PTR [rbp-0x228]
    37f3:	lea    rcx,[rdx+rax*1]
    37f7:	mov    rax,QWORD PTR [rbp-0xb0]
    37fe:	mov    rdx,QWORD PTR [rbp-0xa8]
    3805:	mov    QWORD PTR [rcx],rax
    3808:	mov    QWORD PTR [rcx+0x8],rdx
    380c:	mov    rax,QWORD PTR [rbp-0xa0]
    3813:	mov    rdx,QWORD PTR [rbp-0x98]
    381a:	mov    QWORD PTR [rcx+0x10],rax
    381e:	mov    QWORD PTR [rcx+0x18],rdx
        pair_count += 1;
    3822:	add    DWORD PTR [rbp-0x238],0x1
      PROFILE_SCOPE("child convert")
    3829:	add    QWORD PTR [rbp-0x208],0x1
    3831:	sub    rsp,0x8
    3835:	sub    rsp,0x38
    3839:	mov    rcx,rsp
    383c:	mov    rax,QWORD PTR [rbp-0x70]
    3840:	mov    rdx,QWORD PTR [rbp-0x68]
    3844:	mov    QWORD PTR [rcx],rax
    3847:	mov    QWORD PTR [rcx+0x8],rdx
    384b:	mov    rax,QWORD PTR [rbp-0x60]
    384f:	mov    rdx,QWORD PTR [rbp-0x58]
    3853:	mov    QWORD PTR [rcx+0x10],rax
    3857:	mov    QWORD PTR [rcx+0x18],rdx
    385b:	mov    rax,QWORD PTR [rbp-0x50]
    385f:	mov    rdx,QWORD PTR [rbp-0x48]
    3863:	mov    QWORD PTR [rcx+0x20],rax
    3867:	mov    QWORD PTR [rcx+0x28],rdx
    386b:	mov    rax,QWORD PTR [rbp-0x40]
    386f:	mov    QWORD PTR [rcx+0x30],rax
    3873:	call   1f31 <__profile_end_pass>
    3878:	add    rsp,0x40
    387c:	cmp    QWORD PTR [rbp-0x208],0x0
    3884:	je     369a <main+0x3f7>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    388a:	mov    rax,QWORD PTR [rbp-0x210]
    3891:	mov    rax,QWORD PTR [rax+0x28]
    3895:	mov    QWORD PTR [rbp-0x210],rax
    389c:	cmp    QWORD PTR [rbp-0x210],0x0
    38a4:	je     38bb <main+0x618>
    38a6:	mov    eax,DWORD PTR [rbp-0x238]
    38ac:	cdqe
    38ae:	cmp    rax,QWORD PTR [rbp-0x220]
    38b5:	jb     3643 <main+0x3a0>
      }
    }
  }

  f64 sum = 0.0;
    38bb:	pxor   xmm0,xmm0
    38bf:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    38c7:	lea    rax,[rip+0xda3]        # 4671 <_IO_stdin_used+0x671>
    38ce:	mov    QWORD PTR [rbp-0x290],rax
    38d5:	mov    QWORD PTR [rbp-0x288],0x3
    38e0:	lea    rax,[rbp-0xf0]
    38e7:	mov    rcx,QWORD PTR [rbp-0x290]
    38ee:	mov    rbx,QWORD PTR [rbp-0x288]
    38f5:	mov    rsi,rcx
    38f8:	mov    rdx,rbx
    38fb:	mov    r8d,0x0
    3901:	mov    ecx,0x8
    3906:	mov    rdi,rax
    3909:	call   1e47 <__profile_begin_pass>
    390e:	mov    QWORD PTR [rbp-0x1f8],0x0
    3919:	jmp    3a9b <main+0x7f8>
  {
    for (usize i = 0; i < pair_count; i++)
    391e:	mov    QWORD PTR [rbp-0x1f0],0x0
    3929:	jmp    39fe <main+0x75b>
    {
      f64 earth_radius = 6372.8;
    392e:	movsd  xmm0,QWORD PTR [rip+0xfaa]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    3936:	movsd  QWORD PTR [rbp-0x1b8],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    393e:	mov    rax,QWORD PTR [rbp-0x1f0]
    3945:	shl    rax,0x5
    3949:	mov    rdx,rax
    394c:	mov    rax,QWORD PTR [rbp-0x228]
    3953:	add    rax,rdx
    3956:	movsd  xmm2,QWORD PTR [rax+0x18]
    395b:	mov    rax,QWORD PTR [rbp-0x1f0]
    3962:	shl    rax,0x5
    3966:	mov    rdx,rax
    3969:	mov    rax,QWORD PTR [rbp-0x228]
    3970:	add    rax,rdx
    3973:	movsd  xmm1,QWORD PTR [rax+0x10]
    3978:	mov    rax,QWORD PTR [rbp-0x1f0]
    397f:	shl    rax,0x5
    3983:	mov    rdx,rax
    3986:	mov    rax,QWORD PTR [rbp-0x228]
    398d:	add    rax,rdx
    3990:	movsd  xmm0,QWORD PTR [rax+0x8]
    3995:	mov    rax,QWORD PTR [rbp-0x1f0]
    399c:	shl    rax,0x5
    39a0:	mov    rdx,rax
    39a3:	mov    rax,QWORD PTR [rbp-0x228]
    39aa:	add    rax,rdx
    39ad:	mov    rax,QWORD PTR [rax]
    39b0:	movsd  xmm3,QWORD PTR [rbp-0x1b8]
    39b8:	movapd xmm4,xmm3
    39bc:	movapd xmm3,xmm2
    39c0:	movapd xmm2,xmm1
    39c4:	movapd xmm1,xmm0
    39c8:	movq   xmm0,rax
    39cd:	call   30a2 <reference_haversine>
    39d2:	movq   rax,xmm0
    39d7:	mov    QWORD PTR [rbp-0x1b0],rax
      sum += result;
    39de:	movsd  xmm0,QWORD PTR [rbp-0x200]
    39e6:	addsd  xmm0,QWORD PTR [rbp-0x1b0]
    39ee:	movsd  QWORD PTR [rbp-0x200],xmm0
    for (usize i = 0; i < pair_count; i++)
    39f6:	add    QWORD PTR [rbp-0x1f0],0x1
    39fe:	mov    eax,DWORD PTR [rbp-0x238]
    3a04:	cdqe
    3a06:	cmp    QWORD PTR [rbp-0x1f0],rax
    3a0d:	jb     392e <main+0x68b>
    }
    sum /= pair_count;
    3a13:	pxor   xmm1,xmm1
    3a17:	cvtsi2sd xmm1,DWORD PTR [rbp-0x238]
    3a1f:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3a27:	divsd  xmm0,xmm1
    3a2b:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3a33:	add    QWORD PTR [rbp-0x1f8],0x1
    3a3b:	sub    rsp,0x8
    3a3f:	sub    rsp,0x38
    3a43:	mov    rax,rsp
    3a46:	mov    rcx,QWORD PTR [rbp-0xf0]
    3a4d:	mov    rbx,QWORD PTR [rbp-0xe8]
    3a54:	mov    QWORD PTR [rax],rcx
    3a57:	mov    QWORD PTR [rax+0x8],rbx
    3a5b:	mov    rcx,QWORD PTR [rbp-0xe0]
    3a62:	mov    rbx,QWORD PTR [rbp-0xd8]
    3a69:	mov    QWORD PTR [rax+0x10],rcx
    3a6d:	mov    QWORD PTR [rax+0x18],rbx
    3a71:	mov    rcx,QWORD PTR [rbp-0xd0]
    3a78:	mov    rbx,QWORD PTR [rbp-0xc8]
    3a7f:	mov    QWORD PTR [rax+0x20],rcx
    3a83:	mov    QWORD PTR [rax+0x28],rbx
    3a87:	mov    rdx,QWORD PTR [rbp-0xc0]
    3a8e:	mov    QWORD PTR [rax+0x30],rdx
    3a92:	call   1f31 <__profile_end_pass>
    3a97:	add    rsp,0x40
    3a9b:	cmp    QWORD PTR [rbp-0x1f8],0x0
    3aa3:	je     391e <main+0x67b>
  }

  PROFILE_SCOPE("check")
    3aa9:	lea    rax,[rip+0xbc5]        # 4675 <_IO_stdin_used+0x675>
    3ab0:	mov    QWORD PTR [rbp-0x2a0],rax
    3ab7:	mov    QWORD PTR [rbp-0x298],0x5
    3ac2:	lea    rax,[rbp-0xb0]
    3ac9:	mov    rcx,QWORD PTR [rbp-0x2a0]
    3ad0:	mov    rbx,QWORD PTR [rbp-0x298]
    3ad7:	mov    rsi,rcx
    3ada:	mov    rdx,rbx
    3add:	mov    r8d,0x0
    3ae3:	mov    ecx,0x9
    3ae8:	mov    rdi,rax
    3aeb:	call   1e47 <__profile_begin_pass>
    3af0:	mov    QWORD PTR [rbp-0x1e8],0x0
    3afb:	jmp    3cd0 <main+0xa2d>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3b00:	mov    rax,QWORD PTR [rbp-0x250]
    3b07:	add    rax,0x10
    3b0b:	mov    rdx,QWORD PTR [rax]
    3b0e:	lea    rax,[rbp-0x190]
    3b15:	mov    rsi,rdx
    3b18:	mov    rdi,rax
    3b1b:	call   1357 <read_file_to_arena>
    3b20:	mov    QWORD PTR [rbp-0x70],rax
    3b24:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3b28:	mov    rax,QWORD PTR [rbp-0x68]
    3b2c:	cmp    rax,0xb
    3b30:	jbe    3c43 <main+0x9a0>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3b36:	mov    rax,QWORD PTR [rbp-0x70]
    3b3a:	movsd  xmm0,QWORD PTR [rax]
    3b3e:	movsd  QWORD PTR [rbp-0x1c0],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3b46:	mov    rax,QWORD PTR [rbp-0x70]
    3b4a:	mov    eax,DWORD PTR [rax+0x8]
    3b4d:	mov    DWORD PTR [rbp-0x234],eax

      if (solution_pairs == pair_count)
    3b53:	mov    eax,DWORD PTR [rbp-0x234]
    3b59:	cmp    eax,DWORD PTR [rbp-0x238]
    3b5f:	jne    3c07 <main+0x964>
      {
        if (epsilon_equal(solution_sum, sum))
    3b65:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b6d:	mov    rax,QWORD PTR [rbp-0x1c0]
    3b74:	movapd xmm1,xmm0
    3b78:	movq   xmm0,rax
    3b7d:	call   324d <epsilon_equal>
    3b82:	test   eax,eax
    3b84:	je     3bc8 <main+0x925>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3b86:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b8e:	mov    rax,QWORD PTR [rbp-0x1c0]
    3b95:	lea    rdx,[rip+0xae4]        # 4680 <_IO_stdin_used+0x680>
    3b9c:	lea    rsi,[rip+0xb10]        # 46b3 <_IO_stdin_used+0x6b3>
    3ba3:	movapd xmm1,xmm0
    3ba7:	movq   xmm0,rax
    3bac:	mov    rcx,rdx
    3baf:	mov    edx,0x64
    3bb4:	mov    edi,0x3
    3bb9:	mov    eax,0x2
    3bbe:	call   14a1 <log_message>
    3bc3:	jmp    3c6b <main+0x9c8>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3bc8:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3bd0:	mov    rax,QWORD PTR [rbp-0x1c0]
    3bd7:	lea    rdx,[rip+0xaea]        # 46c8 <_IO_stdin_used+0x6c8>
    3bde:	lea    rsi,[rip+0xace]        # 46b3 <_IO_stdin_used+0x6b3>
    3be5:	movapd xmm1,xmm0
    3be9:	movq   xmm0,rax
    3bee:	mov    rcx,rdx
    3bf1:	mov    edx,0x68
    3bf6:	mov    edi,0x1
    3bfb:	mov    eax,0x2
    3c00:	call   14a1 <log_message>
    3c05:	jmp    3c6b <main+0x9c8>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3c07:	mov    esi,DWORD PTR [rbp-0x238]
    3c0d:	mov    ecx,DWORD PTR [rbp-0x234]
    3c13:	lea    rdx,[rip+0xae6]        # 4700 <_IO_stdin_used+0x700>
    3c1a:	lea    rax,[rip+0xa92]        # 46b3 <_IO_stdin_used+0x6b3>
    3c21:	mov    r9d,esi
    3c24:	mov    r8d,ecx
    3c27:	mov    rcx,rdx
    3c2a:	mov    edx,0x6d
    3c2f:	mov    rsi,rax
    3c32:	mov    edi,0x1
    3c37:	mov    eax,0x0
    3c3c:	call   14a1 <log_message>
    3c41:	jmp    3c6b <main+0x9c8>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3c43:	lea    rdx,[rip+0xafe]        # 4748 <_IO_stdin_used+0x748>
    3c4a:	lea    rax,[rip+0xa62]        # 46b3 <_IO_stdin_used+0x6b3>
    3c51:	mov    rcx,rdx
    3c54:	mov    edx,0x72
    3c59:	mov    rsi,rax
    3c5c:	mov    edi,0x1
    3c61:	mov    eax,0x0
    3c66:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3c6b:	add    QWORD PTR [rbp-0x1e8],0x1
    3c73:	sub    rsp,0x8
    3c77:	sub    rsp,0x38
    3c7b:	mov    rax,rsp
    3c7e:	mov    rcx,QWORD PTR [rbp-0xb0]
    3c85:	mov    rbx,QWORD PTR [rbp-0xa8]
    3c8c:	mov    QWORD PTR [rax],rcx
    3c8f:	mov    QWORD PTR [rax+0x8],rbx
    3c93:	mov    rcx,QWORD PTR [rbp-0xa0]
    3c9a:	mov    rbx,QWORD PTR [rbp-0x98]
    3ca1:	mov    QWORD PTR [rax+0x10],rcx
    3ca5:	mov    QWORD PTR [rax+0x18],rbx
    3ca9:	mov    rcx,QWORD PTR [rbp-0x90]
    3cb0:	mov    rbx,QWORD PTR [rbp-0x88]
    3cb7:	mov    QWORD PTR [rax+0x20],rcx
    3cbb:	mov    QWORD PTR [rax+0x28],rbx
    3cbf:	mov    rdx,QWORD PTR [rbp-0x80]
    3cc3:	mov    QWORD PTR [rax+0x30],rdx
    3cc7:	call   1f31 <__profile_end_pass>
    3ccc:	add    rsp,0x40
    3cd0:	cmp    QWORD PTR [rbp-0x1e8],0x0
    3cd8:	je     3b00 <main+0x85d>
    }
  }

  PROFILE_SCOPE("free")
    3cde:	lea    rax,[rip+0xa9e]        # 4783 <_IO_stdin_used+0x783>
    3ce5:	mov    QWORD PTR [rbp-0x2b0],rax
    3cec:	mov    QWORD PTR [rbp-0x2a8],0x4
    3cf7:	lea    rax,[rbp-0x70]
    3cfb:	mov    rcx,QWORD PTR [rbp-0x2b0]
    3d02:	mov    rbx,QWORD PTR [rbp-0x2a8]
    3d09:	mov    rsi,rcx
    3d0c:	mov    rdx,rbx
    3d0f:	mov    r8d,0x0
    3d15:	mov    ecx,0xa
    3d1a:	mov    rdi,rax
    3d1d:	call   1e47 <__profile_begin_pass>
    3d22:	mov    QWORD PTR [rbp-0x1e0],0x0
    3d2d:	jmp    3d91 <main+0xaee>
  {
    arena_free(&arena);
    3d2f:	lea    rax,[rbp-0x190]
    3d36:	mov    rdi,rax
    3d39:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3d3e:	add    QWORD PTR [rbp-0x1e0],0x1
    3d46:	sub    rsp,0x8
    3d4a:	sub    rsp,0x38
    3d4e:	mov    rax,rsp
    3d51:	mov    rcx,QWORD PTR [rbp-0x70]
    3d55:	mov    rbx,QWORD PTR [rbp-0x68]
    3d59:	mov    QWORD PTR [rax],rcx
    3d5c:	mov    QWORD PTR [rax+0x8],rbx
    3d60:	mov    rcx,QWORD PTR [rbp-0x60]
    3d64:	mov    rbx,QWORD PTR [rbp-0x58]
    3d68:	mov    QWORD PTR [rax+0x10],rcx
    3d6c:	mov    QWORD PTR [rax+0x18],rbx
    3d70:	mov    rcx,QWORD PTR [rbp-0x50]
    3d74:	mov    rbx,QWORD PTR [rbp-0x48]
    3d78:	mov    QWORD PTR [rax+0x20],rcx
    3d7c:	mov    QWORD PTR [rax+0x28],rbx
    3d80:	mov    rdx,QWORD PTR [rbp-0x40]
    3d84:	mov    QWORD PTR [rax+0x30],rdx
    3d88:	call   1f31 <__profile_end_pass>
    3d8d:	add    rsp,0x40
    3d91:	cmp    QWORD PTR [rbp-0x1e0],0x0
    3d99:	je     3d2f <main+0xa8c>
  }

  end_profiling();
    3d9b:	call   1b9b <end_profiling>
    3da0:	mov    eax,0x0
}
    3da5:	mov    rdx,QWORD PTR [rbp-0x38]
    3da9:	sub    rdx,QWORD PTR fs:0x28
    3db2:	je     3db9 <main+0xb16>
    3db4:	call   1060 <__stack_chk_fail@plt>
    3db9:	lea    rsp,[rbp-0x28]
    3dbd:	pop    rbx
    3dbe:	pop    r12
    3dc0:	pop    r13
    3dc2:	pop    r14
    3dc4:	pop    r15
    3dc6:	pop    rbp
    3dc7:	ret

Disassembly of section .fini:

0000000000003dc8 <_fini>:
    3dc8:	endbr64
    3dcc:	sub    rsp,0x8
    3dd0:	add    rsp,0x8
    3dd4:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x4fc1]        # 5fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x4fca]        # 5ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x4fcc]        # 5ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x4fca]        # 6000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x4fc2]        # 6008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x4fba]        # 6010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x4fb2]        # 6018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x4faa]        # 6020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x4fa2]        # 6028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x4f9a]        # 6030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x4f92]        # 6038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x4f8a]        # 6040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x4f82]        # 6048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x4f7a]        # 6050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x4f72]        # 6058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x4f6a]        # 6060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x4f62]        # 6068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x4f5a]        # 6070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x4f52]        # 6078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x4f4a]        # 6080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x4f42]        # 6088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x4f3a]        # 6090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x4f32]        # 6098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2114]        # 32a3 <main>
    118f:	call   QWORD PTR [rip+0x4e2b]        # 5fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x4fa1]        # 6148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x4f9a]        # 6148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x4e0e]        # 5fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x4f71]        # 6148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x4f6a]        # 6148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x4ddd]        # 5fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x4f6d],0x0        # 6188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x4dba],0x0        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x4e76]        # 60a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x4da8]        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x4f44],0x1        # 6188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x4c6e]        # 6180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x4b89]        # 60c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x4be7]        # 6160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x4b2b]        # 60c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x3087]        # 4780 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x305b]        # 4780 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2f9e]        # 4798 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2e9f]        # 47a8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2cbd]        # 47c0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x4639]        # 61a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x4620],rbx        # 61a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x40
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x45ee]        # 61a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x28],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x28],0x0
    1bbe:	je     1e44 <end_profiling+0x2a9>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x20],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x28]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x20]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c41]        # 4878 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x20]
    1c44:	mov    rax,QWORD PTR [rbp-0x28]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x38],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x30],0x0
    1c72:	jmp    1e36 <end_profiling+0x29b>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x30]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x450d]        # 61a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x18],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x18]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1e31 <end_profiling+0x296>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x18]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x28]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b67]        # 4880 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x10],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x18]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x18]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x18]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x18]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x10]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x18]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x18]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x18]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x28]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2a8f]        # 4880 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x8],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x18]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x8]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x38]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x10]
    1e2c:	movsd  QWORD PTR [rbp-0x38],xmm0
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1e31:	add    QWORD PTR [rbp-0x30],0x1
    1e36:	cmp    QWORD PTR [rbp-0x30],0xfff
    1e3e:	jbe    1c77 <end_profiling+0xdc>
      }
    }

  }
}
    1e44:	nop
    1e45:	leave
    1e46:	ret

0000000000001e47 <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1e47:	push   rbp
    1e48:	mov    rbp,rsp
    1e4b:	push   rbx
    1e4c:	sub    rsp,0x78
    1e50:	mov    QWORD PTR [rbp-0x58],rdi
    1e54:	mov    rax,rsi
    1e57:	mov    rsi,rdx
    1e5a:	mov    rax,rax
    1e5d:	mov    edx,0x0
    1e62:	mov    rdx,rsi
    1e65:	mov    QWORD PTR [rbp-0x70],rax
    1e69:	mov    QWORD PTR [rbp-0x68],rdx
    1e6d:	mov    QWORD PTR [rbp-0x60],rcx
    1e71:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1e75:	pxor   xmm0,xmm0
    1e79:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1e7d:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1e81:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1e85:	movq   QWORD PTR [rbp-0x20],xmm0
    1e8a:	mov    rax,QWORD PTR [rbp-0x70]
    1e8e:	mov    rdx,QWORD PTR [rbp-0x68]
    1e92:	mov    QWORD PTR [rbp-0x50],rax
    1e96:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1e9a:	mov    rdx,QWORD PTR [rbp-0x60]
    1e9e:	mov    rax,rdx
    1ea1:	add    rax,rax
    1ea4:	add    rax,rdx
    1ea7:	shl    rax,0x4
    1eab:	mov    rdx,rax
    1eae:	lea    rax,[rip+0x4313]        # 61c8 <g_profiler+0x28>
    1eb5:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1eb9:	mov    QWORD PTR [rbp-0x38],rax
    1ebd:	mov    rax,QWORD PTR [rbp-0x60]
    1ec1:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1ec5:	mov    rax,QWORD PTR [rip+0x42dc]        # 61a8 <g_profiler+0x8>
  Profile_Pass pass =
    1ecc:	mov    QWORD PTR [rbp-0x28],rax
    1ed0:	mov    rax,QWORD PTR [rbp-0x78]
    1ed4:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    1ed8:	mov    rax,QWORD PTR [rbp-0x60]
    1edc:	mov    QWORD PTR [rip+0x42c5],rax        # 61a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    1ee3:	call   1a48 <read_cpu_timer>
    1ee8:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    1eec:	mov    rax,QWORD PTR [rbp-0x58]
    1ef0:	mov    rcx,QWORD PTR [rbp-0x50]
    1ef4:	mov    rbx,QWORD PTR [rbp-0x48]
    1ef8:	mov    QWORD PTR [rax],rcx
    1efb:	mov    QWORD PTR [rax+0x8],rbx
    1eff:	mov    rcx,QWORD PTR [rbp-0x40]
    1f03:	mov    rbx,QWORD PTR [rbp-0x38]
    1f07:	mov    QWORD PTR [rax+0x10],rcx
    1f0b:	mov    QWORD PTR [rax+0x18],rbx
    1f0f:	mov    rcx,QWORD PTR [rbp-0x30]
    1f13:	mov    rbx,QWORD PTR [rbp-0x28]
    1f17:	mov    QWORD PTR [rax+0x20],rcx
    1f1b:	mov    QWORD PTR [rax+0x28],rbx
    1f1f:	mov    rdx,QWORD PTR [rbp-0x20]
    1f23:	mov    QWORD PTR [rax+0x30],rdx
}
    1f27:	mov    rax,QWORD PTR [rbp-0x58]
    1f2b:	mov    rbx,QWORD PTR [rbp-0x8]
    1f2f:	leave
    1f30:	ret

0000000000001f31 <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    1f31:	push   rbp
    1f32:	mov    rbp,rsp
    1f35:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    1f39:	call   1a48 <read_cpu_timer>
    1f3e:	mov    rdx,rax
    1f41:	mov    rax,QWORD PTR [rbp+0x20]
    1f45:	sub    rdx,rax
    1f48:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    1f4c:	mov    rax,QWORD PTR [rbp+0x38]
    1f50:	mov    QWORD PTR [rip+0x4251],rax        # 61a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    1f57:	mov    rdx,QWORD PTR [rbp+0x30]
    1f5b:	mov    rax,rdx
    1f5e:	add    rax,rax
    1f61:	add    rax,rdx
    1f64:	shl    rax,0x4
    1f68:	lea    rdx,[rax+0x10]
    1f6c:	lea    rax,[rip+0x422d]        # 61a0 <g_profiler>
    1f73:	add    rax,rdx
    1f76:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    1f7a:	mov    rax,QWORD PTR [rbp-0x10]
    1f7e:	mov    rdx,QWORD PTR [rax+0x10]
    1f82:	mov    rax,QWORD PTR [rbp-0x18]
    1f86:	add    rdx,rax
    1f89:	mov    rax,QWORD PTR [rbp-0x10]
    1f8d:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    1f91:	mov    rax,QWORD PTR [rbp-0x10]
    1f95:	mov    rax,QWORD PTR [rax+0x20]
    1f99:	lea    rdx,[rax+0x1]
    1f9d:	mov    rax,QWORD PTR [rbp-0x10]
    1fa1:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    1fa5:	mov    rcx,QWORD PTR [rbp-0x10]
    1fa9:	mov    rax,QWORD PTR [rbp+0x10]
    1fad:	mov    rdx,QWORD PTR [rbp+0x18]
    1fb1:	mov    QWORD PTR [rcx],rax
    1fb4:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    1fb8:	mov    rdx,QWORD PTR [rbp+0x28]
    1fbc:	mov    rax,QWORD PTR [rbp-0x18]
    1fc0:	add    rdx,rax
    1fc3:	mov    rax,QWORD PTR [rbp-0x10]
    1fc7:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    1fcb:	mov    rax,QWORD PTR [rbp-0x10]
    1fcf:	mov    rdx,QWORD PTR [rax+0x28]
    1fd3:	mov    rax,QWORD PTR [rbp+0x40]
    1fd7:	add    rdx,rax
    1fda:	mov    rax,QWORD PTR [rbp-0x10]
    1fde:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    1fe2:	mov    rdx,QWORD PTR [rbp+0x38]
    1fe6:	mov    rax,rdx
    1fe9:	add    rax,rax
    1fec:	add    rax,rdx
    1fef:	shl    rax,0x4
    1ff3:	lea    rdx,[rax+0x10]
    1ff7:	lea    rax,[rip+0x41a2]        # 61a0 <g_profiler>
    1ffe:	add    rax,rdx
    2001:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    2005:	mov    rax,QWORD PTR [rbp-0x8]
    2009:	mov    rax,QWORD PTR [rax+0x10]
    200d:	sub    rax,QWORD PTR [rbp-0x18]
    2011:	mov    rdx,rax
    2014:	mov    rax,QWORD PTR [rbp-0x8]
    2018:	mov    QWORD PTR [rax+0x10],rdx
}
    201c:	nop
    201d:	leave
    201e:	ret

000000000000201f <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    201f:	push   rbp
    2020:	mov    rbp,rsp
    2023:	sub    rsp,0x10
    2027:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    202b:	mov    rax,QWORD PTR [rbp-0x8]
    202f:	mov    rdx,QWORD PTR [rax+0x10]
    2033:	mov    rax,QWORD PTR [rbp-0x8]
    2037:	mov    rax,QWORD PTR [rax+0x8]
    203b:	cmp    rdx,rax
    203e:	jb     2065 <parser_at+0x46>
    2040:	lea    rdx,[rip+0x2791]        # 47d8 <__PRETTY_FUNCTION__.5>
    2047:	lea    rsi,[rip+0x2401]        # 444f <_IO_stdin_used+0x44f>
    204e:	lea    rax,[rip+0x240b]        # 4460 <_IO_stdin_used+0x460>
    2055:	mov    rcx,rdx
    2058:	mov    edx,0x2f
    205d:	mov    rdi,rax
    2060:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    2065:	mov    rax,QWORD PTR [rbp-0x8]
    2069:	mov    rdx,QWORD PTR [rax]
    206c:	mov    rax,QWORD PTR [rbp-0x8]
    2070:	mov    rax,QWORD PTR [rax+0x10]
    2074:	add    rax,rdx
}
    2077:	leave
    2078:	ret

0000000000002079 <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    2079:	push   rbp
    207a:	mov    rbp,rsp
    207d:	sub    rsp,0x10
    2081:	mov    QWORD PTR [rbp-0x8],rdi
    2085:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    2089:	mov    rax,QWORD PTR [rbp-0x8]
    208d:	mov    rdi,rax
    2090:	call   201f <parser_at>
    2095:	mov    rdx,QWORD PTR [rbp-0x10]
    2099:	add    rax,rdx
}
    209c:	leave
    209d:	ret

000000000000209e <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    209e:	push   rbp
    209f:	mov    rbp,rsp
    20a2:	mov    QWORD PTR [rbp-0x8],rdi
    20a6:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    20aa:	mov    rax,QWORD PTR [rbp-0x8]
    20ae:	mov    rdx,QWORD PTR [rax+0x10]
    20b2:	mov    rax,QWORD PTR [rbp-0x10]
    20b6:	add    rdx,rax
    20b9:	mov    rax,QWORD PTR [rbp-0x8]
    20bd:	mov    QWORD PTR [rax+0x10],rdx
}
    20c1:	nop
    20c2:	pop    rbp
    20c3:	ret

00000000000020c4 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    20c4:	push   rbp
    20c5:	mov    rbp,rsp
    20c8:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    20cc:	mov    rax,QWORD PTR [rbp-0x8]
    20d0:	mov    rdx,QWORD PTR [rax+0x10]
    20d4:	mov    rax,QWORD PTR [rbp-0x8]
    20d8:	mov    rax,QWORD PTR [rax+0x8]
    20dc:	cmp    rdx,rax
    20df:	setb   al
}
    20e2:	pop    rbp
    20e3:	ret

00000000000020e4 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    20e4:	push   rbp
    20e5:	mov    rbp,rsp
    20e8:	push   r12
    20ea:	push   rbx
    20eb:	sub    rsp,0x20
    20ef:	mov    QWORD PTR [rbp-0x18],rdi
    20f3:	mov    rax,rsi
    20f6:	mov    rcx,rdx
    20f9:	mov    rax,rax
    20fc:	mov    edx,0x0
    2101:	mov    rdx,rcx
    2104:	mov    QWORD PTR [rbp-0x30],rax
    2108:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    210c:	mov    rax,QWORD PTR [rbp-0x28]
    2110:	mov    r12,rax
    2113:	mov    rbx,QWORD PTR [rbp-0x30]
    2117:	mov    rax,QWORD PTR [rbp-0x18]
    211b:	mov    rdi,rax
    211e:	call   201f <parser_at>
    2123:	mov    rdx,r12
    2126:	mov    rsi,rbx
    2129:	mov    rdi,rax
    212c:	call   10d0 <memcmp@plt>
    2131:	test   eax,eax
    2133:	sete   al
}
    2136:	add    rsp,0x20
    213a:	pop    rbx
    213b:	pop    r12
    213d:	pop    rbp
    213e:	ret

000000000000213f <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    213f:	push   rbp
    2140:	mov    rbp,rsp
    2143:	mov    eax,edi
    2145:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    2148:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    214c:	movzx  eax,BYTE PTR [rbp-0x14]
    2150:	cmp    eax,0x2e
    2153:	jg     215c <is_numeric+0x1d>
    2155:	cmp    eax,0x2d
    2158:	jge    2164 <is_numeric+0x25>
    215a:	jmp    2169 <is_numeric+0x2a>
    215c:	sub    eax,0x30
    215f:	cmp    eax,0x9
    2162:	ja     2169 <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2164:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    2168:	nop
  }


  return result;
    2169:	movzx  eax,BYTE PTR [rbp-0x1]
}
    216d:	pop    rbp
    216e:	ret

000000000000216f <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    216f:	push   rbp
    2170:	mov    rbp,rsp
    2173:	sub    rsp,0x50
    2177:	mov    QWORD PTR [rbp-0x48],rdi
    217b:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    217f:	pxor   xmm0,xmm0
    2183:	movaps XMMWORD PTR [rbp-0x20],xmm0
    2187:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    218c:	jmp    219f <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    218e:	mov    rax,QWORD PTR [rbp-0x50]
    2192:	mov    esi,0x1
    2197:	mov    rdi,rax
    219a:	call   209e <parser_advance>
  while (parser_incomplete(parser)  &&
    219f:	mov    rax,QWORD PTR [rbp-0x50]
    21a3:	mov    rdi,rax
    21a6:	call   20c4 <parser_incomplete>
    21ab:	test   al,al
    21ad:	je     21fb <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    21af:	mov    rax,QWORD PTR [rbp-0x50]
    21b3:	mov    rdi,rax
    21b6:	call   201f <parser_at>
    21bb:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    21be:	cmp    al,0x20
    21c0:	je     218e <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    21c2:	mov    rax,QWORD PTR [rbp-0x50]
    21c6:	mov    rdi,rax
    21c9:	call   201f <parser_at>
    21ce:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    21d1:	cmp    al,0xa
    21d3:	je     218e <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    21d5:	mov    rax,QWORD PTR [rbp-0x50]
    21d9:	mov    rdi,rax
    21dc:	call   201f <parser_at>
    21e1:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    21e4:	cmp    al,0xd
    21e6:	je     218e <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    21e8:	mov    rax,QWORD PTR [rbp-0x50]
    21ec:	mov    rdi,rax
    21ef:	call   201f <parser_at>
    21f4:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    21f7:	cmp    al,0x9
    21f9:	je     218e <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    21fb:	mov    rax,QWORD PTR [rbp-0x50]
    21ff:	mov    rdi,rax
    2202:	call   20c4 <parser_incomplete>
    2207:	test   al,al
    2209:	je     2636 <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    220f:	mov    rax,QWORD PTR [rbp-0x50]
    2213:	mov    rdi,rax
    2216:	call   201f <parser_at>
    221b:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    221f:	mov    rax,QWORD PTR [rbp-0x50]
    2223:	mov    rdi,rax
    2226:	call   201f <parser_at>
    222b:	movzx  eax,BYTE PTR [rax]
    222e:	movzx  eax,al
    2231:	cmp    eax,0x7d
    2234:	je     2321 <get_json_token+0x1b2>
    223a:	cmp    eax,0x7d
    223d:	jg     2647 <get_json_token+0x4d8>
    2243:	cmp    eax,0x7b
    2246:	je     22fc <get_json_token+0x18d>
    224c:	cmp    eax,0x7b
    224f:	jg     2647 <get_json_token+0x4d8>
    2255:	cmp    eax,0x74
    2258:	je     24a4 <get_json_token+0x335>
    225e:	cmp    eax,0x74
    2261:	jg     2647 <get_json_token+0x4d8>
    2267:	cmp    eax,0x6e
    226a:	je     25b4 <get_json_token+0x445>
    2270:	cmp    eax,0x6e
    2273:	jg     2647 <get_json_token+0x4d8>
    2279:	cmp    eax,0x66
    227c:	je     252c <get_json_token+0x3bd>
    2282:	cmp    eax,0x66
    2285:	jg     2647 <get_json_token+0x4d8>
    228b:	cmp    eax,0x5d
    228e:	je     236b <get_json_token+0x1fc>
    2294:	cmp    eax,0x5d
    2297:	jg     2647 <get_json_token+0x4d8>
    229d:	cmp    eax,0x5b
    22a0:	je     2346 <get_json_token+0x1d7>
    22a6:	cmp    eax,0x5b
    22a9:	jg     2647 <get_json_token+0x4d8>
    22af:	cmp    eax,0x3a
    22b2:	je     23b5 <get_json_token+0x246>
    22b8:	cmp    eax,0x3a
    22bb:	jg     2647 <get_json_token+0x4d8>
    22c1:	cmp    eax,0x39
    22c4:	jg     2647 <get_json_token+0x4d8>
    22ca:	cmp    eax,0x30
    22cd:	jge    2453 <get_json_token+0x2e4>
    22d3:	cmp    eax,0x2e
    22d6:	jg     2647 <get_json_token+0x4d8>
    22dc:	cmp    eax,0x2d
    22df:	jge    2453 <get_json_token+0x2e4>
    22e5:	cmp    eax,0x22
    22e8:	je     23da <get_json_token+0x26b>
    22ee:	cmp    eax,0x2c
    22f1:	je     2390 <get_json_token+0x221>
    22f7:	jmp    2647 <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    22fc:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    2303:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    230b:	mov    rax,QWORD PTR [rbp-0x50]
    230f:	mov    esi,0x1
    2314:	mov    rdi,rax
    2317:	call   209e <parser_advance>
      }
      break;
    231c:	jmp    2647 <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2321:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    2328:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2330:	mov    rax,QWORD PTR [rbp-0x50]
    2334:	mov    esi,0x1
    2339:	mov    rdi,rax
    233c:	call   209e <parser_advance>
      }
      break;
    2341:	jmp    2647 <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2346:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    234d:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2355:	mov    rax,QWORD PTR [rbp-0x50]
    2359:	mov    esi,0x1
    235e:	mov    rdi,rax
    2361:	call   209e <parser_advance>
      }
      break;
    2366:	jmp    2647 <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    236b:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    2372:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    237a:	mov    rax,QWORD PTR [rbp-0x50]
    237e:	mov    esi,0x1
    2383:	mov    rdi,rax
    2386:	call   209e <parser_advance>
      }
      break;
    238b:	jmp    2647 <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    2390:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    2397:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    239f:	mov    rax,QWORD PTR [rbp-0x50]
    23a3:	mov    esi,0x1
    23a8:	mov    rdi,rax
    23ab:	call   209e <parser_advance>
      }
      break;
    23b0:	jmp    2647 <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    23b5:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    23bc:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    23c4:	mov    rax,QWORD PTR [rbp-0x50]
    23c8:	mov    esi,0x1
    23cd:	mov    rdi,rax
    23d0:	call   209e <parser_advance>
      }
      break;
    23d5:	jmp    2647 <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    23da:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    23e1:	mov    rax,QWORD PTR [rbp-0x50]
    23e5:	mov    esi,0x1
    23ea:	mov    rdi,rax
    23ed:	call   209e <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    23f2:	mov    rax,QWORD PTR [rbp-0x50]
    23f6:	mov    rdi,rax
    23f9:	call   201f <parser_at>
    23fe:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    2402:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    240a:	jmp    2422 <get_json_token+0x2b3>
        {
          string_count += 1;
    240c:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    2411:	mov    rax,QWORD PTR [rbp-0x50]
    2415:	mov    esi,0x1
    241a:	mov    rdi,rax
    241d:	call   209e <parser_advance>
        while (*parser_at(parser) != '"')
    2422:	mov    rax,QWORD PTR [rbp-0x50]
    2426:	mov    rdi,rax
    2429:	call   201f <parser_at>
    242e:	movzx  eax,BYTE PTR [rax]
    2431:	cmp    al,0x22
    2433:	jne    240c <get_json_token+0x29d>
        }
        token.value.count = string_count;
    2435:	mov    rax,QWORD PTR [rbp-0x40]
    2439:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    243d:	mov    rax,QWORD PTR [rbp-0x50]
    2441:	mov    esi,0x1
    2446:	mov    rdi,rax
    2449:	call   209e <parser_advance>
      }
      break;
    244e:	jmp    2647 <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2453:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    245a:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2462:	jmp    247a <get_json_token+0x30b>
        {
          digit_count += 1;
    2464:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    2469:	mov    rax,QWORD PTR [rbp-0x50]
    246d:	mov    esi,0x1
    2472:	mov    rdi,rax
    2475:	call   209e <parser_advance>
        while (is_numeric(*parser_at(parser)))
    247a:	mov    rax,QWORD PTR [rbp-0x50]
    247e:	mov    rdi,rax
    2481:	call   201f <parser_at>
    2486:	movzx  eax,BYTE PTR [rax]
    2489:	movzx  eax,al
    248c:	mov    edi,eax
    248e:	call   213f <is_numeric>
    2493:	test   al,al
    2495:	jne    2464 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    2497:	mov    rax,QWORD PTR [rbp-0x38]
    249b:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    249f:	jmp    2647 <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    24a4:	lea    rax,[rip+0x2001]        # 44ac <_IO_stdin_used+0x4ac>
    24ab:	mov    QWORD PTR [rbp-0x30],rax
    24af:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    24b7:	mov    rcx,QWORD PTR [rbp-0x30]
    24bb:	mov    rdx,QWORD PTR [rbp-0x28]
    24bf:	mov    rax,QWORD PTR [rbp-0x50]
    24c3:	mov    rsi,rcx
    24c6:	mov    rdi,rax
    24c9:	call   20e4 <parser_token_is_literal>
    24ce:	test   al,al
    24d0:	je     24f4 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    24d2:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    24d9:	mov    rax,QWORD PTR [rbp-0x28]
    24dd:	mov    rdx,rax
    24e0:	mov    rax,QWORD PTR [rbp-0x50]
    24e4:	mov    rsi,rdx
    24e7:	mov    rdi,rax
    24ea:	call   209e <parser_advance>
    24ef:	jmp    2647 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    24f4:	mov    rax,QWORD PTR [rbp-0x50]
    24f8:	mov    rcx,QWORD PTR [rax+0x10]
    24fc:	lea    rdx,[rip+0x1fb5]        # 44b8 <_IO_stdin_used+0x4b8>
    2503:	lea    rax,[rip+0x1f45]        # 444f <_IO_stdin_used+0x44f>
    250a:	mov    r8,rcx
    250d:	mov    rcx,rdx
    2510:	mov    edx,0xdf
    2515:	mov    rsi,rax
    2518:	mov    edi,0x1
    251d:	mov    eax,0x0
    2522:	call   14a1 <log_message>
        }
      }
      break;
    2527:	jmp    2647 <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    252c:	lea    rax,[rip+0x1fb2]        # 44e5 <_IO_stdin_used+0x4e5>
    2533:	mov    QWORD PTR [rbp-0x30],rax
    2537:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    253f:	mov    rcx,QWORD PTR [rbp-0x30]
    2543:	mov    rdx,QWORD PTR [rbp-0x28]
    2547:	mov    rax,QWORD PTR [rbp-0x50]
    254b:	mov    rsi,rcx
    254e:	mov    rdi,rax
    2551:	call   20e4 <parser_token_is_literal>
    2556:	test   al,al
    2558:	je     257c <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    255a:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    2561:	mov    rax,QWORD PTR [rbp-0x28]
    2565:	mov    rdx,rax
    2568:	mov    rax,QWORD PTR [rbp-0x50]
    256c:	mov    rsi,rdx
    256f:	mov    rdi,rax
    2572:	call   209e <parser_advance>
    2577:	jmp    2647 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    257c:	mov    rax,QWORD PTR [rbp-0x50]
    2580:	mov    rcx,QWORD PTR [rax+0x10]
    2584:	lea    rdx,[rip+0x1f2d]        # 44b8 <_IO_stdin_used+0x4b8>
    258b:	lea    rax,[rip+0x1ebd]        # 444f <_IO_stdin_used+0x44f>
    2592:	mov    r8,rcx
    2595:	mov    rcx,rdx
    2598:	mov    edx,0xee
    259d:	mov    rsi,rax
    25a0:	mov    edi,0x1
    25a5:	mov    eax,0x0
    25aa:	call   14a1 <log_message>
        }
      }
      break;
    25af:	jmp    2647 <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    25b4:	lea    rax,[rip+0x1f30]        # 44eb <_IO_stdin_used+0x4eb>
    25bb:	mov    QWORD PTR [rbp-0x30],rax
    25bf:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25c7:	mov    rcx,QWORD PTR [rbp-0x30]
    25cb:	mov    rdx,QWORD PTR [rbp-0x28]
    25cf:	mov    rax,QWORD PTR [rbp-0x50]
    25d3:	mov    rsi,rcx
    25d6:	mov    rdi,rax
    25d9:	call   20e4 <parser_token_is_literal>
    25de:	test   al,al
    25e0:	je     2601 <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    25e2:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    25e9:	mov    rax,QWORD PTR [rbp-0x28]
    25ed:	mov    rdx,rax
    25f0:	mov    rax,QWORD PTR [rbp-0x50]
    25f4:	mov    rsi,rdx
    25f7:	mov    rdi,rax
    25fa:	call   209e <parser_advance>
    25ff:	jmp    2647 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2601:	mov    rax,QWORD PTR [rbp-0x50]
    2605:	mov    rcx,QWORD PTR [rax+0x10]
    2609:	lea    rdx,[rip+0x1ea8]        # 44b8 <_IO_stdin_used+0x4b8>
    2610:	lea    rax,[rip+0x1e38]        # 444f <_IO_stdin_used+0x44f>
    2617:	mov    r8,rcx
    261a:	mov    rcx,rdx
    261d:	mov    edx,0xfd
    2622:	mov    rsi,rax
    2625:	mov    edi,0x1
    262a:	mov    eax,0x0
    262f:	call   14a1 <log_message>
        }
      }
      break;
    2634:	jmp    2647 <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    2636:	mov    rax,QWORD PTR [rbp-0x50]
    263a:	mov    esi,0x1
    263f:	mov    rdi,rax
    2642:	call   209e <parser_advance>
  }

  return token;
    2647:	mov    rcx,QWORD PTR [rbp-0x48]
    264b:	mov    rax,QWORD PTR [rbp-0x20]
    264f:	mov    rdx,QWORD PTR [rbp-0x18]
    2653:	mov    QWORD PTR [rcx],rax
    2656:	mov    QWORD PTR [rcx+0x8],rdx
    265a:	mov    rax,QWORD PTR [rbp-0x10]
    265e:	mov    QWORD PTR [rcx+0x10],rax
}
    2662:	mov    rax,QWORD PTR [rbp-0x48]
    2666:	leave
    2667:	ret

0000000000002668 <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    2668:	push   rbp
    2669:	mov    rbp,rsp
    266c:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    266f:	cmp    DWORD PTR [rbp-0x14],0x7
    2673:	je     268d <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2675:	cmp    DWORD PTR [rbp-0x14],0x9
    2679:	je     268d <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    267b:	cmp    DWORD PTR [rbp-0x14],0xa
    267f:	je     268d <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    2681:	cmp    DWORD PTR [rbp-0x14],0xb
    2685:	je     268d <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    2687:	cmp    DWORD PTR [rbp-0x14],0x8
    268b:	jne    2694 <json_token_type_is_value_type+0x2c>
    268d:	mov    eax,0x1
    2692:	jmp    2699 <json_token_type_is_value_type+0x31>
    2694:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2699:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    269c:	mov    eax,DWORD PTR [rbp-0x4]
}
    269f:	pop    rbp
    26a0:	ret

00000000000026a1 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    26a1:	push   rbp
    26a2:	mov    rbp,rsp
    26a5:	push   rbx
    26a6:	sub    rsp,0x88
    26ad:	mov    QWORD PTR [rbp-0x78],rdi
    26b1:	mov    QWORD PTR [rbp-0x80],rsi
    26b5:	mov    QWORD PTR [rbp-0x90],rdx
    26bc:	mov    QWORD PTR [rbp-0x88],rcx
    26c3:	mov    rax,QWORD PTR fs:0x28
    26cc:	mov    QWORD PTR [rbp-0x18],rax
    26d0:	xor    eax,eax
  profile_begin_func();
    26d2:	lea    r8,[rip+0x2117]        # 47f0 <__func__.4>
    26d9:	mov    r9d,0x11
    26df:	lea    rax,[rbp-0x50]
    26e3:	mov    rsi,r8
    26e6:	mov    rdx,r9
    26e9:	mov    r8d,0x0
    26ef:	mov    ecx,0x1
    26f4:	mov    rdi,rax
    26f7:	call   1e47 <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    26fc:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2704:	mov    eax,DWORD PTR [rbp+0x10]
    2707:	cmp    eax,0x1
    270a:	jne    2736 <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    270c:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    2713:	mov    edx,DWORD PTR [rbp-0x64]
    2716:	mov    rsi,QWORD PTR [rbp-0x80]
    271a:	mov    rax,QWORD PTR [rbp-0x78]
    271e:	mov    ecx,edx
    2720:	mov    edx,0x2
    2725:	mov    rdi,rax
    2728:	call   2888 <parse_json_children>
    272d:	mov    QWORD PTR [rbp-0x60],rax
    2731:	jmp    27c0 <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2736:	mov    eax,DWORD PTR [rbp+0x10]
    2739:	cmp    eax,0x3
    273c:	jne    2765 <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    273e:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2745:	mov    edx,DWORD PTR [rbp-0x68]
    2748:	mov    rsi,QWORD PTR [rbp-0x80]
    274c:	mov    rax,QWORD PTR [rbp-0x78]
    2750:	mov    ecx,edx
    2752:	mov    edx,0x4
    2757:	mov    rdi,rax
    275a:	call   2888 <parse_json_children>
    275f:	mov    QWORD PTR [rbp-0x60],rax
    2763:	jmp    27c0 <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    2765:	mov    eax,DWORD PTR [rbp+0x10]
    2768:	mov    edi,eax
    276a:	call   2668 <json_token_type_is_value_type>
    276f:	test   eax,eax
    2771:	jne    27c0 <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2773:	mov    eax,DWORD PTR [rbp+0x10]
    2776:	mov    eax,eax
    2778:	lea    rdx,[rax*8+0x0]
    2780:	lea    rax,[rip+0x3959]        # 60e0 <JSON_Token_Type_strings>
    2787:	mov    rcx,QWORD PTR [rdx+rax*1]
    278b:	lea    rdx,[rip+0x1d5e]        # 44f0 <_IO_stdin_used+0x4f0>
    2792:	lea    rax,[rip+0x1cb6]        # 444f <_IO_stdin_used+0x44f>
    2799:	push   QWORD PTR [rbp+0x20]
    279c:	push   QWORD PTR [rbp+0x18]
    279f:	mov    r8,rcx
    27a2:	mov    rcx,rdx
    27a5:	mov    edx,0x134
    27aa:	mov    rsi,rax
    27ad:	mov    edi,0x1
    27b2:	mov    eax,0x0
    27b7:	call   14a1 <log_message>
    27bc:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    27c0:	mov    rax,QWORD PTR [rbp-0x78]
    27c4:	mov    edx,0x8
    27c9:	mov    esi,0x30
    27ce:	mov    rdi,rax
    27d1:	call   17d3 <arena_alloc>
    27d6:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    27da:	mov    rcx,QWORD PTR [rbp-0x58]
    27de:	mov    rax,QWORD PTR [rbp-0x90]
    27e5:	mov    rdx,QWORD PTR [rbp-0x88]
    27ec:	mov    QWORD PTR [rcx],rax
    27ef:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    27f3:	mov    rax,QWORD PTR [rbp-0x58]
    27f7:	mov    rdx,QWORD PTR [rbp-0x60]
    27fb:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    27ff:	mov    rax,QWORD PTR [rbp-0x58]
    2803:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    280b:	mov    rcx,QWORD PTR [rbp-0x58]
    280f:	mov    rax,QWORD PTR [rbp+0x18]
    2813:	mov    rdx,QWORD PTR [rbp+0x20]
    2817:	mov    QWORD PTR [rcx+0x10],rax
    281b:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    281f:	sub    rsp,0x8
    2823:	sub    rsp,0x38
    2827:	mov    rax,rsp
    282a:	mov    rcx,QWORD PTR [rbp-0x50]
    282e:	mov    rbx,QWORD PTR [rbp-0x48]
    2832:	mov    QWORD PTR [rax],rcx
    2835:	mov    QWORD PTR [rax+0x8],rbx
    2839:	mov    rcx,QWORD PTR [rbp-0x40]
    283d:	mov    rbx,QWORD PTR [rbp-0x38]
    2841:	mov    QWORD PTR [rax+0x10],rcx
    2845:	mov    QWORD PTR [rax+0x18],rbx
    2849:	mov    rcx,QWORD PTR [rbp-0x30]
    284d:	mov    rbx,QWORD PTR [rbp-0x28]
    2851:	mov    QWORD PTR [rax+0x20],rcx
    2855:	mov    QWORD PTR [rax+0x28],rbx
    2859:	mov    rdx,QWORD PTR [rbp-0x20]
    285d:	mov    QWORD PTR [rax+0x30],rdx
    2861:	call   1f31 <__profile_end_pass>
    2866:	add    rsp,0x40

  return result;
    286a:	mov    rax,QWORD PTR [rbp-0x58]
}
    286e:	mov    rdx,QWORD PTR [rbp-0x18]
    2872:	sub    rdx,QWORD PTR fs:0x28
    287b:	je     2882 <parse_json_object+0x1e1>
    287d:	call   1060 <__stack_chk_fail@plt>
    2882:	mov    rbx,QWORD PTR [rbp-0x8]
    2886:	leave
    2887:	ret

0000000000002888 <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    2888:	push   rbp
    2889:	mov    rbp,rsp
    288c:	push   rbx
    288d:	sub    rsp,0x108
    2894:	mov    QWORD PTR [rbp-0xd8],rdi
    289b:	mov    QWORD PTR [rbp-0xe0],rsi
    28a2:	mov    DWORD PTR [rbp-0xe4],edx
    28a8:	mov    DWORD PTR [rbp-0xe8],ecx
    28ae:	mov    rax,QWORD PTR fs:0x28
    28b7:	mov    QWORD PTR [rbp-0x18],rax
    28bb:	xor    eax,eax
  profile_begin_func();
    28bd:	lea    r8,[rip+0x1f4c]        # 4810 <__func__.3>
    28c4:	mov    r9d,0x13
    28ca:	lea    rax,[rbp-0x50]
    28ce:	mov    rsi,r8
    28d1:	mov    rdx,r9
    28d4:	mov    r8d,0x0
    28da:	mov    ecx,0x2
    28df:	mov    rdi,rax
    28e2:	call   1e47 <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    28e7:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    28f2:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    28fd:	jmp    2bd6 <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2902:	pxor   xmm0,xmm0
    2906:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    290d:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2915:	pxor   xmm0,xmm0
    2919:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2920:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2925:	cmp    DWORD PTR [rbp-0xe8],0x0
    292c:	je     2a39 <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2932:	lea    rax,[rbp-0xb0]
    2939:	mov    rdx,QWORD PTR [rbp-0xe0]
    2940:	mov    rsi,rdx
    2943:	mov    rdi,rax
    2946:	call   216f <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    294b:	mov    eax,DWORD PTR [rbp-0xb0]
    2951:	cmp    eax,0x7
    2954:	jne    29d5 <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2956:	lea    rax,[rbp-0x70]
    295a:	mov    rdx,QWORD PTR [rbp-0xe0]
    2961:	mov    rsi,rdx
    2964:	mov    rdi,rax
    2967:	call   216f <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    296c:	mov    eax,DWORD PTR [rbp-0x70]
    296f:	cmp    eax,0x6
    2972:	jne    2992 <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2974:	lea    rax,[rbp-0x90]
    297b:	mov    rdx,QWORD PTR [rbp-0xe0]
    2982:	mov    rsi,rdx
    2985:	mov    rdi,rax
    2988:	call   216f <get_json_token>
    298d:	jmp    2a79 <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2992:	mov    rcx,QWORD PTR [rbp-0xa8]
    2999:	mov    rax,QWORD PTR [rbp-0xa0]
    29a0:	mov    esi,eax
    29a2:	lea    rdx,[rip+0x1b97]        # 4540 <_IO_stdin_used+0x540>
    29a9:	lea    rax,[rip+0x1a9f]        # 444f <_IO_stdin_used+0x44f>
    29b0:	mov    r9,rcx
    29b3:	mov    r8d,esi
    29b6:	mov    rcx,rdx
    29b9:	mov    edx,0x15f
    29be:	mov    rsi,rax
    29c1:	mov    edi,0x1
    29c6:	mov    eax,0x0
    29cb:	call   14a1 <log_message>
    29d0:	jmp    2a79 <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    29d5:	mov    rcx,QWORD PTR [rbp-0xa8]
    29dc:	mov    rax,QWORD PTR [rbp-0xa0]
    29e3:	mov    edi,eax
    29e5:	mov    eax,DWORD PTR [rbp-0xb0]
    29eb:	mov    eax,eax
    29ed:	lea    rdx,[rax*8+0x0]
    29f5:	lea    rax,[rip+0x36e4]        # 60e0 <JSON_Token_Type_strings>
    29fc:	mov    rsi,QWORD PTR [rdx+rax*1]
    2a00:	lea    rdx,[rip+0x1b59]        # 4560 <_IO_stdin_used+0x560>
    2a07:	lea    rax,[rip+0x1a41]        # 444f <_IO_stdin_used+0x44f>
    2a0e:	sub    rsp,0x8
    2a12:	push   rcx
    2a13:	mov    r9d,edi
    2a16:	mov    r8,rsi
    2a19:	mov    rcx,rdx
    2a1c:	mov    edx,0x164
    2a21:	mov    rsi,rax
    2a24:	mov    edi,0x1
    2a29:	mov    eax,0x0
    2a2e:	call   14a1 <log_message>
    2a33:	add    rsp,0x10
    2a37:	jmp    2a79 <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2a39:	lea    rax,[rbp-0x110]
    2a40:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a47:	mov    rsi,rdx
    2a4a:	mov    rdi,rax
    2a4d:	call   216f <get_json_token>
    2a52:	mov    rax,QWORD PTR [rbp-0x110]
    2a59:	mov    rdx,QWORD PTR [rbp-0x108]
    2a60:	mov    QWORD PTR [rbp-0x90],rax
    2a67:	mov    QWORD PTR [rbp-0x88],rdx
    2a6e:	mov    rax,QWORD PTR [rbp-0x100]
    2a75:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2a79:	mov    eax,DWORD PTR [rbp-0x90]
    2a7f:	cmp    DWORD PTR [rbp-0xe4],eax
    2a85:	je     2bef <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2a8b:	mov    rax,QWORD PTR [rbp-0xa8]
    2a92:	mov    rdx,QWORD PTR [rbp-0xa0]
    2a99:	mov    r8,QWORD PTR [rbp-0xe0]
    2aa0:	mov    rdi,QWORD PTR [rbp-0xd8]
    2aa7:	sub    rsp,0x8
    2aab:	sub    rsp,0x18
    2aaf:	mov    rsi,rsp
    2ab2:	mov    rcx,QWORD PTR [rbp-0x90]
    2ab9:	mov    rbx,QWORD PTR [rbp-0x88]
    2ac0:	mov    QWORD PTR [rsi],rcx
    2ac3:	mov    QWORD PTR [rsi+0x8],rbx
    2ac7:	mov    rcx,QWORD PTR [rbp-0x80]
    2acb:	mov    QWORD PTR [rsi+0x10],rcx
    2acf:	mov    rcx,rdx
    2ad2:	mov    rdx,rax
    2ad5:	mov    rsi,r8
    2ad8:	call   26a1 <parse_json_object>
    2add:	add    rsp,0x20
    2ae1:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2ae8:	cmp    QWORD PTR [rbp-0xb8],0x0
    2af0:	je     2b3a <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2af2:	cmp    QWORD PTR [rbp-0xc8],0x0
    2afa:	jne    2b1a <parse_json_children+0x292>
      {
        first_child        = object;
    2afc:	mov    rax,QWORD PTR [rbp-0xb8]
    2b03:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2b0a:	mov    rax,QWORD PTR [rbp-0xb8]
    2b11:	mov    QWORD PTR [rbp-0xc0],rax
    2b18:	jmp    2b3a <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2b1a:	mov    rax,QWORD PTR [rbp-0xc0]
    2b21:	mov    rdx,QWORD PTR [rbp-0xb8]
    2b28:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2b2c:	mov    rax,QWORD PTR [rbp-0xb8]
    2b33:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2b3a:	lea    rax,[rbp-0x70]
    2b3e:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b45:	mov    rsi,rdx
    2b48:	mov    rdi,rax
    2b4b:	call   216f <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2b50:	mov    eax,DWORD PTR [rbp-0x70]
    2b53:	cmp    DWORD PTR [rbp-0xe4],eax
    2b59:	je     2bf2 <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2b5f:	mov    eax,DWORD PTR [rbp-0x70]
    2b62:	cmp    eax,0x5
    2b65:	je     2bd6 <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2b67:	mov    r8,QWORD PTR [rbp-0x68]
    2b6b:	mov    rax,QWORD PTR [rbp-0x60]
    2b6f:	mov    r9d,eax
    2b72:	mov    eax,DWORD PTR [rbp-0x70]
    2b75:	mov    eax,eax
    2b77:	lea    rdx,[rax*8+0x0]
    2b7f:	lea    rax,[rip+0x355a]        # 60e0 <JSON_Token_Type_strings>
    2b86:	mov    r10,QWORD PTR [rdx+rax*1]
    2b8a:	lea    rdi,[rip+0x19f7]        # 4588 <_IO_stdin_used+0x588>
    2b91:	lea    rsi,[rip+0x18b7]        # 444f <_IO_stdin_used+0x44f>
    2b98:	sub    rsp,0x18
    2b9c:	mov    rcx,rsp
    2b9f:	mov    rax,QWORD PTR [rbp-0x70]
    2ba3:	mov    rdx,QWORD PTR [rbp-0x68]
    2ba7:	mov    QWORD PTR [rcx],rax
    2baa:	mov    QWORD PTR [rcx+0x8],rdx
    2bae:	mov    rax,QWORD PTR [rbp-0x60]
    2bb2:	mov    QWORD PTR [rcx+0x10],rax
    2bb6:	push   r8
    2bb8:	mov    r8,r10
    2bbb:	mov    rcx,rdi
    2bbe:	mov    edx,0x18b
    2bc3:	mov    edi,0x1
    2bc8:	mov    eax,0x0
    2bcd:	call   14a1 <log_message>
    2bd2:	add    rsp,0x20
  while (parser_incomplete(parser))
    2bd6:	mov    rax,QWORD PTR [rbp-0xe0]
    2bdd:	mov    rdi,rax
    2be0:	call   20c4 <parser_incomplete>
    2be5:	test   al,al
    2be7:	jne    2902 <parse_json_children+0x7a>
    2bed:	jmp    2bf3 <parse_json_children+0x36b>
      break;
    2bef:	nop
    2bf0:	jmp    2bf3 <parse_json_children+0x36b>
      break;
    2bf2:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2bf3:	sub    rsp,0x8
    2bf7:	sub    rsp,0x38
    2bfb:	mov    rax,rsp
    2bfe:	mov    rcx,QWORD PTR [rbp-0x50]
    2c02:	mov    rbx,QWORD PTR [rbp-0x48]
    2c06:	mov    QWORD PTR [rax],rcx
    2c09:	mov    QWORD PTR [rax+0x8],rbx
    2c0d:	mov    rcx,QWORD PTR [rbp-0x40]
    2c11:	mov    rbx,QWORD PTR [rbp-0x38]
    2c15:	mov    QWORD PTR [rax+0x10],rcx
    2c19:	mov    QWORD PTR [rax+0x18],rbx
    2c1d:	mov    rcx,QWORD PTR [rbp-0x30]
    2c21:	mov    rbx,QWORD PTR [rbp-0x28]
    2c25:	mov    QWORD PTR [rax+0x20],rcx
    2c29:	mov    QWORD PTR [rax+0x28],rbx
    2c2d:	mov    rdx,QWORD PTR [rbp-0x20]
    2c31:	mov    QWORD PTR [rax+0x30],rdx
    2c35:	call   1f31 <__profile_end_pass>
    2c3a:	add    rsp,0x40

  return first_child;
    2c3e:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2c45:	mov    rdx,QWORD PTR [rbp-0x18]
    2c49:	sub    rdx,QWORD PTR fs:0x28
    2c52:	je     2c59 <parse_json_children+0x3d1>
    2c54:	call   1060 <__stack_chk_fail@plt>
    2c59:	mov    rbx,QWORD PTR [rbp-0x8]
    2c5d:	leave
    2c5e:	ret

0000000000002c5f <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2c5f:	push   rbp
    2c60:	mov    rbp,rsp
    2c63:	push   rbx
    2c64:	sub    rsp,0xb8
    2c6b:	mov    QWORD PTR [rbp-0xa8],rdi
    2c72:	mov    rax,rsi
    2c75:	mov    rsi,rdx
    2c78:	mov    rax,rax
    2c7b:	mov    edx,0x0
    2c80:	mov    rdx,rsi
    2c83:	mov    QWORD PTR [rbp-0xc0],rax
    2c8a:	mov    QWORD PTR [rbp-0xb8],rdx
    2c91:	mov    rax,QWORD PTR fs:0x28
    2c9a:	mov    QWORD PTR [rbp-0x18],rax
    2c9e:	xor    eax,eax
  profile_begin_func();
    2ca0:	lea    rcx,[rip+0x1b81]        # 4828 <__func__.2>
    2ca7:	mov    ebx,0xa
    2cac:	lea    rax,[rbp-0x50]
    2cb0:	mov    rsi,rcx
    2cb3:	mov    rdx,rbx
    2cb6:	mov    r8d,0x0
    2cbc:	mov    ecx,0x3
    2cc1:	mov    rdi,rax
    2cc4:	call   1e47 <__profile_begin_pass>

  JSON_Parser parser =
    2cc9:	mov    rax,QWORD PTR [rbp-0xc0]
    2cd0:	mov    rdx,QWORD PTR [rbp-0xb8]
    2cd7:	mov    QWORD PTR [rbp-0x90],rax
    2cde:	mov    QWORD PTR [rbp-0x88],rdx
    2ce5:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2ced:	lea    rax,[rbp-0x70]
    2cf1:	lea    rdx,[rbp-0x90]
    2cf8:	mov    rsi,rdx
    2cfb:	mov    rdi,rax
    2cfe:	call   216f <get_json_token>
    2d03:	mov    ecx,0x0
    2d08:	mov    ebx,0x0
    2d0d:	lea    r8,[rbp-0x90]
    2d14:	mov    rdi,QWORD PTR [rbp-0xa8]
    2d1b:	sub    rsp,0x8
    2d1f:	sub    rsp,0x18
    2d23:	mov    rsi,rsp
    2d26:	mov    rax,QWORD PTR [rbp-0x70]
    2d2a:	mov    rdx,QWORD PTR [rbp-0x68]
    2d2e:	mov    QWORD PTR [rsi],rax
    2d31:	mov    QWORD PTR [rsi+0x8],rdx
    2d35:	mov    rax,QWORD PTR [rbp-0x60]
    2d39:	mov    QWORD PTR [rsi+0x10],rax
    2d3d:	mov    rdx,rcx
    2d40:	mov    rcx,rbx
    2d43:	mov    rsi,r8
    2d46:	call   26a1 <parse_json_object>
    2d4b:	add    rsp,0x20
    2d4f:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2d56:	sub    rsp,0x8
    2d5a:	sub    rsp,0x38
    2d5e:	mov    rax,rsp
    2d61:	mov    rcx,QWORD PTR [rbp-0x50]
    2d65:	mov    rbx,QWORD PTR [rbp-0x48]
    2d69:	mov    QWORD PTR [rax],rcx
    2d6c:	mov    QWORD PTR [rax+0x8],rbx
    2d70:	mov    rcx,QWORD PTR [rbp-0x40]
    2d74:	mov    rbx,QWORD PTR [rbp-0x38]
    2d78:	mov    QWORD PTR [rax+0x10],rcx
    2d7c:	mov    QWORD PTR [rax+0x18],rbx
    2d80:	mov    rcx,QWORD PTR [rbp-0x30]
    2d84:	mov    rbx,QWORD PTR [rbp-0x28]
    2d88:	mov    QWORD PTR [rax+0x20],rcx
    2d8c:	mov    QWORD PTR [rax+0x28],rbx
    2d90:	mov    rdx,QWORD PTR [rbp-0x20]
    2d94:	mov    QWORD PTR [rax+0x30],rdx
    2d98:	call   1f31 <__profile_end_pass>
    2d9d:	add    rsp,0x40

  return outer;
    2da1:	mov    rax,QWORD PTR [rbp-0x98]
}
    2da8:	mov    rdx,QWORD PTR [rbp-0x18]
    2dac:	sub    rdx,QWORD PTR fs:0x28
    2db5:	je     2dbc <parse_json+0x15d>
    2db7:	call   1060 <__stack_chk_fail@plt>
    2dbc:	mov    rbx,QWORD PTR [rbp-0x8]
    2dc0:	leave
    2dc1:	ret

0000000000002dc2 <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2dc2:	push   rbp
    2dc3:	mov    rbp,rsp
    2dc6:	push   rbx
    2dc7:	sub    rsp,0x78
    2dcb:	mov    QWORD PTR [rbp-0x68],rdi
    2dcf:	mov    rax,rsi
    2dd2:	mov    rsi,rdx
    2dd5:	mov    rax,rax
    2dd8:	mov    edx,0x0
    2ddd:	mov    rdx,rsi
    2de0:	mov    QWORD PTR [rbp-0x80],rax
    2de4:	mov    QWORD PTR [rbp-0x78],rdx
    2de8:	mov    rax,QWORD PTR fs:0x28
    2df1:	mov    QWORD PTR [rbp-0x18],rax
    2df5:	xor    eax,eax
  profile_begin_func();
    2df7:	lea    rcx,[rip+0x1a42]        # 4840 <__func__.1>
    2dfe:	mov    ebx,0x12
    2e03:	lea    rax,[rbp-0x50]
    2e07:	mov    rsi,rcx
    2e0a:	mov    rdx,rbx
    2e0d:	mov    r8d,0x0
    2e13:	mov    ecx,0x4
    2e18:	mov    rdi,rax
    2e1b:	call   1e47 <__profile_begin_pass>

  JSON_Object *result = NULL;
    2e20:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2e28:	cmp    QWORD PTR [rbp-0x68],0x0
    2e2d:	je     2e7c <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2e2f:	mov    rax,QWORD PTR [rbp-0x68]
    2e33:	mov    rax,QWORD PTR [rax+0x20]
    2e37:	mov    QWORD PTR [rbp-0x58],rax
    2e3b:	jmp    2e75 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2e3d:	mov    rax,QWORD PTR [rbp-0x58]
    2e41:	mov    rdx,QWORD PTR [rax+0x8]
    2e45:	mov    rax,QWORD PTR [rax]
    2e48:	mov    rdi,QWORD PTR [rbp-0x80]
    2e4c:	mov    rsi,QWORD PTR [rbp-0x78]
    2e50:	mov    rcx,rdx
    2e53:	mov    rdx,rax
    2e56:	call   143f <strings_equal>
    2e5b:	test   al,al
    2e5d:	je     2e69 <lookup_json_object+0xa7>
      {
        result = cursor;
    2e5f:	mov    rax,QWORD PTR [rbp-0x58]
    2e63:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2e67:	jmp    2e7c <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2e69:	mov    rax,QWORD PTR [rbp-0x58]
    2e6d:	mov    rax,QWORD PTR [rax+0x28]
    2e71:	mov    QWORD PTR [rbp-0x58],rax
    2e75:	cmp    QWORD PTR [rbp-0x58],0x0
    2e7a:	jne    2e3d <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2e7c:	sub    rsp,0x8
    2e80:	sub    rsp,0x38
    2e84:	mov    rax,rsp
    2e87:	mov    rcx,QWORD PTR [rbp-0x50]
    2e8b:	mov    rbx,QWORD PTR [rbp-0x48]
    2e8f:	mov    QWORD PTR [rax],rcx
    2e92:	mov    QWORD PTR [rax+0x8],rbx
    2e96:	mov    rcx,QWORD PTR [rbp-0x40]
    2e9a:	mov    rbx,QWORD PTR [rbp-0x38]
    2e9e:	mov    QWORD PTR [rax+0x10],rcx
    2ea2:	mov    QWORD PTR [rax+0x18],rbx
    2ea6:	mov    rcx,QWORD PTR [rbp-0x30]
    2eaa:	mov    rbx,QWORD PTR [rbp-0x28]
    2eae:	mov    QWORD PTR [rax+0x20],rcx
    2eb2:	mov    QWORD PTR [rax+0x28],rbx
    2eb6:	mov    rdx,QWORD PTR [rbp-0x20]
    2eba:	mov    QWORD PTR [rax+0x30],rdx
    2ebe:	call   1f31 <__profile_end_pass>
    2ec3:	add    rsp,0x40

  return result;
    2ec7:	mov    rax,QWORD PTR [rbp-0x60]
}
    2ecb:	mov    rdx,QWORD PTR [rbp-0x18]
    2ecf:	sub    rdx,QWORD PTR fs:0x28
    2ed8:	je     2edf <lookup_json_object+0x11d>
    2eda:	call   1060 <__stack_chk_fail@plt>
    2edf:	mov    rbx,QWORD PTR [rbp-0x8]
    2ee3:	leave
    2ee4:	ret

0000000000002ee5 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    2ee5:	push   rbp
    2ee6:	mov    rbp,rsp
    2ee9:	sub    rsp,0x50
    2eed:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    2ef1:	cmp    QWORD PTR [rbp-0x48],0x0
    2ef6:	jne    2f1d <json_object_to_f64+0x38>
    2ef8:	lea    rdx,[rip+0x1961]        # 4860 <__PRETTY_FUNCTION__.0>
    2eff:	lea    rsi,[rip+0x1549]        # 444f <_IO_stdin_used+0x44f>
    2f06:	lea    rax,[rip+0x16bb]        # 45c8 <_IO_stdin_used+0x5c8>
    2f0d:	mov    rcx,rdx
    2f10:	mov    edx,0x1c2
    2f15:	mov    rdi,rax
    2f18:	call   1090 <__assert_fail@plt>

  String val = object->value;
    2f1d:	mov    rax,QWORD PTR [rbp-0x48]
    2f21:	mov    rdx,QWORD PTR [rax+0x18]
    2f25:	mov    rax,QWORD PTR [rax+0x10]
    2f29:	mov    QWORD PTR [rbp-0x10],rax
    2f2d:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    2f31:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    2f39:	movsd  xmm0,QWORD PTR [rip+0x1947]        # 4888 <__PRETTY_FUNCTION__.0+0x28>
    2f41:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    2f46:	mov    rax,QWORD PTR [rbp-0x8]
    2f4a:	cmp    QWORD PTR [rbp-0x30],rax
    2f4e:	jae    2f74 <json_object_to_f64+0x8f>
    2f50:	mov    rdx,QWORD PTR [rbp-0x10]
    2f54:	mov    rax,QWORD PTR [rbp-0x30]
    2f58:	add    rax,rdx
    2f5b:	movzx  eax,BYTE PTR [rax]
    2f5e:	cmp    al,0x2d
    2f60:	jne    2f74 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    2f62:	movsd  xmm0,QWORD PTR [rip+0x1926]        # 4890 <__PRETTY_FUNCTION__.0+0x30>
    2f6a:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    2f6f:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    2f74:	pxor   xmm0,xmm0
    2f78:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    2f7d:	jmp    2fc4 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    2f7f:	mov    rdx,QWORD PTR [rbp-0x10]
    2f83:	mov    rax,QWORD PTR [rbp-0x30]
    2f87:	add    rax,rdx
    2f8a:	movzx  eax,BYTE PTR [rax]
    2f8d:	sub    eax,0x30
    2f90:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    2f93:	cmp    BYTE PTR [rbp-0x32],0x9
    2f97:	ja     2fd0 <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    2f99:	movsd  xmm1,QWORD PTR [rbp-0x20]
    2f9e:	movsd  xmm0,QWORD PTR [rip+0x18f2]        # 4898 <__PRETTY_FUNCTION__.0+0x38>
    2fa6:	mulsd  xmm1,xmm0
    2faa:	movzx  eax,BYTE PTR [rbp-0x32]
    2fae:	pxor   xmm0,xmm0
    2fb2:	cvtsi2sd xmm0,eax
    2fb6:	addsd  xmm0,xmm1
    2fba:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    2fbf:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    2fc4:	mov    rax,QWORD PTR [rbp-0x8]
    2fc8:	cmp    QWORD PTR [rbp-0x30],rax
    2fcc:	jb     2f7f <json_object_to_f64+0x9a>
    2fce:	jmp    2fd1 <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    2fd0:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    2fd1:	mov    rax,QWORD PTR [rbp-0x8]
    2fd5:	cmp    QWORD PTR [rbp-0x30],rax
    2fd9:	jae    3066 <json_object_to_f64+0x181>
    2fdf:	mov    rdx,QWORD PTR [rbp-0x10]
    2fe3:	mov    rax,QWORD PTR [rbp-0x30]
    2fe7:	add    rax,rdx
    2fea:	movzx  eax,BYTE PTR [rax]
    2fed:	cmp    al,0x2e
    2fef:	jne    3066 <json_object_to_f64+0x181>
  {
    at += 1;
    2ff1:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    2ff6:	movsd  xmm0,QWORD PTR [rip+0x18a2]        # 48a0 <__PRETTY_FUNCTION__.0+0x40>
    2ffe:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    3003:	jmp    3059 <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3005:	mov    rdx,QWORD PTR [rbp-0x10]
    3009:	mov    rax,QWORD PTR [rbp-0x30]
    300d:	add    rax,rdx
    3010:	movzx  eax,BYTE PTR [rax]
    3013:	sub    eax,0x30
    3016:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    3019:	cmp    BYTE PTR [rbp-0x31],0x9
    301d:	ja     3065 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    301f:	movzx  eax,BYTE PTR [rbp-0x31]
    3023:	pxor   xmm0,xmm0
    3027:	cvtsi2sd xmm0,eax
    302b:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    3030:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3035:	addsd  xmm0,xmm1
    3039:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    303e:	movsd  xmm1,QWORD PTR [rbp-0x18]
    3043:	movsd  xmm0,QWORD PTR [rip+0x1855]        # 48a0 <__PRETTY_FUNCTION__.0+0x40>
    304b:	mulsd  xmm0,xmm1
    304f:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3054:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    3059:	mov    rax,QWORD PTR [rbp-0x8]
    305d:	cmp    QWORD PTR [rbp-0x30],rax
    3061:	jb     3005 <json_object_to_f64+0x120>
    3063:	jmp    3066 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    3065:	nop
      }
    }
  }

  return sign * result;
    3066:	movsd  xmm0,QWORD PTR [rbp-0x28]
    306b:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    3070:	leave
    3071:	ret

0000000000003072 <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    3072:	push   rbp
    3073:	mov    rbp,rsp
    3076:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    307b:	movsd  xmm0,QWORD PTR [rbp-0x8]
    3080:	movsd  xmm1,QWORD PTR [rip+0x1820]        # 48a8 <__PRETTY_FUNCTION__.0+0x48>
    3088:	divsd  xmm0,xmm1
}
    308c:	pop    rbp
    308d:	ret

000000000000308e <square>:

static
f64 square(f64 x)
{
    308e:	push   rbp
    308f:	mov    rbp,rsp
    3092:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    3097:	movsd  xmm0,QWORD PTR [rbp-0x8]
    309c:	mulsd  xmm0,xmm0
}
    30a0:	pop    rbp
    30a1:	ret

00000000000030a2 <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    30a2:	push   rbp
    30a3:	mov    rbp,rsp
    30a6:	sub    rsp,0x90
    30ad:	movsd  QWORD PTR [rbp-0x58],xmm0
    30b2:	movsd  QWORD PTR [rbp-0x60],xmm1
    30b7:	movsd  QWORD PTR [rbp-0x68],xmm2
    30bc:	movsd  QWORD PTR [rbp-0x70],xmm3
    30c1:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    30c6:	movsd  xmm0,QWORD PTR [rbp-0x60]
    30cb:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    30d0:	movsd  xmm0,QWORD PTR [rbp-0x70]
    30d5:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    30da:	movsd  xmm0,QWORD PTR [rbp-0x58]
    30df:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    30e4:	movsd  xmm0,QWORD PTR [rbp-0x68]
    30e9:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    30ee:	movsd  xmm0,QWORD PTR [rbp-0x40]
    30f3:	subsd  xmm0,QWORD PTR [rbp-0x48]
    30f8:	movq   rax,xmm0
    30fd:	movq   xmm0,rax
    3102:	call   3072 <to_radians>
    3107:	movq   rax,xmm0
    310c:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    3110:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3115:	subsd  xmm0,QWORD PTR [rbp-0x38]
    311a:	movq   rax,xmm0
    311f:	movq   xmm0,rax
    3124:	call   3072 <to_radians>
    3129:	movq   rax,xmm0
    312e:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    3132:	mov    rax,QWORD PTR [rbp-0x48]
    3136:	movq   xmm0,rax
    313b:	call   3072 <to_radians>
    3140:	movq   rax,xmm0
    3145:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    3149:	mov    rax,QWORD PTR [rbp-0x40]
    314d:	movq   xmm0,rax
    3152:	call   3072 <to_radians>
    3157:	movq   rax,xmm0
    315c:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    3160:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3165:	movsd  xmm1,QWORD PTR [rip+0x1743]        # 48b0 <__PRETTY_FUNCTION__.0+0x50>
    316d:	divsd  xmm0,xmm1
    3171:	movq   rax,xmm0
    3176:	movq   xmm0,rax
    317b:	call   1130 <sin@plt>
    3180:	movq   rax,xmm0
    3185:	movq   xmm0,rax
    318a:	call   308e <square>
    318f:	movsd  QWORD PTR [rbp-0x80],xmm0
    3194:	mov    rax,QWORD PTR [rbp-0x48]
    3198:	movq   xmm0,rax
    319d:	call   10b0 <cos@plt>
    31a2:	movsd  QWORD PTR [rbp-0x88],xmm0
    31aa:	mov    rax,QWORD PTR [rbp-0x40]
    31ae:	movq   xmm0,rax
    31b3:	call   10b0 <cos@plt>
    31b8:	movapd xmm5,xmm0
    31bc:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    31c4:	movsd  QWORD PTR [rbp-0x88],xmm5
    31cc:	movsd  xmm0,QWORD PTR [rbp-0x20]
    31d1:	movsd  xmm1,QWORD PTR [rip+0x16d7]        # 48b0 <__PRETTY_FUNCTION__.0+0x50>
    31d9:	movapd xmm6,xmm0
    31dd:	divsd  xmm6,xmm1
    31e1:	movq   rax,xmm6
    31e6:	movq   xmm0,rax
    31eb:	call   1130 <sin@plt>
    31f0:	movq   rax,xmm0
    31f5:	movq   xmm0,rax
    31fa:	call   308e <square>
    31ff:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    3207:	addsd  xmm0,QWORD PTR [rbp-0x80]
    320c:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    3211:	mov    rax,QWORD PTR [rbp-0x18]
    3215:	movq   xmm0,rax
    321a:	call   1160 <sqrt@plt>
    321f:	movq   rax,xmm0
    3224:	movq   xmm0,rax
    3229:	call   1140 <asin@plt>
    322e:	addsd  xmm0,xmm0
    3232:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    3237:	movsd  xmm0,QWORD PTR [rbp-0x78]
    323c:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    3241:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3246:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    324b:	leave
    324c:	ret

000000000000324d <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    324d:	push   rbp
    324e:	mov    rbp,rsp
    3251:	movsd  QWORD PTR [rbp-0x18],xmm0
    3256:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    325b:	movsd  xmm0,QWORD PTR [rip+0x1655]        # 48b8 <__PRETTY_FUNCTION__.0+0x58>
    3263:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    3268:	movsd  xmm0,QWORD PTR [rbp-0x18]
    326d:	movq   xmm1,QWORD PTR [rip+0x164b]        # 48c0 <__PRETTY_FUNCTION__.0+0x60>
    3275:	andpd  xmm0,xmm1
    3279:	movsd  xmm1,QWORD PTR [rbp-0x20]
    327e:	movq   xmm2,QWORD PTR [rip+0x163a]        # 48c0 <__PRETTY_FUNCTION__.0+0x60>
    3286:	andpd  xmm2,xmm1
    328a:	movapd xmm1,xmm0
    328e:	subsd  xmm1,xmm2
    3292:	movsd  xmm0,QWORD PTR [rbp-0x8]
    3297:	comisd xmm0,xmm1
    329b:	setae  al
    329e:	movzx  eax,al
}
    32a1:	pop    rbp
    32a2:	ret

00000000000032a3 <main>:

int main(int args_count, char **args)
{
    32a3:	push   rbp
    32a4:	mov    rbp,rsp
    32a7:	push   r15
    32a9:	push   r14
    32ab:	push   r13
    32ad:	push   r12
    32af:	push   rbx
    32b0:	sub    rsp,0x2d8
    32b7:	mov    DWORD PTR [rbp-0x244],edi
    32bd:	mov    QWORD PTR [rbp-0x250],rsi
    32c4:	mov    rax,QWORD PTR fs:0x28
    32cd:	mov    QWORD PTR [rbp-0x38],rax
    32d1:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    32d3:	cmp    DWORD PTR [rbp-0x244],0x3
    32da:	je     3307 <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    32dc:	mov    rax,QWORD PTR [rbp-0x250]
    32e3:	mov    rax,QWORD PTR [rax]
    32e6:	lea    rdx,[rip+0x1313]        # 4600 <_IO_stdin_used+0x600>
    32ed:	mov    rsi,rax
    32f0:	mov    rdi,rdx
    32f3:	mov    eax,0x0
    32f8:	call   1070 <printf@plt>
    return 1;
    32fd:	mov    eax,0x1
    3302:	jmp    3da5 <main+0xb02>
  }

  begin_profiling();
    3307:	call   1b3d <begin_profiling>

  Arena arena = {0};
    330c:	pxor   xmm0,xmm0
    3310:	movaps XMMWORD PTR [rbp-0x190],xmm0
    3317:	movaps XMMWORD PTR [rbp-0x180],xmm0
  arena = arena_make(GB(4));
    331e:	lea    rdx,[rbp-0x270]
    3325:	movabs rax,0x100000000
    332f:	mov    rsi,rax
    3332:	mov    rdi,rdx
    3335:	call   1632 <arena_make>
    333a:	mov    rax,QWORD PTR [rbp-0x270]
    3341:	mov    rdx,QWORD PTR [rbp-0x268]
    3348:	mov    QWORD PTR [rbp-0x190],rax
    334f:	mov    QWORD PTR [rbp-0x188],rdx
    3356:	mov    rax,QWORD PTR [rbp-0x260]
    335d:	mov    rdx,QWORD PTR [rbp-0x258]
    3364:	mov    QWORD PTR [rbp-0x180],rax
    336b:	mov    QWORD PTR [rbp-0x178],rdx

  String source = {0};
    3372:	mov    QWORD PTR [rbp-0x1a0],0x0
    337d:	mov    QWORD PTR [rbp-0x198],0x0
  PROFILE_SCOPE_BANDWIDTH("read", 10)
    3388:	lea    r12,[rip+0x129d]        # 462c <_IO_stdin_used+0x62c>
    338f:	mov    r13d,0x4
    3395:	lea    rdi,[rbp-0x170]
    339c:	mov    rdx,r12
    339f:	mov    rax,r13
    33a2:	mov    r8d,0xa
    33a8:	mov    ecx,0x5
    33ad:	mov    rsi,rdx
    33b0:	mov    rdx,rax
    33b3:	call   1e47 <__profile_begin_pass>
    33b8:	mov    QWORD PTR [rbp-0x230],0x0
    33c3:	jmp    345e <main+0x1bb>
  {
    source = read_file_to_arena(&arena, args[1]);
    33c8:	mov    rax,QWORD PTR [rbp-0x250]
    33cf:	add    rax,0x8
    33d3:	mov    rdx,QWORD PTR [rax]
    33d6:	lea    rax,[rbp-0x190]
    33dd:	mov    rsi,rdx
    33e0:	mov    rdi,rax
    33e3:	call   1357 <read_file_to_arena>
    33e8:	mov    QWORD PTR [rbp-0x1a0],rax
    33ef:	mov    QWORD PTR [rbp-0x198],rdx
  PROFILE_SCOPE_BANDWIDTH("read", 10)
    33f6:	add    QWORD PTR [rbp-0x230],0x1
    33fe:	sub    rsp,0x8
    3402:	sub    rsp,0x38
    3406:	mov    rcx,rsp
    3409:	mov    rax,QWORD PTR [rbp-0x170]
    3410:	mov    rdx,QWORD PTR [rbp-0x168]
    3417:	mov    QWORD PTR [rcx],rax
    341a:	mov    QWORD PTR [rcx+0x8],rdx
    341e:	mov    rax,QWORD PTR [rbp-0x160]
    3425:	mov    rdx,QWORD PTR [rbp-0x158]
    342c:	mov    QWORD PTR [rcx+0x10],rax
    3430:	mov    QWORD PTR [rcx+0x18],rdx
    3434:	mov    rax,QWORD PTR [rbp-0x150]
    343b:	mov    rdx,QWORD PTR [rbp-0x148]
    3442:	mov    QWORD PTR [rcx+0x20],rax
    3446:	mov    QWORD PTR [rcx+0x28],rdx
    344a:	mov    rax,QWORD PTR [rbp-0x140]
    3451:	mov    QWORD PTR [rcx+0x30],rax
    3455:	call   1f31 <__profile_end_pass>
    345a:	add    rsp,0x40
    345e:	cmp    QWORD PTR [rbp-0x230],0x0
    3466:	je     33c8 <main+0x125>
  }

  Haversine_Pair *pairs = NULL;
    346c:	mov    QWORD PTR [rbp-0x228],0x0
  i32 pair_count = 0;
    3477:	mov    DWORD PTR [rbp-0x238],0x0
  usize max_pairs = 0;
    3481:	mov    QWORD PTR [rbp-0x220],0x0
  PROFILE_SCOPE("haversine alloc")
    348c:	lea    r14,[rip+0x119e]        # 4631 <_IO_stdin_used+0x631>
    3493:	mov    r15d,0xf
    3499:	lea    rdi,[rbp-0x130]
    34a0:	mov    rdx,r14
    34a3:	mov    rax,r15
    34a6:	mov    r8d,0x0
    34ac:	mov    ecx,0x6
    34b1:	mov    rsi,rdx
    34b4:	mov    rdx,rax
    34b7:	call   1e47 <__profile_begin_pass>
    34bc:	mov    QWORD PTR [rbp-0x218],0x0
    34c7:	jmp    358f <main+0x2ec>
  {
    usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    34cc:	mov    QWORD PTR [rbp-0x1a8],0x18
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    34d7:	mov    rax,QWORD PTR [rbp-0x198]
    34de:	mov    edx,0x0
    34e3:	div    QWORD PTR [rbp-0x1a8]
    34ea:	mov    QWORD PTR [rbp-0x220],rax

    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    34f1:	mov    rax,QWORD PTR [rbp-0x220]
    34f8:	shl    rax,0x5
    34fc:	mov    rcx,rax
    34ff:	lea    rax,[rbp-0x190]
    3506:	mov    edx,0x8
    350b:	mov    rsi,rcx
    350e:	mov    rdi,rax
    3511:	call   17d3 <arena_alloc>
    3516:	mov    QWORD PTR [rbp-0x228],rax
    pair_count = 0;
    351d:	mov    DWORD PTR [rbp-0x238],0x0
  PROFILE_SCOPE("haversine alloc")
    3527:	add    QWORD PTR [rbp-0x218],0x1
    352f:	sub    rsp,0x8
    3533:	sub    rsp,0x38
    3537:	mov    rcx,rsp
    353a:	mov    rax,QWORD PTR [rbp-0x130]
    3541:	mov    rdx,QWORD PTR [rbp-0x128]
    3548:	mov    QWORD PTR [rcx],rax
    354b:	mov    QWORD PTR [rcx+0x8],rdx
    354f:	mov    rax,QWORD PTR [rbp-0x120]
    3556:	mov    rdx,QWORD PTR [rbp-0x118]
    355d:	mov    QWORD PTR [rcx+0x10],rax
    3561:	mov    QWORD PTR [rcx+0x18],rdx
    3565:	mov    rax,QWORD PTR [rbp-0x110]
    356c:	mov    rdx,QWORD PTR [rbp-0x108]
    3573:	mov    QWORD PTR [rcx+0x20],rax
    3577:	mov    QWORD PTR [rcx+0x28],rdx
    357b:	mov    rax,QWORD PTR [rbp-0x100]
    3582:	mov    QWORD PTR [rcx+0x30],rax
    3586:	call   1f31 <__profile_end_pass>
    358b:	add    rsp,0x40
    358f:	cmp    QWORD PTR [rbp-0x218],0x0
    3597:	je     34cc <main+0x229>
  }

  JSON_Object *root = NULL;
    359d:	mov    QWORD PTR [rbp-0x1d8],0x0
  root = parse_json(&arena, source);
    35a8:	mov    rcx,QWORD PTR [rbp-0x1a0]
    35af:	mov    rdx,QWORD PTR [rbp-0x198]
    35b6:	lea    rax,[rbp-0x190]
    35bd:	mov    rsi,rcx
    35c0:	mov    rdi,rax
    35c3:	call   2c5f <parse_json>
    35c8:	mov    QWORD PTR [rbp-0x1d8],rax

  f64 haversine_sum = 0.0;
    35cf:	pxor   xmm0,xmm0
    35d3:	movsd  QWORD PTR [rbp-0x1d0],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    35db:	lea    rax,[rip+0x105f]        # 4641 <_IO_stdin_used+0x641>
    35e2:	mov    QWORD PTR [rbp-0x280],rax
    35e9:	mov    QWORD PTR [rbp-0x278],0x5
    35f4:	mov    rax,QWORD PTR [rbp-0x280]
    35fb:	mov    rdx,QWORD PTR [rbp-0x278]
    3602:	mov    rcx,rax
    3605:	mov    rax,QWORD PTR [rbp-0x1d8]
    360c:	mov    rsi,rcx
    360f:	mov    rdi,rax
    3612:	call   2dc2 <lookup_json_object>
    3617:	mov    QWORD PTR [rbp-0x1c8],rax
  if (pairs)
    361e:	cmp    QWORD PTR [rbp-0x228],0x0
    3626:	je     38bb <main+0x618>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    362c:	mov    rax,QWORD PTR [rbp-0x1c8]
    3633:	mov    rax,QWORD PTR [rax+0x20]
    3637:	mov    QWORD PTR [rbp-0x210],rax
    363e:	jmp    389c <main+0x5f9>
    {
      PROFILE_SCOPE("child convert")
    3643:	lea    rax,[rip+0xffd]        # 4647 <_IO_stdin_used+0x647>
    364a:	mov    QWORD PTR [rbp-0x2c0],rax
    3651:	mov    QWORD PTR [rbp-0x2b8],0xd
    365c:	lea    rdi,[rbp-0x70]
    3660:	mov    rbx,QWORD PTR [rbp-0x2c0]
    3667:	mov    rsi,QWORD PTR [rbp-0x2b8]
    366e:	mov    rdx,rbx
    3671:	mov    rax,rsi
    3674:	mov    r8d,0x0
    367a:	mov    ecx,0x7
    367f:	mov    rsi,rdx
    3682:	mov    rdx,rax
    3685:	call   1e47 <__profile_begin_pass>
    368a:	mov    QWORD PTR [rbp-0x208],0x0
    3695:	jmp    387c <main+0x5d9>
      {
        Haversine_Pair pair =
        {
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    369a:	lea    rax,[rip+0xfb4]        # 4655 <_IO_stdin_used+0x655>
    36a1:	mov    QWORD PTR [rbp-0x2d0],rax
    36a8:	mov    QWORD PTR [rbp-0x2c8],0x2
    36b3:	mov    rbx,QWORD PTR [rbp-0x2d0]
    36ba:	mov    rsi,QWORD PTR [rbp-0x2c8]
    36c1:	mov    rax,rbx
    36c4:	mov    rdx,rsi
    36c7:	mov    rcx,QWORD PTR [rbp-0x210]
    36ce:	mov    rsi,rax
    36d1:	mov    rdi,rcx
    36d4:	call   2dc2 <lookup_json_object>
    36d9:	mov    rdi,rax
    36dc:	call   2ee5 <json_object_to_f64>
    36e1:	movq   rax,xmm0
        Haversine_Pair pair =
    36e6:	mov    QWORD PTR [rbp-0xb0],rax
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    36ed:	lea    rax,[rip+0xf64]        # 4658 <_IO_stdin_used+0x658>
    36f4:	mov    QWORD PTR [rbp-0x2e0],rax
    36fb:	mov    QWORD PTR [rbp-0x2d8],0x2
    3706:	mov    rax,QWORD PTR [rbp-0x2e0]
    370d:	mov    rdx,QWORD PTR [rbp-0x2d8]
    3714:	mov    rcx,rax
    3717:	mov    rax,QWORD PTR [rbp-0x210]
    371e:	mov    rsi,rcx
    3721:	mov    rdi,rax
    3724:	call   2dc2 <lookup_json_object>
    3729:	mov    rdi,rax
    372c:	call   2ee5 <json_object_to_f64>
    3731:	movq   rax,xmm0
        Haversine_Pair pair =
    3736:	mov    QWORD PTR [rbp-0xa8],rax
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    373d:	lea    rax,[rip+0xf17]        # 465b <_IO_stdin_used+0x65b>
    3744:	mov    QWORD PTR [rbp-0x2f0],rax
    374b:	mov    QWORD PTR [rbp-0x2e8],0x2
    3756:	mov    rax,QWORD PTR [rbp-0x2f0]
    375d:	mov    rdx,QWORD PTR [rbp-0x2e8]
    3764:	mov    rcx,rax
    3767:	mov    rax,QWORD PTR [rbp-0x210]
    376e:	mov    rsi,rcx
    3771:	mov    rdi,rax
    3774:	call   2dc2 <lookup_json_object>
    3779:	mov    rdi,rax
    377c:	call   2ee5 <json_object_to_f64>
    3781:	movq   rax,xmm0
        Haversine_Pair pair =
    3786:	mov    QWORD PTR [rbp-0xa0],rax
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    378d:	lea    rax,[rip+0xeca]        # 465e <_IO_stdin_used+0x65e>
    3794:	mov    QWORD PTR [rbp-0x300],rax
    379b:	mov    QWORD PTR [rbp-0x2f8],0x2
    37a6:	mov    rax,QWORD PTR [rbp-0x300]
    37ad:	mov    rdx,QWORD PTR [rbp-0x2f8]
    37b4:	mov    rcx,rax
    37b7:	mov    rax,QWORD PTR [rbp-0x210]
    37be:	mov    rsi,rcx
    37c1:	mov    rdi,rax
    37c4:	call   2dc2 <lookup_json_object>
    37c9:	mov    rdi,rax
    37cc:	call   2ee5 <json_object_to_f64>
    37d1:	movq   rax,xmm0
        Haversine_Pair pair =
    37d6:	mov    QWORD PTR [rbp-0x98],rax
        };

        pairs[pair_count] = pair;
    37dd:	mov    eax,DWORD PTR [rbp-0x238]
    37e3:	cdqe
    37e5:	shl    rax,0x5
    37e9:	mov    rdx,rax
    37ec:	mov    rax,QWORD PTR [rbp-0x228]
    37f3:	lea    rcx,[rdx+rax*1]
    37f7:	mov    rax,QWORD PTR [rbp-0xb0]
    37fe:	mov    rdx,QWORD PTR [rbp-0xa8]
    3805:	mov    QWORD PTR [rcx],rax
    3808:	mov    QWORD PTR [rcx+0x8],rdx
    380c:	mov    rax,QWORD PTR [rbp-0xa0]
    3813:	mov    rdx,QWORD PTR [rbp-0x98]
    381a:	mov    QWORD PTR [rcx+0x10],rax
    381e:	mov    QWORD PTR [rcx+0x18],rdx
        pair_count += 1;
    3822:	add    DWORD PTR [rbp-0x238],0x1
      PROFILE_SCOPE("child convert")
    3829:	add    QWORD PTR [rbp-0x208],0x1
    3831:	sub    rsp,0x8
    3835:	sub    rsp,0x38
    3839:	mov    rcx,rsp
    383c:	mov    rax,QWORD PTR [rbp-0x70]
    3840:	mov    rdx,QWORD PTR [rbp-0x68]
    3844:	mov    QWORD PTR [rcx],rax
    3847:	mov    QWORD PTR [rcx+0x8],rdx
    384b:	mov    rax,QWORD PTR [rbp-0x60]
    384f:	mov    rdx,QWORD PTR [rbp-0x58]
    3853:	mov    QWORD PTR [rcx+0x10],rax
    3857:	mov    QWORD PTR [rcx+0x18],rdx
    385b:	mov    rax,QWORD PTR [rbp-0x50]
    385f:	mov    rdx,QWORD PTR [rbp-0x48]
    3863:	mov    QWORD PTR [rcx+0x20],rax
    3867:	mov    QWORD PTR [rcx+0x28],rdx
    386b:	mov    rax,QWORD PTR [rbp-0x40]
    386f:	mov    QWORD PTR [rcx+0x30],rax
    3873:	call   1f31 <__profile_end_pass>
    3878:	add    rsp,0x40
    387c:	cmp    QWORD PTR [rbp-0x208],0x0
    3884:	je     369a <main+0x3f7>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    388a:	mov    rax,QWORD PTR [rbp-0x210]
    3891:	mov    rax,QWORD PTR [rax+0x28]
    3895:	mov    QWORD PTR [rbp-0x210],rax
    389c:	cmp    QWORD PTR [rbp-0x210],0x0
    38a4:	je     38bb <main+0x618>
    38a6:	mov    eax,DWORD PTR [rbp-0x238]
    38ac:	cdqe
    38ae:	cmp    rax,QWORD PTR [rbp-0x220]
    38b5:	jb     3643 <main+0x3a0>
      }
    }
  }

  f64 sum = 0.0;
    38bb:	pxor   xmm0,xmm0
    38bf:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    38c7:	lea    rax,[rip+0xd93]        # 4661 <_IO_stdin_used+0x661>
    38ce:	mov    QWORD PTR [rbp-0x290],rax
    38d5:	mov    QWORD PTR [rbp-0x288],0x3
    38e0:	lea    rax,[rbp-0xf0]
    38e7:	mov    rcx,QWORD PTR [rbp-0x290]
    38ee:	mov    rbx,QWORD PTR [rbp-0x288]
    38f5:	mov    rsi,rcx
    38f8:	mov    rdx,rbx
    38fb:	mov    r8d,0x0
    3901:	mov    ecx,0x8
    3906:	mov    rdi,rax
    3909:	call   1e47 <__profile_begin_pass>
    390e:	mov    QWORD PTR [rbp-0x1f8],0x0
    3919:	jmp    3a9b <main+0x7f8>
  {
    for (usize i = 0; i < pair_count; i++)
    391e:	mov    QWORD PTR [rbp-0x1f0],0x0
    3929:	jmp    39fe <main+0x75b>
    {
      f64 earth_radius = 6372.8;
    392e:	movsd  xmm0,QWORD PTR [rip+0xf9a]        # 48d0 <__PRETTY_FUNCTION__.0+0x70>
    3936:	movsd  QWORD PTR [rbp-0x1b8],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    393e:	mov    rax,QWORD PTR [rbp-0x1f0]
    3945:	shl    rax,0x5
    3949:	mov    rdx,rax
    394c:	mov    rax,QWORD PTR [rbp-0x228]
    3953:	add    rax,rdx
    3956:	movsd  xmm2,QWORD PTR [rax+0x18]
    395b:	mov    rax,QWORD PTR [rbp-0x1f0]
    3962:	shl    rax,0x5
    3966:	mov    rdx,rax
    3969:	mov    rax,QWORD PTR [rbp-0x228]
    3970:	add    rax,rdx
    3973:	movsd  xmm1,QWORD PTR [rax+0x10]
    3978:	mov    rax,QWORD PTR [rbp-0x1f0]
    397f:	shl    rax,0x5
    3983:	mov    rdx,rax
    3986:	mov    rax,QWORD PTR [rbp-0x228]
    398d:	add    rax,rdx
    3990:	movsd  xmm0,QWORD PTR [rax+0x8]
    3995:	mov    rax,QWORD PTR [rbp-0x1f0]
    399c:	shl    rax,0x5
    39a0:	mov    rdx,rax
    39a3:	mov    rax,QWORD PTR [rbp-0x228]
    39aa:	add    rax,rdx
    39ad:	mov    rax,QWORD PTR [rax]
    39b0:	movsd  xmm3,QWORD PTR [rbp-0x1b8]
    39b8:	movapd xmm4,xmm3
    39bc:	movapd xmm3,xmm2
    39c0:	movapd xmm2,xmm1
    39c4:	movapd xmm1,xmm0
    39c8:	movq   xmm0,rax
    39cd:	call   30a2 <reference_haversine>
    39d2:	movq   rax,xmm0
    39d7:	mov    QWORD PTR [rbp-0x1b0],rax
      sum += result;
    39de:	movsd  xmm0,QWORD PTR [rbp-0x200]
    39e6:	addsd  xmm0,QWORD PTR [rbp-0x1b0]
    39ee:	movsd  QWORD PTR [rbp-0x200],xmm0
    for (usize i = 0; i < pair_count; i++)
    39f6:	add    QWORD PTR [rbp-0x1f0],0x1
    39fe:	mov    eax,DWORD PTR [rbp-0x238]
    3a04:	cdqe
    3a06:	cmp    QWORD PTR [rbp-0x1f0],rax
    3a0d:	jb     392e <main+0x68b>
    }
    sum /= pair_count;
    3a13:	pxor   xmm1,xmm1
    3a17:	cvtsi2sd xmm1,DWORD PTR [rbp-0x238]
    3a1f:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3a27:	divsd  xmm0,xmm1
    3a2b:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3a33:	add    QWORD PTR [rbp-0x1f8],0x1
    3a3b:	sub    rsp,0x8
    3a3f:	sub    rsp,0x38
    3a43:	mov    rax,rsp
    3a46:	mov    rcx,QWORD PTR [rbp-0xf0]
    3a4d:	mov    rbx,QWORD PTR [rbp-0xe8]
    3a54:	mov    QWORD PTR [rax],rcx
    3a57:	mov    QWORD PTR [rax+0x8],rbx
    3a5b:	mov    rcx,QWORD PTR [rbp-0xe0]
    3a62:	mov    rbx,QWORD PTR [rbp-0xd8]
    3a69:	mov    QWORD PTR [rax+0x10],rcx
    3a6d:	mov    QWORD PTR [rax+0x18],rbx
    3a71:	mov    rcx,QWORD PTR [rbp-0xd0]
    3a78:	mov    rbx,QWORD PTR [rbp-0xc8]
    3a7f:	mov    QWORD PTR [rax+0x20],rcx
    3a83:	mov    QWORD PTR [rax+0x28],rbx
    3a87:	mov    rdx,QWORD PTR [rbp-0xc0]
    3a8e:	mov    QWORD PTR [rax+0x30],rdx
    3a92:	call   1f31 <__profile_end_pass>
    3a97:	add    rsp,0x40
    3a9b:	cmp    QWORD PTR [rbp-0x1f8],0x0
    3aa3:	je     391e <main+0x67b>
  }

  PROFILE_SCOPE("check")
    3aa9:	lea    rax,[rip+0xbb5]        # 4665 <_IO_stdin_used+0x665>
    3ab0:	mov    QWORD PTR [rbp-0x2a0],rax
    3ab7:	mov    QWORD PTR [rbp-0x298],0x5
    3ac2:	lea    rax,[rbp-0xb0]
    3ac9:	mov    rcx,QWORD PTR [rbp-0x2a0]
    3ad0:	mov    rbx,QWORD PTR [rbp-0x298]
    3ad7:	mov    rsi,rcx
    3ada:	mov    rdx,rbx
    3add:	mov    r8d,0x0
    3ae3:	mov    ecx,0x9
    3ae8:	mov    rdi,rax
    3aeb:	call   1e47 <__profile_begin_pass>
    3af0:	mov    QWORD PTR [rbp-0x1e8],0x0
    3afb:	jmp    3cd0 <main+0xa2d>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3b00:	mov    rax,QWORD PTR [rbp-0x250]
    3b07:	add    rax,0x10
    3b0b:	mov    rdx,QWORD PTR [rax]
    3b0e:	lea    rax,[rbp-0x190]
    3b15:	mov    rsi,rdx
    3b18:	mov    rdi,rax
    3b1b:	call   1357 <read_file_to_arena>
    3b20:	mov    QWORD PTR [rbp-0x70],rax
    3b24:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3b28:	mov    rax,QWORD PTR [rbp-0x68]
    3b2c:	cmp    rax,0xb
    3b30:	jbe    3c43 <main+0x9a0>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3b36:	mov    rax,QWORD PTR [rbp-0x70]
    3b3a:	movsd  xmm0,QWORD PTR [rax]
    3b3e:	movsd  QWORD PTR [rbp-0x1c0],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3b46:	mov    rax,QWORD PTR [rbp-0x70]
    3b4a:	mov    eax,DWORD PTR [rax+0x8]
    3b4d:	mov    DWORD PTR [rbp-0x234],eax

      if (solution_pairs == pair_count)
    3b53:	mov    eax,DWORD PTR [rbp-0x234]
    3b59:	cmp    eax,DWORD PTR [rbp-0x238]
    3b5f:	jne    3c07 <main+0x964>
      {
        if (epsilon_equal(solution_sum, sum))
    3b65:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b6d:	mov    rax,QWORD PTR [rbp-0x1c0]
    3b74:	movapd xmm1,xmm0
    3b78:	movq   xmm0,rax
    3b7d:	call   324d <epsilon_equal>
    3b82:	test   eax,eax
    3b84:	je     3bc8 <main+0x925>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3b86:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b8e:	mov    rax,QWORD PTR [rbp-0x1c0]
    3b95:	lea    rdx,[rip+0xad4]        # 4670 <_IO_stdin_used+0x670>
    3b9c:	lea    rsi,[rip+0xb00]        # 46a3 <_IO_stdin_used+0x6a3>
    3ba3:	movapd xmm1,xmm0
    3ba7:	movq   xmm0,rax
    3bac:	mov    rcx,rdx
    3baf:	mov    edx,0x64
    3bb4:	mov    edi,0x3
    3bb9:	mov    eax,0x2
    3bbe:	call   14a1 <log_message>
    3bc3:	jmp    3c6b <main+0x9c8>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3bc8:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3bd0:	mov    rax,QWORD PTR [rbp-0x1c0]
    3bd7:	lea    rdx,[rip+0xada]        # 46b8 <_IO_stdin_used+0x6b8>
    3bde:	lea    rsi,[rip+0xabe]        # 46a3 <_IO_stdin_used+0x6a3>
    3be5:	movapd xmm1,xmm0
    3be9:	movq   xmm0,rax
    3bee:	mov    rcx,rdx
    3bf1:	mov    edx,0x68
    3bf6:	mov    edi,0x1
    3bfb:	mov    eax,0x2
    3c00:	call   14a1 <log_message>
    3c05:	jmp    3c6b <main+0x9c8>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3c07:	mov    esi,DWORD PTR [rbp-0x238]
    3c0d:	mov    ecx,DWORD PTR [rbp-0x234]
    3c13:	lea    rdx,[rip+0xad6]        # 46f0 <_IO_stdin_used+0x6f0>
    3c1a:	lea    rax,[rip+0xa82]        # 46a3 <_IO_stdin_used+0x6a3>
    3c21:	mov    r9d,esi
    3c24:	mov    r8d,ecx
    3c27:	mov    rcx,rdx
    3c2a:	mov    edx,0x6d
    3c2f:	mov    rsi,rax
    3c32:	mov    edi,0x1
    3c37:	mov    eax,0x0
    3c3c:	call   14a1 <log_message>
    3c41:	jmp    3c6b <main+0x9c8>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3c43:	lea    rdx,[rip+0xaee]        # 4738 <_IO_stdin_used+0x738>
    3c4a:	lea    rax,[rip+0xa52]        # 46a3 <_IO_stdin_used+0x6a3>
    3c51:	mov    rcx,rdx
    3c54:	mov    edx,0x72
    3c59:	mov    rsi,rax
    3c5c:	mov    edi,0x1
    3c61:	mov    eax,0x0
    3c66:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3c6b:	add    QWORD PTR [rbp-0x1e8],0x1
    3c73:	sub    rsp,0x8
    3c77:	sub    rsp,0x38
    3c7b:	mov    rax,rsp
    3c7e:	mov    rcx,QWORD PTR [rbp-0xb0]
    3c85:	mov    rbx,QWORD PTR [rbp-0xa8]
    3c8c:	mov    QWORD PTR [rax],rcx
    3c8f:	mov    QWORD PTR [rax+0x8],rbx
    3c93:	mov    rcx,QWORD PTR [rbp-0xa0]
    3c9a:	mov    rbx,QWORD PTR [rbp-0x98]
    3ca1:	mov    QWORD PTR [rax+0x10],rcx
    3ca5:	mov    QWORD PTR [rax+0x18],rbx
    3ca9:	mov    rcx,QWORD PTR [rbp-0x90]
    3cb0:	mov    rbx,QWORD PTR [rbp-0x88]
    3cb7:	mov    QWORD PTR [rax+0x20],rcx
    3cbb:	mov    QWORD PTR [rax+0x28],rbx
    3cbf:	mov    rdx,QWORD PTR [rbp-0x80]
    3cc3:	mov    QWORD PTR [rax+0x30],rdx
    3cc7:	call   1f31 <__profile_end_pass>
    3ccc:	add    rsp,0x40
    3cd0:	cmp    QWORD PTR [rbp-0x1e8],0x0
    3cd8:	je     3b00 <main+0x85d>
    }
  }

  PROFILE_SCOPE("free")
    3cde:	lea    rax,[rip+0xa8e]        # 4773 <_IO_stdin_used+0x773>
    3ce5:	mov    QWORD PTR [rbp-0x2b0],rax
    3cec:	mov    QWORD PTR [rbp-0x2a8],0x4
    3cf7:	lea    rax,[rbp-0x70]
    3cfb:	mov    rcx,QWORD PTR [rbp-0x2b0]
    3d02:	mov    rbx,QWORD PTR [rbp-0x2a8]
    3d09:	mov    rsi,rcx
    3d0c:	mov    rdx,rbx
    3d0f:	mov    r8d,0x0
    3d15:	mov    ecx,0xa
    3d1a:	mov    rdi,rax
    3d1d:	call   1e47 <__profile_begin_pass>
    3d22:	mov    QWORD PTR [rbp-0x1e0],0x0
    3d2d:	jmp    3d91 <main+0xaee>
  {
    arena_free(&arena);
    3d2f:	lea    rax,[rbp-0x190]
    3d36:	mov    rdi,rax
    3d39:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3d3e:	add    QWORD PTR [rbp-0x1e0],0x1
    3d46:	sub    rsp,0x8
    3d4a:	sub    rsp,0x38
    3d4e:	mov    rax,rsp
    3d51:	mov    rcx,QWORD PTR [rbp-0x70]
    3d55:	mov    rbx,QWORD PTR [rbp-0x68]
    3d59:	mov    QWORD PTR [rax],rcx
    3d5c:	mov    QWORD PTR [rax+0x8],rbx
    3d60:	mov    rcx,QWORD PTR [rbp-0x60]
    3d64:	mov    rbx,QWORD PTR [rbp-0x58]
    3d68:	mov    QWORD PTR [rax+0x10],rcx
    3d6c:	mov    QWORD PTR [rax+0x18],rbx
    3d70:	mov    rcx,QWORD PTR [rbp-0x50]
    3d74:	mov    rbx,QWORD PTR [rbp-0x48]
    3d78:	mov    QWORD PTR [rax+0x20],rcx
    3d7c:	mov    QWORD PTR [rax+0x28],rbx
    3d80:	mov    rdx,QWORD PTR [rbp-0x40]
    3d84:	mov    QWORD PTR [rax+0x30],rdx
    3d88:	call   1f31 <__profile_end_pass>
    3d8d:	add    rsp,0x40
    3d91:	cmp    QWORD PTR [rbp-0x1e0],0x0
    3d99:	je     3d2f <main+0xa8c>
  }

  end_profiling();
    3d9b:	call   1b9b <end_profiling>
    3da0:	mov    eax,0x0
}
    3da5:	mov    rdx,QWORD PTR [rbp-0x38]
    3da9:	sub    rdx,QWORD PTR fs:0x28
    3db2:	je     3db9 <main+0xb16>
    3db4:	call   1060 <__stack_chk_fail@plt>
    3db9:	lea    rsp,[rbp-0x28]
    3dbd:	pop    rbx
    3dbe:	pop    r12
    3dc0:	pop    r13
    3dc2:	pop    r14
    3dc4:	pop    r15
    3dc6:	pop    rbp
    3dc7:	ret

Disassembly of section .fini:

0000000000003dc8 <_fini>:
    3dc8:	endbr64
    3dcc:	sub    rsp,0x8
    3dd0:	add    rsp,0x8
    3dd4:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x4fc1]        # 5fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x4fca]        # 5ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x4fcc]        # 5ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x4fca]        # 6000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x4fc2]        # 6008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x4fba]        # 6010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x4fb2]        # 6018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x4faa]        # 6020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x4fa2]        # 6028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x4f9a]        # 6030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x4f92]        # 6038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x4f8a]        # 6040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x4f82]        # 6048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x4f7a]        # 6050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x4f72]        # 6058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x4f6a]        # 6060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x4f62]        # 6068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x4f5a]        # 6070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x4f52]        # 6078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x4f4a]        # 6080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x4f42]        # 6088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x4f3a]        # 6090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x4f32]        # 6098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2114]        # 32a3 <main>
    118f:	call   QWORD PTR [rip+0x4e2b]        # 5fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x4fa1]        # 6148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x4f9a]        # 6148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x4e0e]        # 5fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x4f71]        # 6148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x4f6a]        # 6148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x4ddd]        # 5fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x4f6d],0x0        # 6188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x4dba],0x0        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x4e76]        # 60a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x4da8]        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x4f44],0x1        # 6188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x4c6e]        # 6180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x4b89]        # 60c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x4be7]        # 6160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x4b2b]        # 60c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x3087]        # 4780 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x305b]        # 4780 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2f9e]        # 4798 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2e9f]        # 47a8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2cbd]        # 47c0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x4639]        # 61a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x4620],rbx        # 61a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x40
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x45ee]        # 61a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x28],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x28],0x0
    1bbe:	je     1e44 <end_profiling+0x2a9>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x20],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x28]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x20]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c41]        # 4878 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x20]
    1c44:	mov    rax,QWORD PTR [rbp-0x28]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x38],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x30],0x0
    1c72:	jmp    1e36 <end_profiling+0x29b>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x30]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x450d]        # 61a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x18],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x18]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1e31 <end_profiling+0x296>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x18]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x28]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b67]        # 4880 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x10],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x18]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x18]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x18]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x18]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x10]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x18]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x18]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x18]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x28]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2a8f]        # 4880 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x8],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x18]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x8]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x38]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x10]
    1e2c:	movsd  QWORD PTR [rbp-0x38],xmm0
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1e31:	add    QWORD PTR [rbp-0x30],0x1
    1e36:	cmp    QWORD PTR [rbp-0x30],0xfff
    1e3e:	jbe    1c77 <end_profiling+0xdc>
      }
    }

  }
}
    1e44:	nop
    1e45:	leave
    1e46:	ret

0000000000001e47 <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1e47:	push   rbp
    1e48:	mov    rbp,rsp
    1e4b:	push   rbx
    1e4c:	sub    rsp,0x78
    1e50:	mov    QWORD PTR [rbp-0x58],rdi
    1e54:	mov    rax,rsi
    1e57:	mov    rsi,rdx
    1e5a:	mov    rax,rax
    1e5d:	mov    edx,0x0
    1e62:	mov    rdx,rsi
    1e65:	mov    QWORD PTR [rbp-0x70],rax
    1e69:	mov    QWORD PTR [rbp-0x68],rdx
    1e6d:	mov    QWORD PTR [rbp-0x60],rcx
    1e71:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1e75:	pxor   xmm0,xmm0
    1e79:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1e7d:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1e81:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1e85:	movq   QWORD PTR [rbp-0x20],xmm0
    1e8a:	mov    rax,QWORD PTR [rbp-0x70]
    1e8e:	mov    rdx,QWORD PTR [rbp-0x68]
    1e92:	mov    QWORD PTR [rbp-0x50],rax
    1e96:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1e9a:	mov    rdx,QWORD PTR [rbp-0x60]
    1e9e:	mov    rax,rdx
    1ea1:	add    rax,rax
    1ea4:	add    rax,rdx
    1ea7:	shl    rax,0x4
    1eab:	mov    rdx,rax
    1eae:	lea    rax,[rip+0x4313]        # 61c8 <g_profiler+0x28>
    1eb5:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1eb9:	mov    QWORD PTR [rbp-0x38],rax
    1ebd:	mov    rax,QWORD PTR [rbp-0x60]
    1ec1:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1ec5:	mov    rax,QWORD PTR [rip+0x42dc]        # 61a8 <g_profiler+0x8>
  Profile_Pass pass =
    1ecc:	mov    QWORD PTR [rbp-0x28],rax
    1ed0:	mov    rax,QWORD PTR [rbp-0x78]
    1ed4:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    1ed8:	mov    rax,QWORD PTR [rbp-0x60]
    1edc:	mov    QWORD PTR [rip+0x42c5],rax        # 61a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    1ee3:	call   1a48 <read_cpu_timer>
    1ee8:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    1eec:	mov    rax,QWORD PTR [rbp-0x58]
    1ef0:	mov    rcx,QWORD PTR [rbp-0x50]
    1ef4:	mov    rbx,QWORD PTR [rbp-0x48]
    1ef8:	mov    QWORD PTR [rax],rcx
    1efb:	mov    QWORD PTR [rax+0x8],rbx
    1eff:	mov    rcx,QWORD PTR [rbp-0x40]
    1f03:	mov    rbx,QWORD PTR [rbp-0x38]
    1f07:	mov    QWORD PTR [rax+0x10],rcx
    1f0b:	mov    QWORD PTR [rax+0x18],rbx
    1f0f:	mov    rcx,QWORD PTR [rbp-0x30]
    1f13:	mov    rbx,QWORD PTR [rbp-0x28]
    1f17:	mov    QWORD PTR [rax+0x20],rcx
    1f1b:	mov    QWORD PTR [rax+0x28],rbx
    1f1f:	mov    rdx,QWORD PTR [rbp-0x20]
    1f23:	mov    QWORD PTR [rax+0x30],rdx
}
    1f27:	mov    rax,QWORD PTR [rbp-0x58]
    1f2b:	mov    rbx,QWORD PTR [rbp-0x8]
    1f2f:	leave
    1f30:	ret

0000000000001f31 <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    1f31:	push   rbp
    1f32:	mov    rbp,rsp
    1f35:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    1f39:	call   1a48 <read_cpu_timer>
    1f3e:	mov    rdx,rax
    1f41:	mov    rax,QWORD PTR [rbp+0x20]
    1f45:	sub    rdx,rax
    1f48:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    1f4c:	mov    rax,QWORD PTR [rbp+0x38]
    1f50:	mov    QWORD PTR [rip+0x4251],rax        # 61a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    1f57:	mov    rdx,QWORD PTR [rbp+0x30]
    1f5b:	mov    rax,rdx
    1f5e:	add    rax,rax
    1f61:	add    rax,rdx
    1f64:	shl    rax,0x4
    1f68:	lea    rdx,[rax+0x10]
    1f6c:	lea    rax,[rip+0x422d]        # 61a0 <g_profiler>
    1f73:	add    rax,rdx
    1f76:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    1f7a:	mov    rax,QWORD PTR [rbp-0x10]
    1f7e:	mov    rdx,QWORD PTR [rax+0x10]
    1f82:	mov    rax,QWORD PTR [rbp-0x18]
    1f86:	add    rdx,rax
    1f89:	mov    rax,QWORD PTR [rbp-0x10]
    1f8d:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    1f91:	mov    rax,QWORD PTR [rbp-0x10]
    1f95:	mov    rax,QWORD PTR [rax+0x20]
    1f99:	lea    rdx,[rax+0x1]
    1f9d:	mov    rax,QWORD PTR [rbp-0x10]
    1fa1:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    1fa5:	mov    rcx,QWORD PTR [rbp-0x10]
    1fa9:	mov    rax,QWORD PTR [rbp+0x10]
    1fad:	mov    rdx,QWORD PTR [rbp+0x18]
    1fb1:	mov    QWORD PTR [rcx],rax
    1fb4:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    1fb8:	mov    rdx,QWORD PTR [rbp+0x28]
    1fbc:	mov    rax,QWORD PTR [rbp-0x18]
    1fc0:	add    rdx,rax
    1fc3:	mov    rax,QWORD PTR [rbp-0x10]
    1fc7:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    1fcb:	mov    rax,QWORD PTR [rbp-0x10]
    1fcf:	mov    rdx,QWORD PTR [rax+0x28]
    1fd3:	mov    rax,QWORD PTR [rbp+0x40]
    1fd7:	add    rdx,rax
    1fda:	mov    rax,QWORD PTR [rbp-0x10]
    1fde:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    1fe2:	mov    rdx,QWORD PTR [rbp+0x38]
    1fe6:	mov    rax,rdx
    1fe9:	add    rax,rax
    1fec:	add    rax,rdx
    1fef:	shl    rax,0x4
    1ff3:	lea    rdx,[rax+0x10]
    1ff7:	lea    rax,[rip+0x41a2]        # 61a0 <g_profiler>
    1ffe:	add    rax,rdx
    2001:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    2005:	mov    rax,QWORD PTR [rbp-0x8]
    2009:	mov    rax,QWORD PTR [rax+0x10]
    200d:	sub    rax,QWORD PTR [rbp-0x18]
    2011:	mov    rdx,rax
    2014:	mov    rax,QWORD PTR [rbp-0x8]
    2018:	mov    QWORD PTR [rax+0x10],rdx
}
    201c:	nop
    201d:	leave
    201e:	ret

000000000000201f <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    201f:	push   rbp
    2020:	mov    rbp,rsp
    2023:	sub    rsp,0x10
    2027:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    202b:	mov    rax,QWORD PTR [rbp-0x8]
    202f:	mov    rdx,QWORD PTR [rax+0x10]
    2033:	mov    rax,QWORD PTR [rbp-0x8]
    2037:	mov    rax,QWORD PTR [rax+0x8]
    203b:	cmp    rdx,rax
    203e:	jb     2065 <parser_at+0x46>
    2040:	lea    rdx,[rip+0x2791]        # 47d8 <__PRETTY_FUNCTION__.5>
    2047:	lea    rsi,[rip+0x2401]        # 444f <_IO_stdin_used+0x44f>
    204e:	lea    rax,[rip+0x240b]        # 4460 <_IO_stdin_used+0x460>
    2055:	mov    rcx,rdx
    2058:	mov    edx,0x2f
    205d:	mov    rdi,rax
    2060:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    2065:	mov    rax,QWORD PTR [rbp-0x8]
    2069:	mov    rdx,QWORD PTR [rax]
    206c:	mov    rax,QWORD PTR [rbp-0x8]
    2070:	mov    rax,QWORD PTR [rax+0x10]
    2074:	add    rax,rdx
}
    2077:	leave
    2078:	ret

0000000000002079 <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    2079:	push   rbp
    207a:	mov    rbp,rsp
    207d:	sub    rsp,0x10
    2081:	mov    QWORD PTR [rbp-0x8],rdi
    2085:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    2089:	mov    rax,QWORD PTR [rbp-0x8]
    208d:	mov    rdi,rax
    2090:	call   201f <parser_at>
    2095:	mov    rdx,QWORD PTR [rbp-0x10]
    2099:	add    rax,rdx
}
    209c:	leave
    209d:	ret

000000000000209e <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    209e:	push   rbp
    209f:	mov    rbp,rsp
    20a2:	mov    QWORD PTR [rbp-0x8],rdi
    20a6:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    20aa:	mov    rax,QWORD PTR [rbp-0x8]
    20ae:	mov    rdx,QWORD PTR [rax+0x10]
    20b2:	mov    rax,QWORD PTR [rbp-0x10]
    20b6:	add    rdx,rax
    20b9:	mov    rax,QWORD PTR [rbp-0x8]
    20bd:	mov    QWORD PTR [rax+0x10],rdx
}
    20c1:	nop
    20c2:	pop    rbp
    20c3:	ret

00000000000020c4 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    20c4:	push   rbp
    20c5:	mov    rbp,rsp
    20c8:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    20cc:	mov    rax,QWORD PTR [rbp-0x8]
    20d0:	mov    rdx,QWORD PTR [rax+0x10]
    20d4:	mov    rax,QWORD PTR [rbp-0x8]
    20d8:	mov    rax,QWORD PTR [rax+0x8]
    20dc:	cmp    rdx,rax
    20df:	setb   al
}
    20e2:	pop    rbp
    20e3:	ret

00000000000020e4 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    20e4:	push   rbp
    20e5:	mov    rbp,rsp
    20e8:	push   r12
    20ea:	push   rbx
    20eb:	sub    rsp,0x20
    20ef:	mov    QWORD PTR [rbp-0x18],rdi
    20f3:	mov    rax,rsi
    20f6:	mov    rcx,rdx
    20f9:	mov    rax,rax
    20fc:	mov    edx,0x0
    2101:	mov    rdx,rcx
    2104:	mov    QWORD PTR [rbp-0x30],rax
    2108:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    210c:	mov    rax,QWORD PTR [rbp-0x28]
    2110:	mov    r12,rax
    2113:	mov    rbx,QWORD PTR [rbp-0x30]
    2117:	mov    rax,QWORD PTR [rbp-0x18]
    211b:	mov    rdi,rax
    211e:	call   201f <parser_at>
    2123:	mov    rdx,r12
    2126:	mov    rsi,rbx
    2129:	mov    rdi,rax
    212c:	call   10d0 <memcmp@plt>
    2131:	test   eax,eax
    2133:	sete   al
}
    2136:	add    rsp,0x20
    213a:	pop    rbx
    213b:	pop    r12
    213d:	pop    rbp
    213e:	ret

000000000000213f <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    213f:	push   rbp
    2140:	mov    rbp,rsp
    2143:	mov    eax,edi
    2145:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    2148:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    214c:	movzx  eax,BYTE PTR [rbp-0x14]
    2150:	cmp    eax,0x2e
    2153:	jg     215c <is_numeric+0x1d>
    2155:	cmp    eax,0x2d
    2158:	jge    2164 <is_numeric+0x25>
    215a:	jmp    2169 <is_numeric+0x2a>
    215c:	sub    eax,0x30
    215f:	cmp    eax,0x9
    2162:	ja     2169 <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2164:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    2168:	nop
  }


  return result;
    2169:	movzx  eax,BYTE PTR [rbp-0x1]
}
    216d:	pop    rbp
    216e:	ret

000000000000216f <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    216f:	push   rbp
    2170:	mov    rbp,rsp
    2173:	sub    rsp,0x50
    2177:	mov    QWORD PTR [rbp-0x48],rdi
    217b:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    217f:	pxor   xmm0,xmm0
    2183:	movaps XMMWORD PTR [rbp-0x20],xmm0
    2187:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    218c:	jmp    219f <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    218e:	mov    rax,QWORD PTR [rbp-0x50]
    2192:	mov    esi,0x1
    2197:	mov    rdi,rax
    219a:	call   209e <parser_advance>
  while (parser_incomplete(parser)  &&
    219f:	mov    rax,QWORD PTR [rbp-0x50]
    21a3:	mov    rdi,rax
    21a6:	call   20c4 <parser_incomplete>
    21ab:	test   al,al
    21ad:	je     21fb <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    21af:	mov    rax,QWORD PTR [rbp-0x50]
    21b3:	mov    rdi,rax
    21b6:	call   201f <parser_at>
    21bb:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    21be:	cmp    al,0x20
    21c0:	je     218e <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    21c2:	mov    rax,QWORD PTR [rbp-0x50]
    21c6:	mov    rdi,rax
    21c9:	call   201f <parser_at>
    21ce:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    21d1:	cmp    al,0xa
    21d3:	je     218e <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    21d5:	mov    rax,QWORD PTR [rbp-0x50]
    21d9:	mov    rdi,rax
    21dc:	call   201f <parser_at>
    21e1:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    21e4:	cmp    al,0xd
    21e6:	je     218e <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    21e8:	mov    rax,QWORD PTR [rbp-0x50]
    21ec:	mov    rdi,rax
    21ef:	call   201f <parser_at>
    21f4:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    21f7:	cmp    al,0x9
    21f9:	je     218e <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    21fb:	mov    rax,QWORD PTR [rbp-0x50]
    21ff:	mov    rdi,rax
    2202:	call   20c4 <parser_incomplete>
    2207:	test   al,al
    2209:	je     2636 <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    220f:	mov    rax,QWORD PTR [rbp-0x50]
    2213:	mov    rdi,rax
    2216:	call   201f <parser_at>
    221b:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    221f:	mov    rax,QWORD PTR [rbp-0x50]
    2223:	mov    rdi,rax
    2226:	call   201f <parser_at>
    222b:	movzx  eax,BYTE PTR [rax]
    222e:	movzx  eax,al
    2231:	cmp    eax,0x7d
    2234:	je     2321 <get_json_token+0x1b2>
    223a:	cmp    eax,0x7d
    223d:	jg     2647 <get_json_token+0x4d8>
    2243:	cmp    eax,0x7b
    2246:	je     22fc <get_json_token+0x18d>
    224c:	cmp    eax,0x7b
    224f:	jg     2647 <get_json_token+0x4d8>
    2255:	cmp    eax,0x74
    2258:	je     24a4 <get_json_token+0x335>
    225e:	cmp    eax,0x74
    2261:	jg     2647 <get_json_token+0x4d8>
    2267:	cmp    eax,0x6e
    226a:	je     25b4 <get_json_token+0x445>
    2270:	cmp    eax,0x6e
    2273:	jg     2647 <get_json_token+0x4d8>
    2279:	cmp    eax,0x66
    227c:	je     252c <get_json_token+0x3bd>
    2282:	cmp    eax,0x66
    2285:	jg     2647 <get_json_token+0x4d8>
    228b:	cmp    eax,0x5d
    228e:	je     236b <get_json_token+0x1fc>
    2294:	cmp    eax,0x5d
    2297:	jg     2647 <get_json_token+0x4d8>
    229d:	cmp    eax,0x5b
    22a0:	je     2346 <get_json_token+0x1d7>
    22a6:	cmp    eax,0x5b
    22a9:	jg     2647 <get_json_token+0x4d8>
    22af:	cmp    eax,0x3a
    22b2:	je     23b5 <get_json_token+0x246>
    22b8:	cmp    eax,0x3a
    22bb:	jg     2647 <get_json_token+0x4d8>
    22c1:	cmp    eax,0x39
    22c4:	jg     2647 <get_json_token+0x4d8>
    22ca:	cmp    eax,0x30
    22cd:	jge    2453 <get_json_token+0x2e4>
    22d3:	cmp    eax,0x2e
    22d6:	jg     2647 <get_json_token+0x4d8>
    22dc:	cmp    eax,0x2d
    22df:	jge    2453 <get_json_token+0x2e4>
    22e5:	cmp    eax,0x22
    22e8:	je     23da <get_json_token+0x26b>
    22ee:	cmp    eax,0x2c
    22f1:	je     2390 <get_json_token+0x221>
    22f7:	jmp    2647 <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    22fc:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    2303:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    230b:	mov    rax,QWORD PTR [rbp-0x50]
    230f:	mov    esi,0x1
    2314:	mov    rdi,rax
    2317:	call   209e <parser_advance>
      }
      break;
    231c:	jmp    2647 <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2321:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    2328:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2330:	mov    rax,QWORD PTR [rbp-0x50]
    2334:	mov    esi,0x1
    2339:	mov    rdi,rax
    233c:	call   209e <parser_advance>
      }
      break;
    2341:	jmp    2647 <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2346:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    234d:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2355:	mov    rax,QWORD PTR [rbp-0x50]
    2359:	mov    esi,0x1
    235e:	mov    rdi,rax
    2361:	call   209e <parser_advance>
      }
      break;
    2366:	jmp    2647 <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    236b:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    2372:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    237a:	mov    rax,QWORD PTR [rbp-0x50]
    237e:	mov    esi,0x1
    2383:	mov    rdi,rax
    2386:	call   209e <parser_advance>
      }
      break;
    238b:	jmp    2647 <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    2390:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    2397:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    239f:	mov    rax,QWORD PTR [rbp-0x50]
    23a3:	mov    esi,0x1
    23a8:	mov    rdi,rax
    23ab:	call   209e <parser_advance>
      }
      break;
    23b0:	jmp    2647 <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    23b5:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    23bc:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    23c4:	mov    rax,QWORD PTR [rbp-0x50]
    23c8:	mov    esi,0x1
    23cd:	mov    rdi,rax
    23d0:	call   209e <parser_advance>
      }
      break;
    23d5:	jmp    2647 <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    23da:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    23e1:	mov    rax,QWORD PTR [rbp-0x50]
    23e5:	mov    esi,0x1
    23ea:	mov    rdi,rax
    23ed:	call   209e <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    23f2:	mov    rax,QWORD PTR [rbp-0x50]
    23f6:	mov    rdi,rax
    23f9:	call   201f <parser_at>
    23fe:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    2402:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    240a:	jmp    2422 <get_json_token+0x2b3>
        {
          string_count += 1;
    240c:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    2411:	mov    rax,QWORD PTR [rbp-0x50]
    2415:	mov    esi,0x1
    241a:	mov    rdi,rax
    241d:	call   209e <parser_advance>
        while (*parser_at(parser) != '"')
    2422:	mov    rax,QWORD PTR [rbp-0x50]
    2426:	mov    rdi,rax
    2429:	call   201f <parser_at>
    242e:	movzx  eax,BYTE PTR [rax]
    2431:	cmp    al,0x22
    2433:	jne    240c <get_json_token+0x29d>
        }
        token.value.count = string_count;
    2435:	mov    rax,QWORD PTR [rbp-0x40]
    2439:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    243d:	mov    rax,QWORD PTR [rbp-0x50]
    2441:	mov    esi,0x1
    2446:	mov    rdi,rax
    2449:	call   209e <parser_advance>
      }
      break;
    244e:	jmp    2647 <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2453:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    245a:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2462:	jmp    247a <get_json_token+0x30b>
        {
          digit_count += 1;
    2464:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    2469:	mov    rax,QWORD PTR [rbp-0x50]
    246d:	mov    esi,0x1
    2472:	mov    rdi,rax
    2475:	call   209e <parser_advance>
        while (is_numeric(*parser_at(parser)))
    247a:	mov    rax,QWORD PTR [rbp-0x50]
    247e:	mov    rdi,rax
    2481:	call   201f <parser_at>
    2486:	movzx  eax,BYTE PTR [rax]
    2489:	movzx  eax,al
    248c:	mov    edi,eax
    248e:	call   213f <is_numeric>
    2493:	test   al,al
    2495:	jne    2464 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    2497:	mov    rax,QWORD PTR [rbp-0x38]
    249b:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    249f:	jmp    2647 <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    24a4:	lea    rax,[rip+0x2001]        # 44ac <_IO_stdin_used+0x4ac>
    24ab:	mov    QWORD PTR [rbp-0x30],rax
    24af:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    24b7:	mov    rcx,QWORD PTR [rbp-0x30]
    24bb:	mov    rdx,QWORD PTR [rbp-0x28]
    24bf:	mov    rax,QWORD PTR [rbp-0x50]
    24c3:	mov    rsi,rcx
    24c6:	mov    rdi,rax
    24c9:	call   20e4 <parser_token_is_literal>
    24ce:	test   al,al
    24d0:	je     24f4 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    24d2:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    24d9:	mov    rax,QWORD PTR [rbp-0x28]
    24dd:	mov    rdx,rax
    24e0:	mov    rax,QWORD PTR [rbp-0x50]
    24e4:	mov    rsi,rdx
    24e7:	mov    rdi,rax
    24ea:	call   209e <parser_advance>
    24ef:	jmp    2647 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    24f4:	mov    rax,QWORD PTR [rbp-0x50]
    24f8:	mov    rcx,QWORD PTR [rax+0x10]
    24fc:	lea    rdx,[rip+0x1fb5]        # 44b8 <_IO_stdin_used+0x4b8>
    2503:	lea    rax,[rip+0x1f45]        # 444f <_IO_stdin_used+0x44f>
    250a:	mov    r8,rcx
    250d:	mov    rcx,rdx
    2510:	mov    edx,0xdf
    2515:	mov    rsi,rax
    2518:	mov    edi,0x1
    251d:	mov    eax,0x0
    2522:	call   14a1 <log_message>
        }
      }
      break;
    2527:	jmp    2647 <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    252c:	lea    rax,[rip+0x1fb2]        # 44e5 <_IO_stdin_used+0x4e5>
    2533:	mov    QWORD PTR [rbp-0x30],rax
    2537:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    253f:	mov    rcx,QWORD PTR [rbp-0x30]
    2543:	mov    rdx,QWORD PTR [rbp-0x28]
    2547:	mov    rax,QWORD PTR [rbp-0x50]
    254b:	mov    rsi,rcx
    254e:	mov    rdi,rax
    2551:	call   20e4 <parser_token_is_literal>
    2556:	test   al,al
    2558:	je     257c <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    255a:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    2561:	mov    rax,QWORD PTR [rbp-0x28]
    2565:	mov    rdx,rax
    2568:	mov    rax,QWORD PTR [rbp-0x50]
    256c:	mov    rsi,rdx
    256f:	mov    rdi,rax
    2572:	call   209e <parser_advance>
    2577:	jmp    2647 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    257c:	mov    rax,QWORD PTR [rbp-0x50]
    2580:	mov    rcx,QWORD PTR [rax+0x10]
    2584:	lea    rdx,[rip+0x1f2d]        # 44b8 <_IO_stdin_used+0x4b8>
    258b:	lea    rax,[rip+0x1ebd]        # 444f <_IO_stdin_used+0x44f>
    2592:	mov    r8,rcx
    2595:	mov    rcx,rdx
    2598:	mov    edx,0xee
    259d:	mov    rsi,rax
    25a0:	mov    edi,0x1
    25a5:	mov    eax,0x0
    25aa:	call   14a1 <log_message>
        }
      }
      break;
    25af:	jmp    2647 <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    25b4:	lea    rax,[rip+0x1f30]        # 44eb <_IO_stdin_used+0x4eb>
    25bb:	mov    QWORD PTR [rbp-0x30],rax
    25bf:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25c7:	mov    rcx,QWORD PTR [rbp-0x30]
    25cb:	mov    rdx,QWORD PTR [rbp-0x28]
    25cf:	mov    rax,QWORD PTR [rbp-0x50]
    25d3:	mov    rsi,rcx
    25d6:	mov    rdi,rax
    25d9:	call   20e4 <parser_token_is_literal>
    25de:	test   al,al
    25e0:	je     2601 <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    25e2:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    25e9:	mov    rax,QWORD PTR [rbp-0x28]
    25ed:	mov    rdx,rax
    25f0:	mov    rax,QWORD PTR [rbp-0x50]
    25f4:	mov    rsi,rdx
    25f7:	mov    rdi,rax
    25fa:	call   209e <parser_advance>
    25ff:	jmp    2647 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2601:	mov    rax,QWORD PTR [rbp-0x50]
    2605:	mov    rcx,QWORD PTR [rax+0x10]
    2609:	lea    rdx,[rip+0x1ea8]        # 44b8 <_IO_stdin_used+0x4b8>
    2610:	lea    rax,[rip+0x1e38]        # 444f <_IO_stdin_used+0x44f>
    2617:	mov    r8,rcx
    261a:	mov    rcx,rdx
    261d:	mov    edx,0xfd
    2622:	mov    rsi,rax
    2625:	mov    edi,0x1
    262a:	mov    eax,0x0
    262f:	call   14a1 <log_message>
        }
      }
      break;
    2634:	jmp    2647 <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    2636:	mov    rax,QWORD PTR [rbp-0x50]
    263a:	mov    esi,0x1
    263f:	mov    rdi,rax
    2642:	call   209e <parser_advance>
  }

  return token;
    2647:	mov    rcx,QWORD PTR [rbp-0x48]
    264b:	mov    rax,QWORD PTR [rbp-0x20]
    264f:	mov    rdx,QWORD PTR [rbp-0x18]
    2653:	mov    QWORD PTR [rcx],rax
    2656:	mov    QWORD PTR [rcx+0x8],rdx
    265a:	mov    rax,QWORD PTR [rbp-0x10]
    265e:	mov    QWORD PTR [rcx+0x10],rax
}
    2662:	mov    rax,QWORD PTR [rbp-0x48]
    2666:	leave
    2667:	ret

0000000000002668 <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    2668:	push   rbp
    2669:	mov    rbp,rsp
    266c:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    266f:	cmp    DWORD PTR [rbp-0x14],0x7
    2673:	je     268d <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2675:	cmp    DWORD PTR [rbp-0x14],0x9
    2679:	je     268d <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    267b:	cmp    DWORD PTR [rbp-0x14],0xa
    267f:	je     268d <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    2681:	cmp    DWORD PTR [rbp-0x14],0xb
    2685:	je     268d <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    2687:	cmp    DWORD PTR [rbp-0x14],0x8
    268b:	jne    2694 <json_token_type_is_value_type+0x2c>
    268d:	mov    eax,0x1
    2692:	jmp    2699 <json_token_type_is_value_type+0x31>
    2694:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2699:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    269c:	mov    eax,DWORD PTR [rbp-0x4]
}
    269f:	pop    rbp
    26a0:	ret

00000000000026a1 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    26a1:	push   rbp
    26a2:	mov    rbp,rsp
    26a5:	push   rbx
    26a6:	sub    rsp,0x88
    26ad:	mov    QWORD PTR [rbp-0x78],rdi
    26b1:	mov    QWORD PTR [rbp-0x80],rsi
    26b5:	mov    QWORD PTR [rbp-0x90],rdx
    26bc:	mov    QWORD PTR [rbp-0x88],rcx
    26c3:	mov    rax,QWORD PTR fs:0x28
    26cc:	mov    QWORD PTR [rbp-0x18],rax
    26d0:	xor    eax,eax
  profile_begin_func();
    26d2:	lea    r8,[rip+0x2117]        # 47f0 <__func__.4>
    26d9:	mov    r9d,0x11
    26df:	lea    rax,[rbp-0x50]
    26e3:	mov    rsi,r8
    26e6:	mov    rdx,r9
    26e9:	mov    r8d,0x0
    26ef:	mov    ecx,0x1
    26f4:	mov    rdi,rax
    26f7:	call   1e47 <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    26fc:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2704:	mov    eax,DWORD PTR [rbp+0x10]
    2707:	cmp    eax,0x1
    270a:	jne    2736 <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    270c:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    2713:	mov    edx,DWORD PTR [rbp-0x64]
    2716:	mov    rsi,QWORD PTR [rbp-0x80]
    271a:	mov    rax,QWORD PTR [rbp-0x78]
    271e:	mov    ecx,edx
    2720:	mov    edx,0x2
    2725:	mov    rdi,rax
    2728:	call   2888 <parse_json_children>
    272d:	mov    QWORD PTR [rbp-0x60],rax
    2731:	jmp    27c0 <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2736:	mov    eax,DWORD PTR [rbp+0x10]
    2739:	cmp    eax,0x3
    273c:	jne    2765 <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    273e:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2745:	mov    edx,DWORD PTR [rbp-0x68]
    2748:	mov    rsi,QWORD PTR [rbp-0x80]
    274c:	mov    rax,QWORD PTR [rbp-0x78]
    2750:	mov    ecx,edx
    2752:	mov    edx,0x4
    2757:	mov    rdi,rax
    275a:	call   2888 <parse_json_children>
    275f:	mov    QWORD PTR [rbp-0x60],rax
    2763:	jmp    27c0 <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    2765:	mov    eax,DWORD PTR [rbp+0x10]
    2768:	mov    edi,eax
    276a:	call   2668 <json_token_type_is_value_type>
    276f:	test   eax,eax
    2771:	jne    27c0 <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2773:	mov    eax,DWORD PTR [rbp+0x10]
    2776:	mov    eax,eax
    2778:	lea    rdx,[rax*8+0x0]
    2780:	lea    rax,[rip+0x3959]        # 60e0 <JSON_Token_Type_strings>
    2787:	mov    rcx,QWORD PTR [rdx+rax*1]
    278b:	lea    rdx,[rip+0x1d5e]        # 44f0 <_IO_stdin_used+0x4f0>
    2792:	lea    rax,[rip+0x1cb6]        # 444f <_IO_stdin_used+0x44f>
    2799:	push   QWORD PTR [rbp+0x20]
    279c:	push   QWORD PTR [rbp+0x18]
    279f:	mov    r8,rcx
    27a2:	mov    rcx,rdx
    27a5:	mov    edx,0x134
    27aa:	mov    rsi,rax
    27ad:	mov    edi,0x1
    27b2:	mov    eax,0x0
    27b7:	call   14a1 <log_message>
    27bc:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    27c0:	mov    rax,QWORD PTR [rbp-0x78]
    27c4:	mov    edx,0x8
    27c9:	mov    esi,0x30
    27ce:	mov    rdi,rax
    27d1:	call   17d3 <arena_alloc>
    27d6:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    27da:	mov    rcx,QWORD PTR [rbp-0x58]
    27de:	mov    rax,QWORD PTR [rbp-0x90]
    27e5:	mov    rdx,QWORD PTR [rbp-0x88]
    27ec:	mov    QWORD PTR [rcx],rax
    27ef:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    27f3:	mov    rax,QWORD PTR [rbp-0x58]
    27f7:	mov    rdx,QWORD PTR [rbp-0x60]
    27fb:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    27ff:	mov    rax,QWORD PTR [rbp-0x58]
    2803:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    280b:	mov    rcx,QWORD PTR [rbp-0x58]
    280f:	mov    rax,QWORD PTR [rbp+0x18]
    2813:	mov    rdx,QWORD PTR [rbp+0x20]
    2817:	mov    QWORD PTR [rcx+0x10],rax
    281b:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    281f:	sub    rsp,0x8
    2823:	sub    rsp,0x38
    2827:	mov    rax,rsp
    282a:	mov    rcx,QWORD PTR [rbp-0x50]
    282e:	mov    rbx,QWORD PTR [rbp-0x48]
    2832:	mov    QWORD PTR [rax],rcx
    2835:	mov    QWORD PTR [rax+0x8],rbx
    2839:	mov    rcx,QWORD PTR [rbp-0x40]
    283d:	mov    rbx,QWORD PTR [rbp-0x38]
    2841:	mov    QWORD PTR [rax+0x10],rcx
    2845:	mov    QWORD PTR [rax+0x18],rbx
    2849:	mov    rcx,QWORD PTR [rbp-0x30]
    284d:	mov    rbx,QWORD PTR [rbp-0x28]
    2851:	mov    QWORD PTR [rax+0x20],rcx
    2855:	mov    QWORD PTR [rax+0x28],rbx
    2859:	mov    rdx,QWORD PTR [rbp-0x20]
    285d:	mov    QWORD PTR [rax+0x30],rdx
    2861:	call   1f31 <__profile_end_pass>
    2866:	add    rsp,0x40

  return result;
    286a:	mov    rax,QWORD PTR [rbp-0x58]
}
    286e:	mov    rdx,QWORD PTR [rbp-0x18]
    2872:	sub    rdx,QWORD PTR fs:0x28
    287b:	je     2882 <parse_json_object+0x1e1>
    287d:	call   1060 <__stack_chk_fail@plt>
    2882:	mov    rbx,QWORD PTR [rbp-0x8]
    2886:	leave
    2887:	ret

0000000000002888 <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    2888:	push   rbp
    2889:	mov    rbp,rsp
    288c:	push   rbx
    288d:	sub    rsp,0x108
    2894:	mov    QWORD PTR [rbp-0xd8],rdi
    289b:	mov    QWORD PTR [rbp-0xe0],rsi
    28a2:	mov    DWORD PTR [rbp-0xe4],edx
    28a8:	mov    DWORD PTR [rbp-0xe8],ecx
    28ae:	mov    rax,QWORD PTR fs:0x28
    28b7:	mov    QWORD PTR [rbp-0x18],rax
    28bb:	xor    eax,eax
  profile_begin_func();
    28bd:	lea    r8,[rip+0x1f4c]        # 4810 <__func__.3>
    28c4:	mov    r9d,0x13
    28ca:	lea    rax,[rbp-0x50]
    28ce:	mov    rsi,r8
    28d1:	mov    rdx,r9
    28d4:	mov    r8d,0x0
    28da:	mov    ecx,0x2
    28df:	mov    rdi,rax
    28e2:	call   1e47 <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    28e7:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    28f2:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    28fd:	jmp    2bd6 <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2902:	pxor   xmm0,xmm0
    2906:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    290d:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2915:	pxor   xmm0,xmm0
    2919:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2920:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2925:	cmp    DWORD PTR [rbp-0xe8],0x0
    292c:	je     2a39 <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2932:	lea    rax,[rbp-0xb0]
    2939:	mov    rdx,QWORD PTR [rbp-0xe0]
    2940:	mov    rsi,rdx
    2943:	mov    rdi,rax
    2946:	call   216f <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    294b:	mov    eax,DWORD PTR [rbp-0xb0]
    2951:	cmp    eax,0x7
    2954:	jne    29d5 <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2956:	lea    rax,[rbp-0x70]
    295a:	mov    rdx,QWORD PTR [rbp-0xe0]
    2961:	mov    rsi,rdx
    2964:	mov    rdi,rax
    2967:	call   216f <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    296c:	mov    eax,DWORD PTR [rbp-0x70]
    296f:	cmp    eax,0x6
    2972:	jne    2992 <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2974:	lea    rax,[rbp-0x90]
    297b:	mov    rdx,QWORD PTR [rbp-0xe0]
    2982:	mov    rsi,rdx
    2985:	mov    rdi,rax
    2988:	call   216f <get_json_token>
    298d:	jmp    2a79 <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2992:	mov    rcx,QWORD PTR [rbp-0xa8]
    2999:	mov    rax,QWORD PTR [rbp-0xa0]
    29a0:	mov    esi,eax
    29a2:	lea    rdx,[rip+0x1b97]        # 4540 <_IO_stdin_used+0x540>
    29a9:	lea    rax,[rip+0x1a9f]        # 444f <_IO_stdin_used+0x44f>
    29b0:	mov    r9,rcx
    29b3:	mov    r8d,esi
    29b6:	mov    rcx,rdx
    29b9:	mov    edx,0x15f
    29be:	mov    rsi,rax
    29c1:	mov    edi,0x1
    29c6:	mov    eax,0x0
    29cb:	call   14a1 <log_message>
    29d0:	jmp    2a79 <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    29d5:	mov    rcx,QWORD PTR [rbp-0xa8]
    29dc:	mov    rax,QWORD PTR [rbp-0xa0]
    29e3:	mov    edi,eax
    29e5:	mov    eax,DWORD PTR [rbp-0xb0]
    29eb:	mov    eax,eax
    29ed:	lea    rdx,[rax*8+0x0]
    29f5:	lea    rax,[rip+0x36e4]        # 60e0 <JSON_Token_Type_strings>
    29fc:	mov    rsi,QWORD PTR [rdx+rax*1]
    2a00:	lea    rdx,[rip+0x1b59]        # 4560 <_IO_stdin_used+0x560>
    2a07:	lea    rax,[rip+0x1a41]        # 444f <_IO_stdin_used+0x44f>
    2a0e:	sub    rsp,0x8
    2a12:	push   rcx
    2a13:	mov    r9d,edi
    2a16:	mov    r8,rsi
    2a19:	mov    rcx,rdx
    2a1c:	mov    edx,0x164
    2a21:	mov    rsi,rax
    2a24:	mov    edi,0x1
    2a29:	mov    eax,0x0
    2a2e:	call   14a1 <log_message>
    2a33:	add    rsp,0x10
    2a37:	jmp    2a79 <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2a39:	lea    rax,[rbp-0x110]
    2a40:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a47:	mov    rsi,rdx
    2a4a:	mov    rdi,rax
    2a4d:	call   216f <get_json_token>
    2a52:	mov    rax,QWORD PTR [rbp-0x110]
    2a59:	mov    rdx,QWORD PTR [rbp-0x108]
    2a60:	mov    QWORD PTR [rbp-0x90],rax
    2a67:	mov    QWORD PTR [rbp-0x88],rdx
    2a6e:	mov    rax,QWORD PTR [rbp-0x100]
    2a75:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2a79:	mov    eax,DWORD PTR [rbp-0x90]
    2a7f:	cmp    DWORD PTR [rbp-0xe4],eax
    2a85:	je     2bef <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2a8b:	mov    rax,QWORD PTR [rbp-0xa8]
    2a92:	mov    rdx,QWORD PTR [rbp-0xa0]
    2a99:	mov    r8,QWORD PTR [rbp-0xe0]
    2aa0:	mov    rdi,QWORD PTR [rbp-0xd8]
    2aa7:	sub    rsp,0x8
    2aab:	sub    rsp,0x18
    2aaf:	mov    rsi,rsp
    2ab2:	mov    rcx,QWORD PTR [rbp-0x90]
    2ab9:	mov    rbx,QWORD PTR [rbp-0x88]
    2ac0:	mov    QWORD PTR [rsi],rcx
    2ac3:	mov    QWORD PTR [rsi+0x8],rbx
    2ac7:	mov    rcx,QWORD PTR [rbp-0x80]
    2acb:	mov    QWORD PTR [rsi+0x10],rcx
    2acf:	mov    rcx,rdx
    2ad2:	mov    rdx,rax
    2ad5:	mov    rsi,r8
    2ad8:	call   26a1 <parse_json_object>
    2add:	add    rsp,0x20
    2ae1:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2ae8:	cmp    QWORD PTR [rbp-0xb8],0x0
    2af0:	je     2b3a <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2af2:	cmp    QWORD PTR [rbp-0xc8],0x0
    2afa:	jne    2b1a <parse_json_children+0x292>
      {
        first_child        = object;
    2afc:	mov    rax,QWORD PTR [rbp-0xb8]
    2b03:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2b0a:	mov    rax,QWORD PTR [rbp-0xb8]
    2b11:	mov    QWORD PTR [rbp-0xc0],rax
    2b18:	jmp    2b3a <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2b1a:	mov    rax,QWORD PTR [rbp-0xc0]
    2b21:	mov    rdx,QWORD PTR [rbp-0xb8]
    2b28:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2b2c:	mov    rax,QWORD PTR [rbp-0xb8]
    2b33:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2b3a:	lea    rax,[rbp-0x70]
    2b3e:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b45:	mov    rsi,rdx
    2b48:	mov    rdi,rax
    2b4b:	call   216f <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2b50:	mov    eax,DWORD PTR [rbp-0x70]
    2b53:	cmp    DWORD PTR [rbp-0xe4],eax
    2b59:	je     2bf2 <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2b5f:	mov    eax,DWORD PTR [rbp-0x70]
    2b62:	cmp    eax,0x5
    2b65:	je     2bd6 <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2b67:	mov    r8,QWORD PTR [rbp-0x68]
    2b6b:	mov    rax,QWORD PTR [rbp-0x60]
    2b6f:	mov    r9d,eax
    2b72:	mov    eax,DWORD PTR [rbp-0x70]
    2b75:	mov    eax,eax
    2b77:	lea    rdx,[rax*8+0x0]
    2b7f:	lea    rax,[rip+0x355a]        # 60e0 <JSON_Token_Type_strings>
    2b86:	mov    r10,QWORD PTR [rdx+rax*1]
    2b8a:	lea    rdi,[rip+0x19f7]        # 4588 <_IO_stdin_used+0x588>
    2b91:	lea    rsi,[rip+0x18b7]        # 444f <_IO_stdin_used+0x44f>
    2b98:	sub    rsp,0x18
    2b9c:	mov    rcx,rsp
    2b9f:	mov    rax,QWORD PTR [rbp-0x70]
    2ba3:	mov    rdx,QWORD PTR [rbp-0x68]
    2ba7:	mov    QWORD PTR [rcx],rax
    2baa:	mov    QWORD PTR [rcx+0x8],rdx
    2bae:	mov    rax,QWORD PTR [rbp-0x60]
    2bb2:	mov    QWORD PTR [rcx+0x10],rax
    2bb6:	push   r8
    2bb8:	mov    r8,r10
    2bbb:	mov    rcx,rdi
    2bbe:	mov    edx,0x18b
    2bc3:	mov    edi,0x1
    2bc8:	mov    eax,0x0
    2bcd:	call   14a1 <log_message>
    2bd2:	add    rsp,0x20
  while (parser_incomplete(parser))
    2bd6:	mov    rax,QWORD PTR [rbp-0xe0]
    2bdd:	mov    rdi,rax
    2be0:	call   20c4 <parser_incomplete>
    2be5:	test   al,al
    2be7:	jne    2902 <parse_json_children+0x7a>
    2bed:	jmp    2bf3 <parse_json_children+0x36b>
      break;
    2bef:	nop
    2bf0:	jmp    2bf3 <parse_json_children+0x36b>
      break;
    2bf2:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2bf3:	sub    rsp,0x8
    2bf7:	sub    rsp,0x38
    2bfb:	mov    rax,rsp
    2bfe:	mov    rcx,QWORD PTR [rbp-0x50]
    2c02:	mov    rbx,QWORD PTR [rbp-0x48]
    2c06:	mov    QWORD PTR [rax],rcx
    2c09:	mov    QWORD PTR [rax+0x8],rbx
    2c0d:	mov    rcx,QWORD PTR [rbp-0x40]
    2c11:	mov    rbx,QWORD PTR [rbp-0x38]
    2c15:	mov    QWORD PTR [rax+0x10],rcx
    2c19:	mov    QWORD PTR [rax+0x18],rbx
    2c1d:	mov    rcx,QWORD PTR [rbp-0x30]
    2c21:	mov    rbx,QWORD PTR [rbp-0x28]
    2c25:	mov    QWORD PTR [rax+0x20],rcx
    2c29:	mov    QWORD PTR [rax+0x28],rbx
    2c2d:	mov    rdx,QWORD PTR [rbp-0x20]
    2c31:	mov    QWORD PTR [rax+0x30],rdx
    2c35:	call   1f31 <__profile_end_pass>
    2c3a:	add    rsp,0x40

  return first_child;
    2c3e:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2c45:	mov    rdx,QWORD PTR [rbp-0x18]
    2c49:	sub    rdx,QWORD PTR fs:0x28
    2c52:	je     2c59 <parse_json_children+0x3d1>
    2c54:	call   1060 <__stack_chk_fail@plt>
    2c59:	mov    rbx,QWORD PTR [rbp-0x8]
    2c5d:	leave
    2c5e:	ret

0000000000002c5f <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2c5f:	push   rbp
    2c60:	mov    rbp,rsp
    2c63:	push   rbx
    2c64:	sub    rsp,0xb8
    2c6b:	mov    QWORD PTR [rbp-0xa8],rdi
    2c72:	mov    rax,rsi
    2c75:	mov    rsi,rdx
    2c78:	mov    rax,rax
    2c7b:	mov    edx,0x0
    2c80:	mov    rdx,rsi
    2c83:	mov    QWORD PTR [rbp-0xc0],rax
    2c8a:	mov    QWORD PTR [rbp-0xb8],rdx
    2c91:	mov    rax,QWORD PTR fs:0x28
    2c9a:	mov    QWORD PTR [rbp-0x18],rax
    2c9e:	xor    eax,eax
  profile_begin_func();
    2ca0:	lea    rcx,[rip+0x1b81]        # 4828 <__func__.2>
    2ca7:	mov    ebx,0xa
    2cac:	lea    rax,[rbp-0x50]
    2cb0:	mov    rsi,rcx
    2cb3:	mov    rdx,rbx
    2cb6:	mov    r8d,0x0
    2cbc:	mov    ecx,0x3
    2cc1:	mov    rdi,rax
    2cc4:	call   1e47 <__profile_begin_pass>

  JSON_Parser parser =
    2cc9:	mov    rax,QWORD PTR [rbp-0xc0]
    2cd0:	mov    rdx,QWORD PTR [rbp-0xb8]
    2cd7:	mov    QWORD PTR [rbp-0x90],rax
    2cde:	mov    QWORD PTR [rbp-0x88],rdx
    2ce5:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2ced:	lea    rax,[rbp-0x70]
    2cf1:	lea    rdx,[rbp-0x90]
    2cf8:	mov    rsi,rdx
    2cfb:	mov    rdi,rax
    2cfe:	call   216f <get_json_token>
    2d03:	mov    ecx,0x0
    2d08:	mov    ebx,0x0
    2d0d:	lea    r8,[rbp-0x90]
    2d14:	mov    rdi,QWORD PTR [rbp-0xa8]
    2d1b:	sub    rsp,0x8
    2d1f:	sub    rsp,0x18
    2d23:	mov    rsi,rsp
    2d26:	mov    rax,QWORD PTR [rbp-0x70]
    2d2a:	mov    rdx,QWORD PTR [rbp-0x68]
    2d2e:	mov    QWORD PTR [rsi],rax
    2d31:	mov    QWORD PTR [rsi+0x8],rdx
    2d35:	mov    rax,QWORD PTR [rbp-0x60]
    2d39:	mov    QWORD PTR [rsi+0x10],rax
    2d3d:	mov    rdx,rcx
    2d40:	mov    rcx,rbx
    2d43:	mov    rsi,r8
    2d46:	call   26a1 <parse_json_object>
    2d4b:	add    rsp,0x20
    2d4f:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2d56:	sub    rsp,0x8
    2d5a:	sub    rsp,0x38
    2d5e:	mov    rax,rsp
    2d61:	mov    rcx,QWORD PTR [rbp-0x50]
    2d65:	mov    rbx,QWORD PTR [rbp-0x48]
    2d69:	mov    QWORD PTR [rax],rcx
    2d6c:	mov    QWORD PTR [rax+0x8],rbx
    2d70:	mov    rcx,QWORD PTR [rbp-0x40]
    2d74:	mov    rbx,QWORD PTR [rbp-0x38]
    2d78:	mov    QWORD PTR [rax+0x10],rcx
    2d7c:	mov    QWORD PTR [rax+0x18],rbx
    2d80:	mov    rcx,QWORD PTR [rbp-0x30]
    2d84:	mov    rbx,QWORD PTR [rbp-0x28]
    2d88:	mov    QWORD PTR [rax+0x20],rcx
    2d8c:	mov    QWORD PTR [rax+0x28],rbx
    2d90:	mov    rdx,QWORD PTR [rbp-0x20]
    2d94:	mov    QWORD PTR [rax+0x30],rdx
    2d98:	call   1f31 <__profile_end_pass>
    2d9d:	add    rsp,0x40

  return outer;
    2da1:	mov    rax,QWORD PTR [rbp-0x98]
}
    2da8:	mov    rdx,QWORD PTR [rbp-0x18]
    2dac:	sub    rdx,QWORD PTR fs:0x28
    2db5:	je     2dbc <parse_json+0x15d>
    2db7:	call   1060 <__stack_chk_fail@plt>
    2dbc:	mov    rbx,QWORD PTR [rbp-0x8]
    2dc0:	leave
    2dc1:	ret

0000000000002dc2 <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2dc2:	push   rbp
    2dc3:	mov    rbp,rsp
    2dc6:	push   rbx
    2dc7:	sub    rsp,0x78
    2dcb:	mov    QWORD PTR [rbp-0x68],rdi
    2dcf:	mov    rax,rsi
    2dd2:	mov    rsi,rdx
    2dd5:	mov    rax,rax
    2dd8:	mov    edx,0x0
    2ddd:	mov    rdx,rsi
    2de0:	mov    QWORD PTR [rbp-0x80],rax
    2de4:	mov    QWORD PTR [rbp-0x78],rdx
    2de8:	mov    rax,QWORD PTR fs:0x28
    2df1:	mov    QWORD PTR [rbp-0x18],rax
    2df5:	xor    eax,eax
  profile_begin_func();
    2df7:	lea    rcx,[rip+0x1a42]        # 4840 <__func__.1>
    2dfe:	mov    ebx,0x12
    2e03:	lea    rax,[rbp-0x50]
    2e07:	mov    rsi,rcx
    2e0a:	mov    rdx,rbx
    2e0d:	mov    r8d,0x0
    2e13:	mov    ecx,0x4
    2e18:	mov    rdi,rax
    2e1b:	call   1e47 <__profile_begin_pass>

  JSON_Object *result = NULL;
    2e20:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2e28:	cmp    QWORD PTR [rbp-0x68],0x0
    2e2d:	je     2e7c <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2e2f:	mov    rax,QWORD PTR [rbp-0x68]
    2e33:	mov    rax,QWORD PTR [rax+0x20]
    2e37:	mov    QWORD PTR [rbp-0x58],rax
    2e3b:	jmp    2e75 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2e3d:	mov    rax,QWORD PTR [rbp-0x58]
    2e41:	mov    rdx,QWORD PTR [rax+0x8]
    2e45:	mov    rax,QWORD PTR [rax]
    2e48:	mov    rdi,QWORD PTR [rbp-0x80]
    2e4c:	mov    rsi,QWORD PTR [rbp-0x78]
    2e50:	mov    rcx,rdx
    2e53:	mov    rdx,rax
    2e56:	call   143f <strings_equal>
    2e5b:	test   al,al
    2e5d:	je     2e69 <lookup_json_object+0xa7>
      {
        result = cursor;
    2e5f:	mov    rax,QWORD PTR [rbp-0x58]
    2e63:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2e67:	jmp    2e7c <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2e69:	mov    rax,QWORD PTR [rbp-0x58]
    2e6d:	mov    rax,QWORD PTR [rax+0x28]
    2e71:	mov    QWORD PTR [rbp-0x58],rax
    2e75:	cmp    QWORD PTR [rbp-0x58],0x0
    2e7a:	jne    2e3d <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2e7c:	sub    rsp,0x8
    2e80:	sub    rsp,0x38
    2e84:	mov    rax,rsp
    2e87:	mov    rcx,QWORD PTR [rbp-0x50]
    2e8b:	mov    rbx,QWORD PTR [rbp-0x48]
    2e8f:	mov    QWORD PTR [rax],rcx
    2e92:	mov    QWORD PTR [rax+0x8],rbx
    2e96:	mov    rcx,QWORD PTR [rbp-0x40]
    2e9a:	mov    rbx,QWORD PTR [rbp-0x38]
    2e9e:	mov    QWORD PTR [rax+0x10],rcx
    2ea2:	mov    QWORD PTR [rax+0x18],rbx
    2ea6:	mov    rcx,QWORD PTR [rbp-0x30]
    2eaa:	mov    rbx,QWORD PTR [rbp-0x28]
    2eae:	mov    QWORD PTR [rax+0x20],rcx
    2eb2:	mov    QWORD PTR [rax+0x28],rbx
    2eb6:	mov    rdx,QWORD PTR [rbp-0x20]
    2eba:	mov    QWORD PTR [rax+0x30],rdx
    2ebe:	call   1f31 <__profile_end_pass>
    2ec3:	add    rsp,0x40

  return result;
    2ec7:	mov    rax,QWORD PTR [rbp-0x60]
}
    2ecb:	mov    rdx,QWORD PTR [rbp-0x18]
    2ecf:	sub    rdx,QWORD PTR fs:0x28
    2ed8:	je     2edf <lookup_json_object+0x11d>
    2eda:	call   1060 <__stack_chk_fail@plt>
    2edf:	mov    rbx,QWORD PTR [rbp-0x8]
    2ee3:	leave
    2ee4:	ret

0000000000002ee5 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    2ee5:	push   rbp
    2ee6:	mov    rbp,rsp
    2ee9:	sub    rsp,0x50
    2eed:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    2ef1:	cmp    QWORD PTR [rbp-0x48],0x0
    2ef6:	jne    2f1d <json_object_to_f64+0x38>
    2ef8:	lea    rdx,[rip+0x1961]        # 4860 <__PRETTY_FUNCTION__.0>
    2eff:	lea    rsi,[rip+0x1549]        # 444f <_IO_stdin_used+0x44f>
    2f06:	lea    rax,[rip+0x16bb]        # 45c8 <_IO_stdin_used+0x5c8>
    2f0d:	mov    rcx,rdx
    2f10:	mov    edx,0x1c2
    2f15:	mov    rdi,rax
    2f18:	call   1090 <__assert_fail@plt>

  String val = object->value;
    2f1d:	mov    rax,QWORD PTR [rbp-0x48]
    2f21:	mov    rdx,QWORD PTR [rax+0x18]
    2f25:	mov    rax,QWORD PTR [rax+0x10]
    2f29:	mov    QWORD PTR [rbp-0x10],rax
    2f2d:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    2f31:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    2f39:	movsd  xmm0,QWORD PTR [rip+0x1947]        # 4888 <__PRETTY_FUNCTION__.0+0x28>
    2f41:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    2f46:	mov    rax,QWORD PTR [rbp-0x8]
    2f4a:	cmp    QWORD PTR [rbp-0x30],rax
    2f4e:	jae    2f74 <json_object_to_f64+0x8f>
    2f50:	mov    rdx,QWORD PTR [rbp-0x10]
    2f54:	mov    rax,QWORD PTR [rbp-0x30]
    2f58:	add    rax,rdx
    2f5b:	movzx  eax,BYTE PTR [rax]
    2f5e:	cmp    al,0x2d
    2f60:	jne    2f74 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    2f62:	movsd  xmm0,QWORD PTR [rip+0x1926]        # 4890 <__PRETTY_FUNCTION__.0+0x30>
    2f6a:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    2f6f:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    2f74:	pxor   xmm0,xmm0
    2f78:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    2f7d:	jmp    2fc4 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    2f7f:	mov    rdx,QWORD PTR [rbp-0x10]
    2f83:	mov    rax,QWORD PTR [rbp-0x30]
    2f87:	add    rax,rdx
    2f8a:	movzx  eax,BYTE PTR [rax]
    2f8d:	sub    eax,0x30
    2f90:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    2f93:	cmp    BYTE PTR [rbp-0x32],0x9
    2f97:	ja     2fd0 <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    2f99:	movsd  xmm1,QWORD PTR [rbp-0x20]
    2f9e:	movsd  xmm0,QWORD PTR [rip+0x18f2]        # 4898 <__PRETTY_FUNCTION__.0+0x38>
    2fa6:	mulsd  xmm1,xmm0
    2faa:	movzx  eax,BYTE PTR [rbp-0x32]
    2fae:	pxor   xmm0,xmm0
    2fb2:	cvtsi2sd xmm0,eax
    2fb6:	addsd  xmm0,xmm1
    2fba:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    2fbf:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    2fc4:	mov    rax,QWORD PTR [rbp-0x8]
    2fc8:	cmp    QWORD PTR [rbp-0x30],rax
    2fcc:	jb     2f7f <json_object_to_f64+0x9a>
    2fce:	jmp    2fd1 <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    2fd0:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    2fd1:	mov    rax,QWORD PTR [rbp-0x8]
    2fd5:	cmp    QWORD PTR [rbp-0x30],rax
    2fd9:	jae    3066 <json_object_to_f64+0x181>
    2fdf:	mov    rdx,QWORD PTR [rbp-0x10]
    2fe3:	mov    rax,QWORD PTR [rbp-0x30]
    2fe7:	add    rax,rdx
    2fea:	movzx  eax,BYTE PTR [rax]
    2fed:	cmp    al,0x2e
    2fef:	jne    3066 <json_object_to_f64+0x181>
  {
    at += 1;
    2ff1:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    2ff6:	movsd  xmm0,QWORD PTR [rip+0x18a2]        # 48a0 <__PRETTY_FUNCTION__.0+0x40>
    2ffe:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    3003:	jmp    3059 <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3005:	mov    rdx,QWORD PTR [rbp-0x10]
    3009:	mov    rax,QWORD PTR [rbp-0x30]
    300d:	add    rax,rdx
    3010:	movzx  eax,BYTE PTR [rax]
    3013:	sub    eax,0x30
    3016:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    3019:	cmp    BYTE PTR [rbp-0x31],0x9
    301d:	ja     3065 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    301f:	movzx  eax,BYTE PTR [rbp-0x31]
    3023:	pxor   xmm0,xmm0
    3027:	cvtsi2sd xmm0,eax
    302b:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    3030:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3035:	addsd  xmm0,xmm1
    3039:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    303e:	movsd  xmm1,QWORD PTR [rbp-0x18]
    3043:	movsd  xmm0,QWORD PTR [rip+0x1855]        # 48a0 <__PRETTY_FUNCTION__.0+0x40>
    304b:	mulsd  xmm0,xmm1
    304f:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3054:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    3059:	mov    rax,QWORD PTR [rbp-0x8]
    305d:	cmp    QWORD PTR [rbp-0x30],rax
    3061:	jb     3005 <json_object_to_f64+0x120>
    3063:	jmp    3066 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    3065:	nop
      }
    }
  }

  return sign * result;
    3066:	movsd  xmm0,QWORD PTR [rbp-0x28]
    306b:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    3070:	leave
    3071:	ret

0000000000003072 <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    3072:	push   rbp
    3073:	mov    rbp,rsp
    3076:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    307b:	movsd  xmm0,QWORD PTR [rbp-0x8]
    3080:	movsd  xmm1,QWORD PTR [rip+0x1820]        # 48a8 <__PRETTY_FUNCTION__.0+0x48>
    3088:	divsd  xmm0,xmm1
}
    308c:	pop    rbp
    308d:	ret

000000000000308e <square>:

static
f64 square(f64 x)
{
    308e:	push   rbp
    308f:	mov    rbp,rsp
    3092:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    3097:	movsd  xmm0,QWORD PTR [rbp-0x8]
    309c:	mulsd  xmm0,xmm0
}
    30a0:	pop    rbp
    30a1:	ret

00000000000030a2 <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    30a2:	push   rbp
    30a3:	mov    rbp,rsp
    30a6:	sub    rsp,0x90
    30ad:	movsd  QWORD PTR [rbp-0x58],xmm0
    30b2:	movsd  QWORD PTR [rbp-0x60],xmm1
    30b7:	movsd  QWORD PTR [rbp-0x68],xmm2
    30bc:	movsd  QWORD PTR [rbp-0x70],xmm3
    30c1:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    30c6:	movsd  xmm0,QWORD PTR [rbp-0x60]
    30cb:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    30d0:	movsd  xmm0,QWORD PTR [rbp-0x70]
    30d5:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    30da:	movsd  xmm0,QWORD PTR [rbp-0x58]
    30df:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    30e4:	movsd  xmm0,QWORD PTR [rbp-0x68]
    30e9:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    30ee:	movsd  xmm0,QWORD PTR [rbp-0x40]
    30f3:	subsd  xmm0,QWORD PTR [rbp-0x48]
    30f8:	movq   rax,xmm0
    30fd:	movq   xmm0,rax
    3102:	call   3072 <to_radians>
    3107:	movq   rax,xmm0
    310c:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    3110:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3115:	subsd  xmm0,QWORD PTR [rbp-0x38]
    311a:	movq   rax,xmm0
    311f:	movq   xmm0,rax
    3124:	call   3072 <to_radians>
    3129:	movq   rax,xmm0
    312e:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    3132:	mov    rax,QWORD PTR [rbp-0x48]
    3136:	movq   xmm0,rax
    313b:	call   3072 <to_radians>
    3140:	movq   rax,xmm0
    3145:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    3149:	mov    rax,QWORD PTR [rbp-0x40]
    314d:	movq   xmm0,rax
    3152:	call   3072 <to_radians>
    3157:	movq   rax,xmm0
    315c:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    3160:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3165:	movsd  xmm1,QWORD PTR [rip+0x1743]        # 48b0 <__PRETTY_FUNCTION__.0+0x50>
    316d:	divsd  xmm0,xmm1
    3171:	movq   rax,xmm0
    3176:	movq   xmm0,rax
    317b:	call   1130 <sin@plt>
    3180:	movq   rax,xmm0
    3185:	movq   xmm0,rax
    318a:	call   308e <square>
    318f:	movsd  QWORD PTR [rbp-0x80],xmm0
    3194:	mov    rax,QWORD PTR [rbp-0x48]
    3198:	movq   xmm0,rax
    319d:	call   10b0 <cos@plt>
    31a2:	movsd  QWORD PTR [rbp-0x88],xmm0
    31aa:	mov    rax,QWORD PTR [rbp-0x40]
    31ae:	movq   xmm0,rax
    31b3:	call   10b0 <cos@plt>
    31b8:	movapd xmm5,xmm0
    31bc:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    31c4:	movsd  QWORD PTR [rbp-0x88],xmm5
    31cc:	movsd  xmm0,QWORD PTR [rbp-0x20]
    31d1:	movsd  xmm1,QWORD PTR [rip+0x16d7]        # 48b0 <__PRETTY_FUNCTION__.0+0x50>
    31d9:	movapd xmm6,xmm0
    31dd:	divsd  xmm6,xmm1
    31e1:	movq   rax,xmm6
    31e6:	movq   xmm0,rax
    31eb:	call   1130 <sin@plt>
    31f0:	movq   rax,xmm0
    31f5:	movq   xmm0,rax
    31fa:	call   308e <square>
    31ff:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    3207:	addsd  xmm0,QWORD PTR [rbp-0x80]
    320c:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    3211:	mov    rax,QWORD PTR [rbp-0x18]
    3215:	movq   xmm0,rax
    321a:	call   1160 <sqrt@plt>
    321f:	movq   rax,xmm0
    3224:	movq   xmm0,rax
    3229:	call   1140 <asin@plt>
    322e:	addsd  xmm0,xmm0
    3232:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    3237:	movsd  xmm0,QWORD PTR [rbp-0x78]
    323c:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    3241:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3246:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    324b:	leave
    324c:	ret

000000000000324d <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    324d:	push   rbp
    324e:	mov    rbp,rsp
    3251:	movsd  QWORD PTR [rbp-0x18],xmm0
    3256:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    325b:	movsd  xmm0,QWORD PTR [rip+0x1655]        # 48b8 <__PRETTY_FUNCTION__.0+0x58>
    3263:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    3268:	movsd  xmm0,QWORD PTR [rbp-0x18]
    326d:	movq   xmm1,QWORD PTR [rip+0x164b]        # 48c0 <__PRETTY_FUNCTION__.0+0x60>
    3275:	andpd  xmm0,xmm1
    3279:	movsd  xmm1,QWORD PTR [rbp-0x20]
    327e:	movq   xmm2,QWORD PTR [rip+0x163a]        # 48c0 <__PRETTY_FUNCTION__.0+0x60>
    3286:	andpd  xmm2,xmm1
    328a:	movapd xmm1,xmm0
    328e:	subsd  xmm1,xmm2
    3292:	movsd  xmm0,QWORD PTR [rbp-0x8]
    3297:	comisd xmm0,xmm1
    329b:	setae  al
    329e:	movzx  eax,al
}
    32a1:	pop    rbp
    32a2:	ret

00000000000032a3 <main>:

int main(int args_count, char **args)
{
    32a3:	push   rbp
    32a4:	mov    rbp,rsp
    32a7:	push   r15
    32a9:	push   r14
    32ab:	push   r13
    32ad:	push   r12
    32af:	push   rbx
    32b0:	sub    rsp,0x2d8
    32b7:	mov    DWORD PTR [rbp-0x244],edi
    32bd:	mov    QWORD PTR [rbp-0x250],rsi
    32c4:	mov    rax,QWORD PTR fs:0x28
    32cd:	mov    QWORD PTR [rbp-0x38],rax
    32d1:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    32d3:	cmp    DWORD PTR [rbp-0x244],0x3
    32da:	je     3307 <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    32dc:	mov    rax,QWORD PTR [rbp-0x250]
    32e3:	mov    rax,QWORD PTR [rax]
    32e6:	lea    rdx,[rip+0x1313]        # 4600 <_IO_stdin_used+0x600>
    32ed:	mov    rsi,rax
    32f0:	mov    rdi,rdx
    32f3:	mov    eax,0x0
    32f8:	call   1070 <printf@plt>
    return 1;
    32fd:	mov    eax,0x1
    3302:	jmp    3dc0 <main+0xb1d>
  }

  begin_profiling();
    3307:	call   1b3d <begin_profiling>

  Arena arena = {0};
    330c:	pxor   xmm0,xmm0
    3310:	movaps XMMWORD PTR [rbp-0x190],xmm0
    3317:	movaps XMMWORD PTR [rbp-0x180],xmm0
  arena = arena_make(GB(4));
    331e:	lea    rdx,[rbp-0x270]
    3325:	movabs rax,0x100000000
    332f:	mov    rsi,rax
    3332:	mov    rdi,rdx
    3335:	call   1632 <arena_make>
    333a:	mov    rax,QWORD PTR [rbp-0x270]
    3341:	mov    rdx,QWORD PTR [rbp-0x268]
    3348:	mov    QWORD PTR [rbp-0x190],rax
    334f:	mov    QWORD PTR [rbp-0x188],rdx
    3356:	mov    rax,QWORD PTR [rbp-0x260]
    335d:	mov    rdx,QWORD PTR [rbp-0x258]
    3364:	mov    QWORD PTR [rbp-0x180],rax
    336b:	mov    QWORD PTR [rbp-0x178],rdx

  String source = {0};
    3372:	mov    QWORD PTR [rbp-0x1a0],0x0
    337d:	mov    QWORD PTR [rbp-0x198],0x0
  u64 fs = file_size(args[1]);
    3388:	mov    rax,QWORD PTR [rbp-0x250]
    338f:	add    rax,0x8
    3393:	mov    rax,QWORD PTR [rax]
    3396:	mov    rdi,rax
    3399:	call   1303 <file_size>
    339e:	mov    QWORD PTR [rbp-0x1e0],rax
  PROFILE_SCOPE_BANDWIDTH("read", fs)
    33a5:	lea    r12,[rip+0x1280]        # 462c <_IO_stdin_used+0x62c>
    33ac:	mov    r13d,0x4
    33b2:	lea    rdi,[rbp-0x170]
    33b9:	mov    rax,QWORD PTR [rbp-0x1e0]
    33c0:	mov    rsi,r12
    33c3:	mov    rdx,r13
    33c6:	mov    r8,rax
    33c9:	mov    ecx,0x5
    33ce:	call   1e47 <__profile_begin_pass>
    33d3:	mov    QWORD PTR [rbp-0x238],0x0
    33de:	jmp    3479 <main+0x1d6>
  {
    source = read_file_to_arena(&arena, args[1]);
    33e3:	mov    rax,QWORD PTR [rbp-0x250]
    33ea:	add    rax,0x8
    33ee:	mov    rdx,QWORD PTR [rax]
    33f1:	lea    rax,[rbp-0x190]
    33f8:	mov    rsi,rdx
    33fb:	mov    rdi,rax
    33fe:	call   1357 <read_file_to_arena>
    3403:	mov    QWORD PTR [rbp-0x1a0],rax
    340a:	mov    QWORD PTR [rbp-0x198],rdx
  PROFILE_SCOPE_BANDWIDTH("read", fs)
    3411:	add    QWORD PTR [rbp-0x238],0x1
    3419:	sub    rsp,0x8
    341d:	sub    rsp,0x38
    3421:	mov    rcx,rsp
    3424:	mov    rax,QWORD PTR [rbp-0x170]
    342b:	mov    rdx,QWORD PTR [rbp-0x168]
    3432:	mov    QWORD PTR [rcx],rax
    3435:	mov    QWORD PTR [rcx+0x8],rdx
    3439:	mov    rax,QWORD PTR [rbp-0x160]
    3440:	mov    rdx,QWORD PTR [rbp-0x158]
    3447:	mov    QWORD PTR [rcx+0x10],rax
    344b:	mov    QWORD PTR [rcx+0x18],rdx
    344f:	mov    rax,QWORD PTR [rbp-0x150]
    3456:	mov    rdx,QWORD PTR [rbp-0x148]
    345d:	mov    QWORD PTR [rcx+0x20],rax
    3461:	mov    QWORD PTR [rcx+0x28],rdx
    3465:	mov    rax,QWORD PTR [rbp-0x140]
    346c:	mov    QWORD PTR [rcx+0x30],rax
    3470:	call   1f31 <__profile_end_pass>
    3475:	add    rsp,0x40
    3479:	cmp    QWORD PTR [rbp-0x238],0x0
    3481:	je     33e3 <main+0x140>
  }

  Haversine_Pair *pairs = NULL;
    3487:	mov    QWORD PTR [rbp-0x230],0x0
  i32 pair_count = 0;
    3492:	mov    DWORD PTR [rbp-0x240],0x0
  usize max_pairs = 0;
    349c:	mov    QWORD PTR [rbp-0x228],0x0
  PROFILE_SCOPE("haversine alloc")
    34a7:	lea    r14,[rip+0x1183]        # 4631 <_IO_stdin_used+0x631>
    34ae:	mov    r15d,0xf
    34b4:	lea    rdi,[rbp-0x130]
    34bb:	mov    rdx,r14
    34be:	mov    rax,r15
    34c1:	mov    r8d,0x0
    34c7:	mov    ecx,0x6
    34cc:	mov    rsi,rdx
    34cf:	mov    rdx,rax
    34d2:	call   1e47 <__profile_begin_pass>
    34d7:	mov    QWORD PTR [rbp-0x220],0x0
    34e2:	jmp    35aa <main+0x307>
  {
    usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    34e7:	mov    QWORD PTR [rbp-0x1a8],0x18
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    34f2:	mov    rax,QWORD PTR [rbp-0x198]
    34f9:	mov    edx,0x0
    34fe:	div    QWORD PTR [rbp-0x1a8]
    3505:	mov    QWORD PTR [rbp-0x228],rax

    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    350c:	mov    rax,QWORD PTR [rbp-0x228]
    3513:	shl    rax,0x5
    3517:	mov    rcx,rax
    351a:	lea    rax,[rbp-0x190]
    3521:	mov    edx,0x8
    3526:	mov    rsi,rcx
    3529:	mov    rdi,rax
    352c:	call   17d3 <arena_alloc>
    3531:	mov    QWORD PTR [rbp-0x230],rax
    pair_count = 0;
    3538:	mov    DWORD PTR [rbp-0x240],0x0
  PROFILE_SCOPE("haversine alloc")
    3542:	add    QWORD PTR [rbp-0x220],0x1
    354a:	sub    rsp,0x8
    354e:	sub    rsp,0x38
    3552:	mov    rcx,rsp
    3555:	mov    rax,QWORD PTR [rbp-0x130]
    355c:	mov    rdx,QWORD PTR [rbp-0x128]
    3563:	mov    QWORD PTR [rcx],rax
    3566:	mov    QWORD PTR [rcx+0x8],rdx
    356a:	mov    rax,QWORD PTR [rbp-0x120]
    3571:	mov    rdx,QWORD PTR [rbp-0x118]
    3578:	mov    QWORD PTR [rcx+0x10],rax
    357c:	mov    QWORD PTR [rcx+0x18],rdx
    3580:	mov    rax,QWORD PTR [rbp-0x110]
    3587:	mov    rdx,QWORD PTR [rbp-0x108]
    358e:	mov    QWORD PTR [rcx+0x20],rax
    3592:	mov    QWORD PTR [rcx+0x28],rdx
    3596:	mov    rax,QWORD PTR [rbp-0x100]
    359d:	mov    QWORD PTR [rcx+0x30],rax
    35a1:	call   1f31 <__profile_end_pass>
    35a6:	add    rsp,0x40
    35aa:	cmp    QWORD PTR [rbp-0x220],0x0
    35b2:	je     34e7 <main+0x244>
  }

  JSON_Object *root = NULL;
    35b8:	mov    QWORD PTR [rbp-0x1d8],0x0
  root = parse_json(&arena, source);
    35c3:	mov    rcx,QWORD PTR [rbp-0x1a0]
    35ca:	mov    rdx,QWORD PTR [rbp-0x198]
    35d1:	lea    rax,[rbp-0x190]
    35d8:	mov    rsi,rcx
    35db:	mov    rdi,rax
    35de:	call   2c5f <parse_json>
    35e3:	mov    QWORD PTR [rbp-0x1d8],rax

  f64 haversine_sum = 0.0;
    35ea:	pxor   xmm0,xmm0
    35ee:	movsd  QWORD PTR [rbp-0x1d0],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    35f6:	lea    rax,[rip+0x1044]        # 4641 <_IO_stdin_used+0x641>
    35fd:	mov    QWORD PTR [rbp-0x280],rax
    3604:	mov    QWORD PTR [rbp-0x278],0x5
    360f:	mov    rax,QWORD PTR [rbp-0x280]
    3616:	mov    rdx,QWORD PTR [rbp-0x278]
    361d:	mov    rcx,rax
    3620:	mov    rax,QWORD PTR [rbp-0x1d8]
    3627:	mov    rsi,rcx
    362a:	mov    rdi,rax
    362d:	call   2dc2 <lookup_json_object>
    3632:	mov    QWORD PTR [rbp-0x1c8],rax
  if (pairs)
    3639:	cmp    QWORD PTR [rbp-0x230],0x0
    3641:	je     38d6 <main+0x633>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    3647:	mov    rax,QWORD PTR [rbp-0x1c8]
    364e:	mov    rax,QWORD PTR [rax+0x20]
    3652:	mov    QWORD PTR [rbp-0x218],rax
    3659:	jmp    38b7 <main+0x614>
    {
      PROFILE_SCOPE("child convert")
    365e:	lea    rax,[rip+0xfe2]        # 4647 <_IO_stdin_used+0x647>
    3665:	mov    QWORD PTR [rbp-0x2c0],rax
    366c:	mov    QWORD PTR [rbp-0x2b8],0xd
    3677:	lea    rdi,[rbp-0x70]
    367b:	mov    rbx,QWORD PTR [rbp-0x2c0]
    3682:	mov    rsi,QWORD PTR [rbp-0x2b8]
    3689:	mov    rdx,rbx
    368c:	mov    rax,rsi
    368f:	mov    r8d,0x0
    3695:	mov    ecx,0x7
    369a:	mov    rsi,rdx
    369d:	mov    rdx,rax
    36a0:	call   1e47 <__profile_begin_pass>
    36a5:	mov    QWORD PTR [rbp-0x210],0x0
    36b0:	jmp    3897 <main+0x5f4>
      {
        Haversine_Pair pair =
        {
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    36b5:	lea    rax,[rip+0xf99]        # 4655 <_IO_stdin_used+0x655>
    36bc:	mov    QWORD PTR [rbp-0x2d0],rax
    36c3:	mov    QWORD PTR [rbp-0x2c8],0x2
    36ce:	mov    rbx,QWORD PTR [rbp-0x2d0]
    36d5:	mov    rsi,QWORD PTR [rbp-0x2c8]
    36dc:	mov    rax,rbx
    36df:	mov    rdx,rsi
    36e2:	mov    rcx,QWORD PTR [rbp-0x218]
    36e9:	mov    rsi,rax
    36ec:	mov    rdi,rcx
    36ef:	call   2dc2 <lookup_json_object>
    36f4:	mov    rdi,rax
    36f7:	call   2ee5 <json_object_to_f64>
    36fc:	movq   rax,xmm0
        Haversine_Pair pair =
    3701:	mov    QWORD PTR [rbp-0xb0],rax
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    3708:	lea    rax,[rip+0xf49]        # 4658 <_IO_stdin_used+0x658>
    370f:	mov    QWORD PTR [rbp-0x2e0],rax
    3716:	mov    QWORD PTR [rbp-0x2d8],0x2
    3721:	mov    rax,QWORD PTR [rbp-0x2e0]
    3728:	mov    rdx,QWORD PTR [rbp-0x2d8]
    372f:	mov    rcx,rax
    3732:	mov    rax,QWORD PTR [rbp-0x218]
    3739:	mov    rsi,rcx
    373c:	mov    rdi,rax
    373f:	call   2dc2 <lookup_json_object>
    3744:	mov    rdi,rax
    3747:	call   2ee5 <json_object_to_f64>
    374c:	movq   rax,xmm0
        Haversine_Pair pair =
    3751:	mov    QWORD PTR [rbp-0xa8],rax
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    3758:	lea    rax,[rip+0xefc]        # 465b <_IO_stdin_used+0x65b>
    375f:	mov    QWORD PTR [rbp-0x2f0],rax
    3766:	mov    QWORD PTR [rbp-0x2e8],0x2
    3771:	mov    rax,QWORD PTR [rbp-0x2f0]
    3778:	mov    rdx,QWORD PTR [rbp-0x2e8]
    377f:	mov    rcx,rax
    3782:	mov    rax,QWORD PTR [rbp-0x218]
    3789:	mov    rsi,rcx
    378c:	mov    rdi,rax
    378f:	call   2dc2 <lookup_json_object>
    3794:	mov    rdi,rax
    3797:	call   2ee5 <json_object_to_f64>
    379c:	movq   rax,xmm0
        Haversine_Pair pair =
    37a1:	mov    QWORD PTR [rbp-0xa0],rax
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    37a8:	lea    rax,[rip+0xeaf]        # 465e <_IO_stdin_used+0x65e>
    37af:	mov    QWORD PTR [rbp-0x300],rax
    37b6:	mov    QWORD PTR [rbp-0x2f8],0x2
    37c1:	mov    rax,QWORD PTR [rbp-0x300]
    37c8:	mov    rdx,QWORD PTR [rbp-0x2f8]
    37cf:	mov    rcx,rax
    37d2:	mov    rax,QWORD PTR [rbp-0x218]
    37d9:	mov    rsi,rcx
    37dc:	mov    rdi,rax
    37df:	call   2dc2 <lookup_json_object>
    37e4:	mov    rdi,rax
    37e7:	call   2ee5 <json_object_to_f64>
    37ec:	movq   rax,xmm0
        Haversine_Pair pair =
    37f1:	mov    QWORD PTR [rbp-0x98],rax
        };

        pairs[pair_count] = pair;
    37f8:	mov    eax,DWORD PTR [rbp-0x240]
    37fe:	cdqe
    3800:	shl    rax,0x5
    3804:	mov    rdx,rax
    3807:	mov    rax,QWORD PTR [rbp-0x230]
    380e:	lea    rcx,[rdx+rax*1]
    3812:	mov    rax,QWORD PTR [rbp-0xb0]
    3819:	mov    rdx,QWORD PTR [rbp-0xa8]
    3820:	mov    QWORD PTR [rcx],rax
    3823:	mov    QWORD PTR [rcx+0x8],rdx
    3827:	mov    rax,QWORD PTR [rbp-0xa0]
    382e:	mov    rdx,QWORD PTR [rbp-0x98]
    3835:	mov    QWORD PTR [rcx+0x10],rax
    3839:	mov    QWORD PTR [rcx+0x18],rdx
        pair_count += 1;
    383d:	add    DWORD PTR [rbp-0x240],0x1
      PROFILE_SCOPE("child convert")
    3844:	add    QWORD PTR [rbp-0x210],0x1
    384c:	sub    rsp,0x8
    3850:	sub    rsp,0x38
    3854:	mov    rcx,rsp
    3857:	mov    rax,QWORD PTR [rbp-0x70]
    385b:	mov    rdx,QWORD PTR [rbp-0x68]
    385f:	mov    QWORD PTR [rcx],rax
    3862:	mov    QWORD PTR [rcx+0x8],rdx
    3866:	mov    rax,QWORD PTR [rbp-0x60]
    386a:	mov    rdx,QWORD PTR [rbp-0x58]
    386e:	mov    QWORD PTR [rcx+0x10],rax
    3872:	mov    QWORD PTR [rcx+0x18],rdx
    3876:	mov    rax,QWORD PTR [rbp-0x50]
    387a:	mov    rdx,QWORD PTR [rbp-0x48]
    387e:	mov    QWORD PTR [rcx+0x20],rax
    3882:	mov    QWORD PTR [rcx+0x28],rdx
    3886:	mov    rax,QWORD PTR [rbp-0x40]
    388a:	mov    QWORD PTR [rcx+0x30],rax
    388e:	call   1f31 <__profile_end_pass>
    3893:	add    rsp,0x40
    3897:	cmp    QWORD PTR [rbp-0x210],0x0
    389f:	je     36b5 <main+0x412>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    38a5:	mov    rax,QWORD PTR [rbp-0x218]
    38ac:	mov    rax,QWORD PTR [rax+0x28]
    38b0:	mov    QWORD PTR [rbp-0x218],rax
    38b7:	cmp    QWORD PTR [rbp-0x218],0x0
    38bf:	je     38d6 <main+0x633>
    38c1:	mov    eax,DWORD PTR [rbp-0x240]
    38c7:	cdqe
    38c9:	cmp    rax,QWORD PTR [rbp-0x228]
    38d0:	jb     365e <main+0x3bb>
      }
    }
  }

  f64 sum = 0.0;
    38d6:	pxor   xmm0,xmm0
    38da:	movsd  QWORD PTR [rbp-0x208],xmm0
  PROFILE_SCOPE("sum")
    38e2:	lea    rax,[rip+0xd78]        # 4661 <_IO_stdin_used+0x661>
    38e9:	mov    QWORD PTR [rbp-0x290],rax
    38f0:	mov    QWORD PTR [rbp-0x288],0x3
    38fb:	lea    rax,[rbp-0xf0]
    3902:	mov    rcx,QWORD PTR [rbp-0x290]
    3909:	mov    rbx,QWORD PTR [rbp-0x288]
    3910:	mov    rsi,rcx
    3913:	mov    rdx,rbx
    3916:	mov    r8d,0x0
    391c:	mov    ecx,0x8
    3921:	mov    rdi,rax
    3924:	call   1e47 <__profile_begin_pass>
    3929:	mov    QWORD PTR [rbp-0x200],0x0
    3934:	jmp    3ab6 <main+0x813>
  {
    for (usize i = 0; i < pair_count; i++)
    3939:	mov    QWORD PTR [rbp-0x1f8],0x0
    3944:	jmp    3a19 <main+0x776>
    {
      f64 earth_radius = 6372.8;
    3949:	movsd  xmm0,QWORD PTR [rip+0xf7f]        # 48d0 <__PRETTY_FUNCTION__.0+0x70>
    3951:	movsd  QWORD PTR [rbp-0x1b8],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    3959:	mov    rax,QWORD PTR [rbp-0x1f8]
    3960:	shl    rax,0x5
    3964:	mov    rdx,rax
    3967:	mov    rax,QWORD PTR [rbp-0x230]
    396e:	add    rax,rdx
    3971:	movsd  xmm2,QWORD PTR [rax+0x18]
    3976:	mov    rax,QWORD PTR [rbp-0x1f8]
    397d:	shl    rax,0x5
    3981:	mov    rdx,rax
    3984:	mov    rax,QWORD PTR [rbp-0x230]
    398b:	add    rax,rdx
    398e:	movsd  xmm1,QWORD PTR [rax+0x10]
    3993:	mov    rax,QWORD PTR [rbp-0x1f8]
    399a:	shl    rax,0x5
    399e:	mov    rdx,rax
    39a1:	mov    rax,QWORD PTR [rbp-0x230]
    39a8:	add    rax,rdx
    39ab:	movsd  xmm0,QWORD PTR [rax+0x8]
    39b0:	mov    rax,QWORD PTR [rbp-0x1f8]
    39b7:	shl    rax,0x5
    39bb:	mov    rdx,rax
    39be:	mov    rax,QWORD PTR [rbp-0x230]
    39c5:	add    rax,rdx
    39c8:	mov    rax,QWORD PTR [rax]
    39cb:	movsd  xmm3,QWORD PTR [rbp-0x1b8]
    39d3:	movapd xmm4,xmm3
    39d7:	movapd xmm3,xmm2
    39db:	movapd xmm2,xmm1
    39df:	movapd xmm1,xmm0
    39e3:	movq   xmm0,rax
    39e8:	call   30a2 <reference_haversine>
    39ed:	movq   rax,xmm0
    39f2:	mov    QWORD PTR [rbp-0x1b0],rax
      sum += result;
    39f9:	movsd  xmm0,QWORD PTR [rbp-0x208]
    3a01:	addsd  xmm0,QWORD PTR [rbp-0x1b0]
    3a09:	movsd  QWORD PTR [rbp-0x208],xmm0
    for (usize i = 0; i < pair_count; i++)
    3a11:	add    QWORD PTR [rbp-0x1f8],0x1
    3a19:	mov    eax,DWORD PTR [rbp-0x240]
    3a1f:	cdqe
    3a21:	cmp    QWORD PTR [rbp-0x1f8],rax
    3a28:	jb     3949 <main+0x6a6>
    }
    sum /= pair_count;
    3a2e:	pxor   xmm1,xmm1
    3a32:	cvtsi2sd xmm1,DWORD PTR [rbp-0x240]
    3a3a:	movsd  xmm0,QWORD PTR [rbp-0x208]
    3a42:	divsd  xmm0,xmm1
    3a46:	movsd  QWORD PTR [rbp-0x208],xmm0
  PROFILE_SCOPE("sum")
    3a4e:	add    QWORD PTR [rbp-0x200],0x1
    3a56:	sub    rsp,0x8
    3a5a:	sub    rsp,0x38
    3a5e:	mov    rax,rsp
    3a61:	mov    rcx,QWORD PTR [rbp-0xf0]
    3a68:	mov    rbx,QWORD PTR [rbp-0xe8]
    3a6f:	mov    QWORD PTR [rax],rcx
    3a72:	mov    QWORD PTR [rax+0x8],rbx
    3a76:	mov    rcx,QWORD PTR [rbp-0xe0]
    3a7d:	mov    rbx,QWORD PTR [rbp-0xd8]
    3a84:	mov    QWORD PTR [rax+0x10],rcx
    3a88:	mov    QWORD PTR [rax+0x18],rbx
    3a8c:	mov    rcx,QWORD PTR [rbp-0xd0]
    3a93:	mov    rbx,QWORD PTR [rbp-0xc8]
    3a9a:	mov    QWORD PTR [rax+0x20],rcx
    3a9e:	mov    QWORD PTR [rax+0x28],rbx
    3aa2:	mov    rdx,QWORD PTR [rbp-0xc0]
    3aa9:	mov    QWORD PTR [rax+0x30],rdx
    3aad:	call   1f31 <__profile_end_pass>
    3ab2:	add    rsp,0x40
    3ab6:	cmp    QWORD PTR [rbp-0x200],0x0
    3abe:	je     3939 <main+0x696>
  }

  PROFILE_SCOPE("check")
    3ac4:	lea    rax,[rip+0xb9a]        # 4665 <_IO_stdin_used+0x665>
    3acb:	mov    QWORD PTR [rbp-0x2a0],rax
    3ad2:	mov    QWORD PTR [rbp-0x298],0x5
    3add:	lea    rax,[rbp-0xb0]
    3ae4:	mov    rcx,QWORD PTR [rbp-0x2a0]
    3aeb:	mov    rbx,QWORD PTR [rbp-0x298]
    3af2:	mov    rsi,rcx
    3af5:	mov    rdx,rbx
    3af8:	mov    r8d,0x0
    3afe:	mov    ecx,0x9
    3b03:	mov    rdi,rax
    3b06:	call   1e47 <__profile_begin_pass>
    3b0b:	mov    QWORD PTR [rbp-0x1f0],0x0
    3b16:	jmp    3ceb <main+0xa48>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3b1b:	mov    rax,QWORD PTR [rbp-0x250]
    3b22:	add    rax,0x10
    3b26:	mov    rdx,QWORD PTR [rax]
    3b29:	lea    rax,[rbp-0x190]
    3b30:	mov    rsi,rdx
    3b33:	mov    rdi,rax
    3b36:	call   1357 <read_file_to_arena>
    3b3b:	mov    QWORD PTR [rbp-0x70],rax
    3b3f:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3b43:	mov    rax,QWORD PTR [rbp-0x68]
    3b47:	cmp    rax,0xb
    3b4b:	jbe    3c5e <main+0x9bb>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3b51:	mov    rax,QWORD PTR [rbp-0x70]
    3b55:	movsd  xmm0,QWORD PTR [rax]
    3b59:	movsd  QWORD PTR [rbp-0x1c0],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3b61:	mov    rax,QWORD PTR [rbp-0x70]
    3b65:	mov    eax,DWORD PTR [rax+0x8]
    3b68:	mov    DWORD PTR [rbp-0x23c],eax

      if (solution_pairs == pair_count)
    3b6e:	mov    eax,DWORD PTR [rbp-0x23c]
    3b74:	cmp    eax,DWORD PTR [rbp-0x240]
    3b7a:	jne    3c22 <main+0x97f>
      {
        if (epsilon_equal(solution_sum, sum))
    3b80:	movsd  xmm0,QWORD PTR [rbp-0x208]
    3b88:	mov    rax,QWORD PTR [rbp-0x1c0]
    3b8f:	movapd xmm1,xmm0
    3b93:	movq   xmm0,rax
    3b98:	call   324d <epsilon_equal>
    3b9d:	test   eax,eax
    3b9f:	je     3be3 <main+0x940>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3ba1:	movsd  xmm0,QWORD PTR [rbp-0x208]
    3ba9:	mov    rax,QWORD PTR [rbp-0x1c0]
    3bb0:	lea    rdx,[rip+0xab9]        # 4670 <_IO_stdin_used+0x670>
    3bb7:	lea    rsi,[rip+0xae5]        # 46a3 <_IO_stdin_used+0x6a3>
    3bbe:	movapd xmm1,xmm0
    3bc2:	movq   xmm0,rax
    3bc7:	mov    rcx,rdx
    3bca:	mov    edx,0x65
    3bcf:	mov    edi,0x3
    3bd4:	mov    eax,0x2
    3bd9:	call   14a1 <log_message>
    3bde:	jmp    3c86 <main+0x9e3>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3be3:	movsd  xmm0,QWORD PTR [rbp-0x208]
    3beb:	mov    rax,QWORD PTR [rbp-0x1c0]
    3bf2:	lea    rdx,[rip+0xabf]        # 46b8 <_IO_stdin_used+0x6b8>
    3bf9:	lea    rsi,[rip+0xaa3]        # 46a3 <_IO_stdin_used+0x6a3>
    3c00:	movapd xmm1,xmm0
    3c04:	movq   xmm0,rax
    3c09:	mov    rcx,rdx
    3c0c:	mov    edx,0x69
    3c11:	mov    edi,0x1
    3c16:	mov    eax,0x2
    3c1b:	call   14a1 <log_message>
    3c20:	jmp    3c86 <main+0x9e3>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3c22:	mov    esi,DWORD PTR [rbp-0x240]
    3c28:	mov    ecx,DWORD PTR [rbp-0x23c]
    3c2e:	lea    rdx,[rip+0xabb]        # 46f0 <_IO_stdin_used+0x6f0>
    3c35:	lea    rax,[rip+0xa67]        # 46a3 <_IO_stdin_used+0x6a3>
    3c3c:	mov    r9d,esi
    3c3f:	mov    r8d,ecx
    3c42:	mov    rcx,rdx
    3c45:	mov    edx,0x6e
    3c4a:	mov    rsi,rax
    3c4d:	mov    edi,0x1
    3c52:	mov    eax,0x0
    3c57:	call   14a1 <log_message>
    3c5c:	jmp    3c86 <main+0x9e3>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3c5e:	lea    rdx,[rip+0xad3]        # 4738 <_IO_stdin_used+0x738>
    3c65:	lea    rax,[rip+0xa37]        # 46a3 <_IO_stdin_used+0x6a3>
    3c6c:	mov    rcx,rdx
    3c6f:	mov    edx,0x73
    3c74:	mov    rsi,rax
    3c77:	mov    edi,0x1
    3c7c:	mov    eax,0x0
    3c81:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3c86:	add    QWORD PTR [rbp-0x1f0],0x1
    3c8e:	sub    rsp,0x8
    3c92:	sub    rsp,0x38
    3c96:	mov    rax,rsp
    3c99:	mov    rcx,QWORD PTR [rbp-0xb0]
    3ca0:	mov    rbx,QWORD PTR [rbp-0xa8]
    3ca7:	mov    QWORD PTR [rax],rcx
    3caa:	mov    QWORD PTR [rax+0x8],rbx
    3cae:	mov    rcx,QWORD PTR [rbp-0xa0]
    3cb5:	mov    rbx,QWORD PTR [rbp-0x98]
    3cbc:	mov    QWORD PTR [rax+0x10],rcx
    3cc0:	mov    QWORD PTR [rax+0x18],rbx
    3cc4:	mov    rcx,QWORD PTR [rbp-0x90]
    3ccb:	mov    rbx,QWORD PTR [rbp-0x88]
    3cd2:	mov    QWORD PTR [rax+0x20],rcx
    3cd6:	mov    QWORD PTR [rax+0x28],rbx
    3cda:	mov    rdx,QWORD PTR [rbp-0x80]
    3cde:	mov    QWORD PTR [rax+0x30],rdx
    3ce2:	call   1f31 <__profile_end_pass>
    3ce7:	add    rsp,0x40
    3ceb:	cmp    QWORD PTR [rbp-0x1f0],0x0
    3cf3:	je     3b1b <main+0x878>
    }
  }

  PROFILE_SCOPE("free")
    3cf9:	lea    rax,[rip+0xa73]        # 4773 <_IO_stdin_used+0x773>
    3d00:	mov    QWORD PTR [rbp-0x2b0],rax
    3d07:	mov    QWORD PTR [rbp-0x2a8],0x4
    3d12:	lea    rax,[rbp-0x70]
    3d16:	mov    rcx,QWORD PTR [rbp-0x2b0]
    3d1d:	mov    rbx,QWORD PTR [rbp-0x2a8]
    3d24:	mov    rsi,rcx
    3d27:	mov    rdx,rbx
    3d2a:	mov    r8d,0x0
    3d30:	mov    ecx,0xa
    3d35:	mov    rdi,rax
    3d38:	call   1e47 <__profile_begin_pass>
    3d3d:	mov    QWORD PTR [rbp-0x1e8],0x0
    3d48:	jmp    3dac <main+0xb09>
  {
    arena_free(&arena);
    3d4a:	lea    rax,[rbp-0x190]
    3d51:	mov    rdi,rax
    3d54:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3d59:	add    QWORD PTR [rbp-0x1e8],0x1
    3d61:	sub    rsp,0x8
    3d65:	sub    rsp,0x38
    3d69:	mov    rax,rsp
    3d6c:	mov    rcx,QWORD PTR [rbp-0x70]
    3d70:	mov    rbx,QWORD PTR [rbp-0x68]
    3d74:	mov    QWORD PTR [rax],rcx
    3d77:	mov    QWORD PTR [rax+0x8],rbx
    3d7b:	mov    rcx,QWORD PTR [rbp-0x60]
    3d7f:	mov    rbx,QWORD PTR [rbp-0x58]
    3d83:	mov    QWORD PTR [rax+0x10],rcx
    3d87:	mov    QWORD PTR [rax+0x18],rbx
    3d8b:	mov    rcx,QWORD PTR [rbp-0x50]
    3d8f:	mov    rbx,QWORD PTR [rbp-0x48]
    3d93:	mov    QWORD PTR [rax+0x20],rcx
    3d97:	mov    QWORD PTR [rax+0x28],rbx
    3d9b:	mov    rdx,QWORD PTR [rbp-0x40]
    3d9f:	mov    QWORD PTR [rax+0x30],rdx
    3da3:	call   1f31 <__profile_end_pass>
    3da8:	add    rsp,0x40
    3dac:	cmp    QWORD PTR [rbp-0x1e8],0x0
    3db4:	je     3d4a <main+0xaa7>
  }

  end_profiling();
    3db6:	call   1b9b <end_profiling>
    3dbb:	mov    eax,0x0
}
    3dc0:	mov    rdx,QWORD PTR [rbp-0x38]
    3dc4:	sub    rdx,QWORD PTR fs:0x28
    3dcd:	je     3dd4 <main+0xb31>
    3dcf:	call   1060 <__stack_chk_fail@plt>
    3dd4:	lea    rsp,[rbp-0x28]
    3dd8:	pop    rbx
    3dd9:	pop    r12
    3ddb:	pop    r13
    3ddd:	pop    r14
    3ddf:	pop    r15
    3de1:	pop    rbp
    3de2:	ret

Disassembly of section .fini:

0000000000003de4 <_fini>:
    3de4:	endbr64
    3de8:	sub    rsp,0x8
    3dec:	add    rsp,0x8
    3df0:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x4fc1]        # 5fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x4fca]        # 5ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x4fcc]        # 5ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x4fca]        # 6000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x4fc2]        # 6008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x4fba]        # 6010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x4fb2]        # 6018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x4faa]        # 6020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x4fa2]        # 6028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x4f9a]        # 6030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x4f92]        # 6038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x4f8a]        # 6040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x4f82]        # 6048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x4f7a]        # 6050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x4f72]        # 6058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x4f6a]        # 6060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x4f62]        # 6068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x4f5a]        # 6070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x4f52]        # 6078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x4f4a]        # 6080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x4f42]        # 6088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x4f3a]        # 6090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x4f32]        # 6098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2140]        # 32cf <main>
    118f:	call   QWORD PTR [rip+0x4e2b]        # 5fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x4fa1]        # 6148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x4f9a]        # 6148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x4e0e]        # 5fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x4f71]        # 6148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x4f6a]        # 6148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x4ddd]        # 5fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x4f6d],0x0        # 6188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x4dba],0x0        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x4e76]        # 60a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x4da8]        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x4f44],0x1        # 6188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x4c6e]        # 6180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x4b89]        # 60c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x4be7]        # 6160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x4b2b]        # 60c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x3097]        # 4790 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x306b]        # 4790 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fae]        # 47a8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2eaf]        # 47b8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2ccd]        # 47d0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x4639]        # 61a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x4620],rbx        # 61a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x40
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x45ee]        # 61a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x28],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x28],0x0
    1bbe:	je     1e70 <end_profiling+0x2d5>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x20],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x28]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x20]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c51]        # 4888 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x20]
    1c44:	mov    rax,QWORD PTR [rbp-0x28]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x38],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x30],0x0
    1c72:	jmp    1e62 <end_profiling+0x2c7>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x30]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x450d]        # 61a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x18],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x18]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1e5d <end_profiling+0x2c2>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x18]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x28]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b77]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x10],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x18]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x18]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x18]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x18]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x10]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x18]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x18]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x18]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x28]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2a9f]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x8],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x18]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x8]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x38]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x10]
    1e2c:	movsd  QWORD PTR [rbp-0x38],xmm0

        if (zone->bytes_processed)
    1e31:	mov    rax,QWORD PTR [rbp-0x18]
    1e35:	mov    rax,QWORD PTR [rax+0x28]
    1e39:	test   rax,rax
    1e3c:	je     1e5d <end_profiling+0x2c2>
        {
          printf("  Bytes Processed: %lu", zone->bytes_processed);
    1e3e:	mov    rax,QWORD PTR [rbp-0x18]
    1e42:	mov    rax,QWORD PTR [rax+0x28]
    1e46:	lea    rdx,[rip+0x24f7]        # 4344 <_IO_stdin_used+0x344>
    1e4d:	mov    rsi,rax
    1e50:	mov    rdi,rdx
    1e53:	mov    eax,0x0
    1e58:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1e5d:	add    QWORD PTR [rbp-0x30],0x1
    1e62:	cmp    QWORD PTR [rbp-0x30],0xfff
    1e6a:	jbe    1c77 <end_profiling+0xdc>
      }

    }

  }
}
    1e70:	nop
    1e71:	leave
    1e72:	ret

0000000000001e73 <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1e73:	push   rbp
    1e74:	mov    rbp,rsp
    1e77:	push   rbx
    1e78:	sub    rsp,0x78
    1e7c:	mov    QWORD PTR [rbp-0x58],rdi
    1e80:	mov    rax,rsi
    1e83:	mov    rsi,rdx
    1e86:	mov    rax,rax
    1e89:	mov    edx,0x0
    1e8e:	mov    rdx,rsi
    1e91:	mov    QWORD PTR [rbp-0x70],rax
    1e95:	mov    QWORD PTR [rbp-0x68],rdx
    1e99:	mov    QWORD PTR [rbp-0x60],rcx
    1e9d:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1ea1:	pxor   xmm0,xmm0
    1ea5:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1ea9:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1ead:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1eb1:	movq   QWORD PTR [rbp-0x20],xmm0
    1eb6:	mov    rax,QWORD PTR [rbp-0x70]
    1eba:	mov    rdx,QWORD PTR [rbp-0x68]
    1ebe:	mov    QWORD PTR [rbp-0x50],rax
    1ec2:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1ec6:	mov    rdx,QWORD PTR [rbp-0x60]
    1eca:	mov    rax,rdx
    1ecd:	add    rax,rax
    1ed0:	add    rax,rdx
    1ed3:	shl    rax,0x4
    1ed7:	mov    rdx,rax
    1eda:	lea    rax,[rip+0x42e7]        # 61c8 <g_profiler+0x28>
    1ee1:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1ee5:	mov    QWORD PTR [rbp-0x38],rax
    1ee9:	mov    rax,QWORD PTR [rbp-0x60]
    1eed:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1ef1:	mov    rax,QWORD PTR [rip+0x42b0]        # 61a8 <g_profiler+0x8>
  Profile_Pass pass =
    1ef8:	mov    QWORD PTR [rbp-0x28],rax
    1efc:	mov    rax,QWORD PTR [rbp-0x78]
    1f00:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    1f04:	mov    rax,QWORD PTR [rbp-0x60]
    1f08:	mov    QWORD PTR [rip+0x4299],rax        # 61a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    1f0f:	call   1a48 <read_cpu_timer>
    1f14:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    1f18:	mov    rax,QWORD PTR [rbp-0x58]
    1f1c:	mov    rcx,QWORD PTR [rbp-0x50]
    1f20:	mov    rbx,QWORD PTR [rbp-0x48]
    1f24:	mov    QWORD PTR [rax],rcx
    1f27:	mov    QWORD PTR [rax+0x8],rbx
    1f2b:	mov    rcx,QWORD PTR [rbp-0x40]
    1f2f:	mov    rbx,QWORD PTR [rbp-0x38]
    1f33:	mov    QWORD PTR [rax+0x10],rcx
    1f37:	mov    QWORD PTR [rax+0x18],rbx
    1f3b:	mov    rcx,QWORD PTR [rbp-0x30]
    1f3f:	mov    rbx,QWORD PTR [rbp-0x28]
    1f43:	mov    QWORD PTR [rax+0x20],rcx
    1f47:	mov    QWORD PTR [rax+0x28],rbx
    1f4b:	mov    rdx,QWORD PTR [rbp-0x20]
    1f4f:	mov    QWORD PTR [rax+0x30],rdx
}
    1f53:	mov    rax,QWORD PTR [rbp-0x58]
    1f57:	mov    rbx,QWORD PTR [rbp-0x8]
    1f5b:	leave
    1f5c:	ret

0000000000001f5d <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    1f5d:	push   rbp
    1f5e:	mov    rbp,rsp
    1f61:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    1f65:	call   1a48 <read_cpu_timer>
    1f6a:	mov    rdx,rax
    1f6d:	mov    rax,QWORD PTR [rbp+0x20]
    1f71:	sub    rdx,rax
    1f74:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    1f78:	mov    rax,QWORD PTR [rbp+0x38]
    1f7c:	mov    QWORD PTR [rip+0x4225],rax        # 61a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    1f83:	mov    rdx,QWORD PTR [rbp+0x30]
    1f87:	mov    rax,rdx
    1f8a:	add    rax,rax
    1f8d:	add    rax,rdx
    1f90:	shl    rax,0x4
    1f94:	lea    rdx,[rax+0x10]
    1f98:	lea    rax,[rip+0x4201]        # 61a0 <g_profiler>
    1f9f:	add    rax,rdx
    1fa2:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    1fa6:	mov    rax,QWORD PTR [rbp-0x10]
    1faa:	mov    rdx,QWORD PTR [rax+0x10]
    1fae:	mov    rax,QWORD PTR [rbp-0x18]
    1fb2:	add    rdx,rax
    1fb5:	mov    rax,QWORD PTR [rbp-0x10]
    1fb9:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    1fbd:	mov    rax,QWORD PTR [rbp-0x10]
    1fc1:	mov    rax,QWORD PTR [rax+0x20]
    1fc5:	lea    rdx,[rax+0x1]
    1fc9:	mov    rax,QWORD PTR [rbp-0x10]
    1fcd:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    1fd1:	mov    rcx,QWORD PTR [rbp-0x10]
    1fd5:	mov    rax,QWORD PTR [rbp+0x10]
    1fd9:	mov    rdx,QWORD PTR [rbp+0x18]
    1fdd:	mov    QWORD PTR [rcx],rax
    1fe0:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    1fe4:	mov    rdx,QWORD PTR [rbp+0x28]
    1fe8:	mov    rax,QWORD PTR [rbp-0x18]
    1fec:	add    rdx,rax
    1fef:	mov    rax,QWORD PTR [rbp-0x10]
    1ff3:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    1ff7:	mov    rax,QWORD PTR [rbp-0x10]
    1ffb:	mov    rdx,QWORD PTR [rax+0x28]
    1fff:	mov    rax,QWORD PTR [rbp+0x40]
    2003:	add    rdx,rax
    2006:	mov    rax,QWORD PTR [rbp-0x10]
    200a:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    200e:	mov    rdx,QWORD PTR [rbp+0x38]
    2012:	mov    rax,rdx
    2015:	add    rax,rax
    2018:	add    rax,rdx
    201b:	shl    rax,0x4
    201f:	lea    rdx,[rax+0x10]
    2023:	lea    rax,[rip+0x4176]        # 61a0 <g_profiler>
    202a:	add    rax,rdx
    202d:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    2031:	mov    rax,QWORD PTR [rbp-0x8]
    2035:	mov    rax,QWORD PTR [rax+0x10]
    2039:	sub    rax,QWORD PTR [rbp-0x18]
    203d:	mov    rdx,rax
    2040:	mov    rax,QWORD PTR [rbp-0x8]
    2044:	mov    QWORD PTR [rax+0x10],rdx
}
    2048:	nop
    2049:	leave
    204a:	ret

000000000000204b <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    204b:	push   rbp
    204c:	mov    rbp,rsp
    204f:	sub    rsp,0x10
    2053:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2057:	mov    rax,QWORD PTR [rbp-0x8]
    205b:	mov    rdx,QWORD PTR [rax+0x10]
    205f:	mov    rax,QWORD PTR [rbp-0x8]
    2063:	mov    rax,QWORD PTR [rax+0x8]
    2067:	cmp    rdx,rax
    206a:	jb     2091 <parser_at+0x46>
    206c:	lea    rdx,[rip+0x2775]        # 47e8 <__PRETTY_FUNCTION__.5>
    2073:	lea    rsi,[rip+0x23ec]        # 4466 <_IO_stdin_used+0x466>
    207a:	lea    rax,[rip+0x23f7]        # 4478 <_IO_stdin_used+0x478>
    2081:	mov    rcx,rdx
    2084:	mov    edx,0x2f
    2089:	mov    rdi,rax
    208c:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    2091:	mov    rax,QWORD PTR [rbp-0x8]
    2095:	mov    rdx,QWORD PTR [rax]
    2098:	mov    rax,QWORD PTR [rbp-0x8]
    209c:	mov    rax,QWORD PTR [rax+0x10]
    20a0:	add    rax,rdx
}
    20a3:	leave
    20a4:	ret

00000000000020a5 <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    20a5:	push   rbp
    20a6:	mov    rbp,rsp
    20a9:	sub    rsp,0x10
    20ad:	mov    QWORD PTR [rbp-0x8],rdi
    20b1:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    20b5:	mov    rax,QWORD PTR [rbp-0x8]
    20b9:	mov    rdi,rax
    20bc:	call   204b <parser_at>
    20c1:	mov    rdx,QWORD PTR [rbp-0x10]
    20c5:	add    rax,rdx
}
    20c8:	leave
    20c9:	ret

00000000000020ca <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    20ca:	push   rbp
    20cb:	mov    rbp,rsp
    20ce:	mov    QWORD PTR [rbp-0x8],rdi
    20d2:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    20d6:	mov    rax,QWORD PTR [rbp-0x8]
    20da:	mov    rdx,QWORD PTR [rax+0x10]
    20de:	mov    rax,QWORD PTR [rbp-0x10]
    20e2:	add    rdx,rax
    20e5:	mov    rax,QWORD PTR [rbp-0x8]
    20e9:	mov    QWORD PTR [rax+0x10],rdx
}
    20ed:	nop
    20ee:	pop    rbp
    20ef:	ret

00000000000020f0 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    20f0:	push   rbp
    20f1:	mov    rbp,rsp
    20f4:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    20f8:	mov    rax,QWORD PTR [rbp-0x8]
    20fc:	mov    rdx,QWORD PTR [rax+0x10]
    2100:	mov    rax,QWORD PTR [rbp-0x8]
    2104:	mov    rax,QWORD PTR [rax+0x8]
    2108:	cmp    rdx,rax
    210b:	setb   al
}
    210e:	pop    rbp
    210f:	ret

0000000000002110 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    2110:	push   rbp
    2111:	mov    rbp,rsp
    2114:	push   r12
    2116:	push   rbx
    2117:	sub    rsp,0x20
    211b:	mov    QWORD PTR [rbp-0x18],rdi
    211f:	mov    rax,rsi
    2122:	mov    rcx,rdx
    2125:	mov    rax,rax
    2128:	mov    edx,0x0
    212d:	mov    rdx,rcx
    2130:	mov    QWORD PTR [rbp-0x30],rax
    2134:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    2138:	mov    rax,QWORD PTR [rbp-0x28]
    213c:	mov    r12,rax
    213f:	mov    rbx,QWORD PTR [rbp-0x30]
    2143:	mov    rax,QWORD PTR [rbp-0x18]
    2147:	mov    rdi,rax
    214a:	call   204b <parser_at>
    214f:	mov    rdx,r12
    2152:	mov    rsi,rbx
    2155:	mov    rdi,rax
    2158:	call   10d0 <memcmp@plt>
    215d:	test   eax,eax
    215f:	sete   al
}
    2162:	add    rsp,0x20
    2166:	pop    rbx
    2167:	pop    r12
    2169:	pop    rbp
    216a:	ret

000000000000216b <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    216b:	push   rbp
    216c:	mov    rbp,rsp
    216f:	mov    eax,edi
    2171:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    2174:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    2178:	movzx  eax,BYTE PTR [rbp-0x14]
    217c:	cmp    eax,0x2e
    217f:	jg     2188 <is_numeric+0x1d>
    2181:	cmp    eax,0x2d
    2184:	jge    2190 <is_numeric+0x25>
    2186:	jmp    2195 <is_numeric+0x2a>
    2188:	sub    eax,0x30
    218b:	cmp    eax,0x9
    218e:	ja     2195 <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2190:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    2194:	nop
  }


  return result;
    2195:	movzx  eax,BYTE PTR [rbp-0x1]
}
    2199:	pop    rbp
    219a:	ret

000000000000219b <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    219b:	push   rbp
    219c:	mov    rbp,rsp
    219f:	sub    rsp,0x50
    21a3:	mov    QWORD PTR [rbp-0x48],rdi
    21a7:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    21ab:	pxor   xmm0,xmm0
    21af:	movaps XMMWORD PTR [rbp-0x20],xmm0
    21b3:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    21b8:	jmp    21cb <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    21ba:	mov    rax,QWORD PTR [rbp-0x50]
    21be:	mov    esi,0x1
    21c3:	mov    rdi,rax
    21c6:	call   20ca <parser_advance>
  while (parser_incomplete(parser)  &&
    21cb:	mov    rax,QWORD PTR [rbp-0x50]
    21cf:	mov    rdi,rax
    21d2:	call   20f0 <parser_incomplete>
    21d7:	test   al,al
    21d9:	je     2227 <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    21db:	mov    rax,QWORD PTR [rbp-0x50]
    21df:	mov    rdi,rax
    21e2:	call   204b <parser_at>
    21e7:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    21ea:	cmp    al,0x20
    21ec:	je     21ba <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    21ee:	mov    rax,QWORD PTR [rbp-0x50]
    21f2:	mov    rdi,rax
    21f5:	call   204b <parser_at>
    21fa:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    21fd:	cmp    al,0xa
    21ff:	je     21ba <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    2201:	mov    rax,QWORD PTR [rbp-0x50]
    2205:	mov    rdi,rax
    2208:	call   204b <parser_at>
    220d:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    2210:	cmp    al,0xd
    2212:	je     21ba <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    2214:	mov    rax,QWORD PTR [rbp-0x50]
    2218:	mov    rdi,rax
    221b:	call   204b <parser_at>
    2220:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    2223:	cmp    al,0x9
    2225:	je     21ba <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    2227:	mov    rax,QWORD PTR [rbp-0x50]
    222b:	mov    rdi,rax
    222e:	call   20f0 <parser_incomplete>
    2233:	test   al,al
    2235:	je     2662 <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    223b:	mov    rax,QWORD PTR [rbp-0x50]
    223f:	mov    rdi,rax
    2242:	call   204b <parser_at>
    2247:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    224b:	mov    rax,QWORD PTR [rbp-0x50]
    224f:	mov    rdi,rax
    2252:	call   204b <parser_at>
    2257:	movzx  eax,BYTE PTR [rax]
    225a:	movzx  eax,al
    225d:	cmp    eax,0x7d
    2260:	je     234d <get_json_token+0x1b2>
    2266:	cmp    eax,0x7d
    2269:	jg     2673 <get_json_token+0x4d8>
    226f:	cmp    eax,0x7b
    2272:	je     2328 <get_json_token+0x18d>
    2278:	cmp    eax,0x7b
    227b:	jg     2673 <get_json_token+0x4d8>
    2281:	cmp    eax,0x74
    2284:	je     24d0 <get_json_token+0x335>
    228a:	cmp    eax,0x74
    228d:	jg     2673 <get_json_token+0x4d8>
    2293:	cmp    eax,0x6e
    2296:	je     25e0 <get_json_token+0x445>
    229c:	cmp    eax,0x6e
    229f:	jg     2673 <get_json_token+0x4d8>
    22a5:	cmp    eax,0x66
    22a8:	je     2558 <get_json_token+0x3bd>
    22ae:	cmp    eax,0x66
    22b1:	jg     2673 <get_json_token+0x4d8>
    22b7:	cmp    eax,0x5d
    22ba:	je     2397 <get_json_token+0x1fc>
    22c0:	cmp    eax,0x5d
    22c3:	jg     2673 <get_json_token+0x4d8>
    22c9:	cmp    eax,0x5b
    22cc:	je     2372 <get_json_token+0x1d7>
    22d2:	cmp    eax,0x5b
    22d5:	jg     2673 <get_json_token+0x4d8>
    22db:	cmp    eax,0x3a
    22de:	je     23e1 <get_json_token+0x246>
    22e4:	cmp    eax,0x3a
    22e7:	jg     2673 <get_json_token+0x4d8>
    22ed:	cmp    eax,0x39
    22f0:	jg     2673 <get_json_token+0x4d8>
    22f6:	cmp    eax,0x30
    22f9:	jge    247f <get_json_token+0x2e4>
    22ff:	cmp    eax,0x2e
    2302:	jg     2673 <get_json_token+0x4d8>
    2308:	cmp    eax,0x2d
    230b:	jge    247f <get_json_token+0x2e4>
    2311:	cmp    eax,0x22
    2314:	je     2406 <get_json_token+0x26b>
    231a:	cmp    eax,0x2c
    231d:	je     23bc <get_json_token+0x221>
    2323:	jmp    2673 <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    2328:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    232f:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2337:	mov    rax,QWORD PTR [rbp-0x50]
    233b:	mov    esi,0x1
    2340:	mov    rdi,rax
    2343:	call   20ca <parser_advance>
      }
      break;
    2348:	jmp    2673 <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    234d:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    2354:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    235c:	mov    rax,QWORD PTR [rbp-0x50]
    2360:	mov    esi,0x1
    2365:	mov    rdi,rax
    2368:	call   20ca <parser_advance>
      }
      break;
    236d:	jmp    2673 <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2372:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    2379:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2381:	mov    rax,QWORD PTR [rbp-0x50]
    2385:	mov    esi,0x1
    238a:	mov    rdi,rax
    238d:	call   20ca <parser_advance>
      }
      break;
    2392:	jmp    2673 <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    2397:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    239e:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    23a6:	mov    rax,QWORD PTR [rbp-0x50]
    23aa:	mov    esi,0x1
    23af:	mov    rdi,rax
    23b2:	call   20ca <parser_advance>
      }
      break;
    23b7:	jmp    2673 <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    23bc:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    23c3:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    23cb:	mov    rax,QWORD PTR [rbp-0x50]
    23cf:	mov    esi,0x1
    23d4:	mov    rdi,rax
    23d7:	call   20ca <parser_advance>
      }
      break;
    23dc:	jmp    2673 <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    23e1:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    23e8:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    23f0:	mov    rax,QWORD PTR [rbp-0x50]
    23f4:	mov    esi,0x1
    23f9:	mov    rdi,rax
    23fc:	call   20ca <parser_advance>
      }
      break;
    2401:	jmp    2673 <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    2406:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    240d:	mov    rax,QWORD PTR [rbp-0x50]
    2411:	mov    esi,0x1
    2416:	mov    rdi,rax
    2419:	call   20ca <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    241e:	mov    rax,QWORD PTR [rbp-0x50]
    2422:	mov    rdi,rax
    2425:	call   204b <parser_at>
    242a:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    242e:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    2436:	jmp    244e <get_json_token+0x2b3>
        {
          string_count += 1;
    2438:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    243d:	mov    rax,QWORD PTR [rbp-0x50]
    2441:	mov    esi,0x1
    2446:	mov    rdi,rax
    2449:	call   20ca <parser_advance>
        while (*parser_at(parser) != '"')
    244e:	mov    rax,QWORD PTR [rbp-0x50]
    2452:	mov    rdi,rax
    2455:	call   204b <parser_at>
    245a:	movzx  eax,BYTE PTR [rax]
    245d:	cmp    al,0x22
    245f:	jne    2438 <get_json_token+0x29d>
        }
        token.value.count = string_count;
    2461:	mov    rax,QWORD PTR [rbp-0x40]
    2465:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    2469:	mov    rax,QWORD PTR [rbp-0x50]
    246d:	mov    esi,0x1
    2472:	mov    rdi,rax
    2475:	call   20ca <parser_advance>
      }
      break;
    247a:	jmp    2673 <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    247f:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    2486:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    248e:	jmp    24a6 <get_json_token+0x30b>
        {
          digit_count += 1;
    2490:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    2495:	mov    rax,QWORD PTR [rbp-0x50]
    2499:	mov    esi,0x1
    249e:	mov    rdi,rax
    24a1:	call   20ca <parser_advance>
        while (is_numeric(*parser_at(parser)))
    24a6:	mov    rax,QWORD PTR [rbp-0x50]
    24aa:	mov    rdi,rax
    24ad:	call   204b <parser_at>
    24b2:	movzx  eax,BYTE PTR [rax]
    24b5:	movzx  eax,al
    24b8:	mov    edi,eax
    24ba:	call   216b <is_numeric>
    24bf:	test   al,al
    24c1:	jne    2490 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    24c3:	mov    rax,QWORD PTR [rbp-0x38]
    24c7:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    24cb:	jmp    2673 <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    24d0:	lea    rax,[rip+0x1fed]        # 44c4 <_IO_stdin_used+0x4c4>
    24d7:	mov    QWORD PTR [rbp-0x30],rax
    24db:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    24e3:	mov    rcx,QWORD PTR [rbp-0x30]
    24e7:	mov    rdx,QWORD PTR [rbp-0x28]
    24eb:	mov    rax,QWORD PTR [rbp-0x50]
    24ef:	mov    rsi,rcx
    24f2:	mov    rdi,rax
    24f5:	call   2110 <parser_token_is_literal>
    24fa:	test   al,al
    24fc:	je     2520 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    24fe:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    2505:	mov    rax,QWORD PTR [rbp-0x28]
    2509:	mov    rdx,rax
    250c:	mov    rax,QWORD PTR [rbp-0x50]
    2510:	mov    rsi,rdx
    2513:	mov    rdi,rax
    2516:	call   20ca <parser_advance>
    251b:	jmp    2673 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2520:	mov    rax,QWORD PTR [rbp-0x50]
    2524:	mov    rcx,QWORD PTR [rax+0x10]
    2528:	lea    rdx,[rip+0x1fa1]        # 44d0 <_IO_stdin_used+0x4d0>
    252f:	lea    rax,[rip+0x1f30]        # 4466 <_IO_stdin_used+0x466>
    2536:	mov    r8,rcx
    2539:	mov    rcx,rdx
    253c:	mov    edx,0xdf
    2541:	mov    rsi,rax
    2544:	mov    edi,0x1
    2549:	mov    eax,0x0
    254e:	call   14a1 <log_message>
        }
      }
      break;
    2553:	jmp    2673 <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    2558:	lea    rax,[rip+0x1f9e]        # 44fd <_IO_stdin_used+0x4fd>
    255f:	mov    QWORD PTR [rbp-0x30],rax
    2563:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    256b:	mov    rcx,QWORD PTR [rbp-0x30]
    256f:	mov    rdx,QWORD PTR [rbp-0x28]
    2573:	mov    rax,QWORD PTR [rbp-0x50]
    2577:	mov    rsi,rcx
    257a:	mov    rdi,rax
    257d:	call   2110 <parser_token_is_literal>
    2582:	test   al,al
    2584:	je     25a8 <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    2586:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    258d:	mov    rax,QWORD PTR [rbp-0x28]
    2591:	mov    rdx,rax
    2594:	mov    rax,QWORD PTR [rbp-0x50]
    2598:	mov    rsi,rdx
    259b:	mov    rdi,rax
    259e:	call   20ca <parser_advance>
    25a3:	jmp    2673 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    25a8:	mov    rax,QWORD PTR [rbp-0x50]
    25ac:	mov    rcx,QWORD PTR [rax+0x10]
    25b0:	lea    rdx,[rip+0x1f19]        # 44d0 <_IO_stdin_used+0x4d0>
    25b7:	lea    rax,[rip+0x1ea8]        # 4466 <_IO_stdin_used+0x466>
    25be:	mov    r8,rcx
    25c1:	mov    rcx,rdx
    25c4:	mov    edx,0xee
    25c9:	mov    rsi,rax
    25cc:	mov    edi,0x1
    25d1:	mov    eax,0x0
    25d6:	call   14a1 <log_message>
        }
      }
      break;
    25db:	jmp    2673 <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    25e0:	lea    rax,[rip+0x1f1c]        # 4503 <_IO_stdin_used+0x503>
    25e7:	mov    QWORD PTR [rbp-0x30],rax
    25eb:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25f3:	mov    rcx,QWORD PTR [rbp-0x30]
    25f7:	mov    rdx,QWORD PTR [rbp-0x28]
    25fb:	mov    rax,QWORD PTR [rbp-0x50]
    25ff:	mov    rsi,rcx
    2602:	mov    rdi,rax
    2605:	call   2110 <parser_token_is_literal>
    260a:	test   al,al
    260c:	je     262d <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    260e:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    2615:	mov    rax,QWORD PTR [rbp-0x28]
    2619:	mov    rdx,rax
    261c:	mov    rax,QWORD PTR [rbp-0x50]
    2620:	mov    rsi,rdx
    2623:	mov    rdi,rax
    2626:	call   20ca <parser_advance>
    262b:	jmp    2673 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    262d:	mov    rax,QWORD PTR [rbp-0x50]
    2631:	mov    rcx,QWORD PTR [rax+0x10]
    2635:	lea    rdx,[rip+0x1e94]        # 44d0 <_IO_stdin_used+0x4d0>
    263c:	lea    rax,[rip+0x1e23]        # 4466 <_IO_stdin_used+0x466>
    2643:	mov    r8,rcx
    2646:	mov    rcx,rdx
    2649:	mov    edx,0xfd
    264e:	mov    rsi,rax
    2651:	mov    edi,0x1
    2656:	mov    eax,0x0
    265b:	call   14a1 <log_message>
        }
      }
      break;
    2660:	jmp    2673 <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    2662:	mov    rax,QWORD PTR [rbp-0x50]
    2666:	mov    esi,0x1
    266b:	mov    rdi,rax
    266e:	call   20ca <parser_advance>
  }

  return token;
    2673:	mov    rcx,QWORD PTR [rbp-0x48]
    2677:	mov    rax,QWORD PTR [rbp-0x20]
    267b:	mov    rdx,QWORD PTR [rbp-0x18]
    267f:	mov    QWORD PTR [rcx],rax
    2682:	mov    QWORD PTR [rcx+0x8],rdx
    2686:	mov    rax,QWORD PTR [rbp-0x10]
    268a:	mov    QWORD PTR [rcx+0x10],rax
}
    268e:	mov    rax,QWORD PTR [rbp-0x48]
    2692:	leave
    2693:	ret

0000000000002694 <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    2694:	push   rbp
    2695:	mov    rbp,rsp
    2698:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    269b:	cmp    DWORD PTR [rbp-0x14],0x7
    269f:	je     26b9 <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    26a1:	cmp    DWORD PTR [rbp-0x14],0x9
    26a5:	je     26b9 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    26a7:	cmp    DWORD PTR [rbp-0x14],0xa
    26ab:	je     26b9 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    26ad:	cmp    DWORD PTR [rbp-0x14],0xb
    26b1:	je     26b9 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    26b3:	cmp    DWORD PTR [rbp-0x14],0x8
    26b7:	jne    26c0 <json_token_type_is_value_type+0x2c>
    26b9:	mov    eax,0x1
    26be:	jmp    26c5 <json_token_type_is_value_type+0x31>
    26c0:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    26c5:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    26c8:	mov    eax,DWORD PTR [rbp-0x4]
}
    26cb:	pop    rbp
    26cc:	ret

00000000000026cd <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    26cd:	push   rbp
    26ce:	mov    rbp,rsp
    26d1:	push   rbx
    26d2:	sub    rsp,0x88
    26d9:	mov    QWORD PTR [rbp-0x78],rdi
    26dd:	mov    QWORD PTR [rbp-0x80],rsi
    26e1:	mov    QWORD PTR [rbp-0x90],rdx
    26e8:	mov    QWORD PTR [rbp-0x88],rcx
    26ef:	mov    rax,QWORD PTR fs:0x28
    26f8:	mov    QWORD PTR [rbp-0x18],rax
    26fc:	xor    eax,eax
  profile_begin_func();
    26fe:	lea    r8,[rip+0x20fb]        # 4800 <__func__.4>
    2705:	mov    r9d,0x11
    270b:	lea    rax,[rbp-0x50]
    270f:	mov    rsi,r8
    2712:	mov    rdx,r9
    2715:	mov    r8d,0x0
    271b:	mov    ecx,0x1
    2720:	mov    rdi,rax
    2723:	call   1e73 <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    2728:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2730:	mov    eax,DWORD PTR [rbp+0x10]
    2733:	cmp    eax,0x1
    2736:	jne    2762 <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    2738:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    273f:	mov    edx,DWORD PTR [rbp-0x64]
    2742:	mov    rsi,QWORD PTR [rbp-0x80]
    2746:	mov    rax,QWORD PTR [rbp-0x78]
    274a:	mov    ecx,edx
    274c:	mov    edx,0x2
    2751:	mov    rdi,rax
    2754:	call   28b4 <parse_json_children>
    2759:	mov    QWORD PTR [rbp-0x60],rax
    275d:	jmp    27ec <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2762:	mov    eax,DWORD PTR [rbp+0x10]
    2765:	cmp    eax,0x3
    2768:	jne    2791 <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    276a:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2771:	mov    edx,DWORD PTR [rbp-0x68]
    2774:	mov    rsi,QWORD PTR [rbp-0x80]
    2778:	mov    rax,QWORD PTR [rbp-0x78]
    277c:	mov    ecx,edx
    277e:	mov    edx,0x4
    2783:	mov    rdi,rax
    2786:	call   28b4 <parse_json_children>
    278b:	mov    QWORD PTR [rbp-0x60],rax
    278f:	jmp    27ec <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    2791:	mov    eax,DWORD PTR [rbp+0x10]
    2794:	mov    edi,eax
    2796:	call   2694 <json_token_type_is_value_type>
    279b:	test   eax,eax
    279d:	jne    27ec <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    279f:	mov    eax,DWORD PTR [rbp+0x10]
    27a2:	mov    eax,eax
    27a4:	lea    rdx,[rax*8+0x0]
    27ac:	lea    rax,[rip+0x392d]        # 60e0 <JSON_Token_Type_strings>
    27b3:	mov    rcx,QWORD PTR [rdx+rax*1]
    27b7:	lea    rdx,[rip+0x1d4a]        # 4508 <_IO_stdin_used+0x508>
    27be:	lea    rax,[rip+0x1ca1]        # 4466 <_IO_stdin_used+0x466>
    27c5:	push   QWORD PTR [rbp+0x20]
    27c8:	push   QWORD PTR [rbp+0x18]
    27cb:	mov    r8,rcx
    27ce:	mov    rcx,rdx
    27d1:	mov    edx,0x134
    27d6:	mov    rsi,rax
    27d9:	mov    edi,0x1
    27de:	mov    eax,0x0
    27e3:	call   14a1 <log_message>
    27e8:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    27ec:	mov    rax,QWORD PTR [rbp-0x78]
    27f0:	mov    edx,0x8
    27f5:	mov    esi,0x30
    27fa:	mov    rdi,rax
    27fd:	call   17d3 <arena_alloc>
    2802:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    2806:	mov    rcx,QWORD PTR [rbp-0x58]
    280a:	mov    rax,QWORD PTR [rbp-0x90]
    2811:	mov    rdx,QWORD PTR [rbp-0x88]
    2818:	mov    QWORD PTR [rcx],rax
    281b:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    281f:	mov    rax,QWORD PTR [rbp-0x58]
    2823:	mov    rdx,QWORD PTR [rbp-0x60]
    2827:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    282b:	mov    rax,QWORD PTR [rbp-0x58]
    282f:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    2837:	mov    rcx,QWORD PTR [rbp-0x58]
    283b:	mov    rax,QWORD PTR [rbp+0x18]
    283f:	mov    rdx,QWORD PTR [rbp+0x20]
    2843:	mov    QWORD PTR [rcx+0x10],rax
    2847:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    284b:	sub    rsp,0x8
    284f:	sub    rsp,0x38
    2853:	mov    rax,rsp
    2856:	mov    rcx,QWORD PTR [rbp-0x50]
    285a:	mov    rbx,QWORD PTR [rbp-0x48]
    285e:	mov    QWORD PTR [rax],rcx
    2861:	mov    QWORD PTR [rax+0x8],rbx
    2865:	mov    rcx,QWORD PTR [rbp-0x40]
    2869:	mov    rbx,QWORD PTR [rbp-0x38]
    286d:	mov    QWORD PTR [rax+0x10],rcx
    2871:	mov    QWORD PTR [rax+0x18],rbx
    2875:	mov    rcx,QWORD PTR [rbp-0x30]
    2879:	mov    rbx,QWORD PTR [rbp-0x28]
    287d:	mov    QWORD PTR [rax+0x20],rcx
    2881:	mov    QWORD PTR [rax+0x28],rbx
    2885:	mov    rdx,QWORD PTR [rbp-0x20]
    2889:	mov    QWORD PTR [rax+0x30],rdx
    288d:	call   1f5d <__profile_end_pass>
    2892:	add    rsp,0x40

  return result;
    2896:	mov    rax,QWORD PTR [rbp-0x58]
}
    289a:	mov    rdx,QWORD PTR [rbp-0x18]
    289e:	sub    rdx,QWORD PTR fs:0x28
    28a7:	je     28ae <parse_json_object+0x1e1>
    28a9:	call   1060 <__stack_chk_fail@plt>
    28ae:	mov    rbx,QWORD PTR [rbp-0x8]
    28b2:	leave
    28b3:	ret

00000000000028b4 <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    28b4:	push   rbp
    28b5:	mov    rbp,rsp
    28b8:	push   rbx
    28b9:	sub    rsp,0x108
    28c0:	mov    QWORD PTR [rbp-0xd8],rdi
    28c7:	mov    QWORD PTR [rbp-0xe0],rsi
    28ce:	mov    DWORD PTR [rbp-0xe4],edx
    28d4:	mov    DWORD PTR [rbp-0xe8],ecx
    28da:	mov    rax,QWORD PTR fs:0x28
    28e3:	mov    QWORD PTR [rbp-0x18],rax
    28e7:	xor    eax,eax
  profile_begin_func();
    28e9:	lea    r8,[rip+0x1f30]        # 4820 <__func__.3>
    28f0:	mov    r9d,0x13
    28f6:	lea    rax,[rbp-0x50]
    28fa:	mov    rsi,r8
    28fd:	mov    rdx,r9
    2900:	mov    r8d,0x0
    2906:	mov    ecx,0x2
    290b:	mov    rdi,rax
    290e:	call   1e73 <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2913:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    291e:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2929:	jmp    2c02 <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    292e:	pxor   xmm0,xmm0
    2932:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2939:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2941:	pxor   xmm0,xmm0
    2945:	movaps XMMWORD PTR [rbp-0x90],xmm0
    294c:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2951:	cmp    DWORD PTR [rbp-0xe8],0x0
    2958:	je     2a65 <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    295e:	lea    rax,[rbp-0xb0]
    2965:	mov    rdx,QWORD PTR [rbp-0xe0]
    296c:	mov    rsi,rdx
    296f:	mov    rdi,rax
    2972:	call   219b <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2977:	mov    eax,DWORD PTR [rbp-0xb0]
    297d:	cmp    eax,0x7
    2980:	jne    2a01 <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2982:	lea    rax,[rbp-0x70]
    2986:	mov    rdx,QWORD PTR [rbp-0xe0]
    298d:	mov    rsi,rdx
    2990:	mov    rdi,rax
    2993:	call   219b <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2998:	mov    eax,DWORD PTR [rbp-0x70]
    299b:	cmp    eax,0x6
    299e:	jne    29be <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    29a0:	lea    rax,[rbp-0x90]
    29a7:	mov    rdx,QWORD PTR [rbp-0xe0]
    29ae:	mov    rsi,rdx
    29b1:	mov    rdi,rax
    29b4:	call   219b <get_json_token>
    29b9:	jmp    2aa5 <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    29be:	mov    rcx,QWORD PTR [rbp-0xa8]
    29c5:	mov    rax,QWORD PTR [rbp-0xa0]
    29cc:	mov    esi,eax
    29ce:	lea    rdx,[rip+0x1b83]        # 4558 <_IO_stdin_used+0x558>
    29d5:	lea    rax,[rip+0x1a8a]        # 4466 <_IO_stdin_used+0x466>
    29dc:	mov    r9,rcx
    29df:	mov    r8d,esi
    29e2:	mov    rcx,rdx
    29e5:	mov    edx,0x15f
    29ea:	mov    rsi,rax
    29ed:	mov    edi,0x1
    29f2:	mov    eax,0x0
    29f7:	call   14a1 <log_message>
    29fc:	jmp    2aa5 <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2a01:	mov    rcx,QWORD PTR [rbp-0xa8]
    2a08:	mov    rax,QWORD PTR [rbp-0xa0]
    2a0f:	mov    edi,eax
    2a11:	mov    eax,DWORD PTR [rbp-0xb0]
    2a17:	mov    eax,eax
    2a19:	lea    rdx,[rax*8+0x0]
    2a21:	lea    rax,[rip+0x36b8]        # 60e0 <JSON_Token_Type_strings>
    2a28:	mov    rsi,QWORD PTR [rdx+rax*1]
    2a2c:	lea    rdx,[rip+0x1b45]        # 4578 <_IO_stdin_used+0x578>
    2a33:	lea    rax,[rip+0x1a2c]        # 4466 <_IO_stdin_used+0x466>
    2a3a:	sub    rsp,0x8
    2a3e:	push   rcx
    2a3f:	mov    r9d,edi
    2a42:	mov    r8,rsi
    2a45:	mov    rcx,rdx
    2a48:	mov    edx,0x164
    2a4d:	mov    rsi,rax
    2a50:	mov    edi,0x1
    2a55:	mov    eax,0x0
    2a5a:	call   14a1 <log_message>
    2a5f:	add    rsp,0x10
    2a63:	jmp    2aa5 <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2a65:	lea    rax,[rbp-0x110]
    2a6c:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a73:	mov    rsi,rdx
    2a76:	mov    rdi,rax
    2a79:	call   219b <get_json_token>
    2a7e:	mov    rax,QWORD PTR [rbp-0x110]
    2a85:	mov    rdx,QWORD PTR [rbp-0x108]
    2a8c:	mov    QWORD PTR [rbp-0x90],rax
    2a93:	mov    QWORD PTR [rbp-0x88],rdx
    2a9a:	mov    rax,QWORD PTR [rbp-0x100]
    2aa1:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2aa5:	mov    eax,DWORD PTR [rbp-0x90]
    2aab:	cmp    DWORD PTR [rbp-0xe4],eax
    2ab1:	je     2c1b <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2ab7:	mov    rax,QWORD PTR [rbp-0xa8]
    2abe:	mov    rdx,QWORD PTR [rbp-0xa0]
    2ac5:	mov    r8,QWORD PTR [rbp-0xe0]
    2acc:	mov    rdi,QWORD PTR [rbp-0xd8]
    2ad3:	sub    rsp,0x8
    2ad7:	sub    rsp,0x18
    2adb:	mov    rsi,rsp
    2ade:	mov    rcx,QWORD PTR [rbp-0x90]
    2ae5:	mov    rbx,QWORD PTR [rbp-0x88]
    2aec:	mov    QWORD PTR [rsi],rcx
    2aef:	mov    QWORD PTR [rsi+0x8],rbx
    2af3:	mov    rcx,QWORD PTR [rbp-0x80]
    2af7:	mov    QWORD PTR [rsi+0x10],rcx
    2afb:	mov    rcx,rdx
    2afe:	mov    rdx,rax
    2b01:	mov    rsi,r8
    2b04:	call   26cd <parse_json_object>
    2b09:	add    rsp,0x20
    2b0d:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2b14:	cmp    QWORD PTR [rbp-0xb8],0x0
    2b1c:	je     2b66 <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2b1e:	cmp    QWORD PTR [rbp-0xc8],0x0
    2b26:	jne    2b46 <parse_json_children+0x292>
      {
        first_child        = object;
    2b28:	mov    rax,QWORD PTR [rbp-0xb8]
    2b2f:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2b36:	mov    rax,QWORD PTR [rbp-0xb8]
    2b3d:	mov    QWORD PTR [rbp-0xc0],rax
    2b44:	jmp    2b66 <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2b46:	mov    rax,QWORD PTR [rbp-0xc0]
    2b4d:	mov    rdx,QWORD PTR [rbp-0xb8]
    2b54:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2b58:	mov    rax,QWORD PTR [rbp-0xb8]
    2b5f:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2b66:	lea    rax,[rbp-0x70]
    2b6a:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b71:	mov    rsi,rdx
    2b74:	mov    rdi,rax
    2b77:	call   219b <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2b7c:	mov    eax,DWORD PTR [rbp-0x70]
    2b7f:	cmp    DWORD PTR [rbp-0xe4],eax
    2b85:	je     2c1e <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2b8b:	mov    eax,DWORD PTR [rbp-0x70]
    2b8e:	cmp    eax,0x5
    2b91:	je     2c02 <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2b93:	mov    r8,QWORD PTR [rbp-0x68]
    2b97:	mov    rax,QWORD PTR [rbp-0x60]
    2b9b:	mov    r9d,eax
    2b9e:	mov    eax,DWORD PTR [rbp-0x70]
    2ba1:	mov    eax,eax
    2ba3:	lea    rdx,[rax*8+0x0]
    2bab:	lea    rax,[rip+0x352e]        # 60e0 <JSON_Token_Type_strings>
    2bb2:	mov    r10,QWORD PTR [rdx+rax*1]
    2bb6:	lea    rdi,[rip+0x19e3]        # 45a0 <_IO_stdin_used+0x5a0>
    2bbd:	lea    rsi,[rip+0x18a2]        # 4466 <_IO_stdin_used+0x466>
    2bc4:	sub    rsp,0x18
    2bc8:	mov    rcx,rsp
    2bcb:	mov    rax,QWORD PTR [rbp-0x70]
    2bcf:	mov    rdx,QWORD PTR [rbp-0x68]
    2bd3:	mov    QWORD PTR [rcx],rax
    2bd6:	mov    QWORD PTR [rcx+0x8],rdx
    2bda:	mov    rax,QWORD PTR [rbp-0x60]
    2bde:	mov    QWORD PTR [rcx+0x10],rax
    2be2:	push   r8
    2be4:	mov    r8,r10
    2be7:	mov    rcx,rdi
    2bea:	mov    edx,0x18b
    2bef:	mov    edi,0x1
    2bf4:	mov    eax,0x0
    2bf9:	call   14a1 <log_message>
    2bfe:	add    rsp,0x20
  while (parser_incomplete(parser))
    2c02:	mov    rax,QWORD PTR [rbp-0xe0]
    2c09:	mov    rdi,rax
    2c0c:	call   20f0 <parser_incomplete>
    2c11:	test   al,al
    2c13:	jne    292e <parse_json_children+0x7a>
    2c19:	jmp    2c1f <parse_json_children+0x36b>
      break;
    2c1b:	nop
    2c1c:	jmp    2c1f <parse_json_children+0x36b>
      break;
    2c1e:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2c1f:	sub    rsp,0x8
    2c23:	sub    rsp,0x38
    2c27:	mov    rax,rsp
    2c2a:	mov    rcx,QWORD PTR [rbp-0x50]
    2c2e:	mov    rbx,QWORD PTR [rbp-0x48]
    2c32:	mov    QWORD PTR [rax],rcx
    2c35:	mov    QWORD PTR [rax+0x8],rbx
    2c39:	mov    rcx,QWORD PTR [rbp-0x40]
    2c3d:	mov    rbx,QWORD PTR [rbp-0x38]
    2c41:	mov    QWORD PTR [rax+0x10],rcx
    2c45:	mov    QWORD PTR [rax+0x18],rbx
    2c49:	mov    rcx,QWORD PTR [rbp-0x30]
    2c4d:	mov    rbx,QWORD PTR [rbp-0x28]
    2c51:	mov    QWORD PTR [rax+0x20],rcx
    2c55:	mov    QWORD PTR [rax+0x28],rbx
    2c59:	mov    rdx,QWORD PTR [rbp-0x20]
    2c5d:	mov    QWORD PTR [rax+0x30],rdx
    2c61:	call   1f5d <__profile_end_pass>
    2c66:	add    rsp,0x40

  return first_child;
    2c6a:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2c71:	mov    rdx,QWORD PTR [rbp-0x18]
    2c75:	sub    rdx,QWORD PTR fs:0x28
    2c7e:	je     2c85 <parse_json_children+0x3d1>
    2c80:	call   1060 <__stack_chk_fail@plt>
    2c85:	mov    rbx,QWORD PTR [rbp-0x8]
    2c89:	leave
    2c8a:	ret

0000000000002c8b <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2c8b:	push   rbp
    2c8c:	mov    rbp,rsp
    2c8f:	push   rbx
    2c90:	sub    rsp,0xb8
    2c97:	mov    QWORD PTR [rbp-0xa8],rdi
    2c9e:	mov    rax,rsi
    2ca1:	mov    rsi,rdx
    2ca4:	mov    rax,rax
    2ca7:	mov    edx,0x0
    2cac:	mov    rdx,rsi
    2caf:	mov    QWORD PTR [rbp-0xc0],rax
    2cb6:	mov    QWORD PTR [rbp-0xb8],rdx
    2cbd:	mov    rax,QWORD PTR fs:0x28
    2cc6:	mov    QWORD PTR [rbp-0x18],rax
    2cca:	xor    eax,eax
  profile_begin_func();
    2ccc:	lea    rcx,[rip+0x1b65]        # 4838 <__func__.2>
    2cd3:	mov    ebx,0xa
    2cd8:	lea    rax,[rbp-0x50]
    2cdc:	mov    rsi,rcx
    2cdf:	mov    rdx,rbx
    2ce2:	mov    r8d,0x0
    2ce8:	mov    ecx,0x3
    2ced:	mov    rdi,rax
    2cf0:	call   1e73 <__profile_begin_pass>

  JSON_Parser parser =
    2cf5:	mov    rax,QWORD PTR [rbp-0xc0]
    2cfc:	mov    rdx,QWORD PTR [rbp-0xb8]
    2d03:	mov    QWORD PTR [rbp-0x90],rax
    2d0a:	mov    QWORD PTR [rbp-0x88],rdx
    2d11:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2d19:	lea    rax,[rbp-0x70]
    2d1d:	lea    rdx,[rbp-0x90]
    2d24:	mov    rsi,rdx
    2d27:	mov    rdi,rax
    2d2a:	call   219b <get_json_token>
    2d2f:	mov    ecx,0x0
    2d34:	mov    ebx,0x0
    2d39:	lea    r8,[rbp-0x90]
    2d40:	mov    rdi,QWORD PTR [rbp-0xa8]
    2d47:	sub    rsp,0x8
    2d4b:	sub    rsp,0x18
    2d4f:	mov    rsi,rsp
    2d52:	mov    rax,QWORD PTR [rbp-0x70]
    2d56:	mov    rdx,QWORD PTR [rbp-0x68]
    2d5a:	mov    QWORD PTR [rsi],rax
    2d5d:	mov    QWORD PTR [rsi+0x8],rdx
    2d61:	mov    rax,QWORD PTR [rbp-0x60]
    2d65:	mov    QWORD PTR [rsi+0x10],rax
    2d69:	mov    rdx,rcx
    2d6c:	mov    rcx,rbx
    2d6f:	mov    rsi,r8
    2d72:	call   26cd <parse_json_object>
    2d77:	add    rsp,0x20
    2d7b:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2d82:	sub    rsp,0x8
    2d86:	sub    rsp,0x38
    2d8a:	mov    rax,rsp
    2d8d:	mov    rcx,QWORD PTR [rbp-0x50]
    2d91:	mov    rbx,QWORD PTR [rbp-0x48]
    2d95:	mov    QWORD PTR [rax],rcx
    2d98:	mov    QWORD PTR [rax+0x8],rbx
    2d9c:	mov    rcx,QWORD PTR [rbp-0x40]
    2da0:	mov    rbx,QWORD PTR [rbp-0x38]
    2da4:	mov    QWORD PTR [rax+0x10],rcx
    2da8:	mov    QWORD PTR [rax+0x18],rbx
    2dac:	mov    rcx,QWORD PTR [rbp-0x30]
    2db0:	mov    rbx,QWORD PTR [rbp-0x28]
    2db4:	mov    QWORD PTR [rax+0x20],rcx
    2db8:	mov    QWORD PTR [rax+0x28],rbx
    2dbc:	mov    rdx,QWORD PTR [rbp-0x20]
    2dc0:	mov    QWORD PTR [rax+0x30],rdx
    2dc4:	call   1f5d <__profile_end_pass>
    2dc9:	add    rsp,0x40

  return outer;
    2dcd:	mov    rax,QWORD PTR [rbp-0x98]
}
    2dd4:	mov    rdx,QWORD PTR [rbp-0x18]
    2dd8:	sub    rdx,QWORD PTR fs:0x28
    2de1:	je     2de8 <parse_json+0x15d>
    2de3:	call   1060 <__stack_chk_fail@plt>
    2de8:	mov    rbx,QWORD PTR [rbp-0x8]
    2dec:	leave
    2ded:	ret

0000000000002dee <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2dee:	push   rbp
    2def:	mov    rbp,rsp
    2df2:	push   rbx
    2df3:	sub    rsp,0x78
    2df7:	mov    QWORD PTR [rbp-0x68],rdi
    2dfb:	mov    rax,rsi
    2dfe:	mov    rsi,rdx
    2e01:	mov    rax,rax
    2e04:	mov    edx,0x0
    2e09:	mov    rdx,rsi
    2e0c:	mov    QWORD PTR [rbp-0x80],rax
    2e10:	mov    QWORD PTR [rbp-0x78],rdx
    2e14:	mov    rax,QWORD PTR fs:0x28
    2e1d:	mov    QWORD PTR [rbp-0x18],rax
    2e21:	xor    eax,eax
  profile_begin_func();
    2e23:	lea    rcx,[rip+0x1a26]        # 4850 <__func__.1>
    2e2a:	mov    ebx,0x12
    2e2f:	lea    rax,[rbp-0x50]
    2e33:	mov    rsi,rcx
    2e36:	mov    rdx,rbx
    2e39:	mov    r8d,0x0
    2e3f:	mov    ecx,0x4
    2e44:	mov    rdi,rax
    2e47:	call   1e73 <__profile_begin_pass>

  JSON_Object *result = NULL;
    2e4c:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2e54:	cmp    QWORD PTR [rbp-0x68],0x0
    2e59:	je     2ea8 <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2e5b:	mov    rax,QWORD PTR [rbp-0x68]
    2e5f:	mov    rax,QWORD PTR [rax+0x20]
    2e63:	mov    QWORD PTR [rbp-0x58],rax
    2e67:	jmp    2ea1 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2e69:	mov    rax,QWORD PTR [rbp-0x58]
    2e6d:	mov    rdx,QWORD PTR [rax+0x8]
    2e71:	mov    rax,QWORD PTR [rax]
    2e74:	mov    rdi,QWORD PTR [rbp-0x80]
    2e78:	mov    rsi,QWORD PTR [rbp-0x78]
    2e7c:	mov    rcx,rdx
    2e7f:	mov    rdx,rax
    2e82:	call   143f <strings_equal>
    2e87:	test   al,al
    2e89:	je     2e95 <lookup_json_object+0xa7>
      {
        result = cursor;
    2e8b:	mov    rax,QWORD PTR [rbp-0x58]
    2e8f:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2e93:	jmp    2ea8 <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2e95:	mov    rax,QWORD PTR [rbp-0x58]
    2e99:	mov    rax,QWORD PTR [rax+0x28]
    2e9d:	mov    QWORD PTR [rbp-0x58],rax
    2ea1:	cmp    QWORD PTR [rbp-0x58],0x0
    2ea6:	jne    2e69 <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2ea8:	sub    rsp,0x8
    2eac:	sub    rsp,0x38
    2eb0:	mov    rax,rsp
    2eb3:	mov    rcx,QWORD PTR [rbp-0x50]
    2eb7:	mov    rbx,QWORD PTR [rbp-0x48]
    2ebb:	mov    QWORD PTR [rax],rcx
    2ebe:	mov    QWORD PTR [rax+0x8],rbx
    2ec2:	mov    rcx,QWORD PTR [rbp-0x40]
    2ec6:	mov    rbx,QWORD PTR [rbp-0x38]
    2eca:	mov    QWORD PTR [rax+0x10],rcx
    2ece:	mov    QWORD PTR [rax+0x18],rbx
    2ed2:	mov    rcx,QWORD PTR [rbp-0x30]
    2ed6:	mov    rbx,QWORD PTR [rbp-0x28]
    2eda:	mov    QWORD PTR [rax+0x20],rcx
    2ede:	mov    QWORD PTR [rax+0x28],rbx
    2ee2:	mov    rdx,QWORD PTR [rbp-0x20]
    2ee6:	mov    QWORD PTR [rax+0x30],rdx
    2eea:	call   1f5d <__profile_end_pass>
    2eef:	add    rsp,0x40

  return result;
    2ef3:	mov    rax,QWORD PTR [rbp-0x60]
}
    2ef7:	mov    rdx,QWORD PTR [rbp-0x18]
    2efb:	sub    rdx,QWORD PTR fs:0x28
    2f04:	je     2f0b <lookup_json_object+0x11d>
    2f06:	call   1060 <__stack_chk_fail@plt>
    2f0b:	mov    rbx,QWORD PTR [rbp-0x8]
    2f0f:	leave
    2f10:	ret

0000000000002f11 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    2f11:	push   rbp
    2f12:	mov    rbp,rsp
    2f15:	sub    rsp,0x50
    2f19:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    2f1d:	cmp    QWORD PTR [rbp-0x48],0x0
    2f22:	jne    2f49 <json_object_to_f64+0x38>
    2f24:	lea    rdx,[rip+0x1945]        # 4870 <__PRETTY_FUNCTION__.0>
    2f2b:	lea    rsi,[rip+0x1534]        # 4466 <_IO_stdin_used+0x466>
    2f32:	lea    rax,[rip+0x16a7]        # 45e0 <_IO_stdin_used+0x5e0>
    2f39:	mov    rcx,rdx
    2f3c:	mov    edx,0x1c2
    2f41:	mov    rdi,rax
    2f44:	call   1090 <__assert_fail@plt>

  String val = object->value;
    2f49:	mov    rax,QWORD PTR [rbp-0x48]
    2f4d:	mov    rdx,QWORD PTR [rax+0x18]
    2f51:	mov    rax,QWORD PTR [rax+0x10]
    2f55:	mov    QWORD PTR [rbp-0x10],rax
    2f59:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    2f5d:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    2f65:	movsd  xmm0,QWORD PTR [rip+0x192b]        # 4898 <__PRETTY_FUNCTION__.0+0x28>
    2f6d:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    2f72:	mov    rax,QWORD PTR [rbp-0x8]
    2f76:	cmp    QWORD PTR [rbp-0x30],rax
    2f7a:	jae    2fa0 <json_object_to_f64+0x8f>
    2f7c:	mov    rdx,QWORD PTR [rbp-0x10]
    2f80:	mov    rax,QWORD PTR [rbp-0x30]
    2f84:	add    rax,rdx
    2f87:	movzx  eax,BYTE PTR [rax]
    2f8a:	cmp    al,0x2d
    2f8c:	jne    2fa0 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    2f8e:	movsd  xmm0,QWORD PTR [rip+0x190a]        # 48a0 <__PRETTY_FUNCTION__.0+0x30>
    2f96:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    2f9b:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    2fa0:	pxor   xmm0,xmm0
    2fa4:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    2fa9:	jmp    2ff0 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    2fab:	mov    rdx,QWORD PTR [rbp-0x10]
    2faf:	mov    rax,QWORD PTR [rbp-0x30]
    2fb3:	add    rax,rdx
    2fb6:	movzx  eax,BYTE PTR [rax]
    2fb9:	sub    eax,0x30
    2fbc:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    2fbf:	cmp    BYTE PTR [rbp-0x32],0x9
    2fc3:	ja     2ffc <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    2fc5:	movsd  xmm1,QWORD PTR [rbp-0x20]
    2fca:	movsd  xmm0,QWORD PTR [rip+0x18d6]        # 48a8 <__PRETTY_FUNCTION__.0+0x38>
    2fd2:	mulsd  xmm1,xmm0
    2fd6:	movzx  eax,BYTE PTR [rbp-0x32]
    2fda:	pxor   xmm0,xmm0
    2fde:	cvtsi2sd xmm0,eax
    2fe2:	addsd  xmm0,xmm1
    2fe6:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    2feb:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    2ff0:	mov    rax,QWORD PTR [rbp-0x8]
    2ff4:	cmp    QWORD PTR [rbp-0x30],rax
    2ff8:	jb     2fab <json_object_to_f64+0x9a>
    2ffa:	jmp    2ffd <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    2ffc:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    2ffd:	mov    rax,QWORD PTR [rbp-0x8]
    3001:	cmp    QWORD PTR [rbp-0x30],rax
    3005:	jae    3092 <json_object_to_f64+0x181>
    300b:	mov    rdx,QWORD PTR [rbp-0x10]
    300f:	mov    rax,QWORD PTR [rbp-0x30]
    3013:	add    rax,rdx
    3016:	movzx  eax,BYTE PTR [rax]
    3019:	cmp    al,0x2e
    301b:	jne    3092 <json_object_to_f64+0x181>
  {
    at += 1;
    301d:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    3022:	movsd  xmm0,QWORD PTR [rip+0x1886]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    302a:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    302f:	jmp    3085 <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3031:	mov    rdx,QWORD PTR [rbp-0x10]
    3035:	mov    rax,QWORD PTR [rbp-0x30]
    3039:	add    rax,rdx
    303c:	movzx  eax,BYTE PTR [rax]
    303f:	sub    eax,0x30
    3042:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    3045:	cmp    BYTE PTR [rbp-0x31],0x9
    3049:	ja     3091 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    304b:	movzx  eax,BYTE PTR [rbp-0x31]
    304f:	pxor   xmm0,xmm0
    3053:	cvtsi2sd xmm0,eax
    3057:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    305c:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3061:	addsd  xmm0,xmm1
    3065:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    306a:	movsd  xmm1,QWORD PTR [rbp-0x18]
    306f:	movsd  xmm0,QWORD PTR [rip+0x1839]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    3077:	mulsd  xmm0,xmm1
    307b:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3080:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    3085:	mov    rax,QWORD PTR [rbp-0x8]
    3089:	cmp    QWORD PTR [rbp-0x30],rax
    308d:	jb     3031 <json_object_to_f64+0x120>
    308f:	jmp    3092 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    3091:	nop
      }
    }
  }

  return sign * result;
    3092:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3097:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    309c:	leave
    309d:	ret

000000000000309e <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    309e:	push   rbp
    309f:	mov    rbp,rsp
    30a2:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    30a7:	movsd  xmm0,QWORD PTR [rbp-0x8]
    30ac:	movsd  xmm1,QWORD PTR [rip+0x1804]        # 48b8 <__PRETTY_FUNCTION__.0+0x48>
    30b4:	divsd  xmm0,xmm1
}
    30b8:	pop    rbp
    30b9:	ret

00000000000030ba <square>:

static
f64 square(f64 x)
{
    30ba:	push   rbp
    30bb:	mov    rbp,rsp
    30be:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    30c3:	movsd  xmm0,QWORD PTR [rbp-0x8]
    30c8:	mulsd  xmm0,xmm0
}
    30cc:	pop    rbp
    30cd:	ret

00000000000030ce <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    30ce:	push   rbp
    30cf:	mov    rbp,rsp
    30d2:	sub    rsp,0x90
    30d9:	movsd  QWORD PTR [rbp-0x58],xmm0
    30de:	movsd  QWORD PTR [rbp-0x60],xmm1
    30e3:	movsd  QWORD PTR [rbp-0x68],xmm2
    30e8:	movsd  QWORD PTR [rbp-0x70],xmm3
    30ed:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    30f2:	movsd  xmm0,QWORD PTR [rbp-0x60]
    30f7:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    30fc:	movsd  xmm0,QWORD PTR [rbp-0x70]
    3101:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    3106:	movsd  xmm0,QWORD PTR [rbp-0x58]
    310b:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    3110:	movsd  xmm0,QWORD PTR [rbp-0x68]
    3115:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    311a:	movsd  xmm0,QWORD PTR [rbp-0x40]
    311f:	subsd  xmm0,QWORD PTR [rbp-0x48]
    3124:	movq   rax,xmm0
    3129:	movq   xmm0,rax
    312e:	call   309e <to_radians>
    3133:	movq   rax,xmm0
    3138:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    313c:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3141:	subsd  xmm0,QWORD PTR [rbp-0x38]
    3146:	movq   rax,xmm0
    314b:	movq   xmm0,rax
    3150:	call   309e <to_radians>
    3155:	movq   rax,xmm0
    315a:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    315e:	mov    rax,QWORD PTR [rbp-0x48]
    3162:	movq   xmm0,rax
    3167:	call   309e <to_radians>
    316c:	movq   rax,xmm0
    3171:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    3175:	mov    rax,QWORD PTR [rbp-0x40]
    3179:	movq   xmm0,rax
    317e:	call   309e <to_radians>
    3183:	movq   rax,xmm0
    3188:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    318c:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3191:	movsd  xmm1,QWORD PTR [rip+0x1727]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    3199:	divsd  xmm0,xmm1
    319d:	movq   rax,xmm0
    31a2:	movq   xmm0,rax
    31a7:	call   1130 <sin@plt>
    31ac:	movq   rax,xmm0
    31b1:	movq   xmm0,rax
    31b6:	call   30ba <square>
    31bb:	movsd  QWORD PTR [rbp-0x80],xmm0
    31c0:	mov    rax,QWORD PTR [rbp-0x48]
    31c4:	movq   xmm0,rax
    31c9:	call   10b0 <cos@plt>
    31ce:	movsd  QWORD PTR [rbp-0x88],xmm0
    31d6:	mov    rax,QWORD PTR [rbp-0x40]
    31da:	movq   xmm0,rax
    31df:	call   10b0 <cos@plt>
    31e4:	movapd xmm5,xmm0
    31e8:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    31f0:	movsd  QWORD PTR [rbp-0x88],xmm5
    31f8:	movsd  xmm0,QWORD PTR [rbp-0x20]
    31fd:	movsd  xmm1,QWORD PTR [rip+0x16bb]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    3205:	movapd xmm6,xmm0
    3209:	divsd  xmm6,xmm1
    320d:	movq   rax,xmm6
    3212:	movq   xmm0,rax
    3217:	call   1130 <sin@plt>
    321c:	movq   rax,xmm0
    3221:	movq   xmm0,rax
    3226:	call   30ba <square>
    322b:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    3233:	addsd  xmm0,QWORD PTR [rbp-0x80]
    3238:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    323d:	mov    rax,QWORD PTR [rbp-0x18]
    3241:	movq   xmm0,rax
    3246:	call   1160 <sqrt@plt>
    324b:	movq   rax,xmm0
    3250:	movq   xmm0,rax
    3255:	call   1140 <asin@plt>
    325a:	addsd  xmm0,xmm0
    325e:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    3263:	movsd  xmm0,QWORD PTR [rbp-0x78]
    3268:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    326d:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3272:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    3277:	leave
    3278:	ret

0000000000003279 <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    3279:	push   rbp
    327a:	mov    rbp,rsp
    327d:	movsd  QWORD PTR [rbp-0x18],xmm0
    3282:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    3287:	movsd  xmm0,QWORD PTR [rip+0x1639]        # 48c8 <__PRETTY_FUNCTION__.0+0x58>
    328f:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    3294:	movsd  xmm0,QWORD PTR [rbp-0x18]
    3299:	movq   xmm1,QWORD PTR [rip+0x162f]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    32a1:	andpd  xmm0,xmm1
    32a5:	movsd  xmm1,QWORD PTR [rbp-0x20]
    32aa:	movq   xmm2,QWORD PTR [rip+0x161e]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    32b2:	andpd  xmm2,xmm1
    32b6:	movapd xmm1,xmm0
    32ba:	subsd  xmm1,xmm2
    32be:	movsd  xmm0,QWORD PTR [rbp-0x8]
    32c3:	comisd xmm0,xmm1
    32c7:	setae  al
    32ca:	movzx  eax,al
}
    32cd:	pop    rbp
    32ce:	ret

00000000000032cf <main>:

int main(int args_count, char **args)
{
    32cf:	push   rbp
    32d0:	mov    rbp,rsp
    32d3:	push   r15
    32d5:	push   r14
    32d7:	push   r13
    32d9:	push   r12
    32db:	push   rbx
    32dc:	sub    rsp,0x2d8
    32e3:	mov    DWORD PTR [rbp-0x244],edi
    32e9:	mov    QWORD PTR [rbp-0x250],rsi
    32f0:	mov    rax,QWORD PTR fs:0x28
    32f9:	mov    QWORD PTR [rbp-0x38],rax
    32fd:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    32ff:	cmp    DWORD PTR [rbp-0x244],0x3
    3306:	je     3333 <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    3308:	mov    rax,QWORD PTR [rbp-0x250]
    330f:	mov    rax,QWORD PTR [rax]
    3312:	lea    rdx,[rip+0x12ff]        # 4618 <_IO_stdin_used+0x618>
    3319:	mov    rsi,rax
    331c:	mov    rdi,rdx
    331f:	mov    eax,0x0
    3324:	call   1070 <printf@plt>
    return 1;
    3329:	mov    eax,0x1
    332e:	jmp    3de7 <main+0xb18>
  }

  begin_profiling();
    3333:	call   1b3d <begin_profiling>

  Arena arena = {0};
    3338:	pxor   xmm0,xmm0
    333c:	movaps XMMWORD PTR [rbp-0x190],xmm0
    3343:	movaps XMMWORD PTR [rbp-0x180],xmm0
  arena = arena_make(GB(4));
    334a:	lea    rdx,[rbp-0x270]
    3351:	movabs rax,0x100000000
    335b:	mov    rsi,rax
    335e:	mov    rdi,rdx
    3361:	call   1632 <arena_make>
    3366:	mov    rax,QWORD PTR [rbp-0x270]
    336d:	mov    rdx,QWORD PTR [rbp-0x268]
    3374:	mov    QWORD PTR [rbp-0x190],rax
    337b:	mov    QWORD PTR [rbp-0x188],rdx
    3382:	mov    rax,QWORD PTR [rbp-0x260]
    3389:	mov    rdx,QWORD PTR [rbp-0x258]
    3390:	mov    QWORD PTR [rbp-0x180],rax
    3397:	mov    QWORD PTR [rbp-0x178],rdx

  String source = {0};
    339e:	mov    QWORD PTR [rbp-0x1a0],0x0
    33a9:	mov    QWORD PTR [rbp-0x198],0x0
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    33b4:	mov    rax,QWORD PTR [rbp-0x250]
    33bb:	add    rax,0x8
    33bf:	mov    rax,QWORD PTR [rax]
    33c2:	mov    rdi,rax
    33c5:	call   1303 <file_size>
    33ca:	mov    rcx,rax
    33cd:	lea    r12,[rip+0x1270]        # 4644 <_IO_stdin_used+0x644>
    33d4:	mov    r13d,0x4
    33da:	lea    rdi,[rbp-0x170]
    33e1:	mov    rdx,r12
    33e4:	mov    rax,r13
    33e7:	mov    r8,rcx
    33ea:	mov    ecx,0x5
    33ef:	mov    rsi,rdx
    33f2:	mov    rdx,rax
    33f5:	call   1e73 <__profile_begin_pass>
    33fa:	mov    QWORD PTR [rbp-0x230],0x0
    3405:	jmp    34a0 <main+0x1d1>
  {
    source = read_file_to_arena(&arena, args[1]);
    340a:	mov    rax,QWORD PTR [rbp-0x250]
    3411:	add    rax,0x8
    3415:	mov    rdx,QWORD PTR [rax]
    3418:	lea    rax,[rbp-0x190]
    341f:	mov    rsi,rdx
    3422:	mov    rdi,rax
    3425:	call   1357 <read_file_to_arena>
    342a:	mov    QWORD PTR [rbp-0x1a0],rax
    3431:	mov    QWORD PTR [rbp-0x198],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    3438:	add    QWORD PTR [rbp-0x230],0x1
    3440:	sub    rsp,0x8
    3444:	sub    rsp,0x38
    3448:	mov    rcx,rsp
    344b:	mov    rax,QWORD PTR [rbp-0x170]
    3452:	mov    rdx,QWORD PTR [rbp-0x168]
    3459:	mov    QWORD PTR [rcx],rax
    345c:	mov    QWORD PTR [rcx+0x8],rdx
    3460:	mov    rax,QWORD PTR [rbp-0x160]
    3467:	mov    rdx,QWORD PTR [rbp-0x158]
    346e:	mov    QWORD PTR [rcx+0x10],rax
    3472:	mov    QWORD PTR [rcx+0x18],rdx
    3476:	mov    rax,QWORD PTR [rbp-0x150]
    347d:	mov    rdx,QWORD PTR [rbp-0x148]
    3484:	mov    QWORD PTR [rcx+0x20],rax
    3488:	mov    QWORD PTR [rcx+0x28],rdx
    348c:	mov    rax,QWORD PTR [rbp-0x140]
    3493:	mov    QWORD PTR [rcx+0x30],rax
    3497:	call   1f5d <__profile_end_pass>
    349c:	add    rsp,0x40
    34a0:	cmp    QWORD PTR [rbp-0x230],0x0
    34a8:	je     340a <main+0x13b>
  }

  Haversine_Pair *pairs = NULL;
    34ae:	mov    QWORD PTR [rbp-0x228],0x0
  i32 pair_count = 0;
    34b9:	mov    DWORD PTR [rbp-0x238],0x0
  usize max_pairs = 0;
    34c3:	mov    QWORD PTR [rbp-0x220],0x0
  PROFILE_SCOPE("haversine alloc")
    34ce:	lea    r14,[rip+0x1174]        # 4649 <_IO_stdin_used+0x649>
    34d5:	mov    r15d,0xf
    34db:	lea    rdi,[rbp-0x130]
    34e2:	mov    rdx,r14
    34e5:	mov    rax,r15
    34e8:	mov    r8d,0x0
    34ee:	mov    ecx,0x6
    34f3:	mov    rsi,rdx
    34f6:	mov    rdx,rax
    34f9:	call   1e73 <__profile_begin_pass>
    34fe:	mov    QWORD PTR [rbp-0x218],0x0
    3509:	jmp    35d1 <main+0x302>
  {
    usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    350e:	mov    QWORD PTR [rbp-0x1a8],0x18
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    3519:	mov    rax,QWORD PTR [rbp-0x198]
    3520:	mov    edx,0x0
    3525:	div    QWORD PTR [rbp-0x1a8]
    352c:	mov    QWORD PTR [rbp-0x220],rax

    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    3533:	mov    rax,QWORD PTR [rbp-0x220]
    353a:	shl    rax,0x5
    353e:	mov    rcx,rax
    3541:	lea    rax,[rbp-0x190]
    3548:	mov    edx,0x8
    354d:	mov    rsi,rcx
    3550:	mov    rdi,rax
    3553:	call   17d3 <arena_alloc>
    3558:	mov    QWORD PTR [rbp-0x228],rax
    pair_count = 0;
    355f:	mov    DWORD PTR [rbp-0x238],0x0
  PROFILE_SCOPE("haversine alloc")
    3569:	add    QWORD PTR [rbp-0x218],0x1
    3571:	sub    rsp,0x8
    3575:	sub    rsp,0x38
    3579:	mov    rcx,rsp
    357c:	mov    rax,QWORD PTR [rbp-0x130]
    3583:	mov    rdx,QWORD PTR [rbp-0x128]
    358a:	mov    QWORD PTR [rcx],rax
    358d:	mov    QWORD PTR [rcx+0x8],rdx
    3591:	mov    rax,QWORD PTR [rbp-0x120]
    3598:	mov    rdx,QWORD PTR [rbp-0x118]
    359f:	mov    QWORD PTR [rcx+0x10],rax
    35a3:	mov    QWORD PTR [rcx+0x18],rdx
    35a7:	mov    rax,QWORD PTR [rbp-0x110]
    35ae:	mov    rdx,QWORD PTR [rbp-0x108]
    35b5:	mov    QWORD PTR [rcx+0x20],rax
    35b9:	mov    QWORD PTR [rcx+0x28],rdx
    35bd:	mov    rax,QWORD PTR [rbp-0x100]
    35c4:	mov    QWORD PTR [rcx+0x30],rax
    35c8:	call   1f5d <__profile_end_pass>
    35cd:	add    rsp,0x40
    35d1:	cmp    QWORD PTR [rbp-0x218],0x0
    35d9:	je     350e <main+0x23f>
  }

  JSON_Object *root = NULL;
    35df:	mov    QWORD PTR [rbp-0x1d8],0x0
  root = parse_json(&arena, source);
    35ea:	mov    rcx,QWORD PTR [rbp-0x1a0]
    35f1:	mov    rdx,QWORD PTR [rbp-0x198]
    35f8:	lea    rax,[rbp-0x190]
    35ff:	mov    rsi,rcx
    3602:	mov    rdi,rax
    3605:	call   2c8b <parse_json>
    360a:	mov    QWORD PTR [rbp-0x1d8],rax

  f64 haversine_sum = 0.0;
    3611:	pxor   xmm0,xmm0
    3615:	movsd  QWORD PTR [rbp-0x1d0],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    361d:	lea    rax,[rip+0x1035]        # 4659 <_IO_stdin_used+0x659>
    3624:	mov    QWORD PTR [rbp-0x280],rax
    362b:	mov    QWORD PTR [rbp-0x278],0x5
    3636:	mov    rax,QWORD PTR [rbp-0x280]
    363d:	mov    rdx,QWORD PTR [rbp-0x278]
    3644:	mov    rcx,rax
    3647:	mov    rax,QWORD PTR [rbp-0x1d8]
    364e:	mov    rsi,rcx
    3651:	mov    rdi,rax
    3654:	call   2dee <lookup_json_object>
    3659:	mov    QWORD PTR [rbp-0x1c8],rax
  if (pairs)
    3660:	cmp    QWORD PTR [rbp-0x228],0x0
    3668:	je     38fd <main+0x62e>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    366e:	mov    rax,QWORD PTR [rbp-0x1c8]
    3675:	mov    rax,QWORD PTR [rax+0x20]
    3679:	mov    QWORD PTR [rbp-0x210],rax
    3680:	jmp    38de <main+0x60f>
    {
      PROFILE_SCOPE("child convert")
    3685:	lea    rax,[rip+0xfd3]        # 465f <_IO_stdin_used+0x65f>
    368c:	mov    QWORD PTR [rbp-0x2c0],rax
    3693:	mov    QWORD PTR [rbp-0x2b8],0xd
    369e:	lea    rdi,[rbp-0x70]
    36a2:	mov    rbx,QWORD PTR [rbp-0x2c0]
    36a9:	mov    rsi,QWORD PTR [rbp-0x2b8]
    36b0:	mov    rdx,rbx
    36b3:	mov    rax,rsi
    36b6:	mov    r8d,0x0
    36bc:	mov    ecx,0x7
    36c1:	mov    rsi,rdx
    36c4:	mov    rdx,rax
    36c7:	call   1e73 <__profile_begin_pass>
    36cc:	mov    QWORD PTR [rbp-0x208],0x0
    36d7:	jmp    38be <main+0x5ef>
      {
        Haversine_Pair pair =
        {
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    36dc:	lea    rax,[rip+0xf8a]        # 466d <_IO_stdin_used+0x66d>
    36e3:	mov    QWORD PTR [rbp-0x2d0],rax
    36ea:	mov    QWORD PTR [rbp-0x2c8],0x2
    36f5:	mov    rbx,QWORD PTR [rbp-0x2d0]
    36fc:	mov    rsi,QWORD PTR [rbp-0x2c8]
    3703:	mov    rax,rbx
    3706:	mov    rdx,rsi
    3709:	mov    rcx,QWORD PTR [rbp-0x210]
    3710:	mov    rsi,rax
    3713:	mov    rdi,rcx
    3716:	call   2dee <lookup_json_object>
    371b:	mov    rdi,rax
    371e:	call   2f11 <json_object_to_f64>
    3723:	movq   rax,xmm0
        Haversine_Pair pair =
    3728:	mov    QWORD PTR [rbp-0xb0],rax
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    372f:	lea    rax,[rip+0xf3a]        # 4670 <_IO_stdin_used+0x670>
    3736:	mov    QWORD PTR [rbp-0x2e0],rax
    373d:	mov    QWORD PTR [rbp-0x2d8],0x2
    3748:	mov    rax,QWORD PTR [rbp-0x2e0]
    374f:	mov    rdx,QWORD PTR [rbp-0x2d8]
    3756:	mov    rcx,rax
    3759:	mov    rax,QWORD PTR [rbp-0x210]
    3760:	mov    rsi,rcx
    3763:	mov    rdi,rax
    3766:	call   2dee <lookup_json_object>
    376b:	mov    rdi,rax
    376e:	call   2f11 <json_object_to_f64>
    3773:	movq   rax,xmm0
        Haversine_Pair pair =
    3778:	mov    QWORD PTR [rbp-0xa8],rax
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    377f:	lea    rax,[rip+0xeed]        # 4673 <_IO_stdin_used+0x673>
    3786:	mov    QWORD PTR [rbp-0x2f0],rax
    378d:	mov    QWORD PTR [rbp-0x2e8],0x2
    3798:	mov    rax,QWORD PTR [rbp-0x2f0]
    379f:	mov    rdx,QWORD PTR [rbp-0x2e8]
    37a6:	mov    rcx,rax
    37a9:	mov    rax,QWORD PTR [rbp-0x210]
    37b0:	mov    rsi,rcx
    37b3:	mov    rdi,rax
    37b6:	call   2dee <lookup_json_object>
    37bb:	mov    rdi,rax
    37be:	call   2f11 <json_object_to_f64>
    37c3:	movq   rax,xmm0
        Haversine_Pair pair =
    37c8:	mov    QWORD PTR [rbp-0xa0],rax
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    37cf:	lea    rax,[rip+0xea0]        # 4676 <_IO_stdin_used+0x676>
    37d6:	mov    QWORD PTR [rbp-0x300],rax
    37dd:	mov    QWORD PTR [rbp-0x2f8],0x2
    37e8:	mov    rax,QWORD PTR [rbp-0x300]
    37ef:	mov    rdx,QWORD PTR [rbp-0x2f8]
    37f6:	mov    rcx,rax
    37f9:	mov    rax,QWORD PTR [rbp-0x210]
    3800:	mov    rsi,rcx
    3803:	mov    rdi,rax
    3806:	call   2dee <lookup_json_object>
    380b:	mov    rdi,rax
    380e:	call   2f11 <json_object_to_f64>
    3813:	movq   rax,xmm0
        Haversine_Pair pair =
    3818:	mov    QWORD PTR [rbp-0x98],rax
        };

        pairs[pair_count] = pair;
    381f:	mov    eax,DWORD PTR [rbp-0x238]
    3825:	cdqe
    3827:	shl    rax,0x5
    382b:	mov    rdx,rax
    382e:	mov    rax,QWORD PTR [rbp-0x228]
    3835:	lea    rcx,[rdx+rax*1]
    3839:	mov    rax,QWORD PTR [rbp-0xb0]
    3840:	mov    rdx,QWORD PTR [rbp-0xa8]
    3847:	mov    QWORD PTR [rcx],rax
    384a:	mov    QWORD PTR [rcx+0x8],rdx
    384e:	mov    rax,QWORD PTR [rbp-0xa0]
    3855:	mov    rdx,QWORD PTR [rbp-0x98]
    385c:	mov    QWORD PTR [rcx+0x10],rax
    3860:	mov    QWORD PTR [rcx+0x18],rdx
        pair_count += 1;
    3864:	add    DWORD PTR [rbp-0x238],0x1
      PROFILE_SCOPE("child convert")
    386b:	add    QWORD PTR [rbp-0x208],0x1
    3873:	sub    rsp,0x8
    3877:	sub    rsp,0x38
    387b:	mov    rcx,rsp
    387e:	mov    rax,QWORD PTR [rbp-0x70]
    3882:	mov    rdx,QWORD PTR [rbp-0x68]
    3886:	mov    QWORD PTR [rcx],rax
    3889:	mov    QWORD PTR [rcx+0x8],rdx
    388d:	mov    rax,QWORD PTR [rbp-0x60]
    3891:	mov    rdx,QWORD PTR [rbp-0x58]
    3895:	mov    QWORD PTR [rcx+0x10],rax
    3899:	mov    QWORD PTR [rcx+0x18],rdx
    389d:	mov    rax,QWORD PTR [rbp-0x50]
    38a1:	mov    rdx,QWORD PTR [rbp-0x48]
    38a5:	mov    QWORD PTR [rcx+0x20],rax
    38a9:	mov    QWORD PTR [rcx+0x28],rdx
    38ad:	mov    rax,QWORD PTR [rbp-0x40]
    38b1:	mov    QWORD PTR [rcx+0x30],rax
    38b5:	call   1f5d <__profile_end_pass>
    38ba:	add    rsp,0x40
    38be:	cmp    QWORD PTR [rbp-0x208],0x0
    38c6:	je     36dc <main+0x40d>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    38cc:	mov    rax,QWORD PTR [rbp-0x210]
    38d3:	mov    rax,QWORD PTR [rax+0x28]
    38d7:	mov    QWORD PTR [rbp-0x210],rax
    38de:	cmp    QWORD PTR [rbp-0x210],0x0
    38e6:	je     38fd <main+0x62e>
    38e8:	mov    eax,DWORD PTR [rbp-0x238]
    38ee:	cdqe
    38f0:	cmp    rax,QWORD PTR [rbp-0x220]
    38f7:	jb     3685 <main+0x3b6>
      }
    }
  }

  f64 sum = 0.0;
    38fd:	pxor   xmm0,xmm0
    3901:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3909:	lea    rax,[rip+0xd69]        # 4679 <_IO_stdin_used+0x679>
    3910:	mov    QWORD PTR [rbp-0x290],rax
    3917:	mov    QWORD PTR [rbp-0x288],0x3
    3922:	lea    rax,[rbp-0xf0]
    3929:	mov    rcx,QWORD PTR [rbp-0x290]
    3930:	mov    rbx,QWORD PTR [rbp-0x288]
    3937:	mov    rsi,rcx
    393a:	mov    rdx,rbx
    393d:	mov    r8d,0x0
    3943:	mov    ecx,0x8
    3948:	mov    rdi,rax
    394b:	call   1e73 <__profile_begin_pass>
    3950:	mov    QWORD PTR [rbp-0x1f8],0x0
    395b:	jmp    3add <main+0x80e>
  {
    for (usize i = 0; i < pair_count; i++)
    3960:	mov    QWORD PTR [rbp-0x1f0],0x0
    396b:	jmp    3a40 <main+0x771>
    {
      f64 earth_radius = 6372.8;
    3970:	movsd  xmm0,QWORD PTR [rip+0xf68]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    3978:	movsd  QWORD PTR [rbp-0x1b8],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    3980:	mov    rax,QWORD PTR [rbp-0x1f0]
    3987:	shl    rax,0x5
    398b:	mov    rdx,rax
    398e:	mov    rax,QWORD PTR [rbp-0x228]
    3995:	add    rax,rdx
    3998:	movsd  xmm2,QWORD PTR [rax+0x18]
    399d:	mov    rax,QWORD PTR [rbp-0x1f0]
    39a4:	shl    rax,0x5
    39a8:	mov    rdx,rax
    39ab:	mov    rax,QWORD PTR [rbp-0x228]
    39b2:	add    rax,rdx
    39b5:	movsd  xmm1,QWORD PTR [rax+0x10]
    39ba:	mov    rax,QWORD PTR [rbp-0x1f0]
    39c1:	shl    rax,0x5
    39c5:	mov    rdx,rax
    39c8:	mov    rax,QWORD PTR [rbp-0x228]
    39cf:	add    rax,rdx
    39d2:	movsd  xmm0,QWORD PTR [rax+0x8]
    39d7:	mov    rax,QWORD PTR [rbp-0x1f0]
    39de:	shl    rax,0x5
    39e2:	mov    rdx,rax
    39e5:	mov    rax,QWORD PTR [rbp-0x228]
    39ec:	add    rax,rdx
    39ef:	mov    rax,QWORD PTR [rax]
    39f2:	movsd  xmm3,QWORD PTR [rbp-0x1b8]
    39fa:	movapd xmm4,xmm3
    39fe:	movapd xmm3,xmm2
    3a02:	movapd xmm2,xmm1
    3a06:	movapd xmm1,xmm0
    3a0a:	movq   xmm0,rax
    3a0f:	call   30ce <reference_haversine>
    3a14:	movq   rax,xmm0
    3a19:	mov    QWORD PTR [rbp-0x1b0],rax
      sum += result;
    3a20:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3a28:	addsd  xmm0,QWORD PTR [rbp-0x1b0]
    3a30:	movsd  QWORD PTR [rbp-0x200],xmm0
    for (usize i = 0; i < pair_count; i++)
    3a38:	add    QWORD PTR [rbp-0x1f0],0x1
    3a40:	mov    eax,DWORD PTR [rbp-0x238]
    3a46:	cdqe
    3a48:	cmp    QWORD PTR [rbp-0x1f0],rax
    3a4f:	jb     3970 <main+0x6a1>
    }
    sum /= pair_count;
    3a55:	pxor   xmm1,xmm1
    3a59:	cvtsi2sd xmm1,DWORD PTR [rbp-0x238]
    3a61:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3a69:	divsd  xmm0,xmm1
    3a6d:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3a75:	add    QWORD PTR [rbp-0x1f8],0x1
    3a7d:	sub    rsp,0x8
    3a81:	sub    rsp,0x38
    3a85:	mov    rax,rsp
    3a88:	mov    rcx,QWORD PTR [rbp-0xf0]
    3a8f:	mov    rbx,QWORD PTR [rbp-0xe8]
    3a96:	mov    QWORD PTR [rax],rcx
    3a99:	mov    QWORD PTR [rax+0x8],rbx
    3a9d:	mov    rcx,QWORD PTR [rbp-0xe0]
    3aa4:	mov    rbx,QWORD PTR [rbp-0xd8]
    3aab:	mov    QWORD PTR [rax+0x10],rcx
    3aaf:	mov    QWORD PTR [rax+0x18],rbx
    3ab3:	mov    rcx,QWORD PTR [rbp-0xd0]
    3aba:	mov    rbx,QWORD PTR [rbp-0xc8]
    3ac1:	mov    QWORD PTR [rax+0x20],rcx
    3ac5:	mov    QWORD PTR [rax+0x28],rbx
    3ac9:	mov    rdx,QWORD PTR [rbp-0xc0]
    3ad0:	mov    QWORD PTR [rax+0x30],rdx
    3ad4:	call   1f5d <__profile_end_pass>
    3ad9:	add    rsp,0x40
    3add:	cmp    QWORD PTR [rbp-0x1f8],0x0
    3ae5:	je     3960 <main+0x691>
  }

  PROFILE_SCOPE("check")
    3aeb:	lea    rax,[rip+0xb8b]        # 467d <_IO_stdin_used+0x67d>
    3af2:	mov    QWORD PTR [rbp-0x2a0],rax
    3af9:	mov    QWORD PTR [rbp-0x298],0x5
    3b04:	lea    rax,[rbp-0xb0]
    3b0b:	mov    rcx,QWORD PTR [rbp-0x2a0]
    3b12:	mov    rbx,QWORD PTR [rbp-0x298]
    3b19:	mov    rsi,rcx
    3b1c:	mov    rdx,rbx
    3b1f:	mov    r8d,0x0
    3b25:	mov    ecx,0x9
    3b2a:	mov    rdi,rax
    3b2d:	call   1e73 <__profile_begin_pass>
    3b32:	mov    QWORD PTR [rbp-0x1e8],0x0
    3b3d:	jmp    3d12 <main+0xa43>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3b42:	mov    rax,QWORD PTR [rbp-0x250]
    3b49:	add    rax,0x10
    3b4d:	mov    rdx,QWORD PTR [rax]
    3b50:	lea    rax,[rbp-0x190]
    3b57:	mov    rsi,rdx
    3b5a:	mov    rdi,rax
    3b5d:	call   1357 <read_file_to_arena>
    3b62:	mov    QWORD PTR [rbp-0x70],rax
    3b66:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3b6a:	mov    rax,QWORD PTR [rbp-0x68]
    3b6e:	cmp    rax,0xb
    3b72:	jbe    3c85 <main+0x9b6>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3b78:	mov    rax,QWORD PTR [rbp-0x70]
    3b7c:	movsd  xmm0,QWORD PTR [rax]
    3b80:	movsd  QWORD PTR [rbp-0x1c0],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3b88:	mov    rax,QWORD PTR [rbp-0x70]
    3b8c:	mov    eax,DWORD PTR [rax+0x8]
    3b8f:	mov    DWORD PTR [rbp-0x234],eax

      if (solution_pairs == pair_count)
    3b95:	mov    eax,DWORD PTR [rbp-0x234]
    3b9b:	cmp    eax,DWORD PTR [rbp-0x238]
    3ba1:	jne    3c49 <main+0x97a>
      {
        if (epsilon_equal(solution_sum, sum))
    3ba7:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3baf:	mov    rax,QWORD PTR [rbp-0x1c0]
    3bb6:	movapd xmm1,xmm0
    3bba:	movq   xmm0,rax
    3bbf:	call   3279 <epsilon_equal>
    3bc4:	test   eax,eax
    3bc6:	je     3c0a <main+0x93b>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3bc8:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3bd0:	mov    rax,QWORD PTR [rbp-0x1c0]
    3bd7:	lea    rdx,[rip+0xaaa]        # 4688 <_IO_stdin_used+0x688>
    3bde:	lea    rsi,[rip+0xad6]        # 46bb <_IO_stdin_used+0x6bb>
    3be5:	movapd xmm1,xmm0
    3be9:	movq   xmm0,rax
    3bee:	mov    rcx,rdx
    3bf1:	mov    edx,0x64
    3bf6:	mov    edi,0x3
    3bfb:	mov    eax,0x2
    3c00:	call   14a1 <log_message>
    3c05:	jmp    3cad <main+0x9de>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3c0a:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3c12:	mov    rax,QWORD PTR [rbp-0x1c0]
    3c19:	lea    rdx,[rip+0xab0]        # 46d0 <_IO_stdin_used+0x6d0>
    3c20:	lea    rsi,[rip+0xa94]        # 46bb <_IO_stdin_used+0x6bb>
    3c27:	movapd xmm1,xmm0
    3c2b:	movq   xmm0,rax
    3c30:	mov    rcx,rdx
    3c33:	mov    edx,0x68
    3c38:	mov    edi,0x1
    3c3d:	mov    eax,0x2
    3c42:	call   14a1 <log_message>
    3c47:	jmp    3cad <main+0x9de>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3c49:	mov    esi,DWORD PTR [rbp-0x238]
    3c4f:	mov    ecx,DWORD PTR [rbp-0x234]
    3c55:	lea    rdx,[rip+0xaac]        # 4708 <_IO_stdin_used+0x708>
    3c5c:	lea    rax,[rip+0xa58]        # 46bb <_IO_stdin_used+0x6bb>
    3c63:	mov    r9d,esi
    3c66:	mov    r8d,ecx
    3c69:	mov    rcx,rdx
    3c6c:	mov    edx,0x6d
    3c71:	mov    rsi,rax
    3c74:	mov    edi,0x1
    3c79:	mov    eax,0x0
    3c7e:	call   14a1 <log_message>
    3c83:	jmp    3cad <main+0x9de>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3c85:	lea    rdx,[rip+0xac4]        # 4750 <_IO_stdin_used+0x750>
    3c8c:	lea    rax,[rip+0xa28]        # 46bb <_IO_stdin_used+0x6bb>
    3c93:	mov    rcx,rdx
    3c96:	mov    edx,0x72
    3c9b:	mov    rsi,rax
    3c9e:	mov    edi,0x1
    3ca3:	mov    eax,0x0
    3ca8:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3cad:	add    QWORD PTR [rbp-0x1e8],0x1
    3cb5:	sub    rsp,0x8
    3cb9:	sub    rsp,0x38
    3cbd:	mov    rax,rsp
    3cc0:	mov    rcx,QWORD PTR [rbp-0xb0]
    3cc7:	mov    rbx,QWORD PTR [rbp-0xa8]
    3cce:	mov    QWORD PTR [rax],rcx
    3cd1:	mov    QWORD PTR [rax+0x8],rbx
    3cd5:	mov    rcx,QWORD PTR [rbp-0xa0]
    3cdc:	mov    rbx,QWORD PTR [rbp-0x98]
    3ce3:	mov    QWORD PTR [rax+0x10],rcx
    3ce7:	mov    QWORD PTR [rax+0x18],rbx
    3ceb:	mov    rcx,QWORD PTR [rbp-0x90]
    3cf2:	mov    rbx,QWORD PTR [rbp-0x88]
    3cf9:	mov    QWORD PTR [rax+0x20],rcx
    3cfd:	mov    QWORD PTR [rax+0x28],rbx
    3d01:	mov    rdx,QWORD PTR [rbp-0x80]
    3d05:	mov    QWORD PTR [rax+0x30],rdx
    3d09:	call   1f5d <__profile_end_pass>
    3d0e:	add    rsp,0x40
    3d12:	cmp    QWORD PTR [rbp-0x1e8],0x0
    3d1a:	je     3b42 <main+0x873>
    }
  }

  PROFILE_SCOPE("free")
    3d20:	lea    rax,[rip+0xa64]        # 478b <_IO_stdin_used+0x78b>
    3d27:	mov    QWORD PTR [rbp-0x2b0],rax
    3d2e:	mov    QWORD PTR [rbp-0x2a8],0x4
    3d39:	lea    rax,[rbp-0x70]
    3d3d:	mov    rcx,QWORD PTR [rbp-0x2b0]
    3d44:	mov    rbx,QWORD PTR [rbp-0x2a8]
    3d4b:	mov    rsi,rcx
    3d4e:	mov    rdx,rbx
    3d51:	mov    r8d,0x0
    3d57:	mov    ecx,0xa
    3d5c:	mov    rdi,rax
    3d5f:	call   1e73 <__profile_begin_pass>
    3d64:	mov    QWORD PTR [rbp-0x1e0],0x0
    3d6f:	jmp    3dd3 <main+0xb04>
  {
    arena_free(&arena);
    3d71:	lea    rax,[rbp-0x190]
    3d78:	mov    rdi,rax
    3d7b:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3d80:	add    QWORD PTR [rbp-0x1e0],0x1
    3d88:	sub    rsp,0x8
    3d8c:	sub    rsp,0x38
    3d90:	mov    rax,rsp
    3d93:	mov    rcx,QWORD PTR [rbp-0x70]
    3d97:	mov    rbx,QWORD PTR [rbp-0x68]
    3d9b:	mov    QWORD PTR [rax],rcx
    3d9e:	mov    QWORD PTR [rax+0x8],rbx
    3da2:	mov    rcx,QWORD PTR [rbp-0x60]
    3da6:	mov    rbx,QWORD PTR [rbp-0x58]
    3daa:	mov    QWORD PTR [rax+0x10],rcx
    3dae:	mov    QWORD PTR [rax+0x18],rbx
    3db2:	mov    rcx,QWORD PTR [rbp-0x50]
    3db6:	mov    rbx,QWORD PTR [rbp-0x48]
    3dba:	mov    QWORD PTR [rax+0x20],rcx
    3dbe:	mov    QWORD PTR [rax+0x28],rbx
    3dc2:	mov    rdx,QWORD PTR [rbp-0x40]
    3dc6:	mov    QWORD PTR [rax+0x30],rdx
    3dca:	call   1f5d <__profile_end_pass>
    3dcf:	add    rsp,0x40
    3dd3:	cmp    QWORD PTR [rbp-0x1e0],0x0
    3ddb:	je     3d71 <main+0xaa2>
  }

  end_profiling();
    3ddd:	call   1b9b <end_profiling>
    3de2:	mov    eax,0x0
}
    3de7:	mov    rdx,QWORD PTR [rbp-0x38]
    3deb:	sub    rdx,QWORD PTR fs:0x28
    3df4:	je     3dfb <main+0xb2c>
    3df6:	call   1060 <__stack_chk_fail@plt>
    3dfb:	lea    rsp,[rbp-0x28]
    3dff:	pop    rbx
    3e00:	pop    r12
    3e02:	pop    r13
    3e04:	pop    r14
    3e06:	pop    r15
    3e08:	pop    rbp
    3e09:	ret

Disassembly of section .fini:

0000000000003e0c <_fini>:
    3e0c:	endbr64
    3e10:	sub    rsp,0x8
    3e14:	add    rsp,0x8
    3e18:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x4fc1]        # 5fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x4fca]        # 5ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x4fcc]        # 5ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x4fca]        # 6000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x4fc2]        # 6008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x4fba]        # 6010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x4fb2]        # 6018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x4faa]        # 6020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x4fa2]        # 6028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x4f9a]        # 6030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x4f92]        # 6038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x4f8a]        # 6040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x4f82]        # 6048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x4f7a]        # 6050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x4f72]        # 6058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x4f6a]        # 6060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x4f62]        # 6068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x4f5a]        # 6070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x4f52]        # 6078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x4f4a]        # 6080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x4f42]        # 6088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x4f3a]        # 6090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x4f32]        # 6098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2140]        # 32cf <main>
    118f:	call   QWORD PTR [rip+0x4e2b]        # 5fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x4fa1]        # 6148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x4f9a]        # 6148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x4e0e]        # 5fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x4f71]        # 6148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x4f6a]        # 6148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x4ddd]        # 5fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x4f6d],0x0        # 6188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x4dba],0x0        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x4e76]        # 60a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x4da8]        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x4f44],0x1        # 6188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x4c6e]        # 6180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x4b89]        # 60c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x4be7]        # 6160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x4b2b]        # 60c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x3097]        # 4790 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x306b]        # 4790 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fae]        # 47a8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2eaf]        # 47b8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2ccd]        # 47d0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x4639]        # 61a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x4620],rbx        # 61a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x40
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x45ee]        # 61a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x28],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x28],0x0
    1bbe:	je     1e70 <end_profiling+0x2d5>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x20],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x28]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x20]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c51]        # 4888 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x20]
    1c44:	mov    rax,QWORD PTR [rbp-0x28]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x38],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x30],0x0
    1c72:	jmp    1e62 <end_profiling+0x2c7>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x30]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x450d]        # 61a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x18],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x18]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1e5d <end_profiling+0x2c2>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x18]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x28]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b77]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x10],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x18]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x18]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x18]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x18]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x10]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x18]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x18]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x18]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x28]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2a9f]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x8],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x18]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x8]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x38]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x10]
    1e2c:	movsd  QWORD PTR [rbp-0x38],xmm0

        if (zone->bytes_processed)
    1e31:	mov    rax,QWORD PTR [rbp-0x18]
    1e35:	mov    rax,QWORD PTR [rax+0x28]
    1e39:	test   rax,rax
    1e3c:	je     1e5d <end_profiling+0x2c2>
        {
          printf("  Bytes Processed: %lu\n", zone->bytes_processed);
    1e3e:	mov    rax,QWORD PTR [rbp-0x18]
    1e42:	mov    rax,QWORD PTR [rax+0x28]
    1e46:	lea    rdx,[rip+0x24f7]        # 4344 <_IO_stdin_used+0x344>
    1e4d:	mov    rsi,rax
    1e50:	mov    rdi,rdx
    1e53:	mov    eax,0x0
    1e58:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1e5d:	add    QWORD PTR [rbp-0x30],0x1
    1e62:	cmp    QWORD PTR [rbp-0x30],0xfff
    1e6a:	jbe    1c77 <end_profiling+0xdc>
      }

    }

  }
}
    1e70:	nop
    1e71:	leave
    1e72:	ret

0000000000001e73 <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1e73:	push   rbp
    1e74:	mov    rbp,rsp
    1e77:	push   rbx
    1e78:	sub    rsp,0x78
    1e7c:	mov    QWORD PTR [rbp-0x58],rdi
    1e80:	mov    rax,rsi
    1e83:	mov    rsi,rdx
    1e86:	mov    rax,rax
    1e89:	mov    edx,0x0
    1e8e:	mov    rdx,rsi
    1e91:	mov    QWORD PTR [rbp-0x70],rax
    1e95:	mov    QWORD PTR [rbp-0x68],rdx
    1e99:	mov    QWORD PTR [rbp-0x60],rcx
    1e9d:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1ea1:	pxor   xmm0,xmm0
    1ea5:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1ea9:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1ead:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1eb1:	movq   QWORD PTR [rbp-0x20],xmm0
    1eb6:	mov    rax,QWORD PTR [rbp-0x70]
    1eba:	mov    rdx,QWORD PTR [rbp-0x68]
    1ebe:	mov    QWORD PTR [rbp-0x50],rax
    1ec2:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1ec6:	mov    rdx,QWORD PTR [rbp-0x60]
    1eca:	mov    rax,rdx
    1ecd:	add    rax,rax
    1ed0:	add    rax,rdx
    1ed3:	shl    rax,0x4
    1ed7:	mov    rdx,rax
    1eda:	lea    rax,[rip+0x42e7]        # 61c8 <g_profiler+0x28>
    1ee1:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1ee5:	mov    QWORD PTR [rbp-0x38],rax
    1ee9:	mov    rax,QWORD PTR [rbp-0x60]
    1eed:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1ef1:	mov    rax,QWORD PTR [rip+0x42b0]        # 61a8 <g_profiler+0x8>
  Profile_Pass pass =
    1ef8:	mov    QWORD PTR [rbp-0x28],rax
    1efc:	mov    rax,QWORD PTR [rbp-0x78]
    1f00:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    1f04:	mov    rax,QWORD PTR [rbp-0x60]
    1f08:	mov    QWORD PTR [rip+0x4299],rax        # 61a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    1f0f:	call   1a48 <read_cpu_timer>
    1f14:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    1f18:	mov    rax,QWORD PTR [rbp-0x58]
    1f1c:	mov    rcx,QWORD PTR [rbp-0x50]
    1f20:	mov    rbx,QWORD PTR [rbp-0x48]
    1f24:	mov    QWORD PTR [rax],rcx
    1f27:	mov    QWORD PTR [rax+0x8],rbx
    1f2b:	mov    rcx,QWORD PTR [rbp-0x40]
    1f2f:	mov    rbx,QWORD PTR [rbp-0x38]
    1f33:	mov    QWORD PTR [rax+0x10],rcx
    1f37:	mov    QWORD PTR [rax+0x18],rbx
    1f3b:	mov    rcx,QWORD PTR [rbp-0x30]
    1f3f:	mov    rbx,QWORD PTR [rbp-0x28]
    1f43:	mov    QWORD PTR [rax+0x20],rcx
    1f47:	mov    QWORD PTR [rax+0x28],rbx
    1f4b:	mov    rdx,QWORD PTR [rbp-0x20]
    1f4f:	mov    QWORD PTR [rax+0x30],rdx
}
    1f53:	mov    rax,QWORD PTR [rbp-0x58]
    1f57:	mov    rbx,QWORD PTR [rbp-0x8]
    1f5b:	leave
    1f5c:	ret

0000000000001f5d <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    1f5d:	push   rbp
    1f5e:	mov    rbp,rsp
    1f61:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    1f65:	call   1a48 <read_cpu_timer>
    1f6a:	mov    rdx,rax
    1f6d:	mov    rax,QWORD PTR [rbp+0x20]
    1f71:	sub    rdx,rax
    1f74:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    1f78:	mov    rax,QWORD PTR [rbp+0x38]
    1f7c:	mov    QWORD PTR [rip+0x4225],rax        # 61a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    1f83:	mov    rdx,QWORD PTR [rbp+0x30]
    1f87:	mov    rax,rdx
    1f8a:	add    rax,rax
    1f8d:	add    rax,rdx
    1f90:	shl    rax,0x4
    1f94:	lea    rdx,[rax+0x10]
    1f98:	lea    rax,[rip+0x4201]        # 61a0 <g_profiler>
    1f9f:	add    rax,rdx
    1fa2:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    1fa6:	mov    rax,QWORD PTR [rbp-0x10]
    1faa:	mov    rdx,QWORD PTR [rax+0x10]
    1fae:	mov    rax,QWORD PTR [rbp-0x18]
    1fb2:	add    rdx,rax
    1fb5:	mov    rax,QWORD PTR [rbp-0x10]
    1fb9:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    1fbd:	mov    rax,QWORD PTR [rbp-0x10]
    1fc1:	mov    rax,QWORD PTR [rax+0x20]
    1fc5:	lea    rdx,[rax+0x1]
    1fc9:	mov    rax,QWORD PTR [rbp-0x10]
    1fcd:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    1fd1:	mov    rcx,QWORD PTR [rbp-0x10]
    1fd5:	mov    rax,QWORD PTR [rbp+0x10]
    1fd9:	mov    rdx,QWORD PTR [rbp+0x18]
    1fdd:	mov    QWORD PTR [rcx],rax
    1fe0:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    1fe4:	mov    rdx,QWORD PTR [rbp+0x28]
    1fe8:	mov    rax,QWORD PTR [rbp-0x18]
    1fec:	add    rdx,rax
    1fef:	mov    rax,QWORD PTR [rbp-0x10]
    1ff3:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    1ff7:	mov    rax,QWORD PTR [rbp-0x10]
    1ffb:	mov    rdx,QWORD PTR [rax+0x28]
    1fff:	mov    rax,QWORD PTR [rbp+0x40]
    2003:	add    rdx,rax
    2006:	mov    rax,QWORD PTR [rbp-0x10]
    200a:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    200e:	mov    rdx,QWORD PTR [rbp+0x38]
    2012:	mov    rax,rdx
    2015:	add    rax,rax
    2018:	add    rax,rdx
    201b:	shl    rax,0x4
    201f:	lea    rdx,[rax+0x10]
    2023:	lea    rax,[rip+0x4176]        # 61a0 <g_profiler>
    202a:	add    rax,rdx
    202d:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    2031:	mov    rax,QWORD PTR [rbp-0x8]
    2035:	mov    rax,QWORD PTR [rax+0x10]
    2039:	sub    rax,QWORD PTR [rbp-0x18]
    203d:	mov    rdx,rax
    2040:	mov    rax,QWORD PTR [rbp-0x8]
    2044:	mov    QWORD PTR [rax+0x10],rdx
}
    2048:	nop
    2049:	leave
    204a:	ret

000000000000204b <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    204b:	push   rbp
    204c:	mov    rbp,rsp
    204f:	sub    rsp,0x10
    2053:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2057:	mov    rax,QWORD PTR [rbp-0x8]
    205b:	mov    rdx,QWORD PTR [rax+0x10]
    205f:	mov    rax,QWORD PTR [rbp-0x8]
    2063:	mov    rax,QWORD PTR [rax+0x8]
    2067:	cmp    rdx,rax
    206a:	jb     2091 <parser_at+0x46>
    206c:	lea    rdx,[rip+0x2775]        # 47e8 <__PRETTY_FUNCTION__.5>
    2073:	lea    rsi,[rip+0x23ed]        # 4467 <_IO_stdin_used+0x467>
    207a:	lea    rax,[rip+0x23f7]        # 4478 <_IO_stdin_used+0x478>
    2081:	mov    rcx,rdx
    2084:	mov    edx,0x2f
    2089:	mov    rdi,rax
    208c:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    2091:	mov    rax,QWORD PTR [rbp-0x8]
    2095:	mov    rdx,QWORD PTR [rax]
    2098:	mov    rax,QWORD PTR [rbp-0x8]
    209c:	mov    rax,QWORD PTR [rax+0x10]
    20a0:	add    rax,rdx
}
    20a3:	leave
    20a4:	ret

00000000000020a5 <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    20a5:	push   rbp
    20a6:	mov    rbp,rsp
    20a9:	sub    rsp,0x10
    20ad:	mov    QWORD PTR [rbp-0x8],rdi
    20b1:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    20b5:	mov    rax,QWORD PTR [rbp-0x8]
    20b9:	mov    rdi,rax
    20bc:	call   204b <parser_at>
    20c1:	mov    rdx,QWORD PTR [rbp-0x10]
    20c5:	add    rax,rdx
}
    20c8:	leave
    20c9:	ret

00000000000020ca <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    20ca:	push   rbp
    20cb:	mov    rbp,rsp
    20ce:	mov    QWORD PTR [rbp-0x8],rdi
    20d2:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    20d6:	mov    rax,QWORD PTR [rbp-0x8]
    20da:	mov    rdx,QWORD PTR [rax+0x10]
    20de:	mov    rax,QWORD PTR [rbp-0x10]
    20e2:	add    rdx,rax
    20e5:	mov    rax,QWORD PTR [rbp-0x8]
    20e9:	mov    QWORD PTR [rax+0x10],rdx
}
    20ed:	nop
    20ee:	pop    rbp
    20ef:	ret

00000000000020f0 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    20f0:	push   rbp
    20f1:	mov    rbp,rsp
    20f4:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    20f8:	mov    rax,QWORD PTR [rbp-0x8]
    20fc:	mov    rdx,QWORD PTR [rax+0x10]
    2100:	mov    rax,QWORD PTR [rbp-0x8]
    2104:	mov    rax,QWORD PTR [rax+0x8]
    2108:	cmp    rdx,rax
    210b:	setb   al
}
    210e:	pop    rbp
    210f:	ret

0000000000002110 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    2110:	push   rbp
    2111:	mov    rbp,rsp
    2114:	push   r12
    2116:	push   rbx
    2117:	sub    rsp,0x20
    211b:	mov    QWORD PTR [rbp-0x18],rdi
    211f:	mov    rax,rsi
    2122:	mov    rcx,rdx
    2125:	mov    rax,rax
    2128:	mov    edx,0x0
    212d:	mov    rdx,rcx
    2130:	mov    QWORD PTR [rbp-0x30],rax
    2134:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    2138:	mov    rax,QWORD PTR [rbp-0x28]
    213c:	mov    r12,rax
    213f:	mov    rbx,QWORD PTR [rbp-0x30]
    2143:	mov    rax,QWORD PTR [rbp-0x18]
    2147:	mov    rdi,rax
    214a:	call   204b <parser_at>
    214f:	mov    rdx,r12
    2152:	mov    rsi,rbx
    2155:	mov    rdi,rax
    2158:	call   10d0 <memcmp@plt>
    215d:	test   eax,eax
    215f:	sete   al
}
    2162:	add    rsp,0x20
    2166:	pop    rbx
    2167:	pop    r12
    2169:	pop    rbp
    216a:	ret

000000000000216b <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    216b:	push   rbp
    216c:	mov    rbp,rsp
    216f:	mov    eax,edi
    2171:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    2174:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    2178:	movzx  eax,BYTE PTR [rbp-0x14]
    217c:	cmp    eax,0x2e
    217f:	jg     2188 <is_numeric+0x1d>
    2181:	cmp    eax,0x2d
    2184:	jge    2190 <is_numeric+0x25>
    2186:	jmp    2195 <is_numeric+0x2a>
    2188:	sub    eax,0x30
    218b:	cmp    eax,0x9
    218e:	ja     2195 <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2190:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    2194:	nop
  }


  return result;
    2195:	movzx  eax,BYTE PTR [rbp-0x1]
}
    2199:	pop    rbp
    219a:	ret

000000000000219b <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    219b:	push   rbp
    219c:	mov    rbp,rsp
    219f:	sub    rsp,0x50
    21a3:	mov    QWORD PTR [rbp-0x48],rdi
    21a7:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    21ab:	pxor   xmm0,xmm0
    21af:	movaps XMMWORD PTR [rbp-0x20],xmm0
    21b3:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    21b8:	jmp    21cb <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    21ba:	mov    rax,QWORD PTR [rbp-0x50]
    21be:	mov    esi,0x1
    21c3:	mov    rdi,rax
    21c6:	call   20ca <parser_advance>
  while (parser_incomplete(parser)  &&
    21cb:	mov    rax,QWORD PTR [rbp-0x50]
    21cf:	mov    rdi,rax
    21d2:	call   20f0 <parser_incomplete>
    21d7:	test   al,al
    21d9:	je     2227 <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    21db:	mov    rax,QWORD PTR [rbp-0x50]
    21df:	mov    rdi,rax
    21e2:	call   204b <parser_at>
    21e7:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    21ea:	cmp    al,0x20
    21ec:	je     21ba <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    21ee:	mov    rax,QWORD PTR [rbp-0x50]
    21f2:	mov    rdi,rax
    21f5:	call   204b <parser_at>
    21fa:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    21fd:	cmp    al,0xa
    21ff:	je     21ba <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    2201:	mov    rax,QWORD PTR [rbp-0x50]
    2205:	mov    rdi,rax
    2208:	call   204b <parser_at>
    220d:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    2210:	cmp    al,0xd
    2212:	je     21ba <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    2214:	mov    rax,QWORD PTR [rbp-0x50]
    2218:	mov    rdi,rax
    221b:	call   204b <parser_at>
    2220:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    2223:	cmp    al,0x9
    2225:	je     21ba <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    2227:	mov    rax,QWORD PTR [rbp-0x50]
    222b:	mov    rdi,rax
    222e:	call   20f0 <parser_incomplete>
    2233:	test   al,al
    2235:	je     2662 <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    223b:	mov    rax,QWORD PTR [rbp-0x50]
    223f:	mov    rdi,rax
    2242:	call   204b <parser_at>
    2247:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    224b:	mov    rax,QWORD PTR [rbp-0x50]
    224f:	mov    rdi,rax
    2252:	call   204b <parser_at>
    2257:	movzx  eax,BYTE PTR [rax]
    225a:	movzx  eax,al
    225d:	cmp    eax,0x7d
    2260:	je     234d <get_json_token+0x1b2>
    2266:	cmp    eax,0x7d
    2269:	jg     2673 <get_json_token+0x4d8>
    226f:	cmp    eax,0x7b
    2272:	je     2328 <get_json_token+0x18d>
    2278:	cmp    eax,0x7b
    227b:	jg     2673 <get_json_token+0x4d8>
    2281:	cmp    eax,0x74
    2284:	je     24d0 <get_json_token+0x335>
    228a:	cmp    eax,0x74
    228d:	jg     2673 <get_json_token+0x4d8>
    2293:	cmp    eax,0x6e
    2296:	je     25e0 <get_json_token+0x445>
    229c:	cmp    eax,0x6e
    229f:	jg     2673 <get_json_token+0x4d8>
    22a5:	cmp    eax,0x66
    22a8:	je     2558 <get_json_token+0x3bd>
    22ae:	cmp    eax,0x66
    22b1:	jg     2673 <get_json_token+0x4d8>
    22b7:	cmp    eax,0x5d
    22ba:	je     2397 <get_json_token+0x1fc>
    22c0:	cmp    eax,0x5d
    22c3:	jg     2673 <get_json_token+0x4d8>
    22c9:	cmp    eax,0x5b
    22cc:	je     2372 <get_json_token+0x1d7>
    22d2:	cmp    eax,0x5b
    22d5:	jg     2673 <get_json_token+0x4d8>
    22db:	cmp    eax,0x3a
    22de:	je     23e1 <get_json_token+0x246>
    22e4:	cmp    eax,0x3a
    22e7:	jg     2673 <get_json_token+0x4d8>
    22ed:	cmp    eax,0x39
    22f0:	jg     2673 <get_json_token+0x4d8>
    22f6:	cmp    eax,0x30
    22f9:	jge    247f <get_json_token+0x2e4>
    22ff:	cmp    eax,0x2e
    2302:	jg     2673 <get_json_token+0x4d8>
    2308:	cmp    eax,0x2d
    230b:	jge    247f <get_json_token+0x2e4>
    2311:	cmp    eax,0x22
    2314:	je     2406 <get_json_token+0x26b>
    231a:	cmp    eax,0x2c
    231d:	je     23bc <get_json_token+0x221>
    2323:	jmp    2673 <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    2328:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    232f:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2337:	mov    rax,QWORD PTR [rbp-0x50]
    233b:	mov    esi,0x1
    2340:	mov    rdi,rax
    2343:	call   20ca <parser_advance>
      }
      break;
    2348:	jmp    2673 <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    234d:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    2354:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    235c:	mov    rax,QWORD PTR [rbp-0x50]
    2360:	mov    esi,0x1
    2365:	mov    rdi,rax
    2368:	call   20ca <parser_advance>
      }
      break;
    236d:	jmp    2673 <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2372:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    2379:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2381:	mov    rax,QWORD PTR [rbp-0x50]
    2385:	mov    esi,0x1
    238a:	mov    rdi,rax
    238d:	call   20ca <parser_advance>
      }
      break;
    2392:	jmp    2673 <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    2397:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    239e:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    23a6:	mov    rax,QWORD PTR [rbp-0x50]
    23aa:	mov    esi,0x1
    23af:	mov    rdi,rax
    23b2:	call   20ca <parser_advance>
      }
      break;
    23b7:	jmp    2673 <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    23bc:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    23c3:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    23cb:	mov    rax,QWORD PTR [rbp-0x50]
    23cf:	mov    esi,0x1
    23d4:	mov    rdi,rax
    23d7:	call   20ca <parser_advance>
      }
      break;
    23dc:	jmp    2673 <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    23e1:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    23e8:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    23f0:	mov    rax,QWORD PTR [rbp-0x50]
    23f4:	mov    esi,0x1
    23f9:	mov    rdi,rax
    23fc:	call   20ca <parser_advance>
      }
      break;
    2401:	jmp    2673 <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    2406:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    240d:	mov    rax,QWORD PTR [rbp-0x50]
    2411:	mov    esi,0x1
    2416:	mov    rdi,rax
    2419:	call   20ca <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    241e:	mov    rax,QWORD PTR [rbp-0x50]
    2422:	mov    rdi,rax
    2425:	call   204b <parser_at>
    242a:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    242e:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    2436:	jmp    244e <get_json_token+0x2b3>
        {
          string_count += 1;
    2438:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    243d:	mov    rax,QWORD PTR [rbp-0x50]
    2441:	mov    esi,0x1
    2446:	mov    rdi,rax
    2449:	call   20ca <parser_advance>
        while (*parser_at(parser) != '"')
    244e:	mov    rax,QWORD PTR [rbp-0x50]
    2452:	mov    rdi,rax
    2455:	call   204b <parser_at>
    245a:	movzx  eax,BYTE PTR [rax]
    245d:	cmp    al,0x22
    245f:	jne    2438 <get_json_token+0x29d>
        }
        token.value.count = string_count;
    2461:	mov    rax,QWORD PTR [rbp-0x40]
    2465:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    2469:	mov    rax,QWORD PTR [rbp-0x50]
    246d:	mov    esi,0x1
    2472:	mov    rdi,rax
    2475:	call   20ca <parser_advance>
      }
      break;
    247a:	jmp    2673 <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    247f:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    2486:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    248e:	jmp    24a6 <get_json_token+0x30b>
        {
          digit_count += 1;
    2490:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    2495:	mov    rax,QWORD PTR [rbp-0x50]
    2499:	mov    esi,0x1
    249e:	mov    rdi,rax
    24a1:	call   20ca <parser_advance>
        while (is_numeric(*parser_at(parser)))
    24a6:	mov    rax,QWORD PTR [rbp-0x50]
    24aa:	mov    rdi,rax
    24ad:	call   204b <parser_at>
    24b2:	movzx  eax,BYTE PTR [rax]
    24b5:	movzx  eax,al
    24b8:	mov    edi,eax
    24ba:	call   216b <is_numeric>
    24bf:	test   al,al
    24c1:	jne    2490 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    24c3:	mov    rax,QWORD PTR [rbp-0x38]
    24c7:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    24cb:	jmp    2673 <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    24d0:	lea    rax,[rip+0x1fed]        # 44c4 <_IO_stdin_used+0x4c4>
    24d7:	mov    QWORD PTR [rbp-0x30],rax
    24db:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    24e3:	mov    rcx,QWORD PTR [rbp-0x30]
    24e7:	mov    rdx,QWORD PTR [rbp-0x28]
    24eb:	mov    rax,QWORD PTR [rbp-0x50]
    24ef:	mov    rsi,rcx
    24f2:	mov    rdi,rax
    24f5:	call   2110 <parser_token_is_literal>
    24fa:	test   al,al
    24fc:	je     2520 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    24fe:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    2505:	mov    rax,QWORD PTR [rbp-0x28]
    2509:	mov    rdx,rax
    250c:	mov    rax,QWORD PTR [rbp-0x50]
    2510:	mov    rsi,rdx
    2513:	mov    rdi,rax
    2516:	call   20ca <parser_advance>
    251b:	jmp    2673 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2520:	mov    rax,QWORD PTR [rbp-0x50]
    2524:	mov    rcx,QWORD PTR [rax+0x10]
    2528:	lea    rdx,[rip+0x1fa1]        # 44d0 <_IO_stdin_used+0x4d0>
    252f:	lea    rax,[rip+0x1f31]        # 4467 <_IO_stdin_used+0x467>
    2536:	mov    r8,rcx
    2539:	mov    rcx,rdx
    253c:	mov    edx,0xdf
    2541:	mov    rsi,rax
    2544:	mov    edi,0x1
    2549:	mov    eax,0x0
    254e:	call   14a1 <log_message>
        }
      }
      break;
    2553:	jmp    2673 <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    2558:	lea    rax,[rip+0x1f9e]        # 44fd <_IO_stdin_used+0x4fd>
    255f:	mov    QWORD PTR [rbp-0x30],rax
    2563:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    256b:	mov    rcx,QWORD PTR [rbp-0x30]
    256f:	mov    rdx,QWORD PTR [rbp-0x28]
    2573:	mov    rax,QWORD PTR [rbp-0x50]
    2577:	mov    rsi,rcx
    257a:	mov    rdi,rax
    257d:	call   2110 <parser_token_is_literal>
    2582:	test   al,al
    2584:	je     25a8 <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    2586:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    258d:	mov    rax,QWORD PTR [rbp-0x28]
    2591:	mov    rdx,rax
    2594:	mov    rax,QWORD PTR [rbp-0x50]
    2598:	mov    rsi,rdx
    259b:	mov    rdi,rax
    259e:	call   20ca <parser_advance>
    25a3:	jmp    2673 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    25a8:	mov    rax,QWORD PTR [rbp-0x50]
    25ac:	mov    rcx,QWORD PTR [rax+0x10]
    25b0:	lea    rdx,[rip+0x1f19]        # 44d0 <_IO_stdin_used+0x4d0>
    25b7:	lea    rax,[rip+0x1ea9]        # 4467 <_IO_stdin_used+0x467>
    25be:	mov    r8,rcx
    25c1:	mov    rcx,rdx
    25c4:	mov    edx,0xee
    25c9:	mov    rsi,rax
    25cc:	mov    edi,0x1
    25d1:	mov    eax,0x0
    25d6:	call   14a1 <log_message>
        }
      }
      break;
    25db:	jmp    2673 <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    25e0:	lea    rax,[rip+0x1f1c]        # 4503 <_IO_stdin_used+0x503>
    25e7:	mov    QWORD PTR [rbp-0x30],rax
    25eb:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25f3:	mov    rcx,QWORD PTR [rbp-0x30]
    25f7:	mov    rdx,QWORD PTR [rbp-0x28]
    25fb:	mov    rax,QWORD PTR [rbp-0x50]
    25ff:	mov    rsi,rcx
    2602:	mov    rdi,rax
    2605:	call   2110 <parser_token_is_literal>
    260a:	test   al,al
    260c:	je     262d <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    260e:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    2615:	mov    rax,QWORD PTR [rbp-0x28]
    2619:	mov    rdx,rax
    261c:	mov    rax,QWORD PTR [rbp-0x50]
    2620:	mov    rsi,rdx
    2623:	mov    rdi,rax
    2626:	call   20ca <parser_advance>
    262b:	jmp    2673 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    262d:	mov    rax,QWORD PTR [rbp-0x50]
    2631:	mov    rcx,QWORD PTR [rax+0x10]
    2635:	lea    rdx,[rip+0x1e94]        # 44d0 <_IO_stdin_used+0x4d0>
    263c:	lea    rax,[rip+0x1e24]        # 4467 <_IO_stdin_used+0x467>
    2643:	mov    r8,rcx
    2646:	mov    rcx,rdx
    2649:	mov    edx,0xfd
    264e:	mov    rsi,rax
    2651:	mov    edi,0x1
    2656:	mov    eax,0x0
    265b:	call   14a1 <log_message>
        }
      }
      break;
    2660:	jmp    2673 <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    2662:	mov    rax,QWORD PTR [rbp-0x50]
    2666:	mov    esi,0x1
    266b:	mov    rdi,rax
    266e:	call   20ca <parser_advance>
  }

  return token;
    2673:	mov    rcx,QWORD PTR [rbp-0x48]
    2677:	mov    rax,QWORD PTR [rbp-0x20]
    267b:	mov    rdx,QWORD PTR [rbp-0x18]
    267f:	mov    QWORD PTR [rcx],rax
    2682:	mov    QWORD PTR [rcx+0x8],rdx
    2686:	mov    rax,QWORD PTR [rbp-0x10]
    268a:	mov    QWORD PTR [rcx+0x10],rax
}
    268e:	mov    rax,QWORD PTR [rbp-0x48]
    2692:	leave
    2693:	ret

0000000000002694 <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    2694:	push   rbp
    2695:	mov    rbp,rsp
    2698:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    269b:	cmp    DWORD PTR [rbp-0x14],0x7
    269f:	je     26b9 <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    26a1:	cmp    DWORD PTR [rbp-0x14],0x9
    26a5:	je     26b9 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    26a7:	cmp    DWORD PTR [rbp-0x14],0xa
    26ab:	je     26b9 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    26ad:	cmp    DWORD PTR [rbp-0x14],0xb
    26b1:	je     26b9 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    26b3:	cmp    DWORD PTR [rbp-0x14],0x8
    26b7:	jne    26c0 <json_token_type_is_value_type+0x2c>
    26b9:	mov    eax,0x1
    26be:	jmp    26c5 <json_token_type_is_value_type+0x31>
    26c0:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    26c5:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    26c8:	mov    eax,DWORD PTR [rbp-0x4]
}
    26cb:	pop    rbp
    26cc:	ret

00000000000026cd <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    26cd:	push   rbp
    26ce:	mov    rbp,rsp
    26d1:	push   rbx
    26d2:	sub    rsp,0x88
    26d9:	mov    QWORD PTR [rbp-0x78],rdi
    26dd:	mov    QWORD PTR [rbp-0x80],rsi
    26e1:	mov    QWORD PTR [rbp-0x90],rdx
    26e8:	mov    QWORD PTR [rbp-0x88],rcx
    26ef:	mov    rax,QWORD PTR fs:0x28
    26f8:	mov    QWORD PTR [rbp-0x18],rax
    26fc:	xor    eax,eax
  profile_begin_func();
    26fe:	lea    r8,[rip+0x20fb]        # 4800 <__func__.4>
    2705:	mov    r9d,0x11
    270b:	lea    rax,[rbp-0x50]
    270f:	mov    rsi,r8
    2712:	mov    rdx,r9
    2715:	mov    r8d,0x0
    271b:	mov    ecx,0x1
    2720:	mov    rdi,rax
    2723:	call   1e73 <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    2728:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2730:	mov    eax,DWORD PTR [rbp+0x10]
    2733:	cmp    eax,0x1
    2736:	jne    2762 <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    2738:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    273f:	mov    edx,DWORD PTR [rbp-0x64]
    2742:	mov    rsi,QWORD PTR [rbp-0x80]
    2746:	mov    rax,QWORD PTR [rbp-0x78]
    274a:	mov    ecx,edx
    274c:	mov    edx,0x2
    2751:	mov    rdi,rax
    2754:	call   28b4 <parse_json_children>
    2759:	mov    QWORD PTR [rbp-0x60],rax
    275d:	jmp    27ec <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2762:	mov    eax,DWORD PTR [rbp+0x10]
    2765:	cmp    eax,0x3
    2768:	jne    2791 <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    276a:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2771:	mov    edx,DWORD PTR [rbp-0x68]
    2774:	mov    rsi,QWORD PTR [rbp-0x80]
    2778:	mov    rax,QWORD PTR [rbp-0x78]
    277c:	mov    ecx,edx
    277e:	mov    edx,0x4
    2783:	mov    rdi,rax
    2786:	call   28b4 <parse_json_children>
    278b:	mov    QWORD PTR [rbp-0x60],rax
    278f:	jmp    27ec <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    2791:	mov    eax,DWORD PTR [rbp+0x10]
    2794:	mov    edi,eax
    2796:	call   2694 <json_token_type_is_value_type>
    279b:	test   eax,eax
    279d:	jne    27ec <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    279f:	mov    eax,DWORD PTR [rbp+0x10]
    27a2:	mov    eax,eax
    27a4:	lea    rdx,[rax*8+0x0]
    27ac:	lea    rax,[rip+0x392d]        # 60e0 <JSON_Token_Type_strings>
    27b3:	mov    rcx,QWORD PTR [rdx+rax*1]
    27b7:	lea    rdx,[rip+0x1d4a]        # 4508 <_IO_stdin_used+0x508>
    27be:	lea    rax,[rip+0x1ca2]        # 4467 <_IO_stdin_used+0x467>
    27c5:	push   QWORD PTR [rbp+0x20]
    27c8:	push   QWORD PTR [rbp+0x18]
    27cb:	mov    r8,rcx
    27ce:	mov    rcx,rdx
    27d1:	mov    edx,0x134
    27d6:	mov    rsi,rax
    27d9:	mov    edi,0x1
    27de:	mov    eax,0x0
    27e3:	call   14a1 <log_message>
    27e8:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    27ec:	mov    rax,QWORD PTR [rbp-0x78]
    27f0:	mov    edx,0x8
    27f5:	mov    esi,0x30
    27fa:	mov    rdi,rax
    27fd:	call   17d3 <arena_alloc>
    2802:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    2806:	mov    rcx,QWORD PTR [rbp-0x58]
    280a:	mov    rax,QWORD PTR [rbp-0x90]
    2811:	mov    rdx,QWORD PTR [rbp-0x88]
    2818:	mov    QWORD PTR [rcx],rax
    281b:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    281f:	mov    rax,QWORD PTR [rbp-0x58]
    2823:	mov    rdx,QWORD PTR [rbp-0x60]
    2827:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    282b:	mov    rax,QWORD PTR [rbp-0x58]
    282f:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    2837:	mov    rcx,QWORD PTR [rbp-0x58]
    283b:	mov    rax,QWORD PTR [rbp+0x18]
    283f:	mov    rdx,QWORD PTR [rbp+0x20]
    2843:	mov    QWORD PTR [rcx+0x10],rax
    2847:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    284b:	sub    rsp,0x8
    284f:	sub    rsp,0x38
    2853:	mov    rax,rsp
    2856:	mov    rcx,QWORD PTR [rbp-0x50]
    285a:	mov    rbx,QWORD PTR [rbp-0x48]
    285e:	mov    QWORD PTR [rax],rcx
    2861:	mov    QWORD PTR [rax+0x8],rbx
    2865:	mov    rcx,QWORD PTR [rbp-0x40]
    2869:	mov    rbx,QWORD PTR [rbp-0x38]
    286d:	mov    QWORD PTR [rax+0x10],rcx
    2871:	mov    QWORD PTR [rax+0x18],rbx
    2875:	mov    rcx,QWORD PTR [rbp-0x30]
    2879:	mov    rbx,QWORD PTR [rbp-0x28]
    287d:	mov    QWORD PTR [rax+0x20],rcx
    2881:	mov    QWORD PTR [rax+0x28],rbx
    2885:	mov    rdx,QWORD PTR [rbp-0x20]
    2889:	mov    QWORD PTR [rax+0x30],rdx
    288d:	call   1f5d <__profile_end_pass>
    2892:	add    rsp,0x40

  return result;
    2896:	mov    rax,QWORD PTR [rbp-0x58]
}
    289a:	mov    rdx,QWORD PTR [rbp-0x18]
    289e:	sub    rdx,QWORD PTR fs:0x28
    28a7:	je     28ae <parse_json_object+0x1e1>
    28a9:	call   1060 <__stack_chk_fail@plt>
    28ae:	mov    rbx,QWORD PTR [rbp-0x8]
    28b2:	leave
    28b3:	ret

00000000000028b4 <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    28b4:	push   rbp
    28b5:	mov    rbp,rsp
    28b8:	push   rbx
    28b9:	sub    rsp,0x108
    28c0:	mov    QWORD PTR [rbp-0xd8],rdi
    28c7:	mov    QWORD PTR [rbp-0xe0],rsi
    28ce:	mov    DWORD PTR [rbp-0xe4],edx
    28d4:	mov    DWORD PTR [rbp-0xe8],ecx
    28da:	mov    rax,QWORD PTR fs:0x28
    28e3:	mov    QWORD PTR [rbp-0x18],rax
    28e7:	xor    eax,eax
  profile_begin_func();
    28e9:	lea    r8,[rip+0x1f30]        # 4820 <__func__.3>
    28f0:	mov    r9d,0x13
    28f6:	lea    rax,[rbp-0x50]
    28fa:	mov    rsi,r8
    28fd:	mov    rdx,r9
    2900:	mov    r8d,0x0
    2906:	mov    ecx,0x2
    290b:	mov    rdi,rax
    290e:	call   1e73 <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2913:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    291e:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2929:	jmp    2c02 <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    292e:	pxor   xmm0,xmm0
    2932:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2939:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2941:	pxor   xmm0,xmm0
    2945:	movaps XMMWORD PTR [rbp-0x90],xmm0
    294c:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2951:	cmp    DWORD PTR [rbp-0xe8],0x0
    2958:	je     2a65 <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    295e:	lea    rax,[rbp-0xb0]
    2965:	mov    rdx,QWORD PTR [rbp-0xe0]
    296c:	mov    rsi,rdx
    296f:	mov    rdi,rax
    2972:	call   219b <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2977:	mov    eax,DWORD PTR [rbp-0xb0]
    297d:	cmp    eax,0x7
    2980:	jne    2a01 <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2982:	lea    rax,[rbp-0x70]
    2986:	mov    rdx,QWORD PTR [rbp-0xe0]
    298d:	mov    rsi,rdx
    2990:	mov    rdi,rax
    2993:	call   219b <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2998:	mov    eax,DWORD PTR [rbp-0x70]
    299b:	cmp    eax,0x6
    299e:	jne    29be <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    29a0:	lea    rax,[rbp-0x90]
    29a7:	mov    rdx,QWORD PTR [rbp-0xe0]
    29ae:	mov    rsi,rdx
    29b1:	mov    rdi,rax
    29b4:	call   219b <get_json_token>
    29b9:	jmp    2aa5 <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    29be:	mov    rcx,QWORD PTR [rbp-0xa8]
    29c5:	mov    rax,QWORD PTR [rbp-0xa0]
    29cc:	mov    esi,eax
    29ce:	lea    rdx,[rip+0x1b83]        # 4558 <_IO_stdin_used+0x558>
    29d5:	lea    rax,[rip+0x1a8b]        # 4467 <_IO_stdin_used+0x467>
    29dc:	mov    r9,rcx
    29df:	mov    r8d,esi
    29e2:	mov    rcx,rdx
    29e5:	mov    edx,0x15f
    29ea:	mov    rsi,rax
    29ed:	mov    edi,0x1
    29f2:	mov    eax,0x0
    29f7:	call   14a1 <log_message>
    29fc:	jmp    2aa5 <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2a01:	mov    rcx,QWORD PTR [rbp-0xa8]
    2a08:	mov    rax,QWORD PTR [rbp-0xa0]
    2a0f:	mov    edi,eax
    2a11:	mov    eax,DWORD PTR [rbp-0xb0]
    2a17:	mov    eax,eax
    2a19:	lea    rdx,[rax*8+0x0]
    2a21:	lea    rax,[rip+0x36b8]        # 60e0 <JSON_Token_Type_strings>
    2a28:	mov    rsi,QWORD PTR [rdx+rax*1]
    2a2c:	lea    rdx,[rip+0x1b45]        # 4578 <_IO_stdin_used+0x578>
    2a33:	lea    rax,[rip+0x1a2d]        # 4467 <_IO_stdin_used+0x467>
    2a3a:	sub    rsp,0x8
    2a3e:	push   rcx
    2a3f:	mov    r9d,edi
    2a42:	mov    r8,rsi
    2a45:	mov    rcx,rdx
    2a48:	mov    edx,0x164
    2a4d:	mov    rsi,rax
    2a50:	mov    edi,0x1
    2a55:	mov    eax,0x0
    2a5a:	call   14a1 <log_message>
    2a5f:	add    rsp,0x10
    2a63:	jmp    2aa5 <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2a65:	lea    rax,[rbp-0x110]
    2a6c:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a73:	mov    rsi,rdx
    2a76:	mov    rdi,rax
    2a79:	call   219b <get_json_token>
    2a7e:	mov    rax,QWORD PTR [rbp-0x110]
    2a85:	mov    rdx,QWORD PTR [rbp-0x108]
    2a8c:	mov    QWORD PTR [rbp-0x90],rax
    2a93:	mov    QWORD PTR [rbp-0x88],rdx
    2a9a:	mov    rax,QWORD PTR [rbp-0x100]
    2aa1:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2aa5:	mov    eax,DWORD PTR [rbp-0x90]
    2aab:	cmp    DWORD PTR [rbp-0xe4],eax
    2ab1:	je     2c1b <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2ab7:	mov    rax,QWORD PTR [rbp-0xa8]
    2abe:	mov    rdx,QWORD PTR [rbp-0xa0]
    2ac5:	mov    r8,QWORD PTR [rbp-0xe0]
    2acc:	mov    rdi,QWORD PTR [rbp-0xd8]
    2ad3:	sub    rsp,0x8
    2ad7:	sub    rsp,0x18
    2adb:	mov    rsi,rsp
    2ade:	mov    rcx,QWORD PTR [rbp-0x90]
    2ae5:	mov    rbx,QWORD PTR [rbp-0x88]
    2aec:	mov    QWORD PTR [rsi],rcx
    2aef:	mov    QWORD PTR [rsi+0x8],rbx
    2af3:	mov    rcx,QWORD PTR [rbp-0x80]
    2af7:	mov    QWORD PTR [rsi+0x10],rcx
    2afb:	mov    rcx,rdx
    2afe:	mov    rdx,rax
    2b01:	mov    rsi,r8
    2b04:	call   26cd <parse_json_object>
    2b09:	add    rsp,0x20
    2b0d:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2b14:	cmp    QWORD PTR [rbp-0xb8],0x0
    2b1c:	je     2b66 <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2b1e:	cmp    QWORD PTR [rbp-0xc8],0x0
    2b26:	jne    2b46 <parse_json_children+0x292>
      {
        first_child        = object;
    2b28:	mov    rax,QWORD PTR [rbp-0xb8]
    2b2f:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2b36:	mov    rax,QWORD PTR [rbp-0xb8]
    2b3d:	mov    QWORD PTR [rbp-0xc0],rax
    2b44:	jmp    2b66 <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2b46:	mov    rax,QWORD PTR [rbp-0xc0]
    2b4d:	mov    rdx,QWORD PTR [rbp-0xb8]
    2b54:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2b58:	mov    rax,QWORD PTR [rbp-0xb8]
    2b5f:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2b66:	lea    rax,[rbp-0x70]
    2b6a:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b71:	mov    rsi,rdx
    2b74:	mov    rdi,rax
    2b77:	call   219b <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2b7c:	mov    eax,DWORD PTR [rbp-0x70]
    2b7f:	cmp    DWORD PTR [rbp-0xe4],eax
    2b85:	je     2c1e <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2b8b:	mov    eax,DWORD PTR [rbp-0x70]
    2b8e:	cmp    eax,0x5
    2b91:	je     2c02 <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2b93:	mov    r8,QWORD PTR [rbp-0x68]
    2b97:	mov    rax,QWORD PTR [rbp-0x60]
    2b9b:	mov    r9d,eax
    2b9e:	mov    eax,DWORD PTR [rbp-0x70]
    2ba1:	mov    eax,eax
    2ba3:	lea    rdx,[rax*8+0x0]
    2bab:	lea    rax,[rip+0x352e]        # 60e0 <JSON_Token_Type_strings>
    2bb2:	mov    r10,QWORD PTR [rdx+rax*1]
    2bb6:	lea    rdi,[rip+0x19e3]        # 45a0 <_IO_stdin_used+0x5a0>
    2bbd:	lea    rsi,[rip+0x18a3]        # 4467 <_IO_stdin_used+0x467>
    2bc4:	sub    rsp,0x18
    2bc8:	mov    rcx,rsp
    2bcb:	mov    rax,QWORD PTR [rbp-0x70]
    2bcf:	mov    rdx,QWORD PTR [rbp-0x68]
    2bd3:	mov    QWORD PTR [rcx],rax
    2bd6:	mov    QWORD PTR [rcx+0x8],rdx
    2bda:	mov    rax,QWORD PTR [rbp-0x60]
    2bde:	mov    QWORD PTR [rcx+0x10],rax
    2be2:	push   r8
    2be4:	mov    r8,r10
    2be7:	mov    rcx,rdi
    2bea:	mov    edx,0x18b
    2bef:	mov    edi,0x1
    2bf4:	mov    eax,0x0
    2bf9:	call   14a1 <log_message>
    2bfe:	add    rsp,0x20
  while (parser_incomplete(parser))
    2c02:	mov    rax,QWORD PTR [rbp-0xe0]
    2c09:	mov    rdi,rax
    2c0c:	call   20f0 <parser_incomplete>
    2c11:	test   al,al
    2c13:	jne    292e <parse_json_children+0x7a>
    2c19:	jmp    2c1f <parse_json_children+0x36b>
      break;
    2c1b:	nop
    2c1c:	jmp    2c1f <parse_json_children+0x36b>
      break;
    2c1e:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2c1f:	sub    rsp,0x8
    2c23:	sub    rsp,0x38
    2c27:	mov    rax,rsp
    2c2a:	mov    rcx,QWORD PTR [rbp-0x50]
    2c2e:	mov    rbx,QWORD PTR [rbp-0x48]
    2c32:	mov    QWORD PTR [rax],rcx
    2c35:	mov    QWORD PTR [rax+0x8],rbx
    2c39:	mov    rcx,QWORD PTR [rbp-0x40]
    2c3d:	mov    rbx,QWORD PTR [rbp-0x38]
    2c41:	mov    QWORD PTR [rax+0x10],rcx
    2c45:	mov    QWORD PTR [rax+0x18],rbx
    2c49:	mov    rcx,QWORD PTR [rbp-0x30]
    2c4d:	mov    rbx,QWORD PTR [rbp-0x28]
    2c51:	mov    QWORD PTR [rax+0x20],rcx
    2c55:	mov    QWORD PTR [rax+0x28],rbx
    2c59:	mov    rdx,QWORD PTR [rbp-0x20]
    2c5d:	mov    QWORD PTR [rax+0x30],rdx
    2c61:	call   1f5d <__profile_end_pass>
    2c66:	add    rsp,0x40

  return first_child;
    2c6a:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2c71:	mov    rdx,QWORD PTR [rbp-0x18]
    2c75:	sub    rdx,QWORD PTR fs:0x28
    2c7e:	je     2c85 <parse_json_children+0x3d1>
    2c80:	call   1060 <__stack_chk_fail@plt>
    2c85:	mov    rbx,QWORD PTR [rbp-0x8]
    2c89:	leave
    2c8a:	ret

0000000000002c8b <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2c8b:	push   rbp
    2c8c:	mov    rbp,rsp
    2c8f:	push   rbx
    2c90:	sub    rsp,0xb8
    2c97:	mov    QWORD PTR [rbp-0xa8],rdi
    2c9e:	mov    rax,rsi
    2ca1:	mov    rsi,rdx
    2ca4:	mov    rax,rax
    2ca7:	mov    edx,0x0
    2cac:	mov    rdx,rsi
    2caf:	mov    QWORD PTR [rbp-0xc0],rax
    2cb6:	mov    QWORD PTR [rbp-0xb8],rdx
    2cbd:	mov    rax,QWORD PTR fs:0x28
    2cc6:	mov    QWORD PTR [rbp-0x18],rax
    2cca:	xor    eax,eax
  profile_begin_func();
    2ccc:	lea    rcx,[rip+0x1b65]        # 4838 <__func__.2>
    2cd3:	mov    ebx,0xa
    2cd8:	lea    rax,[rbp-0x50]
    2cdc:	mov    rsi,rcx
    2cdf:	mov    rdx,rbx
    2ce2:	mov    r8d,0x0
    2ce8:	mov    ecx,0x3
    2ced:	mov    rdi,rax
    2cf0:	call   1e73 <__profile_begin_pass>

  JSON_Parser parser =
    2cf5:	mov    rax,QWORD PTR [rbp-0xc0]
    2cfc:	mov    rdx,QWORD PTR [rbp-0xb8]
    2d03:	mov    QWORD PTR [rbp-0x90],rax
    2d0a:	mov    QWORD PTR [rbp-0x88],rdx
    2d11:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2d19:	lea    rax,[rbp-0x70]
    2d1d:	lea    rdx,[rbp-0x90]
    2d24:	mov    rsi,rdx
    2d27:	mov    rdi,rax
    2d2a:	call   219b <get_json_token>
    2d2f:	mov    ecx,0x0
    2d34:	mov    ebx,0x0
    2d39:	lea    r8,[rbp-0x90]
    2d40:	mov    rdi,QWORD PTR [rbp-0xa8]
    2d47:	sub    rsp,0x8
    2d4b:	sub    rsp,0x18
    2d4f:	mov    rsi,rsp
    2d52:	mov    rax,QWORD PTR [rbp-0x70]
    2d56:	mov    rdx,QWORD PTR [rbp-0x68]
    2d5a:	mov    QWORD PTR [rsi],rax
    2d5d:	mov    QWORD PTR [rsi+0x8],rdx
    2d61:	mov    rax,QWORD PTR [rbp-0x60]
    2d65:	mov    QWORD PTR [rsi+0x10],rax
    2d69:	mov    rdx,rcx
    2d6c:	mov    rcx,rbx
    2d6f:	mov    rsi,r8
    2d72:	call   26cd <parse_json_object>
    2d77:	add    rsp,0x20
    2d7b:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2d82:	sub    rsp,0x8
    2d86:	sub    rsp,0x38
    2d8a:	mov    rax,rsp
    2d8d:	mov    rcx,QWORD PTR [rbp-0x50]
    2d91:	mov    rbx,QWORD PTR [rbp-0x48]
    2d95:	mov    QWORD PTR [rax],rcx
    2d98:	mov    QWORD PTR [rax+0x8],rbx
    2d9c:	mov    rcx,QWORD PTR [rbp-0x40]
    2da0:	mov    rbx,QWORD PTR [rbp-0x38]
    2da4:	mov    QWORD PTR [rax+0x10],rcx
    2da8:	mov    QWORD PTR [rax+0x18],rbx
    2dac:	mov    rcx,QWORD PTR [rbp-0x30]
    2db0:	mov    rbx,QWORD PTR [rbp-0x28]
    2db4:	mov    QWORD PTR [rax+0x20],rcx
    2db8:	mov    QWORD PTR [rax+0x28],rbx
    2dbc:	mov    rdx,QWORD PTR [rbp-0x20]
    2dc0:	mov    QWORD PTR [rax+0x30],rdx
    2dc4:	call   1f5d <__profile_end_pass>
    2dc9:	add    rsp,0x40

  return outer;
    2dcd:	mov    rax,QWORD PTR [rbp-0x98]
}
    2dd4:	mov    rdx,QWORD PTR [rbp-0x18]
    2dd8:	sub    rdx,QWORD PTR fs:0x28
    2de1:	je     2de8 <parse_json+0x15d>
    2de3:	call   1060 <__stack_chk_fail@plt>
    2de8:	mov    rbx,QWORD PTR [rbp-0x8]
    2dec:	leave
    2ded:	ret

0000000000002dee <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2dee:	push   rbp
    2def:	mov    rbp,rsp
    2df2:	push   rbx
    2df3:	sub    rsp,0x78
    2df7:	mov    QWORD PTR [rbp-0x68],rdi
    2dfb:	mov    rax,rsi
    2dfe:	mov    rsi,rdx
    2e01:	mov    rax,rax
    2e04:	mov    edx,0x0
    2e09:	mov    rdx,rsi
    2e0c:	mov    QWORD PTR [rbp-0x80],rax
    2e10:	mov    QWORD PTR [rbp-0x78],rdx
    2e14:	mov    rax,QWORD PTR fs:0x28
    2e1d:	mov    QWORD PTR [rbp-0x18],rax
    2e21:	xor    eax,eax
  profile_begin_func();
    2e23:	lea    rcx,[rip+0x1a26]        # 4850 <__func__.1>
    2e2a:	mov    ebx,0x12
    2e2f:	lea    rax,[rbp-0x50]
    2e33:	mov    rsi,rcx
    2e36:	mov    rdx,rbx
    2e39:	mov    r8d,0x0
    2e3f:	mov    ecx,0x4
    2e44:	mov    rdi,rax
    2e47:	call   1e73 <__profile_begin_pass>

  JSON_Object *result = NULL;
    2e4c:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2e54:	cmp    QWORD PTR [rbp-0x68],0x0
    2e59:	je     2ea8 <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2e5b:	mov    rax,QWORD PTR [rbp-0x68]
    2e5f:	mov    rax,QWORD PTR [rax+0x20]
    2e63:	mov    QWORD PTR [rbp-0x58],rax
    2e67:	jmp    2ea1 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2e69:	mov    rax,QWORD PTR [rbp-0x58]
    2e6d:	mov    rdx,QWORD PTR [rax+0x8]
    2e71:	mov    rax,QWORD PTR [rax]
    2e74:	mov    rdi,QWORD PTR [rbp-0x80]
    2e78:	mov    rsi,QWORD PTR [rbp-0x78]
    2e7c:	mov    rcx,rdx
    2e7f:	mov    rdx,rax
    2e82:	call   143f <strings_equal>
    2e87:	test   al,al
    2e89:	je     2e95 <lookup_json_object+0xa7>
      {
        result = cursor;
    2e8b:	mov    rax,QWORD PTR [rbp-0x58]
    2e8f:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2e93:	jmp    2ea8 <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2e95:	mov    rax,QWORD PTR [rbp-0x58]
    2e99:	mov    rax,QWORD PTR [rax+0x28]
    2e9d:	mov    QWORD PTR [rbp-0x58],rax
    2ea1:	cmp    QWORD PTR [rbp-0x58],0x0
    2ea6:	jne    2e69 <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2ea8:	sub    rsp,0x8
    2eac:	sub    rsp,0x38
    2eb0:	mov    rax,rsp
    2eb3:	mov    rcx,QWORD PTR [rbp-0x50]
    2eb7:	mov    rbx,QWORD PTR [rbp-0x48]
    2ebb:	mov    QWORD PTR [rax],rcx
    2ebe:	mov    QWORD PTR [rax+0x8],rbx
    2ec2:	mov    rcx,QWORD PTR [rbp-0x40]
    2ec6:	mov    rbx,QWORD PTR [rbp-0x38]
    2eca:	mov    QWORD PTR [rax+0x10],rcx
    2ece:	mov    QWORD PTR [rax+0x18],rbx
    2ed2:	mov    rcx,QWORD PTR [rbp-0x30]
    2ed6:	mov    rbx,QWORD PTR [rbp-0x28]
    2eda:	mov    QWORD PTR [rax+0x20],rcx
    2ede:	mov    QWORD PTR [rax+0x28],rbx
    2ee2:	mov    rdx,QWORD PTR [rbp-0x20]
    2ee6:	mov    QWORD PTR [rax+0x30],rdx
    2eea:	call   1f5d <__profile_end_pass>
    2eef:	add    rsp,0x40

  return result;
    2ef3:	mov    rax,QWORD PTR [rbp-0x60]
}
    2ef7:	mov    rdx,QWORD PTR [rbp-0x18]
    2efb:	sub    rdx,QWORD PTR fs:0x28
    2f04:	je     2f0b <lookup_json_object+0x11d>
    2f06:	call   1060 <__stack_chk_fail@plt>
    2f0b:	mov    rbx,QWORD PTR [rbp-0x8]
    2f0f:	leave
    2f10:	ret

0000000000002f11 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    2f11:	push   rbp
    2f12:	mov    rbp,rsp
    2f15:	sub    rsp,0x50
    2f19:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    2f1d:	cmp    QWORD PTR [rbp-0x48],0x0
    2f22:	jne    2f49 <json_object_to_f64+0x38>
    2f24:	lea    rdx,[rip+0x1945]        # 4870 <__PRETTY_FUNCTION__.0>
    2f2b:	lea    rsi,[rip+0x1535]        # 4467 <_IO_stdin_used+0x467>
    2f32:	lea    rax,[rip+0x16a7]        # 45e0 <_IO_stdin_used+0x5e0>
    2f39:	mov    rcx,rdx
    2f3c:	mov    edx,0x1c2
    2f41:	mov    rdi,rax
    2f44:	call   1090 <__assert_fail@plt>

  String val = object->value;
    2f49:	mov    rax,QWORD PTR [rbp-0x48]
    2f4d:	mov    rdx,QWORD PTR [rax+0x18]
    2f51:	mov    rax,QWORD PTR [rax+0x10]
    2f55:	mov    QWORD PTR [rbp-0x10],rax
    2f59:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    2f5d:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    2f65:	movsd  xmm0,QWORD PTR [rip+0x192b]        # 4898 <__PRETTY_FUNCTION__.0+0x28>
    2f6d:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    2f72:	mov    rax,QWORD PTR [rbp-0x8]
    2f76:	cmp    QWORD PTR [rbp-0x30],rax
    2f7a:	jae    2fa0 <json_object_to_f64+0x8f>
    2f7c:	mov    rdx,QWORD PTR [rbp-0x10]
    2f80:	mov    rax,QWORD PTR [rbp-0x30]
    2f84:	add    rax,rdx
    2f87:	movzx  eax,BYTE PTR [rax]
    2f8a:	cmp    al,0x2d
    2f8c:	jne    2fa0 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    2f8e:	movsd  xmm0,QWORD PTR [rip+0x190a]        # 48a0 <__PRETTY_FUNCTION__.0+0x30>
    2f96:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    2f9b:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    2fa0:	pxor   xmm0,xmm0
    2fa4:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    2fa9:	jmp    2ff0 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    2fab:	mov    rdx,QWORD PTR [rbp-0x10]
    2faf:	mov    rax,QWORD PTR [rbp-0x30]
    2fb3:	add    rax,rdx
    2fb6:	movzx  eax,BYTE PTR [rax]
    2fb9:	sub    eax,0x30
    2fbc:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    2fbf:	cmp    BYTE PTR [rbp-0x32],0x9
    2fc3:	ja     2ffc <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    2fc5:	movsd  xmm1,QWORD PTR [rbp-0x20]
    2fca:	movsd  xmm0,QWORD PTR [rip+0x18d6]        # 48a8 <__PRETTY_FUNCTION__.0+0x38>
    2fd2:	mulsd  xmm1,xmm0
    2fd6:	movzx  eax,BYTE PTR [rbp-0x32]
    2fda:	pxor   xmm0,xmm0
    2fde:	cvtsi2sd xmm0,eax
    2fe2:	addsd  xmm0,xmm1
    2fe6:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    2feb:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    2ff0:	mov    rax,QWORD PTR [rbp-0x8]
    2ff4:	cmp    QWORD PTR [rbp-0x30],rax
    2ff8:	jb     2fab <json_object_to_f64+0x9a>
    2ffa:	jmp    2ffd <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    2ffc:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    2ffd:	mov    rax,QWORD PTR [rbp-0x8]
    3001:	cmp    QWORD PTR [rbp-0x30],rax
    3005:	jae    3092 <json_object_to_f64+0x181>
    300b:	mov    rdx,QWORD PTR [rbp-0x10]
    300f:	mov    rax,QWORD PTR [rbp-0x30]
    3013:	add    rax,rdx
    3016:	movzx  eax,BYTE PTR [rax]
    3019:	cmp    al,0x2e
    301b:	jne    3092 <json_object_to_f64+0x181>
  {
    at += 1;
    301d:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    3022:	movsd  xmm0,QWORD PTR [rip+0x1886]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    302a:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    302f:	jmp    3085 <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3031:	mov    rdx,QWORD PTR [rbp-0x10]
    3035:	mov    rax,QWORD PTR [rbp-0x30]
    3039:	add    rax,rdx
    303c:	movzx  eax,BYTE PTR [rax]
    303f:	sub    eax,0x30
    3042:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    3045:	cmp    BYTE PTR [rbp-0x31],0x9
    3049:	ja     3091 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    304b:	movzx  eax,BYTE PTR [rbp-0x31]
    304f:	pxor   xmm0,xmm0
    3053:	cvtsi2sd xmm0,eax
    3057:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    305c:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3061:	addsd  xmm0,xmm1
    3065:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    306a:	movsd  xmm1,QWORD PTR [rbp-0x18]
    306f:	movsd  xmm0,QWORD PTR [rip+0x1839]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    3077:	mulsd  xmm0,xmm1
    307b:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3080:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    3085:	mov    rax,QWORD PTR [rbp-0x8]
    3089:	cmp    QWORD PTR [rbp-0x30],rax
    308d:	jb     3031 <json_object_to_f64+0x120>
    308f:	jmp    3092 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    3091:	nop
      }
    }
  }

  return sign * result;
    3092:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3097:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    309c:	leave
    309d:	ret

000000000000309e <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    309e:	push   rbp
    309f:	mov    rbp,rsp
    30a2:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    30a7:	movsd  xmm0,QWORD PTR [rbp-0x8]
    30ac:	movsd  xmm1,QWORD PTR [rip+0x1804]        # 48b8 <__PRETTY_FUNCTION__.0+0x48>
    30b4:	divsd  xmm0,xmm1
}
    30b8:	pop    rbp
    30b9:	ret

00000000000030ba <square>:

static
f64 square(f64 x)
{
    30ba:	push   rbp
    30bb:	mov    rbp,rsp
    30be:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    30c3:	movsd  xmm0,QWORD PTR [rbp-0x8]
    30c8:	mulsd  xmm0,xmm0
}
    30cc:	pop    rbp
    30cd:	ret

00000000000030ce <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    30ce:	push   rbp
    30cf:	mov    rbp,rsp
    30d2:	sub    rsp,0x90
    30d9:	movsd  QWORD PTR [rbp-0x58],xmm0
    30de:	movsd  QWORD PTR [rbp-0x60],xmm1
    30e3:	movsd  QWORD PTR [rbp-0x68],xmm2
    30e8:	movsd  QWORD PTR [rbp-0x70],xmm3
    30ed:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    30f2:	movsd  xmm0,QWORD PTR [rbp-0x60]
    30f7:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    30fc:	movsd  xmm0,QWORD PTR [rbp-0x70]
    3101:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    3106:	movsd  xmm0,QWORD PTR [rbp-0x58]
    310b:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    3110:	movsd  xmm0,QWORD PTR [rbp-0x68]
    3115:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    311a:	movsd  xmm0,QWORD PTR [rbp-0x40]
    311f:	subsd  xmm0,QWORD PTR [rbp-0x48]
    3124:	movq   rax,xmm0
    3129:	movq   xmm0,rax
    312e:	call   309e <to_radians>
    3133:	movq   rax,xmm0
    3138:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    313c:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3141:	subsd  xmm0,QWORD PTR [rbp-0x38]
    3146:	movq   rax,xmm0
    314b:	movq   xmm0,rax
    3150:	call   309e <to_radians>
    3155:	movq   rax,xmm0
    315a:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    315e:	mov    rax,QWORD PTR [rbp-0x48]
    3162:	movq   xmm0,rax
    3167:	call   309e <to_radians>
    316c:	movq   rax,xmm0
    3171:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    3175:	mov    rax,QWORD PTR [rbp-0x40]
    3179:	movq   xmm0,rax
    317e:	call   309e <to_radians>
    3183:	movq   rax,xmm0
    3188:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    318c:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3191:	movsd  xmm1,QWORD PTR [rip+0x1727]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    3199:	divsd  xmm0,xmm1
    319d:	movq   rax,xmm0
    31a2:	movq   xmm0,rax
    31a7:	call   1130 <sin@plt>
    31ac:	movq   rax,xmm0
    31b1:	movq   xmm0,rax
    31b6:	call   30ba <square>
    31bb:	movsd  QWORD PTR [rbp-0x80],xmm0
    31c0:	mov    rax,QWORD PTR [rbp-0x48]
    31c4:	movq   xmm0,rax
    31c9:	call   10b0 <cos@plt>
    31ce:	movsd  QWORD PTR [rbp-0x88],xmm0
    31d6:	mov    rax,QWORD PTR [rbp-0x40]
    31da:	movq   xmm0,rax
    31df:	call   10b0 <cos@plt>
    31e4:	movapd xmm5,xmm0
    31e8:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    31f0:	movsd  QWORD PTR [rbp-0x88],xmm5
    31f8:	movsd  xmm0,QWORD PTR [rbp-0x20]
    31fd:	movsd  xmm1,QWORD PTR [rip+0x16bb]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    3205:	movapd xmm6,xmm0
    3209:	divsd  xmm6,xmm1
    320d:	movq   rax,xmm6
    3212:	movq   xmm0,rax
    3217:	call   1130 <sin@plt>
    321c:	movq   rax,xmm0
    3221:	movq   xmm0,rax
    3226:	call   30ba <square>
    322b:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    3233:	addsd  xmm0,QWORD PTR [rbp-0x80]
    3238:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    323d:	mov    rax,QWORD PTR [rbp-0x18]
    3241:	movq   xmm0,rax
    3246:	call   1160 <sqrt@plt>
    324b:	movq   rax,xmm0
    3250:	movq   xmm0,rax
    3255:	call   1140 <asin@plt>
    325a:	addsd  xmm0,xmm0
    325e:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    3263:	movsd  xmm0,QWORD PTR [rbp-0x78]
    3268:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    326d:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3272:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    3277:	leave
    3278:	ret

0000000000003279 <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    3279:	push   rbp
    327a:	mov    rbp,rsp
    327d:	movsd  QWORD PTR [rbp-0x18],xmm0
    3282:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    3287:	movsd  xmm0,QWORD PTR [rip+0x1639]        # 48c8 <__PRETTY_FUNCTION__.0+0x58>
    328f:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    3294:	movsd  xmm0,QWORD PTR [rbp-0x18]
    3299:	movq   xmm1,QWORD PTR [rip+0x162f]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    32a1:	andpd  xmm0,xmm1
    32a5:	movsd  xmm1,QWORD PTR [rbp-0x20]
    32aa:	movq   xmm2,QWORD PTR [rip+0x161e]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    32b2:	andpd  xmm2,xmm1
    32b6:	movapd xmm1,xmm0
    32ba:	subsd  xmm1,xmm2
    32be:	movsd  xmm0,QWORD PTR [rbp-0x8]
    32c3:	comisd xmm0,xmm1
    32c7:	setae  al
    32ca:	movzx  eax,al
}
    32cd:	pop    rbp
    32ce:	ret

00000000000032cf <main>:

int main(int args_count, char **args)
{
    32cf:	push   rbp
    32d0:	mov    rbp,rsp
    32d3:	push   r15
    32d5:	push   r14
    32d7:	push   r13
    32d9:	push   r12
    32db:	push   rbx
    32dc:	sub    rsp,0x2d8
    32e3:	mov    DWORD PTR [rbp-0x244],edi
    32e9:	mov    QWORD PTR [rbp-0x250],rsi
    32f0:	mov    rax,QWORD PTR fs:0x28
    32f9:	mov    QWORD PTR [rbp-0x38],rax
    32fd:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    32ff:	cmp    DWORD PTR [rbp-0x244],0x3
    3306:	je     3333 <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    3308:	mov    rax,QWORD PTR [rbp-0x250]
    330f:	mov    rax,QWORD PTR [rax]
    3312:	lea    rdx,[rip+0x12ff]        # 4618 <_IO_stdin_used+0x618>
    3319:	mov    rsi,rax
    331c:	mov    rdi,rdx
    331f:	mov    eax,0x0
    3324:	call   1070 <printf@plt>
    return 1;
    3329:	mov    eax,0x1
    332e:	jmp    3de7 <main+0xb18>
  }

  begin_profiling();
    3333:	call   1b3d <begin_profiling>

  Arena arena = {0};
    3338:	pxor   xmm0,xmm0
    333c:	movaps XMMWORD PTR [rbp-0x190],xmm0
    3343:	movaps XMMWORD PTR [rbp-0x180],xmm0
  arena = arena_make(GB(4));
    334a:	lea    rdx,[rbp-0x270]
    3351:	movabs rax,0x100000000
    335b:	mov    rsi,rax
    335e:	mov    rdi,rdx
    3361:	call   1632 <arena_make>
    3366:	mov    rax,QWORD PTR [rbp-0x270]
    336d:	mov    rdx,QWORD PTR [rbp-0x268]
    3374:	mov    QWORD PTR [rbp-0x190],rax
    337b:	mov    QWORD PTR [rbp-0x188],rdx
    3382:	mov    rax,QWORD PTR [rbp-0x260]
    3389:	mov    rdx,QWORD PTR [rbp-0x258]
    3390:	mov    QWORD PTR [rbp-0x180],rax
    3397:	mov    QWORD PTR [rbp-0x178],rdx

  String source = {0};
    339e:	mov    QWORD PTR [rbp-0x1a0],0x0
    33a9:	mov    QWORD PTR [rbp-0x198],0x0
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    33b4:	mov    rax,QWORD PTR [rbp-0x250]
    33bb:	add    rax,0x8
    33bf:	mov    rax,QWORD PTR [rax]
    33c2:	mov    rdi,rax
    33c5:	call   1303 <file_size>
    33ca:	mov    rcx,rax
    33cd:	lea    r12,[rip+0x1270]        # 4644 <_IO_stdin_used+0x644>
    33d4:	mov    r13d,0x4
    33da:	lea    rdi,[rbp-0x170]
    33e1:	mov    rdx,r12
    33e4:	mov    rax,r13
    33e7:	mov    r8,rcx
    33ea:	mov    ecx,0x5
    33ef:	mov    rsi,rdx
    33f2:	mov    rdx,rax
    33f5:	call   1e73 <__profile_begin_pass>
    33fa:	mov    QWORD PTR [rbp-0x230],0x0
    3405:	jmp    34a0 <main+0x1d1>
  {
    source = read_file_to_arena(&arena, args[1]);
    340a:	mov    rax,QWORD PTR [rbp-0x250]
    3411:	add    rax,0x8
    3415:	mov    rdx,QWORD PTR [rax]
    3418:	lea    rax,[rbp-0x190]
    341f:	mov    rsi,rdx
    3422:	mov    rdi,rax
    3425:	call   1357 <read_file_to_arena>
    342a:	mov    QWORD PTR [rbp-0x1a0],rax
    3431:	mov    QWORD PTR [rbp-0x198],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    3438:	add    QWORD PTR [rbp-0x230],0x1
    3440:	sub    rsp,0x8
    3444:	sub    rsp,0x38
    3448:	mov    rcx,rsp
    344b:	mov    rax,QWORD PTR [rbp-0x170]
    3452:	mov    rdx,QWORD PTR [rbp-0x168]
    3459:	mov    QWORD PTR [rcx],rax
    345c:	mov    QWORD PTR [rcx+0x8],rdx
    3460:	mov    rax,QWORD PTR [rbp-0x160]
    3467:	mov    rdx,QWORD PTR [rbp-0x158]
    346e:	mov    QWORD PTR [rcx+0x10],rax
    3472:	mov    QWORD PTR [rcx+0x18],rdx
    3476:	mov    rax,QWORD PTR [rbp-0x150]
    347d:	mov    rdx,QWORD PTR [rbp-0x148]
    3484:	mov    QWORD PTR [rcx+0x20],rax
    3488:	mov    QWORD PTR [rcx+0x28],rdx
    348c:	mov    rax,QWORD PTR [rbp-0x140]
    3493:	mov    QWORD PTR [rcx+0x30],rax
    3497:	call   1f5d <__profile_end_pass>
    349c:	add    rsp,0x40
    34a0:	cmp    QWORD PTR [rbp-0x230],0x0
    34a8:	je     340a <main+0x13b>
  }

  Haversine_Pair *pairs = NULL;
    34ae:	mov    QWORD PTR [rbp-0x228],0x0
  i32 pair_count = 0;
    34b9:	mov    DWORD PTR [rbp-0x238],0x0
  usize max_pairs = 0;
    34c3:	mov    QWORD PTR [rbp-0x220],0x0
  PROFILE_SCOPE("haversine alloc")
    34ce:	lea    r14,[rip+0x1174]        # 4649 <_IO_stdin_used+0x649>
    34d5:	mov    r15d,0xf
    34db:	lea    rdi,[rbp-0x130]
    34e2:	mov    rdx,r14
    34e5:	mov    rax,r15
    34e8:	mov    r8d,0x0
    34ee:	mov    ecx,0x6
    34f3:	mov    rsi,rdx
    34f6:	mov    rdx,rax
    34f9:	call   1e73 <__profile_begin_pass>
    34fe:	mov    QWORD PTR [rbp-0x218],0x0
    3509:	jmp    35d1 <main+0x302>
  {
    usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    350e:	mov    QWORD PTR [rbp-0x1a8],0x18
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    3519:	mov    rax,QWORD PTR [rbp-0x198]
    3520:	mov    edx,0x0
    3525:	div    QWORD PTR [rbp-0x1a8]
    352c:	mov    QWORD PTR [rbp-0x220],rax

    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    3533:	mov    rax,QWORD PTR [rbp-0x220]
    353a:	shl    rax,0x5
    353e:	mov    rcx,rax
    3541:	lea    rax,[rbp-0x190]
    3548:	mov    edx,0x8
    354d:	mov    rsi,rcx
    3550:	mov    rdi,rax
    3553:	call   17d3 <arena_alloc>
    3558:	mov    QWORD PTR [rbp-0x228],rax
    pair_count = 0;
    355f:	mov    DWORD PTR [rbp-0x238],0x0
  PROFILE_SCOPE("haversine alloc")
    3569:	add    QWORD PTR [rbp-0x218],0x1
    3571:	sub    rsp,0x8
    3575:	sub    rsp,0x38
    3579:	mov    rcx,rsp
    357c:	mov    rax,QWORD PTR [rbp-0x130]
    3583:	mov    rdx,QWORD PTR [rbp-0x128]
    358a:	mov    QWORD PTR [rcx],rax
    358d:	mov    QWORD PTR [rcx+0x8],rdx
    3591:	mov    rax,QWORD PTR [rbp-0x120]
    3598:	mov    rdx,QWORD PTR [rbp-0x118]
    359f:	mov    QWORD PTR [rcx+0x10],rax
    35a3:	mov    QWORD PTR [rcx+0x18],rdx
    35a7:	mov    rax,QWORD PTR [rbp-0x110]
    35ae:	mov    rdx,QWORD PTR [rbp-0x108]
    35b5:	mov    QWORD PTR [rcx+0x20],rax
    35b9:	mov    QWORD PTR [rcx+0x28],rdx
    35bd:	mov    rax,QWORD PTR [rbp-0x100]
    35c4:	mov    QWORD PTR [rcx+0x30],rax
    35c8:	call   1f5d <__profile_end_pass>
    35cd:	add    rsp,0x40
    35d1:	cmp    QWORD PTR [rbp-0x218],0x0
    35d9:	je     350e <main+0x23f>
  }

  JSON_Object *root = NULL;
    35df:	mov    QWORD PTR [rbp-0x1d8],0x0
  root = parse_json(&arena, source);
    35ea:	mov    rcx,QWORD PTR [rbp-0x1a0]
    35f1:	mov    rdx,QWORD PTR [rbp-0x198]
    35f8:	lea    rax,[rbp-0x190]
    35ff:	mov    rsi,rcx
    3602:	mov    rdi,rax
    3605:	call   2c8b <parse_json>
    360a:	mov    QWORD PTR [rbp-0x1d8],rax

  f64 haversine_sum = 0.0;
    3611:	pxor   xmm0,xmm0
    3615:	movsd  QWORD PTR [rbp-0x1d0],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    361d:	lea    rax,[rip+0x1035]        # 4659 <_IO_stdin_used+0x659>
    3624:	mov    QWORD PTR [rbp-0x280],rax
    362b:	mov    QWORD PTR [rbp-0x278],0x5
    3636:	mov    rax,QWORD PTR [rbp-0x280]
    363d:	mov    rdx,QWORD PTR [rbp-0x278]
    3644:	mov    rcx,rax
    3647:	mov    rax,QWORD PTR [rbp-0x1d8]
    364e:	mov    rsi,rcx
    3651:	mov    rdi,rax
    3654:	call   2dee <lookup_json_object>
    3659:	mov    QWORD PTR [rbp-0x1c8],rax
  if (pairs)
    3660:	cmp    QWORD PTR [rbp-0x228],0x0
    3668:	je     38fd <main+0x62e>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    366e:	mov    rax,QWORD PTR [rbp-0x1c8]
    3675:	mov    rax,QWORD PTR [rax+0x20]
    3679:	mov    QWORD PTR [rbp-0x210],rax
    3680:	jmp    38de <main+0x60f>
    {
      PROFILE_SCOPE("child convert")
    3685:	lea    rax,[rip+0xfd3]        # 465f <_IO_stdin_used+0x65f>
    368c:	mov    QWORD PTR [rbp-0x2c0],rax
    3693:	mov    QWORD PTR [rbp-0x2b8],0xd
    369e:	lea    rdi,[rbp-0x70]
    36a2:	mov    rbx,QWORD PTR [rbp-0x2c0]
    36a9:	mov    rsi,QWORD PTR [rbp-0x2b8]
    36b0:	mov    rdx,rbx
    36b3:	mov    rax,rsi
    36b6:	mov    r8d,0x0
    36bc:	mov    ecx,0x7
    36c1:	mov    rsi,rdx
    36c4:	mov    rdx,rax
    36c7:	call   1e73 <__profile_begin_pass>
    36cc:	mov    QWORD PTR [rbp-0x208],0x0
    36d7:	jmp    38be <main+0x5ef>
      {
        Haversine_Pair pair =
        {
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    36dc:	lea    rax,[rip+0xf8a]        # 466d <_IO_stdin_used+0x66d>
    36e3:	mov    QWORD PTR [rbp-0x2d0],rax
    36ea:	mov    QWORD PTR [rbp-0x2c8],0x2
    36f5:	mov    rbx,QWORD PTR [rbp-0x2d0]
    36fc:	mov    rsi,QWORD PTR [rbp-0x2c8]
    3703:	mov    rax,rbx
    3706:	mov    rdx,rsi
    3709:	mov    rcx,QWORD PTR [rbp-0x210]
    3710:	mov    rsi,rax
    3713:	mov    rdi,rcx
    3716:	call   2dee <lookup_json_object>
    371b:	mov    rdi,rax
    371e:	call   2f11 <json_object_to_f64>
    3723:	movq   rax,xmm0
        Haversine_Pair pair =
    3728:	mov    QWORD PTR [rbp-0xb0],rax
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    372f:	lea    rax,[rip+0xf3a]        # 4670 <_IO_stdin_used+0x670>
    3736:	mov    QWORD PTR [rbp-0x2e0],rax
    373d:	mov    QWORD PTR [rbp-0x2d8],0x2
    3748:	mov    rax,QWORD PTR [rbp-0x2e0]
    374f:	mov    rdx,QWORD PTR [rbp-0x2d8]
    3756:	mov    rcx,rax
    3759:	mov    rax,QWORD PTR [rbp-0x210]
    3760:	mov    rsi,rcx
    3763:	mov    rdi,rax
    3766:	call   2dee <lookup_json_object>
    376b:	mov    rdi,rax
    376e:	call   2f11 <json_object_to_f64>
    3773:	movq   rax,xmm0
        Haversine_Pair pair =
    3778:	mov    QWORD PTR [rbp-0xa8],rax
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    377f:	lea    rax,[rip+0xeed]        # 4673 <_IO_stdin_used+0x673>
    3786:	mov    QWORD PTR [rbp-0x2f0],rax
    378d:	mov    QWORD PTR [rbp-0x2e8],0x2
    3798:	mov    rax,QWORD PTR [rbp-0x2f0]
    379f:	mov    rdx,QWORD PTR [rbp-0x2e8]
    37a6:	mov    rcx,rax
    37a9:	mov    rax,QWORD PTR [rbp-0x210]
    37b0:	mov    rsi,rcx
    37b3:	mov    rdi,rax
    37b6:	call   2dee <lookup_json_object>
    37bb:	mov    rdi,rax
    37be:	call   2f11 <json_object_to_f64>
    37c3:	movq   rax,xmm0
        Haversine_Pair pair =
    37c8:	mov    QWORD PTR [rbp-0xa0],rax
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    37cf:	lea    rax,[rip+0xea0]        # 4676 <_IO_stdin_used+0x676>
    37d6:	mov    QWORD PTR [rbp-0x300],rax
    37dd:	mov    QWORD PTR [rbp-0x2f8],0x2
    37e8:	mov    rax,QWORD PTR [rbp-0x300]
    37ef:	mov    rdx,QWORD PTR [rbp-0x2f8]
    37f6:	mov    rcx,rax
    37f9:	mov    rax,QWORD PTR [rbp-0x210]
    3800:	mov    rsi,rcx
    3803:	mov    rdi,rax
    3806:	call   2dee <lookup_json_object>
    380b:	mov    rdi,rax
    380e:	call   2f11 <json_object_to_f64>
    3813:	movq   rax,xmm0
        Haversine_Pair pair =
    3818:	mov    QWORD PTR [rbp-0x98],rax
        };

        pairs[pair_count] = pair;
    381f:	mov    eax,DWORD PTR [rbp-0x238]
    3825:	cdqe
    3827:	shl    rax,0x5
    382b:	mov    rdx,rax
    382e:	mov    rax,QWORD PTR [rbp-0x228]
    3835:	lea    rcx,[rdx+rax*1]
    3839:	mov    rax,QWORD PTR [rbp-0xb0]
    3840:	mov    rdx,QWORD PTR [rbp-0xa8]
    3847:	mov    QWORD PTR [rcx],rax
    384a:	mov    QWORD PTR [rcx+0x8],rdx
    384e:	mov    rax,QWORD PTR [rbp-0xa0]
    3855:	mov    rdx,QWORD PTR [rbp-0x98]
    385c:	mov    QWORD PTR [rcx+0x10],rax
    3860:	mov    QWORD PTR [rcx+0x18],rdx
        pair_count += 1;
    3864:	add    DWORD PTR [rbp-0x238],0x1
      PROFILE_SCOPE("child convert")
    386b:	add    QWORD PTR [rbp-0x208],0x1
    3873:	sub    rsp,0x8
    3877:	sub    rsp,0x38
    387b:	mov    rcx,rsp
    387e:	mov    rax,QWORD PTR [rbp-0x70]
    3882:	mov    rdx,QWORD PTR [rbp-0x68]
    3886:	mov    QWORD PTR [rcx],rax
    3889:	mov    QWORD PTR [rcx+0x8],rdx
    388d:	mov    rax,QWORD PTR [rbp-0x60]
    3891:	mov    rdx,QWORD PTR [rbp-0x58]
    3895:	mov    QWORD PTR [rcx+0x10],rax
    3899:	mov    QWORD PTR [rcx+0x18],rdx
    389d:	mov    rax,QWORD PTR [rbp-0x50]
    38a1:	mov    rdx,QWORD PTR [rbp-0x48]
    38a5:	mov    QWORD PTR [rcx+0x20],rax
    38a9:	mov    QWORD PTR [rcx+0x28],rdx
    38ad:	mov    rax,QWORD PTR [rbp-0x40]
    38b1:	mov    QWORD PTR [rcx+0x30],rax
    38b5:	call   1f5d <__profile_end_pass>
    38ba:	add    rsp,0x40
    38be:	cmp    QWORD PTR [rbp-0x208],0x0
    38c6:	je     36dc <main+0x40d>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    38cc:	mov    rax,QWORD PTR [rbp-0x210]
    38d3:	mov    rax,QWORD PTR [rax+0x28]
    38d7:	mov    QWORD PTR [rbp-0x210],rax
    38de:	cmp    QWORD PTR [rbp-0x210],0x0
    38e6:	je     38fd <main+0x62e>
    38e8:	mov    eax,DWORD PTR [rbp-0x238]
    38ee:	cdqe
    38f0:	cmp    rax,QWORD PTR [rbp-0x220]
    38f7:	jb     3685 <main+0x3b6>
      }
    }
  }

  f64 sum = 0.0;
    38fd:	pxor   xmm0,xmm0
    3901:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3909:	lea    rax,[rip+0xd69]        # 4679 <_IO_stdin_used+0x679>
    3910:	mov    QWORD PTR [rbp-0x290],rax
    3917:	mov    QWORD PTR [rbp-0x288],0x3
    3922:	lea    rax,[rbp-0xf0]
    3929:	mov    rcx,QWORD PTR [rbp-0x290]
    3930:	mov    rbx,QWORD PTR [rbp-0x288]
    3937:	mov    rsi,rcx
    393a:	mov    rdx,rbx
    393d:	mov    r8d,0x0
    3943:	mov    ecx,0x8
    3948:	mov    rdi,rax
    394b:	call   1e73 <__profile_begin_pass>
    3950:	mov    QWORD PTR [rbp-0x1f8],0x0
    395b:	jmp    3add <main+0x80e>
  {
    for (usize i = 0; i < pair_count; i++)
    3960:	mov    QWORD PTR [rbp-0x1f0],0x0
    396b:	jmp    3a40 <main+0x771>
    {
      f64 earth_radius = 6372.8;
    3970:	movsd  xmm0,QWORD PTR [rip+0xf68]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    3978:	movsd  QWORD PTR [rbp-0x1b8],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    3980:	mov    rax,QWORD PTR [rbp-0x1f0]
    3987:	shl    rax,0x5
    398b:	mov    rdx,rax
    398e:	mov    rax,QWORD PTR [rbp-0x228]
    3995:	add    rax,rdx
    3998:	movsd  xmm2,QWORD PTR [rax+0x18]
    399d:	mov    rax,QWORD PTR [rbp-0x1f0]
    39a4:	shl    rax,0x5
    39a8:	mov    rdx,rax
    39ab:	mov    rax,QWORD PTR [rbp-0x228]
    39b2:	add    rax,rdx
    39b5:	movsd  xmm1,QWORD PTR [rax+0x10]
    39ba:	mov    rax,QWORD PTR [rbp-0x1f0]
    39c1:	shl    rax,0x5
    39c5:	mov    rdx,rax
    39c8:	mov    rax,QWORD PTR [rbp-0x228]
    39cf:	add    rax,rdx
    39d2:	movsd  xmm0,QWORD PTR [rax+0x8]
    39d7:	mov    rax,QWORD PTR [rbp-0x1f0]
    39de:	shl    rax,0x5
    39e2:	mov    rdx,rax
    39e5:	mov    rax,QWORD PTR [rbp-0x228]
    39ec:	add    rax,rdx
    39ef:	mov    rax,QWORD PTR [rax]
    39f2:	movsd  xmm3,QWORD PTR [rbp-0x1b8]
    39fa:	movapd xmm4,xmm3
    39fe:	movapd xmm3,xmm2
    3a02:	movapd xmm2,xmm1
    3a06:	movapd xmm1,xmm0
    3a0a:	movq   xmm0,rax
    3a0f:	call   30ce <reference_haversine>
    3a14:	movq   rax,xmm0
    3a19:	mov    QWORD PTR [rbp-0x1b0],rax
      sum += result;
    3a20:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3a28:	addsd  xmm0,QWORD PTR [rbp-0x1b0]
    3a30:	movsd  QWORD PTR [rbp-0x200],xmm0
    for (usize i = 0; i < pair_count; i++)
    3a38:	add    QWORD PTR [rbp-0x1f0],0x1
    3a40:	mov    eax,DWORD PTR [rbp-0x238]
    3a46:	cdqe
    3a48:	cmp    QWORD PTR [rbp-0x1f0],rax
    3a4f:	jb     3970 <main+0x6a1>
    }
    sum /= pair_count;
    3a55:	pxor   xmm1,xmm1
    3a59:	cvtsi2sd xmm1,DWORD PTR [rbp-0x238]
    3a61:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3a69:	divsd  xmm0,xmm1
    3a6d:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3a75:	add    QWORD PTR [rbp-0x1f8],0x1
    3a7d:	sub    rsp,0x8
    3a81:	sub    rsp,0x38
    3a85:	mov    rax,rsp
    3a88:	mov    rcx,QWORD PTR [rbp-0xf0]
    3a8f:	mov    rbx,QWORD PTR [rbp-0xe8]
    3a96:	mov    QWORD PTR [rax],rcx
    3a99:	mov    QWORD PTR [rax+0x8],rbx
    3a9d:	mov    rcx,QWORD PTR [rbp-0xe0]
    3aa4:	mov    rbx,QWORD PTR [rbp-0xd8]
    3aab:	mov    QWORD PTR [rax+0x10],rcx
    3aaf:	mov    QWORD PTR [rax+0x18],rbx
    3ab3:	mov    rcx,QWORD PTR [rbp-0xd0]
    3aba:	mov    rbx,QWORD PTR [rbp-0xc8]
    3ac1:	mov    QWORD PTR [rax+0x20],rcx
    3ac5:	mov    QWORD PTR [rax+0x28],rbx
    3ac9:	mov    rdx,QWORD PTR [rbp-0xc0]
    3ad0:	mov    QWORD PTR [rax+0x30],rdx
    3ad4:	call   1f5d <__profile_end_pass>
    3ad9:	add    rsp,0x40
    3add:	cmp    QWORD PTR [rbp-0x1f8],0x0
    3ae5:	je     3960 <main+0x691>
  }

  PROFILE_SCOPE("check")
    3aeb:	lea    rax,[rip+0xb8b]        # 467d <_IO_stdin_used+0x67d>
    3af2:	mov    QWORD PTR [rbp-0x2a0],rax
    3af9:	mov    QWORD PTR [rbp-0x298],0x5
    3b04:	lea    rax,[rbp-0xb0]
    3b0b:	mov    rcx,QWORD PTR [rbp-0x2a0]
    3b12:	mov    rbx,QWORD PTR [rbp-0x298]
    3b19:	mov    rsi,rcx
    3b1c:	mov    rdx,rbx
    3b1f:	mov    r8d,0x0
    3b25:	mov    ecx,0x9
    3b2a:	mov    rdi,rax
    3b2d:	call   1e73 <__profile_begin_pass>
    3b32:	mov    QWORD PTR [rbp-0x1e8],0x0
    3b3d:	jmp    3d12 <main+0xa43>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3b42:	mov    rax,QWORD PTR [rbp-0x250]
    3b49:	add    rax,0x10
    3b4d:	mov    rdx,QWORD PTR [rax]
    3b50:	lea    rax,[rbp-0x190]
    3b57:	mov    rsi,rdx
    3b5a:	mov    rdi,rax
    3b5d:	call   1357 <read_file_to_arena>
    3b62:	mov    QWORD PTR [rbp-0x70],rax
    3b66:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3b6a:	mov    rax,QWORD PTR [rbp-0x68]
    3b6e:	cmp    rax,0xb
    3b72:	jbe    3c85 <main+0x9b6>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3b78:	mov    rax,QWORD PTR [rbp-0x70]
    3b7c:	movsd  xmm0,QWORD PTR [rax]
    3b80:	movsd  QWORD PTR [rbp-0x1c0],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3b88:	mov    rax,QWORD PTR [rbp-0x70]
    3b8c:	mov    eax,DWORD PTR [rax+0x8]
    3b8f:	mov    DWORD PTR [rbp-0x234],eax

      if (solution_pairs == pair_count)
    3b95:	mov    eax,DWORD PTR [rbp-0x234]
    3b9b:	cmp    eax,DWORD PTR [rbp-0x238]
    3ba1:	jne    3c49 <main+0x97a>
      {
        if (epsilon_equal(solution_sum, sum))
    3ba7:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3baf:	mov    rax,QWORD PTR [rbp-0x1c0]
    3bb6:	movapd xmm1,xmm0
    3bba:	movq   xmm0,rax
    3bbf:	call   3279 <epsilon_equal>
    3bc4:	test   eax,eax
    3bc6:	je     3c0a <main+0x93b>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3bc8:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3bd0:	mov    rax,QWORD PTR [rbp-0x1c0]
    3bd7:	lea    rdx,[rip+0xaaa]        # 4688 <_IO_stdin_used+0x688>
    3bde:	lea    rsi,[rip+0xad6]        # 46bb <_IO_stdin_used+0x6bb>
    3be5:	movapd xmm1,xmm0
    3be9:	movq   xmm0,rax
    3bee:	mov    rcx,rdx
    3bf1:	mov    edx,0x64
    3bf6:	mov    edi,0x3
    3bfb:	mov    eax,0x2
    3c00:	call   14a1 <log_message>
    3c05:	jmp    3cad <main+0x9de>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3c0a:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3c12:	mov    rax,QWORD PTR [rbp-0x1c0]
    3c19:	lea    rdx,[rip+0xab0]        # 46d0 <_IO_stdin_used+0x6d0>
    3c20:	lea    rsi,[rip+0xa94]        # 46bb <_IO_stdin_used+0x6bb>
    3c27:	movapd xmm1,xmm0
    3c2b:	movq   xmm0,rax
    3c30:	mov    rcx,rdx
    3c33:	mov    edx,0x68
    3c38:	mov    edi,0x1
    3c3d:	mov    eax,0x2
    3c42:	call   14a1 <log_message>
    3c47:	jmp    3cad <main+0x9de>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3c49:	mov    esi,DWORD PTR [rbp-0x238]
    3c4f:	mov    ecx,DWORD PTR [rbp-0x234]
    3c55:	lea    rdx,[rip+0xaac]        # 4708 <_IO_stdin_used+0x708>
    3c5c:	lea    rax,[rip+0xa58]        # 46bb <_IO_stdin_used+0x6bb>
    3c63:	mov    r9d,esi
    3c66:	mov    r8d,ecx
    3c69:	mov    rcx,rdx
    3c6c:	mov    edx,0x6d
    3c71:	mov    rsi,rax
    3c74:	mov    edi,0x1
    3c79:	mov    eax,0x0
    3c7e:	call   14a1 <log_message>
    3c83:	jmp    3cad <main+0x9de>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3c85:	lea    rdx,[rip+0xac4]        # 4750 <_IO_stdin_used+0x750>
    3c8c:	lea    rax,[rip+0xa28]        # 46bb <_IO_stdin_used+0x6bb>
    3c93:	mov    rcx,rdx
    3c96:	mov    edx,0x72
    3c9b:	mov    rsi,rax
    3c9e:	mov    edi,0x1
    3ca3:	mov    eax,0x0
    3ca8:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3cad:	add    QWORD PTR [rbp-0x1e8],0x1
    3cb5:	sub    rsp,0x8
    3cb9:	sub    rsp,0x38
    3cbd:	mov    rax,rsp
    3cc0:	mov    rcx,QWORD PTR [rbp-0xb0]
    3cc7:	mov    rbx,QWORD PTR [rbp-0xa8]
    3cce:	mov    QWORD PTR [rax],rcx
    3cd1:	mov    QWORD PTR [rax+0x8],rbx
    3cd5:	mov    rcx,QWORD PTR [rbp-0xa0]
    3cdc:	mov    rbx,QWORD PTR [rbp-0x98]
    3ce3:	mov    QWORD PTR [rax+0x10],rcx
    3ce7:	mov    QWORD PTR [rax+0x18],rbx
    3ceb:	mov    rcx,QWORD PTR [rbp-0x90]
    3cf2:	mov    rbx,QWORD PTR [rbp-0x88]
    3cf9:	mov    QWORD PTR [rax+0x20],rcx
    3cfd:	mov    QWORD PTR [rax+0x28],rbx
    3d01:	mov    rdx,QWORD PTR [rbp-0x80]
    3d05:	mov    QWORD PTR [rax+0x30],rdx
    3d09:	call   1f5d <__profile_end_pass>
    3d0e:	add    rsp,0x40
    3d12:	cmp    QWORD PTR [rbp-0x1e8],0x0
    3d1a:	je     3b42 <main+0x873>
    }
  }

  PROFILE_SCOPE("free")
    3d20:	lea    rax,[rip+0xa64]        # 478b <_IO_stdin_used+0x78b>
    3d27:	mov    QWORD PTR [rbp-0x2b0],rax
    3d2e:	mov    QWORD PTR [rbp-0x2a8],0x4
    3d39:	lea    rax,[rbp-0x70]
    3d3d:	mov    rcx,QWORD PTR [rbp-0x2b0]
    3d44:	mov    rbx,QWORD PTR [rbp-0x2a8]
    3d4b:	mov    rsi,rcx
    3d4e:	mov    rdx,rbx
    3d51:	mov    r8d,0x0
    3d57:	mov    ecx,0xa
    3d5c:	mov    rdi,rax
    3d5f:	call   1e73 <__profile_begin_pass>
    3d64:	mov    QWORD PTR [rbp-0x1e0],0x0
    3d6f:	jmp    3dd3 <main+0xb04>
  {
    arena_free(&arena);
    3d71:	lea    rax,[rbp-0x190]
    3d78:	mov    rdi,rax
    3d7b:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3d80:	add    QWORD PTR [rbp-0x1e0],0x1
    3d88:	sub    rsp,0x8
    3d8c:	sub    rsp,0x38
    3d90:	mov    rax,rsp
    3d93:	mov    rcx,QWORD PTR [rbp-0x70]
    3d97:	mov    rbx,QWORD PTR [rbp-0x68]
    3d9b:	mov    QWORD PTR [rax],rcx
    3d9e:	mov    QWORD PTR [rax+0x8],rbx
    3da2:	mov    rcx,QWORD PTR [rbp-0x60]
    3da6:	mov    rbx,QWORD PTR [rbp-0x58]
    3daa:	mov    QWORD PTR [rax+0x10],rcx
    3dae:	mov    QWORD PTR [rax+0x18],rbx
    3db2:	mov    rcx,QWORD PTR [rbp-0x50]
    3db6:	mov    rbx,QWORD PTR [rbp-0x48]
    3dba:	mov    QWORD PTR [rax+0x20],rcx
    3dbe:	mov    QWORD PTR [rax+0x28],rbx
    3dc2:	mov    rdx,QWORD PTR [rbp-0x40]
    3dc6:	mov    QWORD PTR [rax+0x30],rdx
    3dca:	call   1f5d <__profile_end_pass>
    3dcf:	add    rsp,0x40
    3dd3:	cmp    QWORD PTR [rbp-0x1e0],0x0
    3ddb:	je     3d71 <main+0xaa2>
  }

  end_profiling();
    3ddd:	call   1b9b <end_profiling>
    3de2:	mov    eax,0x0
}
    3de7:	mov    rdx,QWORD PTR [rbp-0x38]
    3deb:	sub    rdx,QWORD PTR fs:0x28
    3df4:	je     3dfb <main+0xb2c>
    3df6:	call   1060 <__stack_chk_fail@plt>
    3dfb:	lea    rsp,[rbp-0x28]
    3dff:	pop    rbx
    3e00:	pop    r12
    3e02:	pop    r13
    3e04:	pop    r14
    3e06:	pop    r15
    3e08:	pop    rbp
    3e09:	ret

Disassembly of section .fini:

0000000000003e0c <_fini>:
    3e0c:	endbr64
    3e10:	sub    rsp,0x8
    3e14:	add    rsp,0x8
    3e18:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x4fc1]        # 5fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x4fca]        # 5ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x4fcc]        # 5ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x4fca]        # 6000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x4fc2]        # 6008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x4fba]        # 6010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x4fb2]        # 6018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x4faa]        # 6020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x4fa2]        # 6028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x4f9a]        # 6030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x4f92]        # 6038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x4f8a]        # 6040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x4f82]        # 6048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x4f7a]        # 6050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x4f72]        # 6058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x4f6a]        # 6060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x4f62]        # 6068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x4f5a]        # 6070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x4f52]        # 6078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x4f4a]        # 6080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x4f42]        # 6088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x4f3a]        # 6090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x4f32]        # 6098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2150]        # 32df <main>
    118f:	call   QWORD PTR [rip+0x4e2b]        # 5fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x4fa1]        # 6148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x4f9a]        # 6148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x4e0e]        # 5fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x4f71]        # 6148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x4f6a]        # 6148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x4ddd]        # 5fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x4f6d],0x0        # 6188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x4dba],0x0        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x4e76]        # 60a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x4da8]        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x4f44],0x1        # 6188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x4c6e]        # 6180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x4b89]        # 60c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x4be7]        # 6160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x4b2b]        # 60c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x3097]        # 4790 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x306b]        # 4790 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fae]        # 47a8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2eaf]        # 47b8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2ccd]        # 47d0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x4639]        # 61a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x4620],rbx        # 61a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x40
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x45ee]        # 61a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x30],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x30],0x0
    1bbe:	je     1e80 <end_profiling+0x2e5>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x28],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x30]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x28]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c51]        # 4888 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x28]
    1c44:	mov    rax,QWORD PTR [rbp-0x30]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x40],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x38],0x0
    1c72:	jmp    1e72 <end_profiling+0x2d7>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x38]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x450d]        # 61a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x20],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x20]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1e6d <end_profiling+0x2d2>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x20]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x30]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b77]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x18],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x20]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x20]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x20]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x20]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x18]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x20]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x20]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x20]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x30]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2a9f]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x10],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x20]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x10]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x40]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x18]
    1e2c:	movsd  QWORD PTR [rbp-0x40],xmm0

        if (zone->bytes_processed)
    1e31:	mov    rax,QWORD PTR [rbp-0x20]
    1e35:	mov    rax,QWORD PTR [rax+0x28]
    1e39:	test   rax,rax
    1e3c:	je     1e6d <end_profiling+0x2d2>
        {
          u64 gigabytes = zone->bytes_processed / GB(1);
    1e3e:	mov    rax,QWORD PTR [rbp-0x20]
    1e42:	mov    rax,QWORD PTR [rax+0x28]
    1e46:	shr    rax,0x1e
    1e4a:	mov    QWORD PTR [rbp-0x8],rax
          printf("  Bytes Processed: %lu\n", zone->bytes_processed);
    1e4e:	mov    rax,QWORD PTR [rbp-0x20]
    1e52:	mov    rax,QWORD PTR [rax+0x28]
    1e56:	lea    rdx,[rip+0x24e7]        # 4344 <_IO_stdin_used+0x344>
    1e5d:	mov    rsi,rax
    1e60:	mov    rdi,rdx
    1e63:	mov    eax,0x0
    1e68:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1e6d:	add    QWORD PTR [rbp-0x38],0x1
    1e72:	cmp    QWORD PTR [rbp-0x38],0xfff
    1e7a:	jbe    1c77 <end_profiling+0xdc>
        }
      }
    }
  }
}
    1e80:	nop
    1e81:	leave
    1e82:	ret

0000000000001e83 <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1e83:	push   rbp
    1e84:	mov    rbp,rsp
    1e87:	push   rbx
    1e88:	sub    rsp,0x78
    1e8c:	mov    QWORD PTR [rbp-0x58],rdi
    1e90:	mov    rax,rsi
    1e93:	mov    rsi,rdx
    1e96:	mov    rax,rax
    1e99:	mov    edx,0x0
    1e9e:	mov    rdx,rsi
    1ea1:	mov    QWORD PTR [rbp-0x70],rax
    1ea5:	mov    QWORD PTR [rbp-0x68],rdx
    1ea9:	mov    QWORD PTR [rbp-0x60],rcx
    1ead:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1eb1:	pxor   xmm0,xmm0
    1eb5:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1eb9:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1ebd:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1ec1:	movq   QWORD PTR [rbp-0x20],xmm0
    1ec6:	mov    rax,QWORD PTR [rbp-0x70]
    1eca:	mov    rdx,QWORD PTR [rbp-0x68]
    1ece:	mov    QWORD PTR [rbp-0x50],rax
    1ed2:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1ed6:	mov    rdx,QWORD PTR [rbp-0x60]
    1eda:	mov    rax,rdx
    1edd:	add    rax,rax
    1ee0:	add    rax,rdx
    1ee3:	shl    rax,0x4
    1ee7:	mov    rdx,rax
    1eea:	lea    rax,[rip+0x42d7]        # 61c8 <g_profiler+0x28>
    1ef1:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1ef5:	mov    QWORD PTR [rbp-0x38],rax
    1ef9:	mov    rax,QWORD PTR [rbp-0x60]
    1efd:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1f01:	mov    rax,QWORD PTR [rip+0x42a0]        # 61a8 <g_profiler+0x8>
  Profile_Pass pass =
    1f08:	mov    QWORD PTR [rbp-0x28],rax
    1f0c:	mov    rax,QWORD PTR [rbp-0x78]
    1f10:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    1f14:	mov    rax,QWORD PTR [rbp-0x60]
    1f18:	mov    QWORD PTR [rip+0x4289],rax        # 61a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    1f1f:	call   1a48 <read_cpu_timer>
    1f24:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    1f28:	mov    rax,QWORD PTR [rbp-0x58]
    1f2c:	mov    rcx,QWORD PTR [rbp-0x50]
    1f30:	mov    rbx,QWORD PTR [rbp-0x48]
    1f34:	mov    QWORD PTR [rax],rcx
    1f37:	mov    QWORD PTR [rax+0x8],rbx
    1f3b:	mov    rcx,QWORD PTR [rbp-0x40]
    1f3f:	mov    rbx,QWORD PTR [rbp-0x38]
    1f43:	mov    QWORD PTR [rax+0x10],rcx
    1f47:	mov    QWORD PTR [rax+0x18],rbx
    1f4b:	mov    rcx,QWORD PTR [rbp-0x30]
    1f4f:	mov    rbx,QWORD PTR [rbp-0x28]
    1f53:	mov    QWORD PTR [rax+0x20],rcx
    1f57:	mov    QWORD PTR [rax+0x28],rbx
    1f5b:	mov    rdx,QWORD PTR [rbp-0x20]
    1f5f:	mov    QWORD PTR [rax+0x30],rdx
}
    1f63:	mov    rax,QWORD PTR [rbp-0x58]
    1f67:	mov    rbx,QWORD PTR [rbp-0x8]
    1f6b:	leave
    1f6c:	ret

0000000000001f6d <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    1f6d:	push   rbp
    1f6e:	mov    rbp,rsp
    1f71:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    1f75:	call   1a48 <read_cpu_timer>
    1f7a:	mov    rdx,rax
    1f7d:	mov    rax,QWORD PTR [rbp+0x20]
    1f81:	sub    rdx,rax
    1f84:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    1f88:	mov    rax,QWORD PTR [rbp+0x38]
    1f8c:	mov    QWORD PTR [rip+0x4215],rax        # 61a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    1f93:	mov    rdx,QWORD PTR [rbp+0x30]
    1f97:	mov    rax,rdx
    1f9a:	add    rax,rax
    1f9d:	add    rax,rdx
    1fa0:	shl    rax,0x4
    1fa4:	lea    rdx,[rax+0x10]
    1fa8:	lea    rax,[rip+0x41f1]        # 61a0 <g_profiler>
    1faf:	add    rax,rdx
    1fb2:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    1fb6:	mov    rax,QWORD PTR [rbp-0x10]
    1fba:	mov    rdx,QWORD PTR [rax+0x10]
    1fbe:	mov    rax,QWORD PTR [rbp-0x18]
    1fc2:	add    rdx,rax
    1fc5:	mov    rax,QWORD PTR [rbp-0x10]
    1fc9:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    1fcd:	mov    rax,QWORD PTR [rbp-0x10]
    1fd1:	mov    rax,QWORD PTR [rax+0x20]
    1fd5:	lea    rdx,[rax+0x1]
    1fd9:	mov    rax,QWORD PTR [rbp-0x10]
    1fdd:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    1fe1:	mov    rcx,QWORD PTR [rbp-0x10]
    1fe5:	mov    rax,QWORD PTR [rbp+0x10]
    1fe9:	mov    rdx,QWORD PTR [rbp+0x18]
    1fed:	mov    QWORD PTR [rcx],rax
    1ff0:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    1ff4:	mov    rdx,QWORD PTR [rbp+0x28]
    1ff8:	mov    rax,QWORD PTR [rbp-0x18]
    1ffc:	add    rdx,rax
    1fff:	mov    rax,QWORD PTR [rbp-0x10]
    2003:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    2007:	mov    rax,QWORD PTR [rbp-0x10]
    200b:	mov    rdx,QWORD PTR [rax+0x28]
    200f:	mov    rax,QWORD PTR [rbp+0x40]
    2013:	add    rdx,rax
    2016:	mov    rax,QWORD PTR [rbp-0x10]
    201a:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    201e:	mov    rdx,QWORD PTR [rbp+0x38]
    2022:	mov    rax,rdx
    2025:	add    rax,rax
    2028:	add    rax,rdx
    202b:	shl    rax,0x4
    202f:	lea    rdx,[rax+0x10]
    2033:	lea    rax,[rip+0x4166]        # 61a0 <g_profiler>
    203a:	add    rax,rdx
    203d:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    2041:	mov    rax,QWORD PTR [rbp-0x8]
    2045:	mov    rax,QWORD PTR [rax+0x10]
    2049:	sub    rax,QWORD PTR [rbp-0x18]
    204d:	mov    rdx,rax
    2050:	mov    rax,QWORD PTR [rbp-0x8]
    2054:	mov    QWORD PTR [rax+0x10],rdx
}
    2058:	nop
    2059:	leave
    205a:	ret

000000000000205b <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    205b:	push   rbp
    205c:	mov    rbp,rsp
    205f:	sub    rsp,0x10
    2063:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2067:	mov    rax,QWORD PTR [rbp-0x8]
    206b:	mov    rdx,QWORD PTR [rax+0x10]
    206f:	mov    rax,QWORD PTR [rbp-0x8]
    2073:	mov    rax,QWORD PTR [rax+0x8]
    2077:	cmp    rdx,rax
    207a:	jb     20a1 <parser_at+0x46>
    207c:	lea    rdx,[rip+0x2765]        # 47e8 <__PRETTY_FUNCTION__.5>
    2083:	lea    rsi,[rip+0x23dd]        # 4467 <_IO_stdin_used+0x467>
    208a:	lea    rax,[rip+0x23e7]        # 4478 <_IO_stdin_used+0x478>
    2091:	mov    rcx,rdx
    2094:	mov    edx,0x2f
    2099:	mov    rdi,rax
    209c:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    20a1:	mov    rax,QWORD PTR [rbp-0x8]
    20a5:	mov    rdx,QWORD PTR [rax]
    20a8:	mov    rax,QWORD PTR [rbp-0x8]
    20ac:	mov    rax,QWORD PTR [rax+0x10]
    20b0:	add    rax,rdx
}
    20b3:	leave
    20b4:	ret

00000000000020b5 <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    20b5:	push   rbp
    20b6:	mov    rbp,rsp
    20b9:	sub    rsp,0x10
    20bd:	mov    QWORD PTR [rbp-0x8],rdi
    20c1:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    20c5:	mov    rax,QWORD PTR [rbp-0x8]
    20c9:	mov    rdi,rax
    20cc:	call   205b <parser_at>
    20d1:	mov    rdx,QWORD PTR [rbp-0x10]
    20d5:	add    rax,rdx
}
    20d8:	leave
    20d9:	ret

00000000000020da <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    20da:	push   rbp
    20db:	mov    rbp,rsp
    20de:	mov    QWORD PTR [rbp-0x8],rdi
    20e2:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    20e6:	mov    rax,QWORD PTR [rbp-0x8]
    20ea:	mov    rdx,QWORD PTR [rax+0x10]
    20ee:	mov    rax,QWORD PTR [rbp-0x10]
    20f2:	add    rdx,rax
    20f5:	mov    rax,QWORD PTR [rbp-0x8]
    20f9:	mov    QWORD PTR [rax+0x10],rdx
}
    20fd:	nop
    20fe:	pop    rbp
    20ff:	ret

0000000000002100 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    2100:	push   rbp
    2101:	mov    rbp,rsp
    2104:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    2108:	mov    rax,QWORD PTR [rbp-0x8]
    210c:	mov    rdx,QWORD PTR [rax+0x10]
    2110:	mov    rax,QWORD PTR [rbp-0x8]
    2114:	mov    rax,QWORD PTR [rax+0x8]
    2118:	cmp    rdx,rax
    211b:	setb   al
}
    211e:	pop    rbp
    211f:	ret

0000000000002120 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    2120:	push   rbp
    2121:	mov    rbp,rsp
    2124:	push   r12
    2126:	push   rbx
    2127:	sub    rsp,0x20
    212b:	mov    QWORD PTR [rbp-0x18],rdi
    212f:	mov    rax,rsi
    2132:	mov    rcx,rdx
    2135:	mov    rax,rax
    2138:	mov    edx,0x0
    213d:	mov    rdx,rcx
    2140:	mov    QWORD PTR [rbp-0x30],rax
    2144:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    2148:	mov    rax,QWORD PTR [rbp-0x28]
    214c:	mov    r12,rax
    214f:	mov    rbx,QWORD PTR [rbp-0x30]
    2153:	mov    rax,QWORD PTR [rbp-0x18]
    2157:	mov    rdi,rax
    215a:	call   205b <parser_at>
    215f:	mov    rdx,r12
    2162:	mov    rsi,rbx
    2165:	mov    rdi,rax
    2168:	call   10d0 <memcmp@plt>
    216d:	test   eax,eax
    216f:	sete   al
}
    2172:	add    rsp,0x20
    2176:	pop    rbx
    2177:	pop    r12
    2179:	pop    rbp
    217a:	ret

000000000000217b <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    217b:	push   rbp
    217c:	mov    rbp,rsp
    217f:	mov    eax,edi
    2181:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    2184:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    2188:	movzx  eax,BYTE PTR [rbp-0x14]
    218c:	cmp    eax,0x2e
    218f:	jg     2198 <is_numeric+0x1d>
    2191:	cmp    eax,0x2d
    2194:	jge    21a0 <is_numeric+0x25>
    2196:	jmp    21a5 <is_numeric+0x2a>
    2198:	sub    eax,0x30
    219b:	cmp    eax,0x9
    219e:	ja     21a5 <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    21a0:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    21a4:	nop
  }


  return result;
    21a5:	movzx  eax,BYTE PTR [rbp-0x1]
}
    21a9:	pop    rbp
    21aa:	ret

00000000000021ab <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    21ab:	push   rbp
    21ac:	mov    rbp,rsp
    21af:	sub    rsp,0x50
    21b3:	mov    QWORD PTR [rbp-0x48],rdi
    21b7:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    21bb:	pxor   xmm0,xmm0
    21bf:	movaps XMMWORD PTR [rbp-0x20],xmm0
    21c3:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    21c8:	jmp    21db <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    21ca:	mov    rax,QWORD PTR [rbp-0x50]
    21ce:	mov    esi,0x1
    21d3:	mov    rdi,rax
    21d6:	call   20da <parser_advance>
  while (parser_incomplete(parser)  &&
    21db:	mov    rax,QWORD PTR [rbp-0x50]
    21df:	mov    rdi,rax
    21e2:	call   2100 <parser_incomplete>
    21e7:	test   al,al
    21e9:	je     2237 <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    21eb:	mov    rax,QWORD PTR [rbp-0x50]
    21ef:	mov    rdi,rax
    21f2:	call   205b <parser_at>
    21f7:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    21fa:	cmp    al,0x20
    21fc:	je     21ca <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    21fe:	mov    rax,QWORD PTR [rbp-0x50]
    2202:	mov    rdi,rax
    2205:	call   205b <parser_at>
    220a:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    220d:	cmp    al,0xa
    220f:	je     21ca <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    2211:	mov    rax,QWORD PTR [rbp-0x50]
    2215:	mov    rdi,rax
    2218:	call   205b <parser_at>
    221d:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    2220:	cmp    al,0xd
    2222:	je     21ca <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    2224:	mov    rax,QWORD PTR [rbp-0x50]
    2228:	mov    rdi,rax
    222b:	call   205b <parser_at>
    2230:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    2233:	cmp    al,0x9
    2235:	je     21ca <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    2237:	mov    rax,QWORD PTR [rbp-0x50]
    223b:	mov    rdi,rax
    223e:	call   2100 <parser_incomplete>
    2243:	test   al,al
    2245:	je     2672 <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    224b:	mov    rax,QWORD PTR [rbp-0x50]
    224f:	mov    rdi,rax
    2252:	call   205b <parser_at>
    2257:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    225b:	mov    rax,QWORD PTR [rbp-0x50]
    225f:	mov    rdi,rax
    2262:	call   205b <parser_at>
    2267:	movzx  eax,BYTE PTR [rax]
    226a:	movzx  eax,al
    226d:	cmp    eax,0x7d
    2270:	je     235d <get_json_token+0x1b2>
    2276:	cmp    eax,0x7d
    2279:	jg     2683 <get_json_token+0x4d8>
    227f:	cmp    eax,0x7b
    2282:	je     2338 <get_json_token+0x18d>
    2288:	cmp    eax,0x7b
    228b:	jg     2683 <get_json_token+0x4d8>
    2291:	cmp    eax,0x74
    2294:	je     24e0 <get_json_token+0x335>
    229a:	cmp    eax,0x74
    229d:	jg     2683 <get_json_token+0x4d8>
    22a3:	cmp    eax,0x6e
    22a6:	je     25f0 <get_json_token+0x445>
    22ac:	cmp    eax,0x6e
    22af:	jg     2683 <get_json_token+0x4d8>
    22b5:	cmp    eax,0x66
    22b8:	je     2568 <get_json_token+0x3bd>
    22be:	cmp    eax,0x66
    22c1:	jg     2683 <get_json_token+0x4d8>
    22c7:	cmp    eax,0x5d
    22ca:	je     23a7 <get_json_token+0x1fc>
    22d0:	cmp    eax,0x5d
    22d3:	jg     2683 <get_json_token+0x4d8>
    22d9:	cmp    eax,0x5b
    22dc:	je     2382 <get_json_token+0x1d7>
    22e2:	cmp    eax,0x5b
    22e5:	jg     2683 <get_json_token+0x4d8>
    22eb:	cmp    eax,0x3a
    22ee:	je     23f1 <get_json_token+0x246>
    22f4:	cmp    eax,0x3a
    22f7:	jg     2683 <get_json_token+0x4d8>
    22fd:	cmp    eax,0x39
    2300:	jg     2683 <get_json_token+0x4d8>
    2306:	cmp    eax,0x30
    2309:	jge    248f <get_json_token+0x2e4>
    230f:	cmp    eax,0x2e
    2312:	jg     2683 <get_json_token+0x4d8>
    2318:	cmp    eax,0x2d
    231b:	jge    248f <get_json_token+0x2e4>
    2321:	cmp    eax,0x22
    2324:	je     2416 <get_json_token+0x26b>
    232a:	cmp    eax,0x2c
    232d:	je     23cc <get_json_token+0x221>
    2333:	jmp    2683 <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    2338:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    233f:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2347:	mov    rax,QWORD PTR [rbp-0x50]
    234b:	mov    esi,0x1
    2350:	mov    rdi,rax
    2353:	call   20da <parser_advance>
      }
      break;
    2358:	jmp    2683 <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    235d:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    2364:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    236c:	mov    rax,QWORD PTR [rbp-0x50]
    2370:	mov    esi,0x1
    2375:	mov    rdi,rax
    2378:	call   20da <parser_advance>
      }
      break;
    237d:	jmp    2683 <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2382:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    2389:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2391:	mov    rax,QWORD PTR [rbp-0x50]
    2395:	mov    esi,0x1
    239a:	mov    rdi,rax
    239d:	call   20da <parser_advance>
      }
      break;
    23a2:	jmp    2683 <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    23a7:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    23ae:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    23b6:	mov    rax,QWORD PTR [rbp-0x50]
    23ba:	mov    esi,0x1
    23bf:	mov    rdi,rax
    23c2:	call   20da <parser_advance>
      }
      break;
    23c7:	jmp    2683 <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    23cc:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    23d3:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    23db:	mov    rax,QWORD PTR [rbp-0x50]
    23df:	mov    esi,0x1
    23e4:	mov    rdi,rax
    23e7:	call   20da <parser_advance>
      }
      break;
    23ec:	jmp    2683 <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    23f1:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    23f8:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2400:	mov    rax,QWORD PTR [rbp-0x50]
    2404:	mov    esi,0x1
    2409:	mov    rdi,rax
    240c:	call   20da <parser_advance>
      }
      break;
    2411:	jmp    2683 <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    2416:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    241d:	mov    rax,QWORD PTR [rbp-0x50]
    2421:	mov    esi,0x1
    2426:	mov    rdi,rax
    2429:	call   20da <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    242e:	mov    rax,QWORD PTR [rbp-0x50]
    2432:	mov    rdi,rax
    2435:	call   205b <parser_at>
    243a:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    243e:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    2446:	jmp    245e <get_json_token+0x2b3>
        {
          string_count += 1;
    2448:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    244d:	mov    rax,QWORD PTR [rbp-0x50]
    2451:	mov    esi,0x1
    2456:	mov    rdi,rax
    2459:	call   20da <parser_advance>
        while (*parser_at(parser) != '"')
    245e:	mov    rax,QWORD PTR [rbp-0x50]
    2462:	mov    rdi,rax
    2465:	call   205b <parser_at>
    246a:	movzx  eax,BYTE PTR [rax]
    246d:	cmp    al,0x22
    246f:	jne    2448 <get_json_token+0x29d>
        }
        token.value.count = string_count;
    2471:	mov    rax,QWORD PTR [rbp-0x40]
    2475:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    2479:	mov    rax,QWORD PTR [rbp-0x50]
    247d:	mov    esi,0x1
    2482:	mov    rdi,rax
    2485:	call   20da <parser_advance>
      }
      break;
    248a:	jmp    2683 <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    248f:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    2496:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    249e:	jmp    24b6 <get_json_token+0x30b>
        {
          digit_count += 1;
    24a0:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    24a5:	mov    rax,QWORD PTR [rbp-0x50]
    24a9:	mov    esi,0x1
    24ae:	mov    rdi,rax
    24b1:	call   20da <parser_advance>
        while (is_numeric(*parser_at(parser)))
    24b6:	mov    rax,QWORD PTR [rbp-0x50]
    24ba:	mov    rdi,rax
    24bd:	call   205b <parser_at>
    24c2:	movzx  eax,BYTE PTR [rax]
    24c5:	movzx  eax,al
    24c8:	mov    edi,eax
    24ca:	call   217b <is_numeric>
    24cf:	test   al,al
    24d1:	jne    24a0 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    24d3:	mov    rax,QWORD PTR [rbp-0x38]
    24d7:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    24db:	jmp    2683 <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    24e0:	lea    rax,[rip+0x1fdd]        # 44c4 <_IO_stdin_used+0x4c4>
    24e7:	mov    QWORD PTR [rbp-0x30],rax
    24eb:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    24f3:	mov    rcx,QWORD PTR [rbp-0x30]
    24f7:	mov    rdx,QWORD PTR [rbp-0x28]
    24fb:	mov    rax,QWORD PTR [rbp-0x50]
    24ff:	mov    rsi,rcx
    2502:	mov    rdi,rax
    2505:	call   2120 <parser_token_is_literal>
    250a:	test   al,al
    250c:	je     2530 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    250e:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    2515:	mov    rax,QWORD PTR [rbp-0x28]
    2519:	mov    rdx,rax
    251c:	mov    rax,QWORD PTR [rbp-0x50]
    2520:	mov    rsi,rdx
    2523:	mov    rdi,rax
    2526:	call   20da <parser_advance>
    252b:	jmp    2683 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2530:	mov    rax,QWORD PTR [rbp-0x50]
    2534:	mov    rcx,QWORD PTR [rax+0x10]
    2538:	lea    rdx,[rip+0x1f91]        # 44d0 <_IO_stdin_used+0x4d0>
    253f:	lea    rax,[rip+0x1f21]        # 4467 <_IO_stdin_used+0x467>
    2546:	mov    r8,rcx
    2549:	mov    rcx,rdx
    254c:	mov    edx,0xdf
    2551:	mov    rsi,rax
    2554:	mov    edi,0x1
    2559:	mov    eax,0x0
    255e:	call   14a1 <log_message>
        }
      }
      break;
    2563:	jmp    2683 <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    2568:	lea    rax,[rip+0x1f8e]        # 44fd <_IO_stdin_used+0x4fd>
    256f:	mov    QWORD PTR [rbp-0x30],rax
    2573:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    257b:	mov    rcx,QWORD PTR [rbp-0x30]
    257f:	mov    rdx,QWORD PTR [rbp-0x28]
    2583:	mov    rax,QWORD PTR [rbp-0x50]
    2587:	mov    rsi,rcx
    258a:	mov    rdi,rax
    258d:	call   2120 <parser_token_is_literal>
    2592:	test   al,al
    2594:	je     25b8 <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    2596:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    259d:	mov    rax,QWORD PTR [rbp-0x28]
    25a1:	mov    rdx,rax
    25a4:	mov    rax,QWORD PTR [rbp-0x50]
    25a8:	mov    rsi,rdx
    25ab:	mov    rdi,rax
    25ae:	call   20da <parser_advance>
    25b3:	jmp    2683 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    25b8:	mov    rax,QWORD PTR [rbp-0x50]
    25bc:	mov    rcx,QWORD PTR [rax+0x10]
    25c0:	lea    rdx,[rip+0x1f09]        # 44d0 <_IO_stdin_used+0x4d0>
    25c7:	lea    rax,[rip+0x1e99]        # 4467 <_IO_stdin_used+0x467>
    25ce:	mov    r8,rcx
    25d1:	mov    rcx,rdx
    25d4:	mov    edx,0xee
    25d9:	mov    rsi,rax
    25dc:	mov    edi,0x1
    25e1:	mov    eax,0x0
    25e6:	call   14a1 <log_message>
        }
      }
      break;
    25eb:	jmp    2683 <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    25f0:	lea    rax,[rip+0x1f0c]        # 4503 <_IO_stdin_used+0x503>
    25f7:	mov    QWORD PTR [rbp-0x30],rax
    25fb:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    2603:	mov    rcx,QWORD PTR [rbp-0x30]
    2607:	mov    rdx,QWORD PTR [rbp-0x28]
    260b:	mov    rax,QWORD PTR [rbp-0x50]
    260f:	mov    rsi,rcx
    2612:	mov    rdi,rax
    2615:	call   2120 <parser_token_is_literal>
    261a:	test   al,al
    261c:	je     263d <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    261e:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    2625:	mov    rax,QWORD PTR [rbp-0x28]
    2629:	mov    rdx,rax
    262c:	mov    rax,QWORD PTR [rbp-0x50]
    2630:	mov    rsi,rdx
    2633:	mov    rdi,rax
    2636:	call   20da <parser_advance>
    263b:	jmp    2683 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    263d:	mov    rax,QWORD PTR [rbp-0x50]
    2641:	mov    rcx,QWORD PTR [rax+0x10]
    2645:	lea    rdx,[rip+0x1e84]        # 44d0 <_IO_stdin_used+0x4d0>
    264c:	lea    rax,[rip+0x1e14]        # 4467 <_IO_stdin_used+0x467>
    2653:	mov    r8,rcx
    2656:	mov    rcx,rdx
    2659:	mov    edx,0xfd
    265e:	mov    rsi,rax
    2661:	mov    edi,0x1
    2666:	mov    eax,0x0
    266b:	call   14a1 <log_message>
        }
      }
      break;
    2670:	jmp    2683 <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    2672:	mov    rax,QWORD PTR [rbp-0x50]
    2676:	mov    esi,0x1
    267b:	mov    rdi,rax
    267e:	call   20da <parser_advance>
  }

  return token;
    2683:	mov    rcx,QWORD PTR [rbp-0x48]
    2687:	mov    rax,QWORD PTR [rbp-0x20]
    268b:	mov    rdx,QWORD PTR [rbp-0x18]
    268f:	mov    QWORD PTR [rcx],rax
    2692:	mov    QWORD PTR [rcx+0x8],rdx
    2696:	mov    rax,QWORD PTR [rbp-0x10]
    269a:	mov    QWORD PTR [rcx+0x10],rax
}
    269e:	mov    rax,QWORD PTR [rbp-0x48]
    26a2:	leave
    26a3:	ret

00000000000026a4 <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    26a4:	push   rbp
    26a5:	mov    rbp,rsp
    26a8:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    26ab:	cmp    DWORD PTR [rbp-0x14],0x7
    26af:	je     26c9 <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    26b1:	cmp    DWORD PTR [rbp-0x14],0x9
    26b5:	je     26c9 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    26b7:	cmp    DWORD PTR [rbp-0x14],0xa
    26bb:	je     26c9 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    26bd:	cmp    DWORD PTR [rbp-0x14],0xb
    26c1:	je     26c9 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    26c3:	cmp    DWORD PTR [rbp-0x14],0x8
    26c7:	jne    26d0 <json_token_type_is_value_type+0x2c>
    26c9:	mov    eax,0x1
    26ce:	jmp    26d5 <json_token_type_is_value_type+0x31>
    26d0:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    26d5:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    26d8:	mov    eax,DWORD PTR [rbp-0x4]
}
    26db:	pop    rbp
    26dc:	ret

00000000000026dd <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    26dd:	push   rbp
    26de:	mov    rbp,rsp
    26e1:	push   rbx
    26e2:	sub    rsp,0x88
    26e9:	mov    QWORD PTR [rbp-0x78],rdi
    26ed:	mov    QWORD PTR [rbp-0x80],rsi
    26f1:	mov    QWORD PTR [rbp-0x90],rdx
    26f8:	mov    QWORD PTR [rbp-0x88],rcx
    26ff:	mov    rax,QWORD PTR fs:0x28
    2708:	mov    QWORD PTR [rbp-0x18],rax
    270c:	xor    eax,eax
  profile_begin_func();
    270e:	lea    r8,[rip+0x20eb]        # 4800 <__func__.4>
    2715:	mov    r9d,0x11
    271b:	lea    rax,[rbp-0x50]
    271f:	mov    rsi,r8
    2722:	mov    rdx,r9
    2725:	mov    r8d,0x0
    272b:	mov    ecx,0x1
    2730:	mov    rdi,rax
    2733:	call   1e83 <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    2738:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2740:	mov    eax,DWORD PTR [rbp+0x10]
    2743:	cmp    eax,0x1
    2746:	jne    2772 <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    2748:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    274f:	mov    edx,DWORD PTR [rbp-0x64]
    2752:	mov    rsi,QWORD PTR [rbp-0x80]
    2756:	mov    rax,QWORD PTR [rbp-0x78]
    275a:	mov    ecx,edx
    275c:	mov    edx,0x2
    2761:	mov    rdi,rax
    2764:	call   28c4 <parse_json_children>
    2769:	mov    QWORD PTR [rbp-0x60],rax
    276d:	jmp    27fc <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2772:	mov    eax,DWORD PTR [rbp+0x10]
    2775:	cmp    eax,0x3
    2778:	jne    27a1 <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    277a:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2781:	mov    edx,DWORD PTR [rbp-0x68]
    2784:	mov    rsi,QWORD PTR [rbp-0x80]
    2788:	mov    rax,QWORD PTR [rbp-0x78]
    278c:	mov    ecx,edx
    278e:	mov    edx,0x4
    2793:	mov    rdi,rax
    2796:	call   28c4 <parse_json_children>
    279b:	mov    QWORD PTR [rbp-0x60],rax
    279f:	jmp    27fc <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    27a1:	mov    eax,DWORD PTR [rbp+0x10]
    27a4:	mov    edi,eax
    27a6:	call   26a4 <json_token_type_is_value_type>
    27ab:	test   eax,eax
    27ad:	jne    27fc <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    27af:	mov    eax,DWORD PTR [rbp+0x10]
    27b2:	mov    eax,eax
    27b4:	lea    rdx,[rax*8+0x0]
    27bc:	lea    rax,[rip+0x391d]        # 60e0 <JSON_Token_Type_strings>
    27c3:	mov    rcx,QWORD PTR [rdx+rax*1]
    27c7:	lea    rdx,[rip+0x1d3a]        # 4508 <_IO_stdin_used+0x508>
    27ce:	lea    rax,[rip+0x1c92]        # 4467 <_IO_stdin_used+0x467>
    27d5:	push   QWORD PTR [rbp+0x20]
    27d8:	push   QWORD PTR [rbp+0x18]
    27db:	mov    r8,rcx
    27de:	mov    rcx,rdx
    27e1:	mov    edx,0x134
    27e6:	mov    rsi,rax
    27e9:	mov    edi,0x1
    27ee:	mov    eax,0x0
    27f3:	call   14a1 <log_message>
    27f8:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    27fc:	mov    rax,QWORD PTR [rbp-0x78]
    2800:	mov    edx,0x8
    2805:	mov    esi,0x30
    280a:	mov    rdi,rax
    280d:	call   17d3 <arena_alloc>
    2812:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    2816:	mov    rcx,QWORD PTR [rbp-0x58]
    281a:	mov    rax,QWORD PTR [rbp-0x90]
    2821:	mov    rdx,QWORD PTR [rbp-0x88]
    2828:	mov    QWORD PTR [rcx],rax
    282b:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    282f:	mov    rax,QWORD PTR [rbp-0x58]
    2833:	mov    rdx,QWORD PTR [rbp-0x60]
    2837:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    283b:	mov    rax,QWORD PTR [rbp-0x58]
    283f:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    2847:	mov    rcx,QWORD PTR [rbp-0x58]
    284b:	mov    rax,QWORD PTR [rbp+0x18]
    284f:	mov    rdx,QWORD PTR [rbp+0x20]
    2853:	mov    QWORD PTR [rcx+0x10],rax
    2857:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    285b:	sub    rsp,0x8
    285f:	sub    rsp,0x38
    2863:	mov    rax,rsp
    2866:	mov    rcx,QWORD PTR [rbp-0x50]
    286a:	mov    rbx,QWORD PTR [rbp-0x48]
    286e:	mov    QWORD PTR [rax],rcx
    2871:	mov    QWORD PTR [rax+0x8],rbx
    2875:	mov    rcx,QWORD PTR [rbp-0x40]
    2879:	mov    rbx,QWORD PTR [rbp-0x38]
    287d:	mov    QWORD PTR [rax+0x10],rcx
    2881:	mov    QWORD PTR [rax+0x18],rbx
    2885:	mov    rcx,QWORD PTR [rbp-0x30]
    2889:	mov    rbx,QWORD PTR [rbp-0x28]
    288d:	mov    QWORD PTR [rax+0x20],rcx
    2891:	mov    QWORD PTR [rax+0x28],rbx
    2895:	mov    rdx,QWORD PTR [rbp-0x20]
    2899:	mov    QWORD PTR [rax+0x30],rdx
    289d:	call   1f6d <__profile_end_pass>
    28a2:	add    rsp,0x40

  return result;
    28a6:	mov    rax,QWORD PTR [rbp-0x58]
}
    28aa:	mov    rdx,QWORD PTR [rbp-0x18]
    28ae:	sub    rdx,QWORD PTR fs:0x28
    28b7:	je     28be <parse_json_object+0x1e1>
    28b9:	call   1060 <__stack_chk_fail@plt>
    28be:	mov    rbx,QWORD PTR [rbp-0x8]
    28c2:	leave
    28c3:	ret

00000000000028c4 <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    28c4:	push   rbp
    28c5:	mov    rbp,rsp
    28c8:	push   rbx
    28c9:	sub    rsp,0x108
    28d0:	mov    QWORD PTR [rbp-0xd8],rdi
    28d7:	mov    QWORD PTR [rbp-0xe0],rsi
    28de:	mov    DWORD PTR [rbp-0xe4],edx
    28e4:	mov    DWORD PTR [rbp-0xe8],ecx
    28ea:	mov    rax,QWORD PTR fs:0x28
    28f3:	mov    QWORD PTR [rbp-0x18],rax
    28f7:	xor    eax,eax
  profile_begin_func();
    28f9:	lea    r8,[rip+0x1f20]        # 4820 <__func__.3>
    2900:	mov    r9d,0x13
    2906:	lea    rax,[rbp-0x50]
    290a:	mov    rsi,r8
    290d:	mov    rdx,r9
    2910:	mov    r8d,0x0
    2916:	mov    ecx,0x2
    291b:	mov    rdi,rax
    291e:	call   1e83 <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2923:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    292e:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2939:	jmp    2c12 <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    293e:	pxor   xmm0,xmm0
    2942:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2949:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2951:	pxor   xmm0,xmm0
    2955:	movaps XMMWORD PTR [rbp-0x90],xmm0
    295c:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2961:	cmp    DWORD PTR [rbp-0xe8],0x0
    2968:	je     2a75 <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    296e:	lea    rax,[rbp-0xb0]
    2975:	mov    rdx,QWORD PTR [rbp-0xe0]
    297c:	mov    rsi,rdx
    297f:	mov    rdi,rax
    2982:	call   21ab <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2987:	mov    eax,DWORD PTR [rbp-0xb0]
    298d:	cmp    eax,0x7
    2990:	jne    2a11 <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2992:	lea    rax,[rbp-0x70]
    2996:	mov    rdx,QWORD PTR [rbp-0xe0]
    299d:	mov    rsi,rdx
    29a0:	mov    rdi,rax
    29a3:	call   21ab <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    29a8:	mov    eax,DWORD PTR [rbp-0x70]
    29ab:	cmp    eax,0x6
    29ae:	jne    29ce <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    29b0:	lea    rax,[rbp-0x90]
    29b7:	mov    rdx,QWORD PTR [rbp-0xe0]
    29be:	mov    rsi,rdx
    29c1:	mov    rdi,rax
    29c4:	call   21ab <get_json_token>
    29c9:	jmp    2ab5 <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    29ce:	mov    rcx,QWORD PTR [rbp-0xa8]
    29d5:	mov    rax,QWORD PTR [rbp-0xa0]
    29dc:	mov    esi,eax
    29de:	lea    rdx,[rip+0x1b73]        # 4558 <_IO_stdin_used+0x558>
    29e5:	lea    rax,[rip+0x1a7b]        # 4467 <_IO_stdin_used+0x467>
    29ec:	mov    r9,rcx
    29ef:	mov    r8d,esi
    29f2:	mov    rcx,rdx
    29f5:	mov    edx,0x15f
    29fa:	mov    rsi,rax
    29fd:	mov    edi,0x1
    2a02:	mov    eax,0x0
    2a07:	call   14a1 <log_message>
    2a0c:	jmp    2ab5 <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2a11:	mov    rcx,QWORD PTR [rbp-0xa8]
    2a18:	mov    rax,QWORD PTR [rbp-0xa0]
    2a1f:	mov    edi,eax
    2a21:	mov    eax,DWORD PTR [rbp-0xb0]
    2a27:	mov    eax,eax
    2a29:	lea    rdx,[rax*8+0x0]
    2a31:	lea    rax,[rip+0x36a8]        # 60e0 <JSON_Token_Type_strings>
    2a38:	mov    rsi,QWORD PTR [rdx+rax*1]
    2a3c:	lea    rdx,[rip+0x1b35]        # 4578 <_IO_stdin_used+0x578>
    2a43:	lea    rax,[rip+0x1a1d]        # 4467 <_IO_stdin_used+0x467>
    2a4a:	sub    rsp,0x8
    2a4e:	push   rcx
    2a4f:	mov    r9d,edi
    2a52:	mov    r8,rsi
    2a55:	mov    rcx,rdx
    2a58:	mov    edx,0x164
    2a5d:	mov    rsi,rax
    2a60:	mov    edi,0x1
    2a65:	mov    eax,0x0
    2a6a:	call   14a1 <log_message>
    2a6f:	add    rsp,0x10
    2a73:	jmp    2ab5 <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2a75:	lea    rax,[rbp-0x110]
    2a7c:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a83:	mov    rsi,rdx
    2a86:	mov    rdi,rax
    2a89:	call   21ab <get_json_token>
    2a8e:	mov    rax,QWORD PTR [rbp-0x110]
    2a95:	mov    rdx,QWORD PTR [rbp-0x108]
    2a9c:	mov    QWORD PTR [rbp-0x90],rax
    2aa3:	mov    QWORD PTR [rbp-0x88],rdx
    2aaa:	mov    rax,QWORD PTR [rbp-0x100]
    2ab1:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2ab5:	mov    eax,DWORD PTR [rbp-0x90]
    2abb:	cmp    DWORD PTR [rbp-0xe4],eax
    2ac1:	je     2c2b <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2ac7:	mov    rax,QWORD PTR [rbp-0xa8]
    2ace:	mov    rdx,QWORD PTR [rbp-0xa0]
    2ad5:	mov    r8,QWORD PTR [rbp-0xe0]
    2adc:	mov    rdi,QWORD PTR [rbp-0xd8]
    2ae3:	sub    rsp,0x8
    2ae7:	sub    rsp,0x18
    2aeb:	mov    rsi,rsp
    2aee:	mov    rcx,QWORD PTR [rbp-0x90]
    2af5:	mov    rbx,QWORD PTR [rbp-0x88]
    2afc:	mov    QWORD PTR [rsi],rcx
    2aff:	mov    QWORD PTR [rsi+0x8],rbx
    2b03:	mov    rcx,QWORD PTR [rbp-0x80]
    2b07:	mov    QWORD PTR [rsi+0x10],rcx
    2b0b:	mov    rcx,rdx
    2b0e:	mov    rdx,rax
    2b11:	mov    rsi,r8
    2b14:	call   26dd <parse_json_object>
    2b19:	add    rsp,0x20
    2b1d:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2b24:	cmp    QWORD PTR [rbp-0xb8],0x0
    2b2c:	je     2b76 <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2b2e:	cmp    QWORD PTR [rbp-0xc8],0x0
    2b36:	jne    2b56 <parse_json_children+0x292>
      {
        first_child        = object;
    2b38:	mov    rax,QWORD PTR [rbp-0xb8]
    2b3f:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2b46:	mov    rax,QWORD PTR [rbp-0xb8]
    2b4d:	mov    QWORD PTR [rbp-0xc0],rax
    2b54:	jmp    2b76 <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2b56:	mov    rax,QWORD PTR [rbp-0xc0]
    2b5d:	mov    rdx,QWORD PTR [rbp-0xb8]
    2b64:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2b68:	mov    rax,QWORD PTR [rbp-0xb8]
    2b6f:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2b76:	lea    rax,[rbp-0x70]
    2b7a:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b81:	mov    rsi,rdx
    2b84:	mov    rdi,rax
    2b87:	call   21ab <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2b8c:	mov    eax,DWORD PTR [rbp-0x70]
    2b8f:	cmp    DWORD PTR [rbp-0xe4],eax
    2b95:	je     2c2e <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2b9b:	mov    eax,DWORD PTR [rbp-0x70]
    2b9e:	cmp    eax,0x5
    2ba1:	je     2c12 <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2ba3:	mov    r8,QWORD PTR [rbp-0x68]
    2ba7:	mov    rax,QWORD PTR [rbp-0x60]
    2bab:	mov    r9d,eax
    2bae:	mov    eax,DWORD PTR [rbp-0x70]
    2bb1:	mov    eax,eax
    2bb3:	lea    rdx,[rax*8+0x0]
    2bbb:	lea    rax,[rip+0x351e]        # 60e0 <JSON_Token_Type_strings>
    2bc2:	mov    r10,QWORD PTR [rdx+rax*1]
    2bc6:	lea    rdi,[rip+0x19d3]        # 45a0 <_IO_stdin_used+0x5a0>
    2bcd:	lea    rsi,[rip+0x1893]        # 4467 <_IO_stdin_used+0x467>
    2bd4:	sub    rsp,0x18
    2bd8:	mov    rcx,rsp
    2bdb:	mov    rax,QWORD PTR [rbp-0x70]
    2bdf:	mov    rdx,QWORD PTR [rbp-0x68]
    2be3:	mov    QWORD PTR [rcx],rax
    2be6:	mov    QWORD PTR [rcx+0x8],rdx
    2bea:	mov    rax,QWORD PTR [rbp-0x60]
    2bee:	mov    QWORD PTR [rcx+0x10],rax
    2bf2:	push   r8
    2bf4:	mov    r8,r10
    2bf7:	mov    rcx,rdi
    2bfa:	mov    edx,0x18b
    2bff:	mov    edi,0x1
    2c04:	mov    eax,0x0
    2c09:	call   14a1 <log_message>
    2c0e:	add    rsp,0x20
  while (parser_incomplete(parser))
    2c12:	mov    rax,QWORD PTR [rbp-0xe0]
    2c19:	mov    rdi,rax
    2c1c:	call   2100 <parser_incomplete>
    2c21:	test   al,al
    2c23:	jne    293e <parse_json_children+0x7a>
    2c29:	jmp    2c2f <parse_json_children+0x36b>
      break;
    2c2b:	nop
    2c2c:	jmp    2c2f <parse_json_children+0x36b>
      break;
    2c2e:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2c2f:	sub    rsp,0x8
    2c33:	sub    rsp,0x38
    2c37:	mov    rax,rsp
    2c3a:	mov    rcx,QWORD PTR [rbp-0x50]
    2c3e:	mov    rbx,QWORD PTR [rbp-0x48]
    2c42:	mov    QWORD PTR [rax],rcx
    2c45:	mov    QWORD PTR [rax+0x8],rbx
    2c49:	mov    rcx,QWORD PTR [rbp-0x40]
    2c4d:	mov    rbx,QWORD PTR [rbp-0x38]
    2c51:	mov    QWORD PTR [rax+0x10],rcx
    2c55:	mov    QWORD PTR [rax+0x18],rbx
    2c59:	mov    rcx,QWORD PTR [rbp-0x30]
    2c5d:	mov    rbx,QWORD PTR [rbp-0x28]
    2c61:	mov    QWORD PTR [rax+0x20],rcx
    2c65:	mov    QWORD PTR [rax+0x28],rbx
    2c69:	mov    rdx,QWORD PTR [rbp-0x20]
    2c6d:	mov    QWORD PTR [rax+0x30],rdx
    2c71:	call   1f6d <__profile_end_pass>
    2c76:	add    rsp,0x40

  return first_child;
    2c7a:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2c81:	mov    rdx,QWORD PTR [rbp-0x18]
    2c85:	sub    rdx,QWORD PTR fs:0x28
    2c8e:	je     2c95 <parse_json_children+0x3d1>
    2c90:	call   1060 <__stack_chk_fail@plt>
    2c95:	mov    rbx,QWORD PTR [rbp-0x8]
    2c99:	leave
    2c9a:	ret

0000000000002c9b <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2c9b:	push   rbp
    2c9c:	mov    rbp,rsp
    2c9f:	push   rbx
    2ca0:	sub    rsp,0xb8
    2ca7:	mov    QWORD PTR [rbp-0xa8],rdi
    2cae:	mov    rax,rsi
    2cb1:	mov    rsi,rdx
    2cb4:	mov    rax,rax
    2cb7:	mov    edx,0x0
    2cbc:	mov    rdx,rsi
    2cbf:	mov    QWORD PTR [rbp-0xc0],rax
    2cc6:	mov    QWORD PTR [rbp-0xb8],rdx
    2ccd:	mov    rax,QWORD PTR fs:0x28
    2cd6:	mov    QWORD PTR [rbp-0x18],rax
    2cda:	xor    eax,eax
  profile_begin_func();
    2cdc:	lea    rcx,[rip+0x1b55]        # 4838 <__func__.2>
    2ce3:	mov    ebx,0xa
    2ce8:	lea    rax,[rbp-0x50]
    2cec:	mov    rsi,rcx
    2cef:	mov    rdx,rbx
    2cf2:	mov    r8d,0x0
    2cf8:	mov    ecx,0x3
    2cfd:	mov    rdi,rax
    2d00:	call   1e83 <__profile_begin_pass>

  JSON_Parser parser =
    2d05:	mov    rax,QWORD PTR [rbp-0xc0]
    2d0c:	mov    rdx,QWORD PTR [rbp-0xb8]
    2d13:	mov    QWORD PTR [rbp-0x90],rax
    2d1a:	mov    QWORD PTR [rbp-0x88],rdx
    2d21:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2d29:	lea    rax,[rbp-0x70]
    2d2d:	lea    rdx,[rbp-0x90]
    2d34:	mov    rsi,rdx
    2d37:	mov    rdi,rax
    2d3a:	call   21ab <get_json_token>
    2d3f:	mov    ecx,0x0
    2d44:	mov    ebx,0x0
    2d49:	lea    r8,[rbp-0x90]
    2d50:	mov    rdi,QWORD PTR [rbp-0xa8]
    2d57:	sub    rsp,0x8
    2d5b:	sub    rsp,0x18
    2d5f:	mov    rsi,rsp
    2d62:	mov    rax,QWORD PTR [rbp-0x70]
    2d66:	mov    rdx,QWORD PTR [rbp-0x68]
    2d6a:	mov    QWORD PTR [rsi],rax
    2d6d:	mov    QWORD PTR [rsi+0x8],rdx
    2d71:	mov    rax,QWORD PTR [rbp-0x60]
    2d75:	mov    QWORD PTR [rsi+0x10],rax
    2d79:	mov    rdx,rcx
    2d7c:	mov    rcx,rbx
    2d7f:	mov    rsi,r8
    2d82:	call   26dd <parse_json_object>
    2d87:	add    rsp,0x20
    2d8b:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2d92:	sub    rsp,0x8
    2d96:	sub    rsp,0x38
    2d9a:	mov    rax,rsp
    2d9d:	mov    rcx,QWORD PTR [rbp-0x50]
    2da1:	mov    rbx,QWORD PTR [rbp-0x48]
    2da5:	mov    QWORD PTR [rax],rcx
    2da8:	mov    QWORD PTR [rax+0x8],rbx
    2dac:	mov    rcx,QWORD PTR [rbp-0x40]
    2db0:	mov    rbx,QWORD PTR [rbp-0x38]
    2db4:	mov    QWORD PTR [rax+0x10],rcx
    2db8:	mov    QWORD PTR [rax+0x18],rbx
    2dbc:	mov    rcx,QWORD PTR [rbp-0x30]
    2dc0:	mov    rbx,QWORD PTR [rbp-0x28]
    2dc4:	mov    QWORD PTR [rax+0x20],rcx
    2dc8:	mov    QWORD PTR [rax+0x28],rbx
    2dcc:	mov    rdx,QWORD PTR [rbp-0x20]
    2dd0:	mov    QWORD PTR [rax+0x30],rdx
    2dd4:	call   1f6d <__profile_end_pass>
    2dd9:	add    rsp,0x40

  return outer;
    2ddd:	mov    rax,QWORD PTR [rbp-0x98]
}
    2de4:	mov    rdx,QWORD PTR [rbp-0x18]
    2de8:	sub    rdx,QWORD PTR fs:0x28
    2df1:	je     2df8 <parse_json+0x15d>
    2df3:	call   1060 <__stack_chk_fail@plt>
    2df8:	mov    rbx,QWORD PTR [rbp-0x8]
    2dfc:	leave
    2dfd:	ret

0000000000002dfe <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2dfe:	push   rbp
    2dff:	mov    rbp,rsp
    2e02:	push   rbx
    2e03:	sub    rsp,0x78
    2e07:	mov    QWORD PTR [rbp-0x68],rdi
    2e0b:	mov    rax,rsi
    2e0e:	mov    rsi,rdx
    2e11:	mov    rax,rax
    2e14:	mov    edx,0x0
    2e19:	mov    rdx,rsi
    2e1c:	mov    QWORD PTR [rbp-0x80],rax
    2e20:	mov    QWORD PTR [rbp-0x78],rdx
    2e24:	mov    rax,QWORD PTR fs:0x28
    2e2d:	mov    QWORD PTR [rbp-0x18],rax
    2e31:	xor    eax,eax
  profile_begin_func();
    2e33:	lea    rcx,[rip+0x1a16]        # 4850 <__func__.1>
    2e3a:	mov    ebx,0x12
    2e3f:	lea    rax,[rbp-0x50]
    2e43:	mov    rsi,rcx
    2e46:	mov    rdx,rbx
    2e49:	mov    r8d,0x0
    2e4f:	mov    ecx,0x4
    2e54:	mov    rdi,rax
    2e57:	call   1e83 <__profile_begin_pass>

  JSON_Object *result = NULL;
    2e5c:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2e64:	cmp    QWORD PTR [rbp-0x68],0x0
    2e69:	je     2eb8 <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2e6b:	mov    rax,QWORD PTR [rbp-0x68]
    2e6f:	mov    rax,QWORD PTR [rax+0x20]
    2e73:	mov    QWORD PTR [rbp-0x58],rax
    2e77:	jmp    2eb1 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2e79:	mov    rax,QWORD PTR [rbp-0x58]
    2e7d:	mov    rdx,QWORD PTR [rax+0x8]
    2e81:	mov    rax,QWORD PTR [rax]
    2e84:	mov    rdi,QWORD PTR [rbp-0x80]
    2e88:	mov    rsi,QWORD PTR [rbp-0x78]
    2e8c:	mov    rcx,rdx
    2e8f:	mov    rdx,rax
    2e92:	call   143f <strings_equal>
    2e97:	test   al,al
    2e99:	je     2ea5 <lookup_json_object+0xa7>
      {
        result = cursor;
    2e9b:	mov    rax,QWORD PTR [rbp-0x58]
    2e9f:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2ea3:	jmp    2eb8 <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2ea5:	mov    rax,QWORD PTR [rbp-0x58]
    2ea9:	mov    rax,QWORD PTR [rax+0x28]
    2ead:	mov    QWORD PTR [rbp-0x58],rax
    2eb1:	cmp    QWORD PTR [rbp-0x58],0x0
    2eb6:	jne    2e79 <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2eb8:	sub    rsp,0x8
    2ebc:	sub    rsp,0x38
    2ec0:	mov    rax,rsp
    2ec3:	mov    rcx,QWORD PTR [rbp-0x50]
    2ec7:	mov    rbx,QWORD PTR [rbp-0x48]
    2ecb:	mov    QWORD PTR [rax],rcx
    2ece:	mov    QWORD PTR [rax+0x8],rbx
    2ed2:	mov    rcx,QWORD PTR [rbp-0x40]
    2ed6:	mov    rbx,QWORD PTR [rbp-0x38]
    2eda:	mov    QWORD PTR [rax+0x10],rcx
    2ede:	mov    QWORD PTR [rax+0x18],rbx
    2ee2:	mov    rcx,QWORD PTR [rbp-0x30]
    2ee6:	mov    rbx,QWORD PTR [rbp-0x28]
    2eea:	mov    QWORD PTR [rax+0x20],rcx
    2eee:	mov    QWORD PTR [rax+0x28],rbx
    2ef2:	mov    rdx,QWORD PTR [rbp-0x20]
    2ef6:	mov    QWORD PTR [rax+0x30],rdx
    2efa:	call   1f6d <__profile_end_pass>
    2eff:	add    rsp,0x40

  return result;
    2f03:	mov    rax,QWORD PTR [rbp-0x60]
}
    2f07:	mov    rdx,QWORD PTR [rbp-0x18]
    2f0b:	sub    rdx,QWORD PTR fs:0x28
    2f14:	je     2f1b <lookup_json_object+0x11d>
    2f16:	call   1060 <__stack_chk_fail@plt>
    2f1b:	mov    rbx,QWORD PTR [rbp-0x8]
    2f1f:	leave
    2f20:	ret

0000000000002f21 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    2f21:	push   rbp
    2f22:	mov    rbp,rsp
    2f25:	sub    rsp,0x50
    2f29:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    2f2d:	cmp    QWORD PTR [rbp-0x48],0x0
    2f32:	jne    2f59 <json_object_to_f64+0x38>
    2f34:	lea    rdx,[rip+0x1935]        # 4870 <__PRETTY_FUNCTION__.0>
    2f3b:	lea    rsi,[rip+0x1525]        # 4467 <_IO_stdin_used+0x467>
    2f42:	lea    rax,[rip+0x1697]        # 45e0 <_IO_stdin_used+0x5e0>
    2f49:	mov    rcx,rdx
    2f4c:	mov    edx,0x1c2
    2f51:	mov    rdi,rax
    2f54:	call   1090 <__assert_fail@plt>

  String val = object->value;
    2f59:	mov    rax,QWORD PTR [rbp-0x48]
    2f5d:	mov    rdx,QWORD PTR [rax+0x18]
    2f61:	mov    rax,QWORD PTR [rax+0x10]
    2f65:	mov    QWORD PTR [rbp-0x10],rax
    2f69:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    2f6d:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    2f75:	movsd  xmm0,QWORD PTR [rip+0x191b]        # 4898 <__PRETTY_FUNCTION__.0+0x28>
    2f7d:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    2f82:	mov    rax,QWORD PTR [rbp-0x8]
    2f86:	cmp    QWORD PTR [rbp-0x30],rax
    2f8a:	jae    2fb0 <json_object_to_f64+0x8f>
    2f8c:	mov    rdx,QWORD PTR [rbp-0x10]
    2f90:	mov    rax,QWORD PTR [rbp-0x30]
    2f94:	add    rax,rdx
    2f97:	movzx  eax,BYTE PTR [rax]
    2f9a:	cmp    al,0x2d
    2f9c:	jne    2fb0 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    2f9e:	movsd  xmm0,QWORD PTR [rip+0x18fa]        # 48a0 <__PRETTY_FUNCTION__.0+0x30>
    2fa6:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    2fab:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    2fb0:	pxor   xmm0,xmm0
    2fb4:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    2fb9:	jmp    3000 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    2fbb:	mov    rdx,QWORD PTR [rbp-0x10]
    2fbf:	mov    rax,QWORD PTR [rbp-0x30]
    2fc3:	add    rax,rdx
    2fc6:	movzx  eax,BYTE PTR [rax]
    2fc9:	sub    eax,0x30
    2fcc:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    2fcf:	cmp    BYTE PTR [rbp-0x32],0x9
    2fd3:	ja     300c <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    2fd5:	movsd  xmm1,QWORD PTR [rbp-0x20]
    2fda:	movsd  xmm0,QWORD PTR [rip+0x18c6]        # 48a8 <__PRETTY_FUNCTION__.0+0x38>
    2fe2:	mulsd  xmm1,xmm0
    2fe6:	movzx  eax,BYTE PTR [rbp-0x32]
    2fea:	pxor   xmm0,xmm0
    2fee:	cvtsi2sd xmm0,eax
    2ff2:	addsd  xmm0,xmm1
    2ff6:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    2ffb:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    3000:	mov    rax,QWORD PTR [rbp-0x8]
    3004:	cmp    QWORD PTR [rbp-0x30],rax
    3008:	jb     2fbb <json_object_to_f64+0x9a>
    300a:	jmp    300d <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    300c:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    300d:	mov    rax,QWORD PTR [rbp-0x8]
    3011:	cmp    QWORD PTR [rbp-0x30],rax
    3015:	jae    30a2 <json_object_to_f64+0x181>
    301b:	mov    rdx,QWORD PTR [rbp-0x10]
    301f:	mov    rax,QWORD PTR [rbp-0x30]
    3023:	add    rax,rdx
    3026:	movzx  eax,BYTE PTR [rax]
    3029:	cmp    al,0x2e
    302b:	jne    30a2 <json_object_to_f64+0x181>
  {
    at += 1;
    302d:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    3032:	movsd  xmm0,QWORD PTR [rip+0x1876]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    303a:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    303f:	jmp    3095 <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3041:	mov    rdx,QWORD PTR [rbp-0x10]
    3045:	mov    rax,QWORD PTR [rbp-0x30]
    3049:	add    rax,rdx
    304c:	movzx  eax,BYTE PTR [rax]
    304f:	sub    eax,0x30
    3052:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    3055:	cmp    BYTE PTR [rbp-0x31],0x9
    3059:	ja     30a1 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    305b:	movzx  eax,BYTE PTR [rbp-0x31]
    305f:	pxor   xmm0,xmm0
    3063:	cvtsi2sd xmm0,eax
    3067:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    306c:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3071:	addsd  xmm0,xmm1
    3075:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    307a:	movsd  xmm1,QWORD PTR [rbp-0x18]
    307f:	movsd  xmm0,QWORD PTR [rip+0x1829]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    3087:	mulsd  xmm0,xmm1
    308b:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3090:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    3095:	mov    rax,QWORD PTR [rbp-0x8]
    3099:	cmp    QWORD PTR [rbp-0x30],rax
    309d:	jb     3041 <json_object_to_f64+0x120>
    309f:	jmp    30a2 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    30a1:	nop
      }
    }
  }

  return sign * result;
    30a2:	movsd  xmm0,QWORD PTR [rbp-0x28]
    30a7:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    30ac:	leave
    30ad:	ret

00000000000030ae <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    30ae:	push   rbp
    30af:	mov    rbp,rsp
    30b2:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    30b7:	movsd  xmm0,QWORD PTR [rbp-0x8]
    30bc:	movsd  xmm1,QWORD PTR [rip+0x17f4]        # 48b8 <__PRETTY_FUNCTION__.0+0x48>
    30c4:	divsd  xmm0,xmm1
}
    30c8:	pop    rbp
    30c9:	ret

00000000000030ca <square>:

static
f64 square(f64 x)
{
    30ca:	push   rbp
    30cb:	mov    rbp,rsp
    30ce:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    30d3:	movsd  xmm0,QWORD PTR [rbp-0x8]
    30d8:	mulsd  xmm0,xmm0
}
    30dc:	pop    rbp
    30dd:	ret

00000000000030de <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    30de:	push   rbp
    30df:	mov    rbp,rsp
    30e2:	sub    rsp,0x90
    30e9:	movsd  QWORD PTR [rbp-0x58],xmm0
    30ee:	movsd  QWORD PTR [rbp-0x60],xmm1
    30f3:	movsd  QWORD PTR [rbp-0x68],xmm2
    30f8:	movsd  QWORD PTR [rbp-0x70],xmm3
    30fd:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    3102:	movsd  xmm0,QWORD PTR [rbp-0x60]
    3107:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    310c:	movsd  xmm0,QWORD PTR [rbp-0x70]
    3111:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    3116:	movsd  xmm0,QWORD PTR [rbp-0x58]
    311b:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    3120:	movsd  xmm0,QWORD PTR [rbp-0x68]
    3125:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    312a:	movsd  xmm0,QWORD PTR [rbp-0x40]
    312f:	subsd  xmm0,QWORD PTR [rbp-0x48]
    3134:	movq   rax,xmm0
    3139:	movq   xmm0,rax
    313e:	call   30ae <to_radians>
    3143:	movq   rax,xmm0
    3148:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    314c:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3151:	subsd  xmm0,QWORD PTR [rbp-0x38]
    3156:	movq   rax,xmm0
    315b:	movq   xmm0,rax
    3160:	call   30ae <to_radians>
    3165:	movq   rax,xmm0
    316a:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    316e:	mov    rax,QWORD PTR [rbp-0x48]
    3172:	movq   xmm0,rax
    3177:	call   30ae <to_radians>
    317c:	movq   rax,xmm0
    3181:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    3185:	mov    rax,QWORD PTR [rbp-0x40]
    3189:	movq   xmm0,rax
    318e:	call   30ae <to_radians>
    3193:	movq   rax,xmm0
    3198:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    319c:	movsd  xmm0,QWORD PTR [rbp-0x28]
    31a1:	movsd  xmm1,QWORD PTR [rip+0x1717]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    31a9:	divsd  xmm0,xmm1
    31ad:	movq   rax,xmm0
    31b2:	movq   xmm0,rax
    31b7:	call   1130 <sin@plt>
    31bc:	movq   rax,xmm0
    31c1:	movq   xmm0,rax
    31c6:	call   30ca <square>
    31cb:	movsd  QWORD PTR [rbp-0x80],xmm0
    31d0:	mov    rax,QWORD PTR [rbp-0x48]
    31d4:	movq   xmm0,rax
    31d9:	call   10b0 <cos@plt>
    31de:	movsd  QWORD PTR [rbp-0x88],xmm0
    31e6:	mov    rax,QWORD PTR [rbp-0x40]
    31ea:	movq   xmm0,rax
    31ef:	call   10b0 <cos@plt>
    31f4:	movapd xmm5,xmm0
    31f8:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    3200:	movsd  QWORD PTR [rbp-0x88],xmm5
    3208:	movsd  xmm0,QWORD PTR [rbp-0x20]
    320d:	movsd  xmm1,QWORD PTR [rip+0x16ab]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    3215:	movapd xmm6,xmm0
    3219:	divsd  xmm6,xmm1
    321d:	movq   rax,xmm6
    3222:	movq   xmm0,rax
    3227:	call   1130 <sin@plt>
    322c:	movq   rax,xmm0
    3231:	movq   xmm0,rax
    3236:	call   30ca <square>
    323b:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    3243:	addsd  xmm0,QWORD PTR [rbp-0x80]
    3248:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    324d:	mov    rax,QWORD PTR [rbp-0x18]
    3251:	movq   xmm0,rax
    3256:	call   1160 <sqrt@plt>
    325b:	movq   rax,xmm0
    3260:	movq   xmm0,rax
    3265:	call   1140 <asin@plt>
    326a:	addsd  xmm0,xmm0
    326e:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    3273:	movsd  xmm0,QWORD PTR [rbp-0x78]
    3278:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    327d:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3282:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    3287:	leave
    3288:	ret

0000000000003289 <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    3289:	push   rbp
    328a:	mov    rbp,rsp
    328d:	movsd  QWORD PTR [rbp-0x18],xmm0
    3292:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    3297:	movsd  xmm0,QWORD PTR [rip+0x1629]        # 48c8 <__PRETTY_FUNCTION__.0+0x58>
    329f:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    32a4:	movsd  xmm0,QWORD PTR [rbp-0x18]
    32a9:	movq   xmm1,QWORD PTR [rip+0x161f]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    32b1:	andpd  xmm0,xmm1
    32b5:	movsd  xmm1,QWORD PTR [rbp-0x20]
    32ba:	movq   xmm2,QWORD PTR [rip+0x160e]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    32c2:	andpd  xmm2,xmm1
    32c6:	movapd xmm1,xmm0
    32ca:	subsd  xmm1,xmm2
    32ce:	movsd  xmm0,QWORD PTR [rbp-0x8]
    32d3:	comisd xmm0,xmm1
    32d7:	setae  al
    32da:	movzx  eax,al
}
    32dd:	pop    rbp
    32de:	ret

00000000000032df <main>:

int main(int args_count, char **args)
{
    32df:	push   rbp
    32e0:	mov    rbp,rsp
    32e3:	push   r15
    32e5:	push   r14
    32e7:	push   r13
    32e9:	push   r12
    32eb:	push   rbx
    32ec:	sub    rsp,0x2d8
    32f3:	mov    DWORD PTR [rbp-0x244],edi
    32f9:	mov    QWORD PTR [rbp-0x250],rsi
    3300:	mov    rax,QWORD PTR fs:0x28
    3309:	mov    QWORD PTR [rbp-0x38],rax
    330d:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    330f:	cmp    DWORD PTR [rbp-0x244],0x3
    3316:	je     3343 <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    3318:	mov    rax,QWORD PTR [rbp-0x250]
    331f:	mov    rax,QWORD PTR [rax]
    3322:	lea    rdx,[rip+0x12ef]        # 4618 <_IO_stdin_used+0x618>
    3329:	mov    rsi,rax
    332c:	mov    rdi,rdx
    332f:	mov    eax,0x0
    3334:	call   1070 <printf@plt>
    return 1;
    3339:	mov    eax,0x1
    333e:	jmp    3df7 <main+0xb18>
  }

  begin_profiling();
    3343:	call   1b3d <begin_profiling>

  Arena arena = {0};
    3348:	pxor   xmm0,xmm0
    334c:	movaps XMMWORD PTR [rbp-0x190],xmm0
    3353:	movaps XMMWORD PTR [rbp-0x180],xmm0
  arena = arena_make(GB(4));
    335a:	lea    rdx,[rbp-0x270]
    3361:	movabs rax,0x100000000
    336b:	mov    rsi,rax
    336e:	mov    rdi,rdx
    3371:	call   1632 <arena_make>
    3376:	mov    rax,QWORD PTR [rbp-0x270]
    337d:	mov    rdx,QWORD PTR [rbp-0x268]
    3384:	mov    QWORD PTR [rbp-0x190],rax
    338b:	mov    QWORD PTR [rbp-0x188],rdx
    3392:	mov    rax,QWORD PTR [rbp-0x260]
    3399:	mov    rdx,QWORD PTR [rbp-0x258]
    33a0:	mov    QWORD PTR [rbp-0x180],rax
    33a7:	mov    QWORD PTR [rbp-0x178],rdx

  String source = {0};
    33ae:	mov    QWORD PTR [rbp-0x1a0],0x0
    33b9:	mov    QWORD PTR [rbp-0x198],0x0
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    33c4:	mov    rax,QWORD PTR [rbp-0x250]
    33cb:	add    rax,0x8
    33cf:	mov    rax,QWORD PTR [rax]
    33d2:	mov    rdi,rax
    33d5:	call   1303 <file_size>
    33da:	mov    rcx,rax
    33dd:	lea    r12,[rip+0x1260]        # 4644 <_IO_stdin_used+0x644>
    33e4:	mov    r13d,0x4
    33ea:	lea    rdi,[rbp-0x170]
    33f1:	mov    rdx,r12
    33f4:	mov    rax,r13
    33f7:	mov    r8,rcx
    33fa:	mov    ecx,0x5
    33ff:	mov    rsi,rdx
    3402:	mov    rdx,rax
    3405:	call   1e83 <__profile_begin_pass>
    340a:	mov    QWORD PTR [rbp-0x230],0x0
    3415:	jmp    34b0 <main+0x1d1>
  {
    source = read_file_to_arena(&arena, args[1]);
    341a:	mov    rax,QWORD PTR [rbp-0x250]
    3421:	add    rax,0x8
    3425:	mov    rdx,QWORD PTR [rax]
    3428:	lea    rax,[rbp-0x190]
    342f:	mov    rsi,rdx
    3432:	mov    rdi,rax
    3435:	call   1357 <read_file_to_arena>
    343a:	mov    QWORD PTR [rbp-0x1a0],rax
    3441:	mov    QWORD PTR [rbp-0x198],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    3448:	add    QWORD PTR [rbp-0x230],0x1
    3450:	sub    rsp,0x8
    3454:	sub    rsp,0x38
    3458:	mov    rcx,rsp
    345b:	mov    rax,QWORD PTR [rbp-0x170]
    3462:	mov    rdx,QWORD PTR [rbp-0x168]
    3469:	mov    QWORD PTR [rcx],rax
    346c:	mov    QWORD PTR [rcx+0x8],rdx
    3470:	mov    rax,QWORD PTR [rbp-0x160]
    3477:	mov    rdx,QWORD PTR [rbp-0x158]
    347e:	mov    QWORD PTR [rcx+0x10],rax
    3482:	mov    QWORD PTR [rcx+0x18],rdx
    3486:	mov    rax,QWORD PTR [rbp-0x150]
    348d:	mov    rdx,QWORD PTR [rbp-0x148]
    3494:	mov    QWORD PTR [rcx+0x20],rax
    3498:	mov    QWORD PTR [rcx+0x28],rdx
    349c:	mov    rax,QWORD PTR [rbp-0x140]
    34a3:	mov    QWORD PTR [rcx+0x30],rax
    34a7:	call   1f6d <__profile_end_pass>
    34ac:	add    rsp,0x40
    34b0:	cmp    QWORD PTR [rbp-0x230],0x0
    34b8:	je     341a <main+0x13b>
  }

  Haversine_Pair *pairs = NULL;
    34be:	mov    QWORD PTR [rbp-0x228],0x0
  i32 pair_count = 0;
    34c9:	mov    DWORD PTR [rbp-0x238],0x0
  usize max_pairs = 0;
    34d3:	mov    QWORD PTR [rbp-0x220],0x0
  PROFILE_SCOPE("haversine alloc")
    34de:	lea    r14,[rip+0x1164]        # 4649 <_IO_stdin_used+0x649>
    34e5:	mov    r15d,0xf
    34eb:	lea    rdi,[rbp-0x130]
    34f2:	mov    rdx,r14
    34f5:	mov    rax,r15
    34f8:	mov    r8d,0x0
    34fe:	mov    ecx,0x6
    3503:	mov    rsi,rdx
    3506:	mov    rdx,rax
    3509:	call   1e83 <__profile_begin_pass>
    350e:	mov    QWORD PTR [rbp-0x218],0x0
    3519:	jmp    35e1 <main+0x302>
  {
    usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    351e:	mov    QWORD PTR [rbp-0x1a8],0x18
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    3529:	mov    rax,QWORD PTR [rbp-0x198]
    3530:	mov    edx,0x0
    3535:	div    QWORD PTR [rbp-0x1a8]
    353c:	mov    QWORD PTR [rbp-0x220],rax

    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    3543:	mov    rax,QWORD PTR [rbp-0x220]
    354a:	shl    rax,0x5
    354e:	mov    rcx,rax
    3551:	lea    rax,[rbp-0x190]
    3558:	mov    edx,0x8
    355d:	mov    rsi,rcx
    3560:	mov    rdi,rax
    3563:	call   17d3 <arena_alloc>
    3568:	mov    QWORD PTR [rbp-0x228],rax
    pair_count = 0;
    356f:	mov    DWORD PTR [rbp-0x238],0x0
  PROFILE_SCOPE("haversine alloc")
    3579:	add    QWORD PTR [rbp-0x218],0x1
    3581:	sub    rsp,0x8
    3585:	sub    rsp,0x38
    3589:	mov    rcx,rsp
    358c:	mov    rax,QWORD PTR [rbp-0x130]
    3593:	mov    rdx,QWORD PTR [rbp-0x128]
    359a:	mov    QWORD PTR [rcx],rax
    359d:	mov    QWORD PTR [rcx+0x8],rdx
    35a1:	mov    rax,QWORD PTR [rbp-0x120]
    35a8:	mov    rdx,QWORD PTR [rbp-0x118]
    35af:	mov    QWORD PTR [rcx+0x10],rax
    35b3:	mov    QWORD PTR [rcx+0x18],rdx
    35b7:	mov    rax,QWORD PTR [rbp-0x110]
    35be:	mov    rdx,QWORD PTR [rbp-0x108]
    35c5:	mov    QWORD PTR [rcx+0x20],rax
    35c9:	mov    QWORD PTR [rcx+0x28],rdx
    35cd:	mov    rax,QWORD PTR [rbp-0x100]
    35d4:	mov    QWORD PTR [rcx+0x30],rax
    35d8:	call   1f6d <__profile_end_pass>
    35dd:	add    rsp,0x40
    35e1:	cmp    QWORD PTR [rbp-0x218],0x0
    35e9:	je     351e <main+0x23f>
  }

  JSON_Object *root = NULL;
    35ef:	mov    QWORD PTR [rbp-0x1d8],0x0
  root = parse_json(&arena, source);
    35fa:	mov    rcx,QWORD PTR [rbp-0x1a0]
    3601:	mov    rdx,QWORD PTR [rbp-0x198]
    3608:	lea    rax,[rbp-0x190]
    360f:	mov    rsi,rcx
    3612:	mov    rdi,rax
    3615:	call   2c9b <parse_json>
    361a:	mov    QWORD PTR [rbp-0x1d8],rax

  f64 haversine_sum = 0.0;
    3621:	pxor   xmm0,xmm0
    3625:	movsd  QWORD PTR [rbp-0x1d0],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    362d:	lea    rax,[rip+0x1025]        # 4659 <_IO_stdin_used+0x659>
    3634:	mov    QWORD PTR [rbp-0x280],rax
    363b:	mov    QWORD PTR [rbp-0x278],0x5
    3646:	mov    rax,QWORD PTR [rbp-0x280]
    364d:	mov    rdx,QWORD PTR [rbp-0x278]
    3654:	mov    rcx,rax
    3657:	mov    rax,QWORD PTR [rbp-0x1d8]
    365e:	mov    rsi,rcx
    3661:	mov    rdi,rax
    3664:	call   2dfe <lookup_json_object>
    3669:	mov    QWORD PTR [rbp-0x1c8],rax
  if (pairs)
    3670:	cmp    QWORD PTR [rbp-0x228],0x0
    3678:	je     390d <main+0x62e>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    367e:	mov    rax,QWORD PTR [rbp-0x1c8]
    3685:	mov    rax,QWORD PTR [rax+0x20]
    3689:	mov    QWORD PTR [rbp-0x210],rax
    3690:	jmp    38ee <main+0x60f>
    {
      PROFILE_SCOPE("child convert")
    3695:	lea    rax,[rip+0xfc3]        # 465f <_IO_stdin_used+0x65f>
    369c:	mov    QWORD PTR [rbp-0x2c0],rax
    36a3:	mov    QWORD PTR [rbp-0x2b8],0xd
    36ae:	lea    rdi,[rbp-0x70]
    36b2:	mov    rbx,QWORD PTR [rbp-0x2c0]
    36b9:	mov    rsi,QWORD PTR [rbp-0x2b8]
    36c0:	mov    rdx,rbx
    36c3:	mov    rax,rsi
    36c6:	mov    r8d,0x0
    36cc:	mov    ecx,0x7
    36d1:	mov    rsi,rdx
    36d4:	mov    rdx,rax
    36d7:	call   1e83 <__profile_begin_pass>
    36dc:	mov    QWORD PTR [rbp-0x208],0x0
    36e7:	jmp    38ce <main+0x5ef>
      {
        Haversine_Pair pair =
        {
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    36ec:	lea    rax,[rip+0xf7a]        # 466d <_IO_stdin_used+0x66d>
    36f3:	mov    QWORD PTR [rbp-0x2d0],rax
    36fa:	mov    QWORD PTR [rbp-0x2c8],0x2
    3705:	mov    rbx,QWORD PTR [rbp-0x2d0]
    370c:	mov    rsi,QWORD PTR [rbp-0x2c8]
    3713:	mov    rax,rbx
    3716:	mov    rdx,rsi
    3719:	mov    rcx,QWORD PTR [rbp-0x210]
    3720:	mov    rsi,rax
    3723:	mov    rdi,rcx
    3726:	call   2dfe <lookup_json_object>
    372b:	mov    rdi,rax
    372e:	call   2f21 <json_object_to_f64>
    3733:	movq   rax,xmm0
        Haversine_Pair pair =
    3738:	mov    QWORD PTR [rbp-0xb0],rax
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    373f:	lea    rax,[rip+0xf2a]        # 4670 <_IO_stdin_used+0x670>
    3746:	mov    QWORD PTR [rbp-0x2e0],rax
    374d:	mov    QWORD PTR [rbp-0x2d8],0x2
    3758:	mov    rax,QWORD PTR [rbp-0x2e0]
    375f:	mov    rdx,QWORD PTR [rbp-0x2d8]
    3766:	mov    rcx,rax
    3769:	mov    rax,QWORD PTR [rbp-0x210]
    3770:	mov    rsi,rcx
    3773:	mov    rdi,rax
    3776:	call   2dfe <lookup_json_object>
    377b:	mov    rdi,rax
    377e:	call   2f21 <json_object_to_f64>
    3783:	movq   rax,xmm0
        Haversine_Pair pair =
    3788:	mov    QWORD PTR [rbp-0xa8],rax
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    378f:	lea    rax,[rip+0xedd]        # 4673 <_IO_stdin_used+0x673>
    3796:	mov    QWORD PTR [rbp-0x2f0],rax
    379d:	mov    QWORD PTR [rbp-0x2e8],0x2
    37a8:	mov    rax,QWORD PTR [rbp-0x2f0]
    37af:	mov    rdx,QWORD PTR [rbp-0x2e8]
    37b6:	mov    rcx,rax
    37b9:	mov    rax,QWORD PTR [rbp-0x210]
    37c0:	mov    rsi,rcx
    37c3:	mov    rdi,rax
    37c6:	call   2dfe <lookup_json_object>
    37cb:	mov    rdi,rax
    37ce:	call   2f21 <json_object_to_f64>
    37d3:	movq   rax,xmm0
        Haversine_Pair pair =
    37d8:	mov    QWORD PTR [rbp-0xa0],rax
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    37df:	lea    rax,[rip+0xe90]        # 4676 <_IO_stdin_used+0x676>
    37e6:	mov    QWORD PTR [rbp-0x300],rax
    37ed:	mov    QWORD PTR [rbp-0x2f8],0x2
    37f8:	mov    rax,QWORD PTR [rbp-0x300]
    37ff:	mov    rdx,QWORD PTR [rbp-0x2f8]
    3806:	mov    rcx,rax
    3809:	mov    rax,QWORD PTR [rbp-0x210]
    3810:	mov    rsi,rcx
    3813:	mov    rdi,rax
    3816:	call   2dfe <lookup_json_object>
    381b:	mov    rdi,rax
    381e:	call   2f21 <json_object_to_f64>
    3823:	movq   rax,xmm0
        Haversine_Pair pair =
    3828:	mov    QWORD PTR [rbp-0x98],rax
        };

        pairs[pair_count] = pair;
    382f:	mov    eax,DWORD PTR [rbp-0x238]
    3835:	cdqe
    3837:	shl    rax,0x5
    383b:	mov    rdx,rax
    383e:	mov    rax,QWORD PTR [rbp-0x228]
    3845:	lea    rcx,[rdx+rax*1]
    3849:	mov    rax,QWORD PTR [rbp-0xb0]
    3850:	mov    rdx,QWORD PTR [rbp-0xa8]
    3857:	mov    QWORD PTR [rcx],rax
    385a:	mov    QWORD PTR [rcx+0x8],rdx
    385e:	mov    rax,QWORD PTR [rbp-0xa0]
    3865:	mov    rdx,QWORD PTR [rbp-0x98]
    386c:	mov    QWORD PTR [rcx+0x10],rax
    3870:	mov    QWORD PTR [rcx+0x18],rdx
        pair_count += 1;
    3874:	add    DWORD PTR [rbp-0x238],0x1
      PROFILE_SCOPE("child convert")
    387b:	add    QWORD PTR [rbp-0x208],0x1
    3883:	sub    rsp,0x8
    3887:	sub    rsp,0x38
    388b:	mov    rcx,rsp
    388e:	mov    rax,QWORD PTR [rbp-0x70]
    3892:	mov    rdx,QWORD PTR [rbp-0x68]
    3896:	mov    QWORD PTR [rcx],rax
    3899:	mov    QWORD PTR [rcx+0x8],rdx
    389d:	mov    rax,QWORD PTR [rbp-0x60]
    38a1:	mov    rdx,QWORD PTR [rbp-0x58]
    38a5:	mov    QWORD PTR [rcx+0x10],rax
    38a9:	mov    QWORD PTR [rcx+0x18],rdx
    38ad:	mov    rax,QWORD PTR [rbp-0x50]
    38b1:	mov    rdx,QWORD PTR [rbp-0x48]
    38b5:	mov    QWORD PTR [rcx+0x20],rax
    38b9:	mov    QWORD PTR [rcx+0x28],rdx
    38bd:	mov    rax,QWORD PTR [rbp-0x40]
    38c1:	mov    QWORD PTR [rcx+0x30],rax
    38c5:	call   1f6d <__profile_end_pass>
    38ca:	add    rsp,0x40
    38ce:	cmp    QWORD PTR [rbp-0x208],0x0
    38d6:	je     36ec <main+0x40d>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    38dc:	mov    rax,QWORD PTR [rbp-0x210]
    38e3:	mov    rax,QWORD PTR [rax+0x28]
    38e7:	mov    QWORD PTR [rbp-0x210],rax
    38ee:	cmp    QWORD PTR [rbp-0x210],0x0
    38f6:	je     390d <main+0x62e>
    38f8:	mov    eax,DWORD PTR [rbp-0x238]
    38fe:	cdqe
    3900:	cmp    rax,QWORD PTR [rbp-0x220]
    3907:	jb     3695 <main+0x3b6>
      }
    }
  }

  f64 sum = 0.0;
    390d:	pxor   xmm0,xmm0
    3911:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3919:	lea    rax,[rip+0xd59]        # 4679 <_IO_stdin_used+0x679>
    3920:	mov    QWORD PTR [rbp-0x290],rax
    3927:	mov    QWORD PTR [rbp-0x288],0x3
    3932:	lea    rax,[rbp-0xf0]
    3939:	mov    rcx,QWORD PTR [rbp-0x290]
    3940:	mov    rbx,QWORD PTR [rbp-0x288]
    3947:	mov    rsi,rcx
    394a:	mov    rdx,rbx
    394d:	mov    r8d,0x0
    3953:	mov    ecx,0x8
    3958:	mov    rdi,rax
    395b:	call   1e83 <__profile_begin_pass>
    3960:	mov    QWORD PTR [rbp-0x1f8],0x0
    396b:	jmp    3aed <main+0x80e>
  {
    for (usize i = 0; i < pair_count; i++)
    3970:	mov    QWORD PTR [rbp-0x1f0],0x0
    397b:	jmp    3a50 <main+0x771>
    {
      f64 earth_radius = 6372.8;
    3980:	movsd  xmm0,QWORD PTR [rip+0xf58]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    3988:	movsd  QWORD PTR [rbp-0x1b8],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    3990:	mov    rax,QWORD PTR [rbp-0x1f0]
    3997:	shl    rax,0x5
    399b:	mov    rdx,rax
    399e:	mov    rax,QWORD PTR [rbp-0x228]
    39a5:	add    rax,rdx
    39a8:	movsd  xmm2,QWORD PTR [rax+0x18]
    39ad:	mov    rax,QWORD PTR [rbp-0x1f0]
    39b4:	shl    rax,0x5
    39b8:	mov    rdx,rax
    39bb:	mov    rax,QWORD PTR [rbp-0x228]
    39c2:	add    rax,rdx
    39c5:	movsd  xmm1,QWORD PTR [rax+0x10]
    39ca:	mov    rax,QWORD PTR [rbp-0x1f0]
    39d1:	shl    rax,0x5
    39d5:	mov    rdx,rax
    39d8:	mov    rax,QWORD PTR [rbp-0x228]
    39df:	add    rax,rdx
    39e2:	movsd  xmm0,QWORD PTR [rax+0x8]
    39e7:	mov    rax,QWORD PTR [rbp-0x1f0]
    39ee:	shl    rax,0x5
    39f2:	mov    rdx,rax
    39f5:	mov    rax,QWORD PTR [rbp-0x228]
    39fc:	add    rax,rdx
    39ff:	mov    rax,QWORD PTR [rax]
    3a02:	movsd  xmm3,QWORD PTR [rbp-0x1b8]
    3a0a:	movapd xmm4,xmm3
    3a0e:	movapd xmm3,xmm2
    3a12:	movapd xmm2,xmm1
    3a16:	movapd xmm1,xmm0
    3a1a:	movq   xmm0,rax
    3a1f:	call   30de <reference_haversine>
    3a24:	movq   rax,xmm0
    3a29:	mov    QWORD PTR [rbp-0x1b0],rax
      sum += result;
    3a30:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3a38:	addsd  xmm0,QWORD PTR [rbp-0x1b0]
    3a40:	movsd  QWORD PTR [rbp-0x200],xmm0
    for (usize i = 0; i < pair_count; i++)
    3a48:	add    QWORD PTR [rbp-0x1f0],0x1
    3a50:	mov    eax,DWORD PTR [rbp-0x238]
    3a56:	cdqe
    3a58:	cmp    QWORD PTR [rbp-0x1f0],rax
    3a5f:	jb     3980 <main+0x6a1>
    }
    sum /= pair_count;
    3a65:	pxor   xmm1,xmm1
    3a69:	cvtsi2sd xmm1,DWORD PTR [rbp-0x238]
    3a71:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3a79:	divsd  xmm0,xmm1
    3a7d:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3a85:	add    QWORD PTR [rbp-0x1f8],0x1
    3a8d:	sub    rsp,0x8
    3a91:	sub    rsp,0x38
    3a95:	mov    rax,rsp
    3a98:	mov    rcx,QWORD PTR [rbp-0xf0]
    3a9f:	mov    rbx,QWORD PTR [rbp-0xe8]
    3aa6:	mov    QWORD PTR [rax],rcx
    3aa9:	mov    QWORD PTR [rax+0x8],rbx
    3aad:	mov    rcx,QWORD PTR [rbp-0xe0]
    3ab4:	mov    rbx,QWORD PTR [rbp-0xd8]
    3abb:	mov    QWORD PTR [rax+0x10],rcx
    3abf:	mov    QWORD PTR [rax+0x18],rbx
    3ac3:	mov    rcx,QWORD PTR [rbp-0xd0]
    3aca:	mov    rbx,QWORD PTR [rbp-0xc8]
    3ad1:	mov    QWORD PTR [rax+0x20],rcx
    3ad5:	mov    QWORD PTR [rax+0x28],rbx
    3ad9:	mov    rdx,QWORD PTR [rbp-0xc0]
    3ae0:	mov    QWORD PTR [rax+0x30],rdx
    3ae4:	call   1f6d <__profile_end_pass>
    3ae9:	add    rsp,0x40
    3aed:	cmp    QWORD PTR [rbp-0x1f8],0x0
    3af5:	je     3970 <main+0x691>
  }

  PROFILE_SCOPE("check")
    3afb:	lea    rax,[rip+0xb7b]        # 467d <_IO_stdin_used+0x67d>
    3b02:	mov    QWORD PTR [rbp-0x2a0],rax
    3b09:	mov    QWORD PTR [rbp-0x298],0x5
    3b14:	lea    rax,[rbp-0xb0]
    3b1b:	mov    rcx,QWORD PTR [rbp-0x2a0]
    3b22:	mov    rbx,QWORD PTR [rbp-0x298]
    3b29:	mov    rsi,rcx
    3b2c:	mov    rdx,rbx
    3b2f:	mov    r8d,0x0
    3b35:	mov    ecx,0x9
    3b3a:	mov    rdi,rax
    3b3d:	call   1e83 <__profile_begin_pass>
    3b42:	mov    QWORD PTR [rbp-0x1e8],0x0
    3b4d:	jmp    3d22 <main+0xa43>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3b52:	mov    rax,QWORD PTR [rbp-0x250]
    3b59:	add    rax,0x10
    3b5d:	mov    rdx,QWORD PTR [rax]
    3b60:	lea    rax,[rbp-0x190]
    3b67:	mov    rsi,rdx
    3b6a:	mov    rdi,rax
    3b6d:	call   1357 <read_file_to_arena>
    3b72:	mov    QWORD PTR [rbp-0x70],rax
    3b76:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3b7a:	mov    rax,QWORD PTR [rbp-0x68]
    3b7e:	cmp    rax,0xb
    3b82:	jbe    3c95 <main+0x9b6>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3b88:	mov    rax,QWORD PTR [rbp-0x70]
    3b8c:	movsd  xmm0,QWORD PTR [rax]
    3b90:	movsd  QWORD PTR [rbp-0x1c0],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3b98:	mov    rax,QWORD PTR [rbp-0x70]
    3b9c:	mov    eax,DWORD PTR [rax+0x8]
    3b9f:	mov    DWORD PTR [rbp-0x234],eax

      if (solution_pairs == pair_count)
    3ba5:	mov    eax,DWORD PTR [rbp-0x234]
    3bab:	cmp    eax,DWORD PTR [rbp-0x238]
    3bb1:	jne    3c59 <main+0x97a>
      {
        if (epsilon_equal(solution_sum, sum))
    3bb7:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3bbf:	mov    rax,QWORD PTR [rbp-0x1c0]
    3bc6:	movapd xmm1,xmm0
    3bca:	movq   xmm0,rax
    3bcf:	call   3289 <epsilon_equal>
    3bd4:	test   eax,eax
    3bd6:	je     3c1a <main+0x93b>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3bd8:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3be0:	mov    rax,QWORD PTR [rbp-0x1c0]
    3be7:	lea    rdx,[rip+0xa9a]        # 4688 <_IO_stdin_used+0x688>
    3bee:	lea    rsi,[rip+0xac6]        # 46bb <_IO_stdin_used+0x6bb>
    3bf5:	movapd xmm1,xmm0
    3bf9:	movq   xmm0,rax
    3bfe:	mov    rcx,rdx
    3c01:	mov    edx,0x64
    3c06:	mov    edi,0x3
    3c0b:	mov    eax,0x2
    3c10:	call   14a1 <log_message>
    3c15:	jmp    3cbd <main+0x9de>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3c1a:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3c22:	mov    rax,QWORD PTR [rbp-0x1c0]
    3c29:	lea    rdx,[rip+0xaa0]        # 46d0 <_IO_stdin_used+0x6d0>
    3c30:	lea    rsi,[rip+0xa84]        # 46bb <_IO_stdin_used+0x6bb>
    3c37:	movapd xmm1,xmm0
    3c3b:	movq   xmm0,rax
    3c40:	mov    rcx,rdx
    3c43:	mov    edx,0x68
    3c48:	mov    edi,0x1
    3c4d:	mov    eax,0x2
    3c52:	call   14a1 <log_message>
    3c57:	jmp    3cbd <main+0x9de>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3c59:	mov    esi,DWORD PTR [rbp-0x238]
    3c5f:	mov    ecx,DWORD PTR [rbp-0x234]
    3c65:	lea    rdx,[rip+0xa9c]        # 4708 <_IO_stdin_used+0x708>
    3c6c:	lea    rax,[rip+0xa48]        # 46bb <_IO_stdin_used+0x6bb>
    3c73:	mov    r9d,esi
    3c76:	mov    r8d,ecx
    3c79:	mov    rcx,rdx
    3c7c:	mov    edx,0x6d
    3c81:	mov    rsi,rax
    3c84:	mov    edi,0x1
    3c89:	mov    eax,0x0
    3c8e:	call   14a1 <log_message>
    3c93:	jmp    3cbd <main+0x9de>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3c95:	lea    rdx,[rip+0xab4]        # 4750 <_IO_stdin_used+0x750>
    3c9c:	lea    rax,[rip+0xa18]        # 46bb <_IO_stdin_used+0x6bb>
    3ca3:	mov    rcx,rdx
    3ca6:	mov    edx,0x72
    3cab:	mov    rsi,rax
    3cae:	mov    edi,0x1
    3cb3:	mov    eax,0x0
    3cb8:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3cbd:	add    QWORD PTR [rbp-0x1e8],0x1
    3cc5:	sub    rsp,0x8
    3cc9:	sub    rsp,0x38
    3ccd:	mov    rax,rsp
    3cd0:	mov    rcx,QWORD PTR [rbp-0xb0]
    3cd7:	mov    rbx,QWORD PTR [rbp-0xa8]
    3cde:	mov    QWORD PTR [rax],rcx
    3ce1:	mov    QWORD PTR [rax+0x8],rbx
    3ce5:	mov    rcx,QWORD PTR [rbp-0xa0]
    3cec:	mov    rbx,QWORD PTR [rbp-0x98]
    3cf3:	mov    QWORD PTR [rax+0x10],rcx
    3cf7:	mov    QWORD PTR [rax+0x18],rbx
    3cfb:	mov    rcx,QWORD PTR [rbp-0x90]
    3d02:	mov    rbx,QWORD PTR [rbp-0x88]
    3d09:	mov    QWORD PTR [rax+0x20],rcx
    3d0d:	mov    QWORD PTR [rax+0x28],rbx
    3d11:	mov    rdx,QWORD PTR [rbp-0x80]
    3d15:	mov    QWORD PTR [rax+0x30],rdx
    3d19:	call   1f6d <__profile_end_pass>
    3d1e:	add    rsp,0x40
    3d22:	cmp    QWORD PTR [rbp-0x1e8],0x0
    3d2a:	je     3b52 <main+0x873>
    }
  }

  PROFILE_SCOPE("free")
    3d30:	lea    rax,[rip+0xa54]        # 478b <_IO_stdin_used+0x78b>
    3d37:	mov    QWORD PTR [rbp-0x2b0],rax
    3d3e:	mov    QWORD PTR [rbp-0x2a8],0x4
    3d49:	lea    rax,[rbp-0x70]
    3d4d:	mov    rcx,QWORD PTR [rbp-0x2b0]
    3d54:	mov    rbx,QWORD PTR [rbp-0x2a8]
    3d5b:	mov    rsi,rcx
    3d5e:	mov    rdx,rbx
    3d61:	mov    r8d,0x0
    3d67:	mov    ecx,0xa
    3d6c:	mov    rdi,rax
    3d6f:	call   1e83 <__profile_begin_pass>
    3d74:	mov    QWORD PTR [rbp-0x1e0],0x0
    3d7f:	jmp    3de3 <main+0xb04>
  {
    arena_free(&arena);
    3d81:	lea    rax,[rbp-0x190]
    3d88:	mov    rdi,rax
    3d8b:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3d90:	add    QWORD PTR [rbp-0x1e0],0x1
    3d98:	sub    rsp,0x8
    3d9c:	sub    rsp,0x38
    3da0:	mov    rax,rsp
    3da3:	mov    rcx,QWORD PTR [rbp-0x70]
    3da7:	mov    rbx,QWORD PTR [rbp-0x68]
    3dab:	mov    QWORD PTR [rax],rcx
    3dae:	mov    QWORD PTR [rax+0x8],rbx
    3db2:	mov    rcx,QWORD PTR [rbp-0x60]
    3db6:	mov    rbx,QWORD PTR [rbp-0x58]
    3dba:	mov    QWORD PTR [rax+0x10],rcx
    3dbe:	mov    QWORD PTR [rax+0x18],rbx
    3dc2:	mov    rcx,QWORD PTR [rbp-0x50]
    3dc6:	mov    rbx,QWORD PTR [rbp-0x48]
    3dca:	mov    QWORD PTR [rax+0x20],rcx
    3dce:	mov    QWORD PTR [rax+0x28],rbx
    3dd2:	mov    rdx,QWORD PTR [rbp-0x40]
    3dd6:	mov    QWORD PTR [rax+0x30],rdx
    3dda:	call   1f6d <__profile_end_pass>
    3ddf:	add    rsp,0x40
    3de3:	cmp    QWORD PTR [rbp-0x1e0],0x0
    3deb:	je     3d81 <main+0xaa2>
  }

  end_profiling();
    3ded:	call   1b9b <end_profiling>
    3df2:	mov    eax,0x0
}
    3df7:	mov    rdx,QWORD PTR [rbp-0x38]
    3dfb:	sub    rdx,QWORD PTR fs:0x28
    3e04:	je     3e0b <main+0xb2c>
    3e06:	call   1060 <__stack_chk_fail@plt>
    3e0b:	lea    rsp,[rbp-0x28]
    3e0f:	pop    rbx
    3e10:	pop    r12
    3e12:	pop    r13
    3e14:	pop    r14
    3e16:	pop    r15
    3e18:	pop    rbp
    3e19:	ret

Disassembly of section .fini:

0000000000003e1c <_fini>:
    3e1c:	endbr64
    3e20:	sub    rsp,0x8
    3e24:	add    rsp,0x8
    3e28:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x5fc1]        # 6fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x5fca]        # 6ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x5fcc]        # 6ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x5fca]        # 7000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x5fc2]        # 7008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x5fba]        # 7010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x5fb2]        # 7018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x5faa]        # 7020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x5fa2]        # 7028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x5f9a]        # 7030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x5f92]        # 7038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x5f8a]        # 7040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x5f82]        # 7048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x5f7a]        # 7050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x5f72]        # 7058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x5f6a]        # 7060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x5f62]        # 7068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x5f5a]        # 7070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x5f52]        # 7078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x5f4a]        # 7080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x5f42]        # 7088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x5f3a]        # 7090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x5f32]        # 7098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2247]        # 33d6 <main>
    118f:	call   QWORD PTR [rip+0x5e2b]        # 6fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x5fa1]        # 7148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x5f9a]        # 7148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x5e0e]        # 6fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x5f71]        # 7148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x5f6a]        # 7148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x5ddd]        # 6fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x5f6d],0x0        # 7188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x5dba],0x0        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x5e76]        # 70a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x5da8]        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x5f44],0x1        # 7188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x5c6e]        # 7180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x5b89]        # 70c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x5be7]        # 7160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x5b2b]        # 70c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x30a7]        # 47a0 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x307b]        # 47a0 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fbe]        # 47b8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2ebf]        # 47c8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2cdd]        # 47e0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x5639]        # 71a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x5620],rbx        # 71a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x50
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x55ee]        # 71a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x40],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x40],0x0
    1bbe:	je     1f77 <end_profiling+0x3dc>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x38],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x40]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x38]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c61]        # 4898 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x38]
    1c44:	mov    rax,QWORD PTR [rbp-0x40]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x50],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x48],0x0
    1c72:	jmp    1f69 <end_profiling+0x3ce>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x48]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x550d]        # 71a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x30],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x30]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1f64 <end_profiling+0x3c9>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x30]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x40]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b87]        # 48a0 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x28],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x30]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x30]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x30]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x30]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x28]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x30]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x30]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x30]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x40]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2aaf]        # 48a0 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x20],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x30]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x20]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x50]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x28]
    1e2c:	movsd  QWORD PTR [rbp-0x50],xmm0

        if (zone->bytes_processed)
    1e31:	mov    rax,QWORD PTR [rbp-0x30]
    1e35:	mov    rax,QWORD PTR [rax+0x28]
    1e39:	test   rax,rax
    1e3c:	je     1f64 <end_profiling+0x3c9>
        {
          u64 gigabytes = zone->bytes_processed / GB(1);
    1e42:	mov    rax,QWORD PTR [rbp-0x30]
    1e46:	mov    rax,QWORD PTR [rax+0x28]
    1e4a:	shr    rax,0x1e
    1e4e:	mov    QWORD PTR [rbp-0x18],rax
          u64 megabytes = zone->bytes_processed / MB(1);
    1e52:	mov    rax,QWORD PTR [rbp-0x30]
    1e56:	mov    rax,QWORD PTR [rax+0x28]
    1e5a:	shr    rax,0x14
    1e5e:	mov    QWORD PTR [rbp-0x10],rax

          u64 gb_per_s = gigabytes / (f64)zone->elapsed_exclusive / (f64)freq * 1000000.0;
    1e62:	mov    rax,QWORD PTR [rbp-0x18]
    1e66:	test   rax,rax
    1e69:	js     1e76 <end_profiling+0x2db>
    1e6b:	pxor   xmm0,xmm0
    1e6f:	cvtsi2sd xmm0,rax
    1e74:	jmp    1e8f <end_profiling+0x2f4>
    1e76:	mov    rdx,rax
    1e79:	shr    rdx,1
    1e7c:	and    eax,0x1
    1e7f:	or     rdx,rax
    1e82:	pxor   xmm0,xmm0
    1e86:	cvtsi2sd xmm0,rdx
    1e8b:	addsd  xmm0,xmm0
    1e8f:	mov    rax,QWORD PTR [rbp-0x30]
    1e93:	mov    rax,QWORD PTR [rax+0x10]
    1e97:	test   rax,rax
    1e9a:	js     1ea7 <end_profiling+0x30c>
    1e9c:	pxor   xmm1,xmm1
    1ea0:	cvtsi2sd xmm1,rax
    1ea5:	jmp    1ec0 <end_profiling+0x325>
    1ea7:	mov    rdx,rax
    1eaa:	shr    rdx,1
    1ead:	and    eax,0x1
    1eb0:	or     rdx,rax
    1eb3:	pxor   xmm1,xmm1
    1eb7:	cvtsi2sd xmm1,rdx
    1ebc:	addsd  xmm1,xmm1
    1ec0:	movapd xmm2,xmm0
    1ec4:	divsd  xmm2,xmm1
    1ec8:	mov    rax,QWORD PTR [rbp-0x38]
    1ecc:	test   rax,rax
    1ecf:	js     1edc <end_profiling+0x341>
    1ed1:	pxor   xmm0,xmm0
    1ed5:	cvtsi2sd xmm0,rax
    1eda:	jmp    1ef5 <end_profiling+0x35a>
    1edc:	mov    rdx,rax
    1edf:	shr    rdx,1
    1ee2:	and    eax,0x1
    1ee5:	or     rdx,rax
    1ee8:	pxor   xmm0,xmm0
    1eec:	cvtsi2sd xmm0,rdx
    1ef1:	addsd  xmm0,xmm0
    1ef5:	divsd  xmm2,xmm0
    1ef9:	movapd xmm1,xmm2
    1efd:	movsd  xmm0,QWORD PTR [rip+0x29a3]        # 48a8 <__PRETTY_FUNCTION__.0+0x28>
    1f05:	mulsd  xmm0,xmm1
    1f09:	comisd xmm0,QWORD PTR [rip+0x299f]        # 48b0 <__PRETTY_FUNCTION__.0+0x30>
    1f11:	jae    1f1e <end_profiling+0x383>
    1f13:	cvttsd2si rax,xmm0
    1f18:	mov    QWORD PTR [rbp-0x8],rax
    1f1c:	jmp    1f41 <end_profiling+0x3a6>
    1f1e:	movsd  xmm1,QWORD PTR [rip+0x298a]        # 48b0 <__PRETTY_FUNCTION__.0+0x30>
    1f26:	subsd  xmm0,xmm1
    1f2a:	cvttsd2si rax,xmm0
    1f2f:	mov    QWORD PTR [rbp-0x8],rax
    1f33:	movabs rax,0x8000000000000000
    1f3d:	xor    QWORD PTR [rbp-0x8],rax
    1f41:	mov    rax,QWORD PTR [rbp-0x8]
    1f45:	mov    QWORD PTR [rbp-0x8],rax

          printf("  Megabytes Processed: %lu\n", megabytes);
    1f49:	mov    rax,QWORD PTR [rbp-0x10]
    1f4d:	lea    rdx,[rip+0x23f0]        # 4344 <_IO_stdin_used+0x344>
    1f54:	mov    rsi,rax
    1f57:	mov    rdi,rdx
    1f5a:	mov    eax,0x0
    1f5f:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1f64:	add    QWORD PTR [rbp-0x48],0x1
    1f69:	cmp    QWORD PTR [rbp-0x48],0xfff
    1f71:	jbe    1c77 <end_profiling+0xdc>
        }
      }
    }
  }
}
    1f77:	nop
    1f78:	leave
    1f79:	ret

0000000000001f7a <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1f7a:	push   rbp
    1f7b:	mov    rbp,rsp
    1f7e:	push   rbx
    1f7f:	sub    rsp,0x78
    1f83:	mov    QWORD PTR [rbp-0x58],rdi
    1f87:	mov    rax,rsi
    1f8a:	mov    rsi,rdx
    1f8d:	mov    rax,rax
    1f90:	mov    edx,0x0
    1f95:	mov    rdx,rsi
    1f98:	mov    QWORD PTR [rbp-0x70],rax
    1f9c:	mov    QWORD PTR [rbp-0x68],rdx
    1fa0:	mov    QWORD PTR [rbp-0x60],rcx
    1fa4:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1fa8:	pxor   xmm0,xmm0
    1fac:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1fb0:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1fb4:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1fb8:	movq   QWORD PTR [rbp-0x20],xmm0
    1fbd:	mov    rax,QWORD PTR [rbp-0x70]
    1fc1:	mov    rdx,QWORD PTR [rbp-0x68]
    1fc5:	mov    QWORD PTR [rbp-0x50],rax
    1fc9:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1fcd:	mov    rdx,QWORD PTR [rbp-0x60]
    1fd1:	mov    rax,rdx
    1fd4:	add    rax,rax
    1fd7:	add    rax,rdx
    1fda:	shl    rax,0x4
    1fde:	mov    rdx,rax
    1fe1:	lea    rax,[rip+0x51e0]        # 71c8 <g_profiler+0x28>
    1fe8:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1fec:	mov    QWORD PTR [rbp-0x38],rax
    1ff0:	mov    rax,QWORD PTR [rbp-0x60]
    1ff4:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1ff8:	mov    rax,QWORD PTR [rip+0x51a9]        # 71a8 <g_profiler+0x8>
  Profile_Pass pass =
    1fff:	mov    QWORD PTR [rbp-0x28],rax
    2003:	mov    rax,QWORD PTR [rbp-0x78]
    2007:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    200b:	mov    rax,QWORD PTR [rbp-0x60]
    200f:	mov    QWORD PTR [rip+0x5192],rax        # 71a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    2016:	call   1a48 <read_cpu_timer>
    201b:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    201f:	mov    rax,QWORD PTR [rbp-0x58]
    2023:	mov    rcx,QWORD PTR [rbp-0x50]
    2027:	mov    rbx,QWORD PTR [rbp-0x48]
    202b:	mov    QWORD PTR [rax],rcx
    202e:	mov    QWORD PTR [rax+0x8],rbx
    2032:	mov    rcx,QWORD PTR [rbp-0x40]
    2036:	mov    rbx,QWORD PTR [rbp-0x38]
    203a:	mov    QWORD PTR [rax+0x10],rcx
    203e:	mov    QWORD PTR [rax+0x18],rbx
    2042:	mov    rcx,QWORD PTR [rbp-0x30]
    2046:	mov    rbx,QWORD PTR [rbp-0x28]
    204a:	mov    QWORD PTR [rax+0x20],rcx
    204e:	mov    QWORD PTR [rax+0x28],rbx
    2052:	mov    rdx,QWORD PTR [rbp-0x20]
    2056:	mov    QWORD PTR [rax+0x30],rdx
}
    205a:	mov    rax,QWORD PTR [rbp-0x58]
    205e:	mov    rbx,QWORD PTR [rbp-0x8]
    2062:	leave
    2063:	ret

0000000000002064 <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    2064:	push   rbp
    2065:	mov    rbp,rsp
    2068:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    206c:	call   1a48 <read_cpu_timer>
    2071:	mov    rdx,rax
    2074:	mov    rax,QWORD PTR [rbp+0x20]
    2078:	sub    rdx,rax
    207b:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    207f:	mov    rax,QWORD PTR [rbp+0x38]
    2083:	mov    QWORD PTR [rip+0x511e],rax        # 71a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    208a:	mov    rdx,QWORD PTR [rbp+0x30]
    208e:	mov    rax,rdx
    2091:	add    rax,rax
    2094:	add    rax,rdx
    2097:	shl    rax,0x4
    209b:	lea    rdx,[rax+0x10]
    209f:	lea    rax,[rip+0x50fa]        # 71a0 <g_profiler>
    20a6:	add    rax,rdx
    20a9:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    20ad:	mov    rax,QWORD PTR [rbp-0x10]
    20b1:	mov    rdx,QWORD PTR [rax+0x10]
    20b5:	mov    rax,QWORD PTR [rbp-0x18]
    20b9:	add    rdx,rax
    20bc:	mov    rax,QWORD PTR [rbp-0x10]
    20c0:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    20c4:	mov    rax,QWORD PTR [rbp-0x10]
    20c8:	mov    rax,QWORD PTR [rax+0x20]
    20cc:	lea    rdx,[rax+0x1]
    20d0:	mov    rax,QWORD PTR [rbp-0x10]
    20d4:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    20d8:	mov    rcx,QWORD PTR [rbp-0x10]
    20dc:	mov    rax,QWORD PTR [rbp+0x10]
    20e0:	mov    rdx,QWORD PTR [rbp+0x18]
    20e4:	mov    QWORD PTR [rcx],rax
    20e7:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    20eb:	mov    rdx,QWORD PTR [rbp+0x28]
    20ef:	mov    rax,QWORD PTR [rbp-0x18]
    20f3:	add    rdx,rax
    20f6:	mov    rax,QWORD PTR [rbp-0x10]
    20fa:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    20fe:	mov    rax,QWORD PTR [rbp-0x10]
    2102:	mov    rdx,QWORD PTR [rax+0x28]
    2106:	mov    rax,QWORD PTR [rbp+0x40]
    210a:	add    rdx,rax
    210d:	mov    rax,QWORD PTR [rbp-0x10]
    2111:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    2115:	mov    rdx,QWORD PTR [rbp+0x38]
    2119:	mov    rax,rdx
    211c:	add    rax,rax
    211f:	add    rax,rdx
    2122:	shl    rax,0x4
    2126:	lea    rdx,[rax+0x10]
    212a:	lea    rax,[rip+0x506f]        # 71a0 <g_profiler>
    2131:	add    rax,rdx
    2134:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    2138:	mov    rax,QWORD PTR [rbp-0x8]
    213c:	mov    rax,QWORD PTR [rax+0x10]
    2140:	sub    rax,QWORD PTR [rbp-0x18]
    2144:	mov    rdx,rax
    2147:	mov    rax,QWORD PTR [rbp-0x8]
    214b:	mov    QWORD PTR [rax+0x10],rdx
}
    214f:	nop
    2150:	leave
    2151:	ret

0000000000002152 <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    2152:	push   rbp
    2153:	mov    rbp,rsp
    2156:	sub    rsp,0x10
    215a:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    215e:	mov    rax,QWORD PTR [rbp-0x8]
    2162:	mov    rdx,QWORD PTR [rax+0x10]
    2166:	mov    rax,QWORD PTR [rbp-0x8]
    216a:	mov    rax,QWORD PTR [rax+0x8]
    216e:	cmp    rdx,rax
    2171:	jb     2198 <parser_at+0x46>
    2173:	lea    rdx,[rip+0x267e]        # 47f8 <__PRETTY_FUNCTION__.5>
    217a:	lea    rsi,[rip+0x22ea]        # 446b <_IO_stdin_used+0x46b>
    2181:	lea    rax,[rip+0x22f8]        # 4480 <_IO_stdin_used+0x480>
    2188:	mov    rcx,rdx
    218b:	mov    edx,0x2f
    2190:	mov    rdi,rax
    2193:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    2198:	mov    rax,QWORD PTR [rbp-0x8]
    219c:	mov    rdx,QWORD PTR [rax]
    219f:	mov    rax,QWORD PTR [rbp-0x8]
    21a3:	mov    rax,QWORD PTR [rax+0x10]
    21a7:	add    rax,rdx
}
    21aa:	leave
    21ab:	ret

00000000000021ac <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    21ac:	push   rbp
    21ad:	mov    rbp,rsp
    21b0:	sub    rsp,0x10
    21b4:	mov    QWORD PTR [rbp-0x8],rdi
    21b8:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    21bc:	mov    rax,QWORD PTR [rbp-0x8]
    21c0:	mov    rdi,rax
    21c3:	call   2152 <parser_at>
    21c8:	mov    rdx,QWORD PTR [rbp-0x10]
    21cc:	add    rax,rdx
}
    21cf:	leave
    21d0:	ret

00000000000021d1 <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    21d1:	push   rbp
    21d2:	mov    rbp,rsp
    21d5:	mov    QWORD PTR [rbp-0x8],rdi
    21d9:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    21dd:	mov    rax,QWORD PTR [rbp-0x8]
    21e1:	mov    rdx,QWORD PTR [rax+0x10]
    21e5:	mov    rax,QWORD PTR [rbp-0x10]
    21e9:	add    rdx,rax
    21ec:	mov    rax,QWORD PTR [rbp-0x8]
    21f0:	mov    QWORD PTR [rax+0x10],rdx
}
    21f4:	nop
    21f5:	pop    rbp
    21f6:	ret

00000000000021f7 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    21f7:	push   rbp
    21f8:	mov    rbp,rsp
    21fb:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    21ff:	mov    rax,QWORD PTR [rbp-0x8]
    2203:	mov    rdx,QWORD PTR [rax+0x10]
    2207:	mov    rax,QWORD PTR [rbp-0x8]
    220b:	mov    rax,QWORD PTR [rax+0x8]
    220f:	cmp    rdx,rax
    2212:	setb   al
}
    2215:	pop    rbp
    2216:	ret

0000000000002217 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    2217:	push   rbp
    2218:	mov    rbp,rsp
    221b:	push   r12
    221d:	push   rbx
    221e:	sub    rsp,0x20
    2222:	mov    QWORD PTR [rbp-0x18],rdi
    2226:	mov    rax,rsi
    2229:	mov    rcx,rdx
    222c:	mov    rax,rax
    222f:	mov    edx,0x0
    2234:	mov    rdx,rcx
    2237:	mov    QWORD PTR [rbp-0x30],rax
    223b:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    223f:	mov    rax,QWORD PTR [rbp-0x28]
    2243:	mov    r12,rax
    2246:	mov    rbx,QWORD PTR [rbp-0x30]
    224a:	mov    rax,QWORD PTR [rbp-0x18]
    224e:	mov    rdi,rax
    2251:	call   2152 <parser_at>
    2256:	mov    rdx,r12
    2259:	mov    rsi,rbx
    225c:	mov    rdi,rax
    225f:	call   10d0 <memcmp@plt>
    2264:	test   eax,eax
    2266:	sete   al
}
    2269:	add    rsp,0x20
    226d:	pop    rbx
    226e:	pop    r12
    2270:	pop    rbp
    2271:	ret

0000000000002272 <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    2272:	push   rbp
    2273:	mov    rbp,rsp
    2276:	mov    eax,edi
    2278:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    227b:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    227f:	movzx  eax,BYTE PTR [rbp-0x14]
    2283:	cmp    eax,0x2e
    2286:	jg     228f <is_numeric+0x1d>
    2288:	cmp    eax,0x2d
    228b:	jge    2297 <is_numeric+0x25>
    228d:	jmp    229c <is_numeric+0x2a>
    228f:	sub    eax,0x30
    2292:	cmp    eax,0x9
    2295:	ja     229c <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2297:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    229b:	nop
  }


  return result;
    229c:	movzx  eax,BYTE PTR [rbp-0x1]
}
    22a0:	pop    rbp
    22a1:	ret

00000000000022a2 <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    22a2:	push   rbp
    22a3:	mov    rbp,rsp
    22a6:	sub    rsp,0x50
    22aa:	mov    QWORD PTR [rbp-0x48],rdi
    22ae:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    22b2:	pxor   xmm0,xmm0
    22b6:	movaps XMMWORD PTR [rbp-0x20],xmm0
    22ba:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    22bf:	jmp    22d2 <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    22c1:	mov    rax,QWORD PTR [rbp-0x50]
    22c5:	mov    esi,0x1
    22ca:	mov    rdi,rax
    22cd:	call   21d1 <parser_advance>
  while (parser_incomplete(parser)  &&
    22d2:	mov    rax,QWORD PTR [rbp-0x50]
    22d6:	mov    rdi,rax
    22d9:	call   21f7 <parser_incomplete>
    22de:	test   al,al
    22e0:	je     232e <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    22e2:	mov    rax,QWORD PTR [rbp-0x50]
    22e6:	mov    rdi,rax
    22e9:	call   2152 <parser_at>
    22ee:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    22f1:	cmp    al,0x20
    22f3:	je     22c1 <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    22f5:	mov    rax,QWORD PTR [rbp-0x50]
    22f9:	mov    rdi,rax
    22fc:	call   2152 <parser_at>
    2301:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    2304:	cmp    al,0xa
    2306:	je     22c1 <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    2308:	mov    rax,QWORD PTR [rbp-0x50]
    230c:	mov    rdi,rax
    230f:	call   2152 <parser_at>
    2314:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    2317:	cmp    al,0xd
    2319:	je     22c1 <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    231b:	mov    rax,QWORD PTR [rbp-0x50]
    231f:	mov    rdi,rax
    2322:	call   2152 <parser_at>
    2327:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    232a:	cmp    al,0x9
    232c:	je     22c1 <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    232e:	mov    rax,QWORD PTR [rbp-0x50]
    2332:	mov    rdi,rax
    2335:	call   21f7 <parser_incomplete>
    233a:	test   al,al
    233c:	je     2769 <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    2342:	mov    rax,QWORD PTR [rbp-0x50]
    2346:	mov    rdi,rax
    2349:	call   2152 <parser_at>
    234e:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    2352:	mov    rax,QWORD PTR [rbp-0x50]
    2356:	mov    rdi,rax
    2359:	call   2152 <parser_at>
    235e:	movzx  eax,BYTE PTR [rax]
    2361:	movzx  eax,al
    2364:	cmp    eax,0x7d
    2367:	je     2454 <get_json_token+0x1b2>
    236d:	cmp    eax,0x7d
    2370:	jg     277a <get_json_token+0x4d8>
    2376:	cmp    eax,0x7b
    2379:	je     242f <get_json_token+0x18d>
    237f:	cmp    eax,0x7b
    2382:	jg     277a <get_json_token+0x4d8>
    2388:	cmp    eax,0x74
    238b:	je     25d7 <get_json_token+0x335>
    2391:	cmp    eax,0x74
    2394:	jg     277a <get_json_token+0x4d8>
    239a:	cmp    eax,0x6e
    239d:	je     26e7 <get_json_token+0x445>
    23a3:	cmp    eax,0x6e
    23a6:	jg     277a <get_json_token+0x4d8>
    23ac:	cmp    eax,0x66
    23af:	je     265f <get_json_token+0x3bd>
    23b5:	cmp    eax,0x66
    23b8:	jg     277a <get_json_token+0x4d8>
    23be:	cmp    eax,0x5d
    23c1:	je     249e <get_json_token+0x1fc>
    23c7:	cmp    eax,0x5d
    23ca:	jg     277a <get_json_token+0x4d8>
    23d0:	cmp    eax,0x5b
    23d3:	je     2479 <get_json_token+0x1d7>
    23d9:	cmp    eax,0x5b
    23dc:	jg     277a <get_json_token+0x4d8>
    23e2:	cmp    eax,0x3a
    23e5:	je     24e8 <get_json_token+0x246>
    23eb:	cmp    eax,0x3a
    23ee:	jg     277a <get_json_token+0x4d8>
    23f4:	cmp    eax,0x39
    23f7:	jg     277a <get_json_token+0x4d8>
    23fd:	cmp    eax,0x30
    2400:	jge    2586 <get_json_token+0x2e4>
    2406:	cmp    eax,0x2e
    2409:	jg     277a <get_json_token+0x4d8>
    240f:	cmp    eax,0x2d
    2412:	jge    2586 <get_json_token+0x2e4>
    2418:	cmp    eax,0x22
    241b:	je     250d <get_json_token+0x26b>
    2421:	cmp    eax,0x2c
    2424:	je     24c3 <get_json_token+0x221>
    242a:	jmp    277a <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    242f:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    2436:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    243e:	mov    rax,QWORD PTR [rbp-0x50]
    2442:	mov    esi,0x1
    2447:	mov    rdi,rax
    244a:	call   21d1 <parser_advance>
      }
      break;
    244f:	jmp    277a <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2454:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    245b:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2463:	mov    rax,QWORD PTR [rbp-0x50]
    2467:	mov    esi,0x1
    246c:	mov    rdi,rax
    246f:	call   21d1 <parser_advance>
      }
      break;
    2474:	jmp    277a <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2479:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    2480:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2488:	mov    rax,QWORD PTR [rbp-0x50]
    248c:	mov    esi,0x1
    2491:	mov    rdi,rax
    2494:	call   21d1 <parser_advance>
      }
      break;
    2499:	jmp    277a <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    249e:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    24a5:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24ad:	mov    rax,QWORD PTR [rbp-0x50]
    24b1:	mov    esi,0x1
    24b6:	mov    rdi,rax
    24b9:	call   21d1 <parser_advance>
      }
      break;
    24be:	jmp    277a <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    24c3:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    24ca:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24d2:	mov    rax,QWORD PTR [rbp-0x50]
    24d6:	mov    esi,0x1
    24db:	mov    rdi,rax
    24de:	call   21d1 <parser_advance>
      }
      break;
    24e3:	jmp    277a <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    24e8:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    24ef:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24f7:	mov    rax,QWORD PTR [rbp-0x50]
    24fb:	mov    esi,0x1
    2500:	mov    rdi,rax
    2503:	call   21d1 <parser_advance>
      }
      break;
    2508:	jmp    277a <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    250d:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    2514:	mov    rax,QWORD PTR [rbp-0x50]
    2518:	mov    esi,0x1
    251d:	mov    rdi,rax
    2520:	call   21d1 <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    2525:	mov    rax,QWORD PTR [rbp-0x50]
    2529:	mov    rdi,rax
    252c:	call   2152 <parser_at>
    2531:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    2535:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    253d:	jmp    2555 <get_json_token+0x2b3>
        {
          string_count += 1;
    253f:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    2544:	mov    rax,QWORD PTR [rbp-0x50]
    2548:	mov    esi,0x1
    254d:	mov    rdi,rax
    2550:	call   21d1 <parser_advance>
        while (*parser_at(parser) != '"')
    2555:	mov    rax,QWORD PTR [rbp-0x50]
    2559:	mov    rdi,rax
    255c:	call   2152 <parser_at>
    2561:	movzx  eax,BYTE PTR [rax]
    2564:	cmp    al,0x22
    2566:	jne    253f <get_json_token+0x29d>
        }
        token.value.count = string_count;
    2568:	mov    rax,QWORD PTR [rbp-0x40]
    256c:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    2570:	mov    rax,QWORD PTR [rbp-0x50]
    2574:	mov    esi,0x1
    2579:	mov    rdi,rax
    257c:	call   21d1 <parser_advance>
      }
      break;
    2581:	jmp    277a <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2586:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    258d:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2595:	jmp    25ad <get_json_token+0x30b>
        {
          digit_count += 1;
    2597:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    259c:	mov    rax,QWORD PTR [rbp-0x50]
    25a0:	mov    esi,0x1
    25a5:	mov    rdi,rax
    25a8:	call   21d1 <parser_advance>
        while (is_numeric(*parser_at(parser)))
    25ad:	mov    rax,QWORD PTR [rbp-0x50]
    25b1:	mov    rdi,rax
    25b4:	call   2152 <parser_at>
    25b9:	movzx  eax,BYTE PTR [rax]
    25bc:	movzx  eax,al
    25bf:	mov    edi,eax
    25c1:	call   2272 <is_numeric>
    25c6:	test   al,al
    25c8:	jne    2597 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    25ca:	mov    rax,QWORD PTR [rbp-0x38]
    25ce:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    25d2:	jmp    277a <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    25d7:	lea    rax,[rip+0x1eee]        # 44cc <_IO_stdin_used+0x4cc>
    25de:	mov    QWORD PTR [rbp-0x30],rax
    25e2:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25ea:	mov    rcx,QWORD PTR [rbp-0x30]
    25ee:	mov    rdx,QWORD PTR [rbp-0x28]
    25f2:	mov    rax,QWORD PTR [rbp-0x50]
    25f6:	mov    rsi,rcx
    25f9:	mov    rdi,rax
    25fc:	call   2217 <parser_token_is_literal>
    2601:	test   al,al
    2603:	je     2627 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    2605:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    260c:	mov    rax,QWORD PTR [rbp-0x28]
    2610:	mov    rdx,rax
    2613:	mov    rax,QWORD PTR [rbp-0x50]
    2617:	mov    rsi,rdx
    261a:	mov    rdi,rax
    261d:	call   21d1 <parser_advance>
    2622:	jmp    277a <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2627:	mov    rax,QWORD PTR [rbp-0x50]
    262b:	mov    rcx,QWORD PTR [rax+0x10]
    262f:	lea    rdx,[rip+0x1ea2]        # 44d8 <_IO_stdin_used+0x4d8>
    2636:	lea    rax,[rip+0x1e2e]        # 446b <_IO_stdin_used+0x46b>
    263d:	mov    r8,rcx
    2640:	mov    rcx,rdx
    2643:	mov    edx,0xdf
    2648:	mov    rsi,rax
    264b:	mov    edi,0x1
    2650:	mov    eax,0x0
    2655:	call   14a1 <log_message>
        }
      }
      break;
    265a:	jmp    277a <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    265f:	lea    rax,[rip+0x1e9f]        # 4505 <_IO_stdin_used+0x505>
    2666:	mov    QWORD PTR [rbp-0x30],rax
    266a:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    2672:	mov    rcx,QWORD PTR [rbp-0x30]
    2676:	mov    rdx,QWORD PTR [rbp-0x28]
    267a:	mov    rax,QWORD PTR [rbp-0x50]
    267e:	mov    rsi,rcx
    2681:	mov    rdi,rax
    2684:	call   2217 <parser_token_is_literal>
    2689:	test   al,al
    268b:	je     26af <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    268d:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    2694:	mov    rax,QWORD PTR [rbp-0x28]
    2698:	mov    rdx,rax
    269b:	mov    rax,QWORD PTR [rbp-0x50]
    269f:	mov    rsi,rdx
    26a2:	mov    rdi,rax
    26a5:	call   21d1 <parser_advance>
    26aa:	jmp    277a <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    26af:	mov    rax,QWORD PTR [rbp-0x50]
    26b3:	mov    rcx,QWORD PTR [rax+0x10]
    26b7:	lea    rdx,[rip+0x1e1a]        # 44d8 <_IO_stdin_used+0x4d8>
    26be:	lea    rax,[rip+0x1da6]        # 446b <_IO_stdin_used+0x46b>
    26c5:	mov    r8,rcx
    26c8:	mov    rcx,rdx
    26cb:	mov    edx,0xee
    26d0:	mov    rsi,rax
    26d3:	mov    edi,0x1
    26d8:	mov    eax,0x0
    26dd:	call   14a1 <log_message>
        }
      }
      break;
    26e2:	jmp    277a <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    26e7:	lea    rax,[rip+0x1e1d]        # 450b <_IO_stdin_used+0x50b>
    26ee:	mov    QWORD PTR [rbp-0x30],rax
    26f2:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    26fa:	mov    rcx,QWORD PTR [rbp-0x30]
    26fe:	mov    rdx,QWORD PTR [rbp-0x28]
    2702:	mov    rax,QWORD PTR [rbp-0x50]
    2706:	mov    rsi,rcx
    2709:	mov    rdi,rax
    270c:	call   2217 <parser_token_is_literal>
    2711:	test   al,al
    2713:	je     2734 <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    2715:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    271c:	mov    rax,QWORD PTR [rbp-0x28]
    2720:	mov    rdx,rax
    2723:	mov    rax,QWORD PTR [rbp-0x50]
    2727:	mov    rsi,rdx
    272a:	mov    rdi,rax
    272d:	call   21d1 <parser_advance>
    2732:	jmp    277a <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2734:	mov    rax,QWORD PTR [rbp-0x50]
    2738:	mov    rcx,QWORD PTR [rax+0x10]
    273c:	lea    rdx,[rip+0x1d95]        # 44d8 <_IO_stdin_used+0x4d8>
    2743:	lea    rax,[rip+0x1d21]        # 446b <_IO_stdin_used+0x46b>
    274a:	mov    r8,rcx
    274d:	mov    rcx,rdx
    2750:	mov    edx,0xfd
    2755:	mov    rsi,rax
    2758:	mov    edi,0x1
    275d:	mov    eax,0x0
    2762:	call   14a1 <log_message>
        }
      }
      break;
    2767:	jmp    277a <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    2769:	mov    rax,QWORD PTR [rbp-0x50]
    276d:	mov    esi,0x1
    2772:	mov    rdi,rax
    2775:	call   21d1 <parser_advance>
  }

  return token;
    277a:	mov    rcx,QWORD PTR [rbp-0x48]
    277e:	mov    rax,QWORD PTR [rbp-0x20]
    2782:	mov    rdx,QWORD PTR [rbp-0x18]
    2786:	mov    QWORD PTR [rcx],rax
    2789:	mov    QWORD PTR [rcx+0x8],rdx
    278d:	mov    rax,QWORD PTR [rbp-0x10]
    2791:	mov    QWORD PTR [rcx+0x10],rax
}
    2795:	mov    rax,QWORD PTR [rbp-0x48]
    2799:	leave
    279a:	ret

000000000000279b <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    279b:	push   rbp
    279c:	mov    rbp,rsp
    279f:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    27a2:	cmp    DWORD PTR [rbp-0x14],0x7
    27a6:	je     27c0 <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    27a8:	cmp    DWORD PTR [rbp-0x14],0x9
    27ac:	je     27c0 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    27ae:	cmp    DWORD PTR [rbp-0x14],0xa
    27b2:	je     27c0 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    27b4:	cmp    DWORD PTR [rbp-0x14],0xb
    27b8:	je     27c0 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    27ba:	cmp    DWORD PTR [rbp-0x14],0x8
    27be:	jne    27c7 <json_token_type_is_value_type+0x2c>
    27c0:	mov    eax,0x1
    27c5:	jmp    27cc <json_token_type_is_value_type+0x31>
    27c7:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    27cc:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    27cf:	mov    eax,DWORD PTR [rbp-0x4]
}
    27d2:	pop    rbp
    27d3:	ret

00000000000027d4 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    27d4:	push   rbp
    27d5:	mov    rbp,rsp
    27d8:	push   rbx
    27d9:	sub    rsp,0x88
    27e0:	mov    QWORD PTR [rbp-0x78],rdi
    27e4:	mov    QWORD PTR [rbp-0x80],rsi
    27e8:	mov    QWORD PTR [rbp-0x90],rdx
    27ef:	mov    QWORD PTR [rbp-0x88],rcx
    27f6:	mov    rax,QWORD PTR fs:0x28
    27ff:	mov    QWORD PTR [rbp-0x18],rax
    2803:	xor    eax,eax
  profile_begin_func();
    2805:	lea    r8,[rip+0x2004]        # 4810 <__func__.4>
    280c:	mov    r9d,0x11
    2812:	lea    rax,[rbp-0x50]
    2816:	mov    rsi,r8
    2819:	mov    rdx,r9
    281c:	mov    r8d,0x0
    2822:	mov    ecx,0x1
    2827:	mov    rdi,rax
    282a:	call   1f7a <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    282f:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2837:	mov    eax,DWORD PTR [rbp+0x10]
    283a:	cmp    eax,0x1
    283d:	jne    2869 <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    283f:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    2846:	mov    edx,DWORD PTR [rbp-0x64]
    2849:	mov    rsi,QWORD PTR [rbp-0x80]
    284d:	mov    rax,QWORD PTR [rbp-0x78]
    2851:	mov    ecx,edx
    2853:	mov    edx,0x2
    2858:	mov    rdi,rax
    285b:	call   29bb <parse_json_children>
    2860:	mov    QWORD PTR [rbp-0x60],rax
    2864:	jmp    28f3 <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2869:	mov    eax,DWORD PTR [rbp+0x10]
    286c:	cmp    eax,0x3
    286f:	jne    2898 <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    2871:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2878:	mov    edx,DWORD PTR [rbp-0x68]
    287b:	mov    rsi,QWORD PTR [rbp-0x80]
    287f:	mov    rax,QWORD PTR [rbp-0x78]
    2883:	mov    ecx,edx
    2885:	mov    edx,0x4
    288a:	mov    rdi,rax
    288d:	call   29bb <parse_json_children>
    2892:	mov    QWORD PTR [rbp-0x60],rax
    2896:	jmp    28f3 <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    2898:	mov    eax,DWORD PTR [rbp+0x10]
    289b:	mov    edi,eax
    289d:	call   279b <json_token_type_is_value_type>
    28a2:	test   eax,eax
    28a4:	jne    28f3 <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    28a6:	mov    eax,DWORD PTR [rbp+0x10]
    28a9:	mov    eax,eax
    28ab:	lea    rdx,[rax*8+0x0]
    28b3:	lea    rax,[rip+0x4826]        # 70e0 <JSON_Token_Type_strings>
    28ba:	mov    rcx,QWORD PTR [rdx+rax*1]
    28be:	lea    rdx,[rip+0x1c4b]        # 4510 <_IO_stdin_used+0x510>
    28c5:	lea    rax,[rip+0x1b9f]        # 446b <_IO_stdin_used+0x46b>
    28cc:	push   QWORD PTR [rbp+0x20]
    28cf:	push   QWORD PTR [rbp+0x18]
    28d2:	mov    r8,rcx
    28d5:	mov    rcx,rdx
    28d8:	mov    edx,0x134
    28dd:	mov    rsi,rax
    28e0:	mov    edi,0x1
    28e5:	mov    eax,0x0
    28ea:	call   14a1 <log_message>
    28ef:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    28f3:	mov    rax,QWORD PTR [rbp-0x78]
    28f7:	mov    edx,0x8
    28fc:	mov    esi,0x30
    2901:	mov    rdi,rax
    2904:	call   17d3 <arena_alloc>
    2909:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    290d:	mov    rcx,QWORD PTR [rbp-0x58]
    2911:	mov    rax,QWORD PTR [rbp-0x90]
    2918:	mov    rdx,QWORD PTR [rbp-0x88]
    291f:	mov    QWORD PTR [rcx],rax
    2922:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    2926:	mov    rax,QWORD PTR [rbp-0x58]
    292a:	mov    rdx,QWORD PTR [rbp-0x60]
    292e:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    2932:	mov    rax,QWORD PTR [rbp-0x58]
    2936:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    293e:	mov    rcx,QWORD PTR [rbp-0x58]
    2942:	mov    rax,QWORD PTR [rbp+0x18]
    2946:	mov    rdx,QWORD PTR [rbp+0x20]
    294a:	mov    QWORD PTR [rcx+0x10],rax
    294e:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    2952:	sub    rsp,0x8
    2956:	sub    rsp,0x38
    295a:	mov    rax,rsp
    295d:	mov    rcx,QWORD PTR [rbp-0x50]
    2961:	mov    rbx,QWORD PTR [rbp-0x48]
    2965:	mov    QWORD PTR [rax],rcx
    2968:	mov    QWORD PTR [rax+0x8],rbx
    296c:	mov    rcx,QWORD PTR [rbp-0x40]
    2970:	mov    rbx,QWORD PTR [rbp-0x38]
    2974:	mov    QWORD PTR [rax+0x10],rcx
    2978:	mov    QWORD PTR [rax+0x18],rbx
    297c:	mov    rcx,QWORD PTR [rbp-0x30]
    2980:	mov    rbx,QWORD PTR [rbp-0x28]
    2984:	mov    QWORD PTR [rax+0x20],rcx
    2988:	mov    QWORD PTR [rax+0x28],rbx
    298c:	mov    rdx,QWORD PTR [rbp-0x20]
    2990:	mov    QWORD PTR [rax+0x30],rdx
    2994:	call   2064 <__profile_end_pass>
    2999:	add    rsp,0x40

  return result;
    299d:	mov    rax,QWORD PTR [rbp-0x58]
}
    29a1:	mov    rdx,QWORD PTR [rbp-0x18]
    29a5:	sub    rdx,QWORD PTR fs:0x28
    29ae:	je     29b5 <parse_json_object+0x1e1>
    29b0:	call   1060 <__stack_chk_fail@plt>
    29b5:	mov    rbx,QWORD PTR [rbp-0x8]
    29b9:	leave
    29ba:	ret

00000000000029bb <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    29bb:	push   rbp
    29bc:	mov    rbp,rsp
    29bf:	push   rbx
    29c0:	sub    rsp,0x108
    29c7:	mov    QWORD PTR [rbp-0xd8],rdi
    29ce:	mov    QWORD PTR [rbp-0xe0],rsi
    29d5:	mov    DWORD PTR [rbp-0xe4],edx
    29db:	mov    DWORD PTR [rbp-0xe8],ecx
    29e1:	mov    rax,QWORD PTR fs:0x28
    29ea:	mov    QWORD PTR [rbp-0x18],rax
    29ee:	xor    eax,eax
  profile_begin_func();
    29f0:	lea    r8,[rip+0x1e39]        # 4830 <__func__.3>
    29f7:	mov    r9d,0x13
    29fd:	lea    rax,[rbp-0x50]
    2a01:	mov    rsi,r8
    2a04:	mov    rdx,r9
    2a07:	mov    r8d,0x0
    2a0d:	mov    ecx,0x2
    2a12:	mov    rdi,rax
    2a15:	call   1f7a <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2a1a:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    2a25:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2a30:	jmp    2d09 <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2a35:	pxor   xmm0,xmm0
    2a39:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2a40:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2a48:	pxor   xmm0,xmm0
    2a4c:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2a53:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2a58:	cmp    DWORD PTR [rbp-0xe8],0x0
    2a5f:	je     2b6c <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2a65:	lea    rax,[rbp-0xb0]
    2a6c:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a73:	mov    rsi,rdx
    2a76:	mov    rdi,rax
    2a79:	call   22a2 <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2a7e:	mov    eax,DWORD PTR [rbp-0xb0]
    2a84:	cmp    eax,0x7
    2a87:	jne    2b08 <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2a89:	lea    rax,[rbp-0x70]
    2a8d:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a94:	mov    rsi,rdx
    2a97:	mov    rdi,rax
    2a9a:	call   22a2 <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2a9f:	mov    eax,DWORD PTR [rbp-0x70]
    2aa2:	cmp    eax,0x6
    2aa5:	jne    2ac5 <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2aa7:	lea    rax,[rbp-0x90]
    2aae:	mov    rdx,QWORD PTR [rbp-0xe0]
    2ab5:	mov    rsi,rdx
    2ab8:	mov    rdi,rax
    2abb:	call   22a2 <get_json_token>
    2ac0:	jmp    2bac <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2ac5:	mov    rcx,QWORD PTR [rbp-0xa8]
    2acc:	mov    rax,QWORD PTR [rbp-0xa0]
    2ad3:	mov    esi,eax
    2ad5:	lea    rdx,[rip+0x1a84]        # 4560 <_IO_stdin_used+0x560>
    2adc:	lea    rax,[rip+0x1988]        # 446b <_IO_stdin_used+0x46b>
    2ae3:	mov    r9,rcx
    2ae6:	mov    r8d,esi
    2ae9:	mov    rcx,rdx
    2aec:	mov    edx,0x15f
    2af1:	mov    rsi,rax
    2af4:	mov    edi,0x1
    2af9:	mov    eax,0x0
    2afe:	call   14a1 <log_message>
    2b03:	jmp    2bac <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2b08:	mov    rcx,QWORD PTR [rbp-0xa8]
    2b0f:	mov    rax,QWORD PTR [rbp-0xa0]
    2b16:	mov    edi,eax
    2b18:	mov    eax,DWORD PTR [rbp-0xb0]
    2b1e:	mov    eax,eax
    2b20:	lea    rdx,[rax*8+0x0]
    2b28:	lea    rax,[rip+0x45b1]        # 70e0 <JSON_Token_Type_strings>
    2b2f:	mov    rsi,QWORD PTR [rdx+rax*1]
    2b33:	lea    rdx,[rip+0x1a46]        # 4580 <_IO_stdin_used+0x580>
    2b3a:	lea    rax,[rip+0x192a]        # 446b <_IO_stdin_used+0x46b>
    2b41:	sub    rsp,0x8
    2b45:	push   rcx
    2b46:	mov    r9d,edi
    2b49:	mov    r8,rsi
    2b4c:	mov    rcx,rdx
    2b4f:	mov    edx,0x164
    2b54:	mov    rsi,rax
    2b57:	mov    edi,0x1
    2b5c:	mov    eax,0x0
    2b61:	call   14a1 <log_message>
    2b66:	add    rsp,0x10
    2b6a:	jmp    2bac <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2b6c:	lea    rax,[rbp-0x110]
    2b73:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b7a:	mov    rsi,rdx
    2b7d:	mov    rdi,rax
    2b80:	call   22a2 <get_json_token>
    2b85:	mov    rax,QWORD PTR [rbp-0x110]
    2b8c:	mov    rdx,QWORD PTR [rbp-0x108]
    2b93:	mov    QWORD PTR [rbp-0x90],rax
    2b9a:	mov    QWORD PTR [rbp-0x88],rdx
    2ba1:	mov    rax,QWORD PTR [rbp-0x100]
    2ba8:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2bac:	mov    eax,DWORD PTR [rbp-0x90]
    2bb2:	cmp    DWORD PTR [rbp-0xe4],eax
    2bb8:	je     2d22 <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2bbe:	mov    rax,QWORD PTR [rbp-0xa8]
    2bc5:	mov    rdx,QWORD PTR [rbp-0xa0]
    2bcc:	mov    r8,QWORD PTR [rbp-0xe0]
    2bd3:	mov    rdi,QWORD PTR [rbp-0xd8]
    2bda:	sub    rsp,0x8
    2bde:	sub    rsp,0x18
    2be2:	mov    rsi,rsp
    2be5:	mov    rcx,QWORD PTR [rbp-0x90]
    2bec:	mov    rbx,QWORD PTR [rbp-0x88]
    2bf3:	mov    QWORD PTR [rsi],rcx
    2bf6:	mov    QWORD PTR [rsi+0x8],rbx
    2bfa:	mov    rcx,QWORD PTR [rbp-0x80]
    2bfe:	mov    QWORD PTR [rsi+0x10],rcx
    2c02:	mov    rcx,rdx
    2c05:	mov    rdx,rax
    2c08:	mov    rsi,r8
    2c0b:	call   27d4 <parse_json_object>
    2c10:	add    rsp,0x20
    2c14:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2c1b:	cmp    QWORD PTR [rbp-0xb8],0x0
    2c23:	je     2c6d <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2c25:	cmp    QWORD PTR [rbp-0xc8],0x0
    2c2d:	jne    2c4d <parse_json_children+0x292>
      {
        first_child        = object;
    2c2f:	mov    rax,QWORD PTR [rbp-0xb8]
    2c36:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2c3d:	mov    rax,QWORD PTR [rbp-0xb8]
    2c44:	mov    QWORD PTR [rbp-0xc0],rax
    2c4b:	jmp    2c6d <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2c4d:	mov    rax,QWORD PTR [rbp-0xc0]
    2c54:	mov    rdx,QWORD PTR [rbp-0xb8]
    2c5b:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2c5f:	mov    rax,QWORD PTR [rbp-0xb8]
    2c66:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2c6d:	lea    rax,[rbp-0x70]
    2c71:	mov    rdx,QWORD PTR [rbp-0xe0]
    2c78:	mov    rsi,rdx
    2c7b:	mov    rdi,rax
    2c7e:	call   22a2 <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2c83:	mov    eax,DWORD PTR [rbp-0x70]
    2c86:	cmp    DWORD PTR [rbp-0xe4],eax
    2c8c:	je     2d25 <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2c92:	mov    eax,DWORD PTR [rbp-0x70]
    2c95:	cmp    eax,0x5
    2c98:	je     2d09 <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2c9a:	mov    r8,QWORD PTR [rbp-0x68]
    2c9e:	mov    rax,QWORD PTR [rbp-0x60]
    2ca2:	mov    r9d,eax
    2ca5:	mov    eax,DWORD PTR [rbp-0x70]
    2ca8:	mov    eax,eax
    2caa:	lea    rdx,[rax*8+0x0]
    2cb2:	lea    rax,[rip+0x4427]        # 70e0 <JSON_Token_Type_strings>
    2cb9:	mov    r10,QWORD PTR [rdx+rax*1]
    2cbd:	lea    rdi,[rip+0x18e4]        # 45a8 <_IO_stdin_used+0x5a8>
    2cc4:	lea    rsi,[rip+0x17a0]        # 446b <_IO_stdin_used+0x46b>
    2ccb:	sub    rsp,0x18
    2ccf:	mov    rcx,rsp
    2cd2:	mov    rax,QWORD PTR [rbp-0x70]
    2cd6:	mov    rdx,QWORD PTR [rbp-0x68]
    2cda:	mov    QWORD PTR [rcx],rax
    2cdd:	mov    QWORD PTR [rcx+0x8],rdx
    2ce1:	mov    rax,QWORD PTR [rbp-0x60]
    2ce5:	mov    QWORD PTR [rcx+0x10],rax
    2ce9:	push   r8
    2ceb:	mov    r8,r10
    2cee:	mov    rcx,rdi
    2cf1:	mov    edx,0x18b
    2cf6:	mov    edi,0x1
    2cfb:	mov    eax,0x0
    2d00:	call   14a1 <log_message>
    2d05:	add    rsp,0x20
  while (parser_incomplete(parser))
    2d09:	mov    rax,QWORD PTR [rbp-0xe0]
    2d10:	mov    rdi,rax
    2d13:	call   21f7 <parser_incomplete>
    2d18:	test   al,al
    2d1a:	jne    2a35 <parse_json_children+0x7a>
    2d20:	jmp    2d26 <parse_json_children+0x36b>
      break;
    2d22:	nop
    2d23:	jmp    2d26 <parse_json_children+0x36b>
      break;
    2d25:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2d26:	sub    rsp,0x8
    2d2a:	sub    rsp,0x38
    2d2e:	mov    rax,rsp
    2d31:	mov    rcx,QWORD PTR [rbp-0x50]
    2d35:	mov    rbx,QWORD PTR [rbp-0x48]
    2d39:	mov    QWORD PTR [rax],rcx
    2d3c:	mov    QWORD PTR [rax+0x8],rbx
    2d40:	mov    rcx,QWORD PTR [rbp-0x40]
    2d44:	mov    rbx,QWORD PTR [rbp-0x38]
    2d48:	mov    QWORD PTR [rax+0x10],rcx
    2d4c:	mov    QWORD PTR [rax+0x18],rbx
    2d50:	mov    rcx,QWORD PTR [rbp-0x30]
    2d54:	mov    rbx,QWORD PTR [rbp-0x28]
    2d58:	mov    QWORD PTR [rax+0x20],rcx
    2d5c:	mov    QWORD PTR [rax+0x28],rbx
    2d60:	mov    rdx,QWORD PTR [rbp-0x20]
    2d64:	mov    QWORD PTR [rax+0x30],rdx
    2d68:	call   2064 <__profile_end_pass>
    2d6d:	add    rsp,0x40

  return first_child;
    2d71:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2d78:	mov    rdx,QWORD PTR [rbp-0x18]
    2d7c:	sub    rdx,QWORD PTR fs:0x28
    2d85:	je     2d8c <parse_json_children+0x3d1>
    2d87:	call   1060 <__stack_chk_fail@plt>
    2d8c:	mov    rbx,QWORD PTR [rbp-0x8]
    2d90:	leave
    2d91:	ret

0000000000002d92 <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2d92:	push   rbp
    2d93:	mov    rbp,rsp
    2d96:	push   rbx
    2d97:	sub    rsp,0xb8
    2d9e:	mov    QWORD PTR [rbp-0xa8],rdi
    2da5:	mov    rax,rsi
    2da8:	mov    rsi,rdx
    2dab:	mov    rax,rax
    2dae:	mov    edx,0x0
    2db3:	mov    rdx,rsi
    2db6:	mov    QWORD PTR [rbp-0xc0],rax
    2dbd:	mov    QWORD PTR [rbp-0xb8],rdx
    2dc4:	mov    rax,QWORD PTR fs:0x28
    2dcd:	mov    QWORD PTR [rbp-0x18],rax
    2dd1:	xor    eax,eax
  profile_begin_func();
    2dd3:	lea    rcx,[rip+0x1a6e]        # 4848 <__func__.2>
    2dda:	mov    ebx,0xa
    2ddf:	lea    rax,[rbp-0x50]
    2de3:	mov    rsi,rcx
    2de6:	mov    rdx,rbx
    2de9:	mov    r8d,0x0
    2def:	mov    ecx,0x3
    2df4:	mov    rdi,rax
    2df7:	call   1f7a <__profile_begin_pass>

  JSON_Parser parser =
    2dfc:	mov    rax,QWORD PTR [rbp-0xc0]
    2e03:	mov    rdx,QWORD PTR [rbp-0xb8]
    2e0a:	mov    QWORD PTR [rbp-0x90],rax
    2e11:	mov    QWORD PTR [rbp-0x88],rdx
    2e18:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2e20:	lea    rax,[rbp-0x70]
    2e24:	lea    rdx,[rbp-0x90]
    2e2b:	mov    rsi,rdx
    2e2e:	mov    rdi,rax
    2e31:	call   22a2 <get_json_token>
    2e36:	mov    ecx,0x0
    2e3b:	mov    ebx,0x0
    2e40:	lea    r8,[rbp-0x90]
    2e47:	mov    rdi,QWORD PTR [rbp-0xa8]
    2e4e:	sub    rsp,0x8
    2e52:	sub    rsp,0x18
    2e56:	mov    rsi,rsp
    2e59:	mov    rax,QWORD PTR [rbp-0x70]
    2e5d:	mov    rdx,QWORD PTR [rbp-0x68]
    2e61:	mov    QWORD PTR [rsi],rax
    2e64:	mov    QWORD PTR [rsi+0x8],rdx
    2e68:	mov    rax,QWORD PTR [rbp-0x60]
    2e6c:	mov    QWORD PTR [rsi+0x10],rax
    2e70:	mov    rdx,rcx
    2e73:	mov    rcx,rbx
    2e76:	mov    rsi,r8
    2e79:	call   27d4 <parse_json_object>
    2e7e:	add    rsp,0x20
    2e82:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2e89:	sub    rsp,0x8
    2e8d:	sub    rsp,0x38
    2e91:	mov    rax,rsp
    2e94:	mov    rcx,QWORD PTR [rbp-0x50]
    2e98:	mov    rbx,QWORD PTR [rbp-0x48]
    2e9c:	mov    QWORD PTR [rax],rcx
    2e9f:	mov    QWORD PTR [rax+0x8],rbx
    2ea3:	mov    rcx,QWORD PTR [rbp-0x40]
    2ea7:	mov    rbx,QWORD PTR [rbp-0x38]
    2eab:	mov    QWORD PTR [rax+0x10],rcx
    2eaf:	mov    QWORD PTR [rax+0x18],rbx
    2eb3:	mov    rcx,QWORD PTR [rbp-0x30]
    2eb7:	mov    rbx,QWORD PTR [rbp-0x28]
    2ebb:	mov    QWORD PTR [rax+0x20],rcx
    2ebf:	mov    QWORD PTR [rax+0x28],rbx
    2ec3:	mov    rdx,QWORD PTR [rbp-0x20]
    2ec7:	mov    QWORD PTR [rax+0x30],rdx
    2ecb:	call   2064 <__profile_end_pass>
    2ed0:	add    rsp,0x40

  return outer;
    2ed4:	mov    rax,QWORD PTR [rbp-0x98]
}
    2edb:	mov    rdx,QWORD PTR [rbp-0x18]
    2edf:	sub    rdx,QWORD PTR fs:0x28
    2ee8:	je     2eef <parse_json+0x15d>
    2eea:	call   1060 <__stack_chk_fail@plt>
    2eef:	mov    rbx,QWORD PTR [rbp-0x8]
    2ef3:	leave
    2ef4:	ret

0000000000002ef5 <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2ef5:	push   rbp
    2ef6:	mov    rbp,rsp
    2ef9:	push   rbx
    2efa:	sub    rsp,0x78
    2efe:	mov    QWORD PTR [rbp-0x68],rdi
    2f02:	mov    rax,rsi
    2f05:	mov    rsi,rdx
    2f08:	mov    rax,rax
    2f0b:	mov    edx,0x0
    2f10:	mov    rdx,rsi
    2f13:	mov    QWORD PTR [rbp-0x80],rax
    2f17:	mov    QWORD PTR [rbp-0x78],rdx
    2f1b:	mov    rax,QWORD PTR fs:0x28
    2f24:	mov    QWORD PTR [rbp-0x18],rax
    2f28:	xor    eax,eax
  profile_begin_func();
    2f2a:	lea    rcx,[rip+0x192f]        # 4860 <__func__.1>
    2f31:	mov    ebx,0x12
    2f36:	lea    rax,[rbp-0x50]
    2f3a:	mov    rsi,rcx
    2f3d:	mov    rdx,rbx
    2f40:	mov    r8d,0x0
    2f46:	mov    ecx,0x4
    2f4b:	mov    rdi,rax
    2f4e:	call   1f7a <__profile_begin_pass>

  JSON_Object *result = NULL;
    2f53:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2f5b:	cmp    QWORD PTR [rbp-0x68],0x0
    2f60:	je     2faf <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f62:	mov    rax,QWORD PTR [rbp-0x68]
    2f66:	mov    rax,QWORD PTR [rax+0x20]
    2f6a:	mov    QWORD PTR [rbp-0x58],rax
    2f6e:	jmp    2fa8 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2f70:	mov    rax,QWORD PTR [rbp-0x58]
    2f74:	mov    rdx,QWORD PTR [rax+0x8]
    2f78:	mov    rax,QWORD PTR [rax]
    2f7b:	mov    rdi,QWORD PTR [rbp-0x80]
    2f7f:	mov    rsi,QWORD PTR [rbp-0x78]
    2f83:	mov    rcx,rdx
    2f86:	mov    rdx,rax
    2f89:	call   143f <strings_equal>
    2f8e:	test   al,al
    2f90:	je     2f9c <lookup_json_object+0xa7>
      {
        result = cursor;
    2f92:	mov    rax,QWORD PTR [rbp-0x58]
    2f96:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2f9a:	jmp    2faf <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f9c:	mov    rax,QWORD PTR [rbp-0x58]
    2fa0:	mov    rax,QWORD PTR [rax+0x28]
    2fa4:	mov    QWORD PTR [rbp-0x58],rax
    2fa8:	cmp    QWORD PTR [rbp-0x58],0x0
    2fad:	jne    2f70 <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2faf:	sub    rsp,0x8
    2fb3:	sub    rsp,0x38
    2fb7:	mov    rax,rsp
    2fba:	mov    rcx,QWORD PTR [rbp-0x50]
    2fbe:	mov    rbx,QWORD PTR [rbp-0x48]
    2fc2:	mov    QWORD PTR [rax],rcx
    2fc5:	mov    QWORD PTR [rax+0x8],rbx
    2fc9:	mov    rcx,QWORD PTR [rbp-0x40]
    2fcd:	mov    rbx,QWORD PTR [rbp-0x38]
    2fd1:	mov    QWORD PTR [rax+0x10],rcx
    2fd5:	mov    QWORD PTR [rax+0x18],rbx
    2fd9:	mov    rcx,QWORD PTR [rbp-0x30]
    2fdd:	mov    rbx,QWORD PTR [rbp-0x28]
    2fe1:	mov    QWORD PTR [rax+0x20],rcx
    2fe5:	mov    QWORD PTR [rax+0x28],rbx
    2fe9:	mov    rdx,QWORD PTR [rbp-0x20]
    2fed:	mov    QWORD PTR [rax+0x30],rdx
    2ff1:	call   2064 <__profile_end_pass>
    2ff6:	add    rsp,0x40

  return result;
    2ffa:	mov    rax,QWORD PTR [rbp-0x60]
}
    2ffe:	mov    rdx,QWORD PTR [rbp-0x18]
    3002:	sub    rdx,QWORD PTR fs:0x28
    300b:	je     3012 <lookup_json_object+0x11d>
    300d:	call   1060 <__stack_chk_fail@plt>
    3012:	mov    rbx,QWORD PTR [rbp-0x8]
    3016:	leave
    3017:	ret

0000000000003018 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    3018:	push   rbp
    3019:	mov    rbp,rsp
    301c:	sub    rsp,0x50
    3020:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    3024:	cmp    QWORD PTR [rbp-0x48],0x0
    3029:	jne    3050 <json_object_to_f64+0x38>
    302b:	lea    rdx,[rip+0x184e]        # 4880 <__PRETTY_FUNCTION__.0>
    3032:	lea    rsi,[rip+0x1432]        # 446b <_IO_stdin_used+0x46b>
    3039:	lea    rax,[rip+0x15a8]        # 45e8 <_IO_stdin_used+0x5e8>
    3040:	mov    rcx,rdx
    3043:	mov    edx,0x1c2
    3048:	mov    rdi,rax
    304b:	call   1090 <__assert_fail@plt>

  String val = object->value;
    3050:	mov    rax,QWORD PTR [rbp-0x48]
    3054:	mov    rdx,QWORD PTR [rax+0x18]
    3058:	mov    rax,QWORD PTR [rax+0x10]
    305c:	mov    QWORD PTR [rbp-0x10],rax
    3060:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    3064:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    306c:	movsd  xmm0,QWORD PTR [rip+0x1844]        # 48b8 <__PRETTY_FUNCTION__.0+0x38>
    3074:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    3079:	mov    rax,QWORD PTR [rbp-0x8]
    307d:	cmp    QWORD PTR [rbp-0x30],rax
    3081:	jae    30a7 <json_object_to_f64+0x8f>
    3083:	mov    rdx,QWORD PTR [rbp-0x10]
    3087:	mov    rax,QWORD PTR [rbp-0x30]
    308b:	add    rax,rdx
    308e:	movzx  eax,BYTE PTR [rax]
    3091:	cmp    al,0x2d
    3093:	jne    30a7 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    3095:	movsd  xmm0,QWORD PTR [rip+0x1823]        # 48c0 <__PRETTY_FUNCTION__.0+0x40>
    309d:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    30a2:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    30a7:	pxor   xmm0,xmm0
    30ab:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    30b0:	jmp    30f7 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    30b2:	mov    rdx,QWORD PTR [rbp-0x10]
    30b6:	mov    rax,QWORD PTR [rbp-0x30]
    30ba:	add    rax,rdx
    30bd:	movzx  eax,BYTE PTR [rax]
    30c0:	sub    eax,0x30
    30c3:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    30c6:	cmp    BYTE PTR [rbp-0x32],0x9
    30ca:	ja     3103 <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    30cc:	movsd  xmm1,QWORD PTR [rbp-0x20]
    30d1:	movsd  xmm0,QWORD PTR [rip+0x17ef]        # 48c8 <__PRETTY_FUNCTION__.0+0x48>
    30d9:	mulsd  xmm1,xmm0
    30dd:	movzx  eax,BYTE PTR [rbp-0x32]
    30e1:	pxor   xmm0,xmm0
    30e5:	cvtsi2sd xmm0,eax
    30e9:	addsd  xmm0,xmm1
    30ed:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    30f2:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    30f7:	mov    rax,QWORD PTR [rbp-0x8]
    30fb:	cmp    QWORD PTR [rbp-0x30],rax
    30ff:	jb     30b2 <json_object_to_f64+0x9a>
    3101:	jmp    3104 <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    3103:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    3104:	mov    rax,QWORD PTR [rbp-0x8]
    3108:	cmp    QWORD PTR [rbp-0x30],rax
    310c:	jae    3199 <json_object_to_f64+0x181>
    3112:	mov    rdx,QWORD PTR [rbp-0x10]
    3116:	mov    rax,QWORD PTR [rbp-0x30]
    311a:	add    rax,rdx
    311d:	movzx  eax,BYTE PTR [rax]
    3120:	cmp    al,0x2e
    3122:	jne    3199 <json_object_to_f64+0x181>
  {
    at += 1;
    3124:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    3129:	movsd  xmm0,QWORD PTR [rip+0x179f]        # 48d0 <__PRETTY_FUNCTION__.0+0x50>
    3131:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    3136:	jmp    318c <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3138:	mov    rdx,QWORD PTR [rbp-0x10]
    313c:	mov    rax,QWORD PTR [rbp-0x30]
    3140:	add    rax,rdx
    3143:	movzx  eax,BYTE PTR [rax]
    3146:	sub    eax,0x30
    3149:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    314c:	cmp    BYTE PTR [rbp-0x31],0x9
    3150:	ja     3198 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    3152:	movzx  eax,BYTE PTR [rbp-0x31]
    3156:	pxor   xmm0,xmm0
    315a:	cvtsi2sd xmm0,eax
    315e:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    3163:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3168:	addsd  xmm0,xmm1
    316c:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    3171:	movsd  xmm1,QWORD PTR [rbp-0x18]
    3176:	movsd  xmm0,QWORD PTR [rip+0x1752]        # 48d0 <__PRETTY_FUNCTION__.0+0x50>
    317e:	mulsd  xmm0,xmm1
    3182:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3187:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    318c:	mov    rax,QWORD PTR [rbp-0x8]
    3190:	cmp    QWORD PTR [rbp-0x30],rax
    3194:	jb     3138 <json_object_to_f64+0x120>
    3196:	jmp    3199 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    3198:	nop
      }
    }
  }

  return sign * result;
    3199:	movsd  xmm0,QWORD PTR [rbp-0x28]
    319e:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    31a3:	leave
    31a4:	ret

00000000000031a5 <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    31a5:	push   rbp
    31a6:	mov    rbp,rsp
    31a9:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    31ae:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31b3:	movsd  xmm1,QWORD PTR [rip+0x171d]        # 48d8 <__PRETTY_FUNCTION__.0+0x58>
    31bb:	divsd  xmm0,xmm1
}
    31bf:	pop    rbp
    31c0:	ret

00000000000031c1 <square>:

static
f64 square(f64 x)
{
    31c1:	push   rbp
    31c2:	mov    rbp,rsp
    31c5:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    31ca:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31cf:	mulsd  xmm0,xmm0
}
    31d3:	pop    rbp
    31d4:	ret

00000000000031d5 <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    31d5:	push   rbp
    31d6:	mov    rbp,rsp
    31d9:	sub    rsp,0x90
    31e0:	movsd  QWORD PTR [rbp-0x58],xmm0
    31e5:	movsd  QWORD PTR [rbp-0x60],xmm1
    31ea:	movsd  QWORD PTR [rbp-0x68],xmm2
    31ef:	movsd  QWORD PTR [rbp-0x70],xmm3
    31f4:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    31f9:	movsd  xmm0,QWORD PTR [rbp-0x60]
    31fe:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    3203:	movsd  xmm0,QWORD PTR [rbp-0x70]
    3208:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    320d:	movsd  xmm0,QWORD PTR [rbp-0x58]
    3212:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    3217:	movsd  xmm0,QWORD PTR [rbp-0x68]
    321c:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    3221:	movsd  xmm0,QWORD PTR [rbp-0x40]
    3226:	subsd  xmm0,QWORD PTR [rbp-0x48]
    322b:	movq   rax,xmm0
    3230:	movq   xmm0,rax
    3235:	call   31a5 <to_radians>
    323a:	movq   rax,xmm0
    323f:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    3243:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3248:	subsd  xmm0,QWORD PTR [rbp-0x38]
    324d:	movq   rax,xmm0
    3252:	movq   xmm0,rax
    3257:	call   31a5 <to_radians>
    325c:	movq   rax,xmm0
    3261:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    3265:	mov    rax,QWORD PTR [rbp-0x48]
    3269:	movq   xmm0,rax
    326e:	call   31a5 <to_radians>
    3273:	movq   rax,xmm0
    3278:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    327c:	mov    rax,QWORD PTR [rbp-0x40]
    3280:	movq   xmm0,rax
    3285:	call   31a5 <to_radians>
    328a:	movq   rax,xmm0
    328f:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    3293:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3298:	movsd  xmm1,QWORD PTR [rip+0x1640]        # 48e0 <__PRETTY_FUNCTION__.0+0x60>
    32a0:	divsd  xmm0,xmm1
    32a4:	movq   rax,xmm0
    32a9:	movq   xmm0,rax
    32ae:	call   1130 <sin@plt>
    32b3:	movq   rax,xmm0
    32b8:	movq   xmm0,rax
    32bd:	call   31c1 <square>
    32c2:	movsd  QWORD PTR [rbp-0x80],xmm0
    32c7:	mov    rax,QWORD PTR [rbp-0x48]
    32cb:	movq   xmm0,rax
    32d0:	call   10b0 <cos@plt>
    32d5:	movsd  QWORD PTR [rbp-0x88],xmm0
    32dd:	mov    rax,QWORD PTR [rbp-0x40]
    32e1:	movq   xmm0,rax
    32e6:	call   10b0 <cos@plt>
    32eb:	movapd xmm5,xmm0
    32ef:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    32f7:	movsd  QWORD PTR [rbp-0x88],xmm5
    32ff:	movsd  xmm0,QWORD PTR [rbp-0x20]
    3304:	movsd  xmm1,QWORD PTR [rip+0x15d4]        # 48e0 <__PRETTY_FUNCTION__.0+0x60>
    330c:	movapd xmm6,xmm0
    3310:	divsd  xmm6,xmm1
    3314:	movq   rax,xmm6
    3319:	movq   xmm0,rax
    331e:	call   1130 <sin@plt>
    3323:	movq   rax,xmm0
    3328:	movq   xmm0,rax
    332d:	call   31c1 <square>
    3332:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    333a:	addsd  xmm0,QWORD PTR [rbp-0x80]
    333f:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    3344:	mov    rax,QWORD PTR [rbp-0x18]
    3348:	movq   xmm0,rax
    334d:	call   1160 <sqrt@plt>
    3352:	movq   rax,xmm0
    3357:	movq   xmm0,rax
    335c:	call   1140 <asin@plt>
    3361:	addsd  xmm0,xmm0
    3365:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    336a:	movsd  xmm0,QWORD PTR [rbp-0x78]
    336f:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    3374:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3379:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    337e:	leave
    337f:	ret

0000000000003380 <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    3380:	push   rbp
    3381:	mov    rbp,rsp
    3384:	movsd  QWORD PTR [rbp-0x18],xmm0
    3389:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    338e:	movsd  xmm0,QWORD PTR [rip+0x1552]        # 48e8 <__PRETTY_FUNCTION__.0+0x68>
    3396:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    339b:	movsd  xmm0,QWORD PTR [rbp-0x18]
    33a0:	movq   xmm1,QWORD PTR [rip+0x1548]        # 48f0 <__PRETTY_FUNCTION__.0+0x70>
    33a8:	andpd  xmm0,xmm1
    33ac:	movsd  xmm1,QWORD PTR [rbp-0x20]
    33b1:	movq   xmm2,QWORD PTR [rip+0x1537]        # 48f0 <__PRETTY_FUNCTION__.0+0x70>
    33b9:	andpd  xmm2,xmm1
    33bd:	movapd xmm1,xmm0
    33c1:	subsd  xmm1,xmm2
    33c5:	movsd  xmm0,QWORD PTR [rbp-0x8]
    33ca:	comisd xmm0,xmm1
    33ce:	setae  al
    33d1:	movzx  eax,al
}
    33d4:	pop    rbp
    33d5:	ret

00000000000033d6 <main>:

int main(int args_count, char **args)
{
    33d6:	push   rbp
    33d7:	mov    rbp,rsp
    33da:	push   r15
    33dc:	push   r14
    33de:	push   r13
    33e0:	push   r12
    33e2:	push   rbx
    33e3:	sub    rsp,0x2d8
    33ea:	mov    DWORD PTR [rbp-0x244],edi
    33f0:	mov    QWORD PTR [rbp-0x250],rsi
    33f7:	mov    rax,QWORD PTR fs:0x28
    3400:	mov    QWORD PTR [rbp-0x38],rax
    3404:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    3406:	cmp    DWORD PTR [rbp-0x244],0x3
    340d:	je     343a <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    340f:	mov    rax,QWORD PTR [rbp-0x250]
    3416:	mov    rax,QWORD PTR [rax]
    3419:	lea    rdx,[rip+0x1200]        # 4620 <_IO_stdin_used+0x620>
    3420:	mov    rsi,rax
    3423:	mov    rdi,rdx
    3426:	mov    eax,0x0
    342b:	call   1070 <printf@plt>
    return 1;
    3430:	mov    eax,0x1
    3435:	jmp    3eee <main+0xb18>
  }

  begin_profiling();
    343a:	call   1b3d <begin_profiling>

  Arena arena = {0};
    343f:	pxor   xmm0,xmm0
    3443:	movaps XMMWORD PTR [rbp-0x190],xmm0
    344a:	movaps XMMWORD PTR [rbp-0x180],xmm0
  arena = arena_make(GB(4));
    3451:	lea    rdx,[rbp-0x270]
    3458:	movabs rax,0x100000000
    3462:	mov    rsi,rax
    3465:	mov    rdi,rdx
    3468:	call   1632 <arena_make>
    346d:	mov    rax,QWORD PTR [rbp-0x270]
    3474:	mov    rdx,QWORD PTR [rbp-0x268]
    347b:	mov    QWORD PTR [rbp-0x190],rax
    3482:	mov    QWORD PTR [rbp-0x188],rdx
    3489:	mov    rax,QWORD PTR [rbp-0x260]
    3490:	mov    rdx,QWORD PTR [rbp-0x258]
    3497:	mov    QWORD PTR [rbp-0x180],rax
    349e:	mov    QWORD PTR [rbp-0x178],rdx

  String source = {0};
    34a5:	mov    QWORD PTR [rbp-0x1a0],0x0
    34b0:	mov    QWORD PTR [rbp-0x198],0x0
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    34bb:	mov    rax,QWORD PTR [rbp-0x250]
    34c2:	add    rax,0x8
    34c6:	mov    rax,QWORD PTR [rax]
    34c9:	mov    rdi,rax
    34cc:	call   1303 <file_size>
    34d1:	mov    rcx,rax
    34d4:	lea    r12,[rip+0x1171]        # 464c <_IO_stdin_used+0x64c>
    34db:	mov    r13d,0x4
    34e1:	lea    rdi,[rbp-0x170]
    34e8:	mov    rdx,r12
    34eb:	mov    rax,r13
    34ee:	mov    r8,rcx
    34f1:	mov    ecx,0x5
    34f6:	mov    rsi,rdx
    34f9:	mov    rdx,rax
    34fc:	call   1f7a <__profile_begin_pass>
    3501:	mov    QWORD PTR [rbp-0x230],0x0
    350c:	jmp    35a7 <main+0x1d1>
  {
    source = read_file_to_arena(&arena, args[1]);
    3511:	mov    rax,QWORD PTR [rbp-0x250]
    3518:	add    rax,0x8
    351c:	mov    rdx,QWORD PTR [rax]
    351f:	lea    rax,[rbp-0x190]
    3526:	mov    rsi,rdx
    3529:	mov    rdi,rax
    352c:	call   1357 <read_file_to_arena>
    3531:	mov    QWORD PTR [rbp-0x1a0],rax
    3538:	mov    QWORD PTR [rbp-0x198],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    353f:	add    QWORD PTR [rbp-0x230],0x1
    3547:	sub    rsp,0x8
    354b:	sub    rsp,0x38
    354f:	mov    rcx,rsp
    3552:	mov    rax,QWORD PTR [rbp-0x170]
    3559:	mov    rdx,QWORD PTR [rbp-0x168]
    3560:	mov    QWORD PTR [rcx],rax
    3563:	mov    QWORD PTR [rcx+0x8],rdx
    3567:	mov    rax,QWORD PTR [rbp-0x160]
    356e:	mov    rdx,QWORD PTR [rbp-0x158]
    3575:	mov    QWORD PTR [rcx+0x10],rax
    3579:	mov    QWORD PTR [rcx+0x18],rdx
    357d:	mov    rax,QWORD PTR [rbp-0x150]
    3584:	mov    rdx,QWORD PTR [rbp-0x148]
    358b:	mov    QWORD PTR [rcx+0x20],rax
    358f:	mov    QWORD PTR [rcx+0x28],rdx
    3593:	mov    rax,QWORD PTR [rbp-0x140]
    359a:	mov    QWORD PTR [rcx+0x30],rax
    359e:	call   2064 <__profile_end_pass>
    35a3:	add    rsp,0x40
    35a7:	cmp    QWORD PTR [rbp-0x230],0x0
    35af:	je     3511 <main+0x13b>
  }

  Haversine_Pair *pairs = NULL;
    35b5:	mov    QWORD PTR [rbp-0x228],0x0
  i32 pair_count = 0;
    35c0:	mov    DWORD PTR [rbp-0x238],0x0
  usize max_pairs = 0;
    35ca:	mov    QWORD PTR [rbp-0x220],0x0
  PROFILE_SCOPE("haversine alloc")
    35d5:	lea    r14,[rip+0x1075]        # 4651 <_IO_stdin_used+0x651>
    35dc:	mov    r15d,0xf
    35e2:	lea    rdi,[rbp-0x130]
    35e9:	mov    rdx,r14
    35ec:	mov    rax,r15
    35ef:	mov    r8d,0x0
    35f5:	mov    ecx,0x6
    35fa:	mov    rsi,rdx
    35fd:	mov    rdx,rax
    3600:	call   1f7a <__profile_begin_pass>
    3605:	mov    QWORD PTR [rbp-0x218],0x0
    3610:	jmp    36d8 <main+0x302>
  {
    usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    3615:	mov    QWORD PTR [rbp-0x1a8],0x18
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    3620:	mov    rax,QWORD PTR [rbp-0x198]
    3627:	mov    edx,0x0
    362c:	div    QWORD PTR [rbp-0x1a8]
    3633:	mov    QWORD PTR [rbp-0x220],rax

    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    363a:	mov    rax,QWORD PTR [rbp-0x220]
    3641:	shl    rax,0x5
    3645:	mov    rcx,rax
    3648:	lea    rax,[rbp-0x190]
    364f:	mov    edx,0x8
    3654:	mov    rsi,rcx
    3657:	mov    rdi,rax
    365a:	call   17d3 <arena_alloc>
    365f:	mov    QWORD PTR [rbp-0x228],rax
    pair_count = 0;
    3666:	mov    DWORD PTR [rbp-0x238],0x0
  PROFILE_SCOPE("haversine alloc")
    3670:	add    QWORD PTR [rbp-0x218],0x1
    3678:	sub    rsp,0x8
    367c:	sub    rsp,0x38
    3680:	mov    rcx,rsp
    3683:	mov    rax,QWORD PTR [rbp-0x130]
    368a:	mov    rdx,QWORD PTR [rbp-0x128]
    3691:	mov    QWORD PTR [rcx],rax
    3694:	mov    QWORD PTR [rcx+0x8],rdx
    3698:	mov    rax,QWORD PTR [rbp-0x120]
    369f:	mov    rdx,QWORD PTR [rbp-0x118]
    36a6:	mov    QWORD PTR [rcx+0x10],rax
    36aa:	mov    QWORD PTR [rcx+0x18],rdx
    36ae:	mov    rax,QWORD PTR [rbp-0x110]
    36b5:	mov    rdx,QWORD PTR [rbp-0x108]
    36bc:	mov    QWORD PTR [rcx+0x20],rax
    36c0:	mov    QWORD PTR [rcx+0x28],rdx
    36c4:	mov    rax,QWORD PTR [rbp-0x100]
    36cb:	mov    QWORD PTR [rcx+0x30],rax
    36cf:	call   2064 <__profile_end_pass>
    36d4:	add    rsp,0x40
    36d8:	cmp    QWORD PTR [rbp-0x218],0x0
    36e0:	je     3615 <main+0x23f>
  }

  JSON_Object *root = NULL;
    36e6:	mov    QWORD PTR [rbp-0x1d8],0x0
  root = parse_json(&arena, source);
    36f1:	mov    rcx,QWORD PTR [rbp-0x1a0]
    36f8:	mov    rdx,QWORD PTR [rbp-0x198]
    36ff:	lea    rax,[rbp-0x190]
    3706:	mov    rsi,rcx
    3709:	mov    rdi,rax
    370c:	call   2d92 <parse_json>
    3711:	mov    QWORD PTR [rbp-0x1d8],rax

  f64 haversine_sum = 0.0;
    3718:	pxor   xmm0,xmm0
    371c:	movsd  QWORD PTR [rbp-0x1d0],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    3724:	lea    rax,[rip+0xf36]        # 4661 <_IO_stdin_used+0x661>
    372b:	mov    QWORD PTR [rbp-0x280],rax
    3732:	mov    QWORD PTR [rbp-0x278],0x5
    373d:	mov    rax,QWORD PTR [rbp-0x280]
    3744:	mov    rdx,QWORD PTR [rbp-0x278]
    374b:	mov    rcx,rax
    374e:	mov    rax,QWORD PTR [rbp-0x1d8]
    3755:	mov    rsi,rcx
    3758:	mov    rdi,rax
    375b:	call   2ef5 <lookup_json_object>
    3760:	mov    QWORD PTR [rbp-0x1c8],rax
  if (pairs)
    3767:	cmp    QWORD PTR [rbp-0x228],0x0
    376f:	je     3a04 <main+0x62e>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    3775:	mov    rax,QWORD PTR [rbp-0x1c8]
    377c:	mov    rax,QWORD PTR [rax+0x20]
    3780:	mov    QWORD PTR [rbp-0x210],rax
    3787:	jmp    39e5 <main+0x60f>
    {
      PROFILE_SCOPE("child convert")
    378c:	lea    rax,[rip+0xed4]        # 4667 <_IO_stdin_used+0x667>
    3793:	mov    QWORD PTR [rbp-0x2c0],rax
    379a:	mov    QWORD PTR [rbp-0x2b8],0xd
    37a5:	lea    rdi,[rbp-0x70]
    37a9:	mov    rbx,QWORD PTR [rbp-0x2c0]
    37b0:	mov    rsi,QWORD PTR [rbp-0x2b8]
    37b7:	mov    rdx,rbx
    37ba:	mov    rax,rsi
    37bd:	mov    r8d,0x0
    37c3:	mov    ecx,0x7
    37c8:	mov    rsi,rdx
    37cb:	mov    rdx,rax
    37ce:	call   1f7a <__profile_begin_pass>
    37d3:	mov    QWORD PTR [rbp-0x208],0x0
    37de:	jmp    39c5 <main+0x5ef>
      {
        Haversine_Pair pair =
        {
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    37e3:	lea    rax,[rip+0xe8b]        # 4675 <_IO_stdin_used+0x675>
    37ea:	mov    QWORD PTR [rbp-0x2d0],rax
    37f1:	mov    QWORD PTR [rbp-0x2c8],0x2
    37fc:	mov    rbx,QWORD PTR [rbp-0x2d0]
    3803:	mov    rsi,QWORD PTR [rbp-0x2c8]
    380a:	mov    rax,rbx
    380d:	mov    rdx,rsi
    3810:	mov    rcx,QWORD PTR [rbp-0x210]
    3817:	mov    rsi,rax
    381a:	mov    rdi,rcx
    381d:	call   2ef5 <lookup_json_object>
    3822:	mov    rdi,rax
    3825:	call   3018 <json_object_to_f64>
    382a:	movq   rax,xmm0
        Haversine_Pair pair =
    382f:	mov    QWORD PTR [rbp-0xb0],rax
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    3836:	lea    rax,[rip+0xe3b]        # 4678 <_IO_stdin_used+0x678>
    383d:	mov    QWORD PTR [rbp-0x2e0],rax
    3844:	mov    QWORD PTR [rbp-0x2d8],0x2
    384f:	mov    rax,QWORD PTR [rbp-0x2e0]
    3856:	mov    rdx,QWORD PTR [rbp-0x2d8]
    385d:	mov    rcx,rax
    3860:	mov    rax,QWORD PTR [rbp-0x210]
    3867:	mov    rsi,rcx
    386a:	mov    rdi,rax
    386d:	call   2ef5 <lookup_json_object>
    3872:	mov    rdi,rax
    3875:	call   3018 <json_object_to_f64>
    387a:	movq   rax,xmm0
        Haversine_Pair pair =
    387f:	mov    QWORD PTR [rbp-0xa8],rax
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    3886:	lea    rax,[rip+0xdee]        # 467b <_IO_stdin_used+0x67b>
    388d:	mov    QWORD PTR [rbp-0x2f0],rax
    3894:	mov    QWORD PTR [rbp-0x2e8],0x2
    389f:	mov    rax,QWORD PTR [rbp-0x2f0]
    38a6:	mov    rdx,QWORD PTR [rbp-0x2e8]
    38ad:	mov    rcx,rax
    38b0:	mov    rax,QWORD PTR [rbp-0x210]
    38b7:	mov    rsi,rcx
    38ba:	mov    rdi,rax
    38bd:	call   2ef5 <lookup_json_object>
    38c2:	mov    rdi,rax
    38c5:	call   3018 <json_object_to_f64>
    38ca:	movq   rax,xmm0
        Haversine_Pair pair =
    38cf:	mov    QWORD PTR [rbp-0xa0],rax
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    38d6:	lea    rax,[rip+0xda1]        # 467e <_IO_stdin_used+0x67e>
    38dd:	mov    QWORD PTR [rbp-0x300],rax
    38e4:	mov    QWORD PTR [rbp-0x2f8],0x2
    38ef:	mov    rax,QWORD PTR [rbp-0x300]
    38f6:	mov    rdx,QWORD PTR [rbp-0x2f8]
    38fd:	mov    rcx,rax
    3900:	mov    rax,QWORD PTR [rbp-0x210]
    3907:	mov    rsi,rcx
    390a:	mov    rdi,rax
    390d:	call   2ef5 <lookup_json_object>
    3912:	mov    rdi,rax
    3915:	call   3018 <json_object_to_f64>
    391a:	movq   rax,xmm0
        Haversine_Pair pair =
    391f:	mov    QWORD PTR [rbp-0x98],rax
        };

        pairs[pair_count] = pair;
    3926:	mov    eax,DWORD PTR [rbp-0x238]
    392c:	cdqe
    392e:	shl    rax,0x5
    3932:	mov    rdx,rax
    3935:	mov    rax,QWORD PTR [rbp-0x228]
    393c:	lea    rcx,[rdx+rax*1]
    3940:	mov    rax,QWORD PTR [rbp-0xb0]
    3947:	mov    rdx,QWORD PTR [rbp-0xa8]
    394e:	mov    QWORD PTR [rcx],rax
    3951:	mov    QWORD PTR [rcx+0x8],rdx
    3955:	mov    rax,QWORD PTR [rbp-0xa0]
    395c:	mov    rdx,QWORD PTR [rbp-0x98]
    3963:	mov    QWORD PTR [rcx+0x10],rax
    3967:	mov    QWORD PTR [rcx+0x18],rdx
        pair_count += 1;
    396b:	add    DWORD PTR [rbp-0x238],0x1
      PROFILE_SCOPE("child convert")
    3972:	add    QWORD PTR [rbp-0x208],0x1
    397a:	sub    rsp,0x8
    397e:	sub    rsp,0x38
    3982:	mov    rcx,rsp
    3985:	mov    rax,QWORD PTR [rbp-0x70]
    3989:	mov    rdx,QWORD PTR [rbp-0x68]
    398d:	mov    QWORD PTR [rcx],rax
    3990:	mov    QWORD PTR [rcx+0x8],rdx
    3994:	mov    rax,QWORD PTR [rbp-0x60]
    3998:	mov    rdx,QWORD PTR [rbp-0x58]
    399c:	mov    QWORD PTR [rcx+0x10],rax
    39a0:	mov    QWORD PTR [rcx+0x18],rdx
    39a4:	mov    rax,QWORD PTR [rbp-0x50]
    39a8:	mov    rdx,QWORD PTR [rbp-0x48]
    39ac:	mov    QWORD PTR [rcx+0x20],rax
    39b0:	mov    QWORD PTR [rcx+0x28],rdx
    39b4:	mov    rax,QWORD PTR [rbp-0x40]
    39b8:	mov    QWORD PTR [rcx+0x30],rax
    39bc:	call   2064 <__profile_end_pass>
    39c1:	add    rsp,0x40
    39c5:	cmp    QWORD PTR [rbp-0x208],0x0
    39cd:	je     37e3 <main+0x40d>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    39d3:	mov    rax,QWORD PTR [rbp-0x210]
    39da:	mov    rax,QWORD PTR [rax+0x28]
    39de:	mov    QWORD PTR [rbp-0x210],rax
    39e5:	cmp    QWORD PTR [rbp-0x210],0x0
    39ed:	je     3a04 <main+0x62e>
    39ef:	mov    eax,DWORD PTR [rbp-0x238]
    39f5:	cdqe
    39f7:	cmp    rax,QWORD PTR [rbp-0x220]
    39fe:	jb     378c <main+0x3b6>
      }
    }
  }

  f64 sum = 0.0;
    3a04:	pxor   xmm0,xmm0
    3a08:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3a10:	lea    rax,[rip+0xc6a]        # 4681 <_IO_stdin_used+0x681>
    3a17:	mov    QWORD PTR [rbp-0x290],rax
    3a1e:	mov    QWORD PTR [rbp-0x288],0x3
    3a29:	lea    rax,[rbp-0xf0]
    3a30:	mov    rcx,QWORD PTR [rbp-0x290]
    3a37:	mov    rbx,QWORD PTR [rbp-0x288]
    3a3e:	mov    rsi,rcx
    3a41:	mov    rdx,rbx
    3a44:	mov    r8d,0x0
    3a4a:	mov    ecx,0x8
    3a4f:	mov    rdi,rax
    3a52:	call   1f7a <__profile_begin_pass>
    3a57:	mov    QWORD PTR [rbp-0x1f8],0x0
    3a62:	jmp    3be4 <main+0x80e>
  {
    for (usize i = 0; i < pair_count; i++)
    3a67:	mov    QWORD PTR [rbp-0x1f0],0x0
    3a72:	jmp    3b47 <main+0x771>
    {
      f64 earth_radius = 6372.8;
    3a77:	movsd  xmm0,QWORD PTR [rip+0xe81]        # 4900 <__PRETTY_FUNCTION__.0+0x80>
    3a7f:	movsd  QWORD PTR [rbp-0x1b8],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    3a87:	mov    rax,QWORD PTR [rbp-0x1f0]
    3a8e:	shl    rax,0x5
    3a92:	mov    rdx,rax
    3a95:	mov    rax,QWORD PTR [rbp-0x228]
    3a9c:	add    rax,rdx
    3a9f:	movsd  xmm2,QWORD PTR [rax+0x18]
    3aa4:	mov    rax,QWORD PTR [rbp-0x1f0]
    3aab:	shl    rax,0x5
    3aaf:	mov    rdx,rax
    3ab2:	mov    rax,QWORD PTR [rbp-0x228]
    3ab9:	add    rax,rdx
    3abc:	movsd  xmm1,QWORD PTR [rax+0x10]
    3ac1:	mov    rax,QWORD PTR [rbp-0x1f0]
    3ac8:	shl    rax,0x5
    3acc:	mov    rdx,rax
    3acf:	mov    rax,QWORD PTR [rbp-0x228]
    3ad6:	add    rax,rdx
    3ad9:	movsd  xmm0,QWORD PTR [rax+0x8]
    3ade:	mov    rax,QWORD PTR [rbp-0x1f0]
    3ae5:	shl    rax,0x5
    3ae9:	mov    rdx,rax
    3aec:	mov    rax,QWORD PTR [rbp-0x228]
    3af3:	add    rax,rdx
    3af6:	mov    rax,QWORD PTR [rax]
    3af9:	movsd  xmm3,QWORD PTR [rbp-0x1b8]
    3b01:	movapd xmm4,xmm3
    3b05:	movapd xmm3,xmm2
    3b09:	movapd xmm2,xmm1
    3b0d:	movapd xmm1,xmm0
    3b11:	movq   xmm0,rax
    3b16:	call   31d5 <reference_haversine>
    3b1b:	movq   rax,xmm0
    3b20:	mov    QWORD PTR [rbp-0x1b0],rax
      sum += result;
    3b27:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b2f:	addsd  xmm0,QWORD PTR [rbp-0x1b0]
    3b37:	movsd  QWORD PTR [rbp-0x200],xmm0
    for (usize i = 0; i < pair_count; i++)
    3b3f:	add    QWORD PTR [rbp-0x1f0],0x1
    3b47:	mov    eax,DWORD PTR [rbp-0x238]
    3b4d:	cdqe
    3b4f:	cmp    QWORD PTR [rbp-0x1f0],rax
    3b56:	jb     3a77 <main+0x6a1>
    }
    sum /= pair_count;
    3b5c:	pxor   xmm1,xmm1
    3b60:	cvtsi2sd xmm1,DWORD PTR [rbp-0x238]
    3b68:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b70:	divsd  xmm0,xmm1
    3b74:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3b7c:	add    QWORD PTR [rbp-0x1f8],0x1
    3b84:	sub    rsp,0x8
    3b88:	sub    rsp,0x38
    3b8c:	mov    rax,rsp
    3b8f:	mov    rcx,QWORD PTR [rbp-0xf0]
    3b96:	mov    rbx,QWORD PTR [rbp-0xe8]
    3b9d:	mov    QWORD PTR [rax],rcx
    3ba0:	mov    QWORD PTR [rax+0x8],rbx
    3ba4:	mov    rcx,QWORD PTR [rbp-0xe0]
    3bab:	mov    rbx,QWORD PTR [rbp-0xd8]
    3bb2:	mov    QWORD PTR [rax+0x10],rcx
    3bb6:	mov    QWORD PTR [rax+0x18],rbx
    3bba:	mov    rcx,QWORD PTR [rbp-0xd0]
    3bc1:	mov    rbx,QWORD PTR [rbp-0xc8]
    3bc8:	mov    QWORD PTR [rax+0x20],rcx
    3bcc:	mov    QWORD PTR [rax+0x28],rbx
    3bd0:	mov    rdx,QWORD PTR [rbp-0xc0]
    3bd7:	mov    QWORD PTR [rax+0x30],rdx
    3bdb:	call   2064 <__profile_end_pass>
    3be0:	add    rsp,0x40
    3be4:	cmp    QWORD PTR [rbp-0x1f8],0x0
    3bec:	je     3a67 <main+0x691>
  }

  PROFILE_SCOPE("check")
    3bf2:	lea    rax,[rip+0xa8c]        # 4685 <_IO_stdin_used+0x685>
    3bf9:	mov    QWORD PTR [rbp-0x2a0],rax
    3c00:	mov    QWORD PTR [rbp-0x298],0x5
    3c0b:	lea    rax,[rbp-0xb0]
    3c12:	mov    rcx,QWORD PTR [rbp-0x2a0]
    3c19:	mov    rbx,QWORD PTR [rbp-0x298]
    3c20:	mov    rsi,rcx
    3c23:	mov    rdx,rbx
    3c26:	mov    r8d,0x0
    3c2c:	mov    ecx,0x9
    3c31:	mov    rdi,rax
    3c34:	call   1f7a <__profile_begin_pass>
    3c39:	mov    QWORD PTR [rbp-0x1e8],0x0
    3c44:	jmp    3e19 <main+0xa43>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3c49:	mov    rax,QWORD PTR [rbp-0x250]
    3c50:	add    rax,0x10
    3c54:	mov    rdx,QWORD PTR [rax]
    3c57:	lea    rax,[rbp-0x190]
    3c5e:	mov    rsi,rdx
    3c61:	mov    rdi,rax
    3c64:	call   1357 <read_file_to_arena>
    3c69:	mov    QWORD PTR [rbp-0x70],rax
    3c6d:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3c71:	mov    rax,QWORD PTR [rbp-0x68]
    3c75:	cmp    rax,0xb
    3c79:	jbe    3d8c <main+0x9b6>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3c7f:	mov    rax,QWORD PTR [rbp-0x70]
    3c83:	movsd  xmm0,QWORD PTR [rax]
    3c87:	movsd  QWORD PTR [rbp-0x1c0],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3c8f:	mov    rax,QWORD PTR [rbp-0x70]
    3c93:	mov    eax,DWORD PTR [rax+0x8]
    3c96:	mov    DWORD PTR [rbp-0x234],eax

      if (solution_pairs == pair_count)
    3c9c:	mov    eax,DWORD PTR [rbp-0x234]
    3ca2:	cmp    eax,DWORD PTR [rbp-0x238]
    3ca8:	jne    3d50 <main+0x97a>
      {
        if (epsilon_equal(solution_sum, sum))
    3cae:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3cb6:	mov    rax,QWORD PTR [rbp-0x1c0]
    3cbd:	movapd xmm1,xmm0
    3cc1:	movq   xmm0,rax
    3cc6:	call   3380 <epsilon_equal>
    3ccb:	test   eax,eax
    3ccd:	je     3d11 <main+0x93b>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3ccf:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3cd7:	mov    rax,QWORD PTR [rbp-0x1c0]
    3cde:	lea    rdx,[rip+0x9ab]        # 4690 <_IO_stdin_used+0x690>
    3ce5:	lea    rsi,[rip+0x9d7]        # 46c3 <_IO_stdin_used+0x6c3>
    3cec:	movapd xmm1,xmm0
    3cf0:	movq   xmm0,rax
    3cf5:	mov    rcx,rdx
    3cf8:	mov    edx,0x64
    3cfd:	mov    edi,0x3
    3d02:	mov    eax,0x2
    3d07:	call   14a1 <log_message>
    3d0c:	jmp    3db4 <main+0x9de>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3d11:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3d19:	mov    rax,QWORD PTR [rbp-0x1c0]
    3d20:	lea    rdx,[rip+0x9b1]        # 46d8 <_IO_stdin_used+0x6d8>
    3d27:	lea    rsi,[rip+0x995]        # 46c3 <_IO_stdin_used+0x6c3>
    3d2e:	movapd xmm1,xmm0
    3d32:	movq   xmm0,rax
    3d37:	mov    rcx,rdx
    3d3a:	mov    edx,0x68
    3d3f:	mov    edi,0x1
    3d44:	mov    eax,0x2
    3d49:	call   14a1 <log_message>
    3d4e:	jmp    3db4 <main+0x9de>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3d50:	mov    esi,DWORD PTR [rbp-0x238]
    3d56:	mov    ecx,DWORD PTR [rbp-0x234]
    3d5c:	lea    rdx,[rip+0x9ad]        # 4710 <_IO_stdin_used+0x710>
    3d63:	lea    rax,[rip+0x959]        # 46c3 <_IO_stdin_used+0x6c3>
    3d6a:	mov    r9d,esi
    3d6d:	mov    r8d,ecx
    3d70:	mov    rcx,rdx
    3d73:	mov    edx,0x6d
    3d78:	mov    rsi,rax
    3d7b:	mov    edi,0x1
    3d80:	mov    eax,0x0
    3d85:	call   14a1 <log_message>
    3d8a:	jmp    3db4 <main+0x9de>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3d8c:	lea    rdx,[rip+0x9c5]        # 4758 <_IO_stdin_used+0x758>
    3d93:	lea    rax,[rip+0x929]        # 46c3 <_IO_stdin_used+0x6c3>
    3d9a:	mov    rcx,rdx
    3d9d:	mov    edx,0x72
    3da2:	mov    rsi,rax
    3da5:	mov    edi,0x1
    3daa:	mov    eax,0x0
    3daf:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3db4:	add    QWORD PTR [rbp-0x1e8],0x1
    3dbc:	sub    rsp,0x8
    3dc0:	sub    rsp,0x38
    3dc4:	mov    rax,rsp
    3dc7:	mov    rcx,QWORD PTR [rbp-0xb0]
    3dce:	mov    rbx,QWORD PTR [rbp-0xa8]
    3dd5:	mov    QWORD PTR [rax],rcx
    3dd8:	mov    QWORD PTR [rax+0x8],rbx
    3ddc:	mov    rcx,QWORD PTR [rbp-0xa0]
    3de3:	mov    rbx,QWORD PTR [rbp-0x98]
    3dea:	mov    QWORD PTR [rax+0x10],rcx
    3dee:	mov    QWORD PTR [rax+0x18],rbx
    3df2:	mov    rcx,QWORD PTR [rbp-0x90]
    3df9:	mov    rbx,QWORD PTR [rbp-0x88]
    3e00:	mov    QWORD PTR [rax+0x20],rcx
    3e04:	mov    QWORD PTR [rax+0x28],rbx
    3e08:	mov    rdx,QWORD PTR [rbp-0x80]
    3e0c:	mov    QWORD PTR [rax+0x30],rdx
    3e10:	call   2064 <__profile_end_pass>
    3e15:	add    rsp,0x40
    3e19:	cmp    QWORD PTR [rbp-0x1e8],0x0
    3e21:	je     3c49 <main+0x873>
    }
  }

  PROFILE_SCOPE("free")
    3e27:	lea    rax,[rip+0x965]        # 4793 <_IO_stdin_used+0x793>
    3e2e:	mov    QWORD PTR [rbp-0x2b0],rax
    3e35:	mov    QWORD PTR [rbp-0x2a8],0x4
    3e40:	lea    rax,[rbp-0x70]
    3e44:	mov    rcx,QWORD PTR [rbp-0x2b0]
    3e4b:	mov    rbx,QWORD PTR [rbp-0x2a8]
    3e52:	mov    rsi,rcx
    3e55:	mov    rdx,rbx
    3e58:	mov    r8d,0x0
    3e5e:	mov    ecx,0xa
    3e63:	mov    rdi,rax
    3e66:	call   1f7a <__profile_begin_pass>
    3e6b:	mov    QWORD PTR [rbp-0x1e0],0x0
    3e76:	jmp    3eda <main+0xb04>
  {
    arena_free(&arena);
    3e78:	lea    rax,[rbp-0x190]
    3e7f:	mov    rdi,rax
    3e82:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3e87:	add    QWORD PTR [rbp-0x1e0],0x1
    3e8f:	sub    rsp,0x8
    3e93:	sub    rsp,0x38
    3e97:	mov    rax,rsp
    3e9a:	mov    rcx,QWORD PTR [rbp-0x70]
    3e9e:	mov    rbx,QWORD PTR [rbp-0x68]
    3ea2:	mov    QWORD PTR [rax],rcx
    3ea5:	mov    QWORD PTR [rax+0x8],rbx
    3ea9:	mov    rcx,QWORD PTR [rbp-0x60]
    3ead:	mov    rbx,QWORD PTR [rbp-0x58]
    3eb1:	mov    QWORD PTR [rax+0x10],rcx
    3eb5:	mov    QWORD PTR [rax+0x18],rbx
    3eb9:	mov    rcx,QWORD PTR [rbp-0x50]
    3ebd:	mov    rbx,QWORD PTR [rbp-0x48]
    3ec1:	mov    QWORD PTR [rax+0x20],rcx
    3ec5:	mov    QWORD PTR [rax+0x28],rbx
    3ec9:	mov    rdx,QWORD PTR [rbp-0x40]
    3ecd:	mov    QWORD PTR [rax+0x30],rdx
    3ed1:	call   2064 <__profile_end_pass>
    3ed6:	add    rsp,0x40
    3eda:	cmp    QWORD PTR [rbp-0x1e0],0x0
    3ee2:	je     3e78 <main+0xaa2>
  }

  end_profiling();
    3ee4:	call   1b9b <end_profiling>
    3ee9:	mov    eax,0x0
}
    3eee:	mov    rdx,QWORD PTR [rbp-0x38]
    3ef2:	sub    rdx,QWORD PTR fs:0x28
    3efb:	je     3f02 <main+0xb2c>
    3efd:	call   1060 <__stack_chk_fail@plt>
    3f02:	lea    rsp,[rbp-0x28]
    3f06:	pop    rbx
    3f07:	pop    r12
    3f09:	pop    r13
    3f0b:	pop    r14
    3f0d:	pop    r15
    3f0f:	pop    rbp
    3f10:	ret

Disassembly of section .fini:

0000000000003f14 <_fini>:
    3f14:	endbr64
    3f18:	sub    rsp,0x8
    3f1c:	add    rsp,0x8
    3f20:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x5fc1]        # 6fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x5fca]        # 6ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x5fcc]        # 6ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x5fca]        # 7000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x5fc2]        # 7008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x5fba]        # 7010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x5fb2]        # 7018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x5faa]        # 7020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x5fa2]        # 7028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x5f9a]        # 7030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x5f92]        # 7038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x5f8a]        # 7040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x5f82]        # 7048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x5f7a]        # 7050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x5f72]        # 7058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x5f6a]        # 7060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x5f62]        # 7068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x5f5a]        # 7070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x5f52]        # 7078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x5f4a]        # 7080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x5f42]        # 7088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x5f3a]        # 7090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x5f32]        # 7098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x226b]        # 33fa <main>
    118f:	call   QWORD PTR [rip+0x5e2b]        # 6fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x5fa1]        # 7148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x5f9a]        # 7148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x5e0e]        # 6fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x5f71]        # 7148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x5f6a]        # 7148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x5ddd]        # 6fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x5f6d],0x0        # 7188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x5dba],0x0        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x5e76]        # 70a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x5da8]        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x5f44],0x1        # 7188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x5c6e]        # 7180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x5b89]        # 70c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x5be7]        # 7160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x5b2b]        # 70c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x30a7]        # 47a0 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x307b]        # 47a0 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fbe]        # 47b8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2ebf]        # 47c8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2cdd]        # 47e0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x5639]        # 71a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x5620],rbx        # 71a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x50
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x55ee]        # 71a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x40],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x40],0x0
    1bbe:	je     1f9b <end_profiling+0x400>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x38],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x40]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x38]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c61]        # 4898 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x38]
    1c44:	mov    rax,QWORD PTR [rbp-0x40]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x50],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x48],0x0
    1c72:	jmp    1f8d <end_profiling+0x3f2>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x48]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x550d]        # 71a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x30],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x30]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1f88 <end_profiling+0x3ed>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x30]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x40]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b87]        # 48a0 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x28],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x30]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x30]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x30]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x30]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x28]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x30]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x30]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x30]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x40]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2aaf]        # 48a0 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x20],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x30]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x20]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x50]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x28]
    1e2c:	movsd  QWORD PTR [rbp-0x50],xmm0

        if (zone->bytes_processed)
    1e31:	mov    rax,QWORD PTR [rbp-0x30]
    1e35:	mov    rax,QWORD PTR [rax+0x28]
    1e39:	test   rax,rax
    1e3c:	je     1f88 <end_profiling+0x3ed>
        {
          u64 gigabytes = zone->bytes_processed / BILLION(1);
    1e42:	mov    rax,QWORD PTR [rbp-0x30]
    1e46:	mov    rax,QWORD PTR [rax+0x28]
    1e4a:	shr    rax,0x9
    1e4e:	movabs rdx,0x44b82fa09b5a53
    1e58:	mul    rdx
    1e5b:	mov    rax,rdx
    1e5e:	shr    rax,0xb
    1e62:	mov    QWORD PTR [rbp-0x18],rax
          u64 megabytes = zone->bytes_processed / MILLION(1);
    1e66:	mov    rax,QWORD PTR [rbp-0x30]
    1e6a:	mov    rax,QWORD PTR [rax+0x28]
    1e6e:	movabs rdx,0x431bde82d7b634db
    1e78:	mul    rdx
    1e7b:	mov    rax,rdx
    1e7e:	shr    rax,0x12
    1e82:	mov    QWORD PTR [rbp-0x10],rax

          u64 gb_per_s = gigabytes / (f64)zone->elapsed_exclusive / (f64)freq * MILLION(1);
    1e86:	mov    rax,QWORD PTR [rbp-0x18]
    1e8a:	test   rax,rax
    1e8d:	js     1e9a <end_profiling+0x2ff>
    1e8f:	pxor   xmm0,xmm0
    1e93:	cvtsi2sd xmm0,rax
    1e98:	jmp    1eb3 <end_profiling+0x318>
    1e9a:	mov    rdx,rax
    1e9d:	shr    rdx,1
    1ea0:	and    eax,0x1
    1ea3:	or     rdx,rax
    1ea6:	pxor   xmm0,xmm0
    1eaa:	cvtsi2sd xmm0,rdx
    1eaf:	addsd  xmm0,xmm0
    1eb3:	mov    rax,QWORD PTR [rbp-0x30]
    1eb7:	mov    rax,QWORD PTR [rax+0x10]
    1ebb:	test   rax,rax
    1ebe:	js     1ecb <end_profiling+0x330>
    1ec0:	pxor   xmm1,xmm1
    1ec4:	cvtsi2sd xmm1,rax
    1ec9:	jmp    1ee4 <end_profiling+0x349>
    1ecb:	mov    rdx,rax
    1ece:	shr    rdx,1
    1ed1:	and    eax,0x1
    1ed4:	or     rdx,rax
    1ed7:	pxor   xmm1,xmm1
    1edb:	cvtsi2sd xmm1,rdx
    1ee0:	addsd  xmm1,xmm1
    1ee4:	movapd xmm2,xmm0
    1ee8:	divsd  xmm2,xmm1
    1eec:	mov    rax,QWORD PTR [rbp-0x38]
    1ef0:	test   rax,rax
    1ef3:	js     1f00 <end_profiling+0x365>
    1ef5:	pxor   xmm0,xmm0
    1ef9:	cvtsi2sd xmm0,rax
    1efe:	jmp    1f19 <end_profiling+0x37e>
    1f00:	mov    rdx,rax
    1f03:	shr    rdx,1
    1f06:	and    eax,0x1
    1f09:	or     rdx,rax
    1f0c:	pxor   xmm0,xmm0
    1f10:	cvtsi2sd xmm0,rdx
    1f15:	addsd  xmm0,xmm0
    1f19:	divsd  xmm2,xmm0
    1f1d:	movapd xmm1,xmm2
    1f21:	movsd  xmm0,QWORD PTR [rip+0x297f]        # 48a8 <__PRETTY_FUNCTION__.0+0x28>
    1f29:	mulsd  xmm0,xmm1
    1f2d:	comisd xmm0,QWORD PTR [rip+0x297b]        # 48b0 <__PRETTY_FUNCTION__.0+0x30>
    1f35:	jae    1f42 <end_profiling+0x3a7>
    1f37:	cvttsd2si rax,xmm0
    1f3c:	mov    QWORD PTR [rbp-0x8],rax
    1f40:	jmp    1f65 <end_profiling+0x3ca>
    1f42:	movsd  xmm1,QWORD PTR [rip+0x2966]        # 48b0 <__PRETTY_FUNCTION__.0+0x30>
    1f4a:	subsd  xmm0,xmm1
    1f4e:	cvttsd2si rax,xmm0
    1f53:	mov    QWORD PTR [rbp-0x8],rax
    1f57:	movabs rax,0x8000000000000000
    1f61:	xor    QWORD PTR [rbp-0x8],rax
    1f65:	mov    rax,QWORD PTR [rbp-0x8]
    1f69:	mov    QWORD PTR [rbp-0x8],rax

          printf("  Megabytes Processed: %lu\n", megabytes);
    1f6d:	mov    rax,QWORD PTR [rbp-0x10]
    1f71:	lea    rdx,[rip+0x23cc]        # 4344 <_IO_stdin_used+0x344>
    1f78:	mov    rsi,rax
    1f7b:	mov    rdi,rdx
    1f7e:	mov    eax,0x0
    1f83:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1f88:	add    QWORD PTR [rbp-0x48],0x1
    1f8d:	cmp    QWORD PTR [rbp-0x48],0xfff
    1f95:	jbe    1c77 <end_profiling+0xdc>
        }
      }
    }
  }
}
    1f9b:	nop
    1f9c:	leave
    1f9d:	ret

0000000000001f9e <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1f9e:	push   rbp
    1f9f:	mov    rbp,rsp
    1fa2:	push   rbx
    1fa3:	sub    rsp,0x78
    1fa7:	mov    QWORD PTR [rbp-0x58],rdi
    1fab:	mov    rax,rsi
    1fae:	mov    rsi,rdx
    1fb1:	mov    rax,rax
    1fb4:	mov    edx,0x0
    1fb9:	mov    rdx,rsi
    1fbc:	mov    QWORD PTR [rbp-0x70],rax
    1fc0:	mov    QWORD PTR [rbp-0x68],rdx
    1fc4:	mov    QWORD PTR [rbp-0x60],rcx
    1fc8:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1fcc:	pxor   xmm0,xmm0
    1fd0:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1fd4:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1fd8:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1fdc:	movq   QWORD PTR [rbp-0x20],xmm0
    1fe1:	mov    rax,QWORD PTR [rbp-0x70]
    1fe5:	mov    rdx,QWORD PTR [rbp-0x68]
    1fe9:	mov    QWORD PTR [rbp-0x50],rax
    1fed:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1ff1:	mov    rdx,QWORD PTR [rbp-0x60]
    1ff5:	mov    rax,rdx
    1ff8:	add    rax,rax
    1ffb:	add    rax,rdx
    1ffe:	shl    rax,0x4
    2002:	mov    rdx,rax
    2005:	lea    rax,[rip+0x51bc]        # 71c8 <g_profiler+0x28>
    200c:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    2010:	mov    QWORD PTR [rbp-0x38],rax
    2014:	mov    rax,QWORD PTR [rbp-0x60]
    2018:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    201c:	mov    rax,QWORD PTR [rip+0x5185]        # 71a8 <g_profiler+0x8>
  Profile_Pass pass =
    2023:	mov    QWORD PTR [rbp-0x28],rax
    2027:	mov    rax,QWORD PTR [rbp-0x78]
    202b:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    202f:	mov    rax,QWORD PTR [rbp-0x60]
    2033:	mov    QWORD PTR [rip+0x516e],rax        # 71a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    203a:	call   1a48 <read_cpu_timer>
    203f:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    2043:	mov    rax,QWORD PTR [rbp-0x58]
    2047:	mov    rcx,QWORD PTR [rbp-0x50]
    204b:	mov    rbx,QWORD PTR [rbp-0x48]
    204f:	mov    QWORD PTR [rax],rcx
    2052:	mov    QWORD PTR [rax+0x8],rbx
    2056:	mov    rcx,QWORD PTR [rbp-0x40]
    205a:	mov    rbx,QWORD PTR [rbp-0x38]
    205e:	mov    QWORD PTR [rax+0x10],rcx
    2062:	mov    QWORD PTR [rax+0x18],rbx
    2066:	mov    rcx,QWORD PTR [rbp-0x30]
    206a:	mov    rbx,QWORD PTR [rbp-0x28]
    206e:	mov    QWORD PTR [rax+0x20],rcx
    2072:	mov    QWORD PTR [rax+0x28],rbx
    2076:	mov    rdx,QWORD PTR [rbp-0x20]
    207a:	mov    QWORD PTR [rax+0x30],rdx
}
    207e:	mov    rax,QWORD PTR [rbp-0x58]
    2082:	mov    rbx,QWORD PTR [rbp-0x8]
    2086:	leave
    2087:	ret

0000000000002088 <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    2088:	push   rbp
    2089:	mov    rbp,rsp
    208c:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    2090:	call   1a48 <read_cpu_timer>
    2095:	mov    rdx,rax
    2098:	mov    rax,QWORD PTR [rbp+0x20]
    209c:	sub    rdx,rax
    209f:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    20a3:	mov    rax,QWORD PTR [rbp+0x38]
    20a7:	mov    QWORD PTR [rip+0x50fa],rax        # 71a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    20ae:	mov    rdx,QWORD PTR [rbp+0x30]
    20b2:	mov    rax,rdx
    20b5:	add    rax,rax
    20b8:	add    rax,rdx
    20bb:	shl    rax,0x4
    20bf:	lea    rdx,[rax+0x10]
    20c3:	lea    rax,[rip+0x50d6]        # 71a0 <g_profiler>
    20ca:	add    rax,rdx
    20cd:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    20d1:	mov    rax,QWORD PTR [rbp-0x10]
    20d5:	mov    rdx,QWORD PTR [rax+0x10]
    20d9:	mov    rax,QWORD PTR [rbp-0x18]
    20dd:	add    rdx,rax
    20e0:	mov    rax,QWORD PTR [rbp-0x10]
    20e4:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    20e8:	mov    rax,QWORD PTR [rbp-0x10]
    20ec:	mov    rax,QWORD PTR [rax+0x20]
    20f0:	lea    rdx,[rax+0x1]
    20f4:	mov    rax,QWORD PTR [rbp-0x10]
    20f8:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    20fc:	mov    rcx,QWORD PTR [rbp-0x10]
    2100:	mov    rax,QWORD PTR [rbp+0x10]
    2104:	mov    rdx,QWORD PTR [rbp+0x18]
    2108:	mov    QWORD PTR [rcx],rax
    210b:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    210f:	mov    rdx,QWORD PTR [rbp+0x28]
    2113:	mov    rax,QWORD PTR [rbp-0x18]
    2117:	add    rdx,rax
    211a:	mov    rax,QWORD PTR [rbp-0x10]
    211e:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    2122:	mov    rax,QWORD PTR [rbp-0x10]
    2126:	mov    rdx,QWORD PTR [rax+0x28]
    212a:	mov    rax,QWORD PTR [rbp+0x40]
    212e:	add    rdx,rax
    2131:	mov    rax,QWORD PTR [rbp-0x10]
    2135:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    2139:	mov    rdx,QWORD PTR [rbp+0x38]
    213d:	mov    rax,rdx
    2140:	add    rax,rax
    2143:	add    rax,rdx
    2146:	shl    rax,0x4
    214a:	lea    rdx,[rax+0x10]
    214e:	lea    rax,[rip+0x504b]        # 71a0 <g_profiler>
    2155:	add    rax,rdx
    2158:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    215c:	mov    rax,QWORD PTR [rbp-0x8]
    2160:	mov    rax,QWORD PTR [rax+0x10]
    2164:	sub    rax,QWORD PTR [rbp-0x18]
    2168:	mov    rdx,rax
    216b:	mov    rax,QWORD PTR [rbp-0x8]
    216f:	mov    QWORD PTR [rax+0x10],rdx
}
    2173:	nop
    2174:	leave
    2175:	ret

0000000000002176 <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    2176:	push   rbp
    2177:	mov    rbp,rsp
    217a:	sub    rsp,0x10
    217e:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2182:	mov    rax,QWORD PTR [rbp-0x8]
    2186:	mov    rdx,QWORD PTR [rax+0x10]
    218a:	mov    rax,QWORD PTR [rbp-0x8]
    218e:	mov    rax,QWORD PTR [rax+0x8]
    2192:	cmp    rdx,rax
    2195:	jb     21bc <parser_at+0x46>
    2197:	lea    rdx,[rip+0x265a]        # 47f8 <__PRETTY_FUNCTION__.5>
    219e:	lea    rsi,[rip+0x22c6]        # 446b <_IO_stdin_used+0x46b>
    21a5:	lea    rax,[rip+0x22d4]        # 4480 <_IO_stdin_used+0x480>
    21ac:	mov    rcx,rdx
    21af:	mov    edx,0x2f
    21b4:	mov    rdi,rax
    21b7:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    21bc:	mov    rax,QWORD PTR [rbp-0x8]
    21c0:	mov    rdx,QWORD PTR [rax]
    21c3:	mov    rax,QWORD PTR [rbp-0x8]
    21c7:	mov    rax,QWORD PTR [rax+0x10]
    21cb:	add    rax,rdx
}
    21ce:	leave
    21cf:	ret

00000000000021d0 <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    21d0:	push   rbp
    21d1:	mov    rbp,rsp
    21d4:	sub    rsp,0x10
    21d8:	mov    QWORD PTR [rbp-0x8],rdi
    21dc:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    21e0:	mov    rax,QWORD PTR [rbp-0x8]
    21e4:	mov    rdi,rax
    21e7:	call   2176 <parser_at>
    21ec:	mov    rdx,QWORD PTR [rbp-0x10]
    21f0:	add    rax,rdx
}
    21f3:	leave
    21f4:	ret

00000000000021f5 <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    21f5:	push   rbp
    21f6:	mov    rbp,rsp
    21f9:	mov    QWORD PTR [rbp-0x8],rdi
    21fd:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    2201:	mov    rax,QWORD PTR [rbp-0x8]
    2205:	mov    rdx,QWORD PTR [rax+0x10]
    2209:	mov    rax,QWORD PTR [rbp-0x10]
    220d:	add    rdx,rax
    2210:	mov    rax,QWORD PTR [rbp-0x8]
    2214:	mov    QWORD PTR [rax+0x10],rdx
}
    2218:	nop
    2219:	pop    rbp
    221a:	ret

000000000000221b <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    221b:	push   rbp
    221c:	mov    rbp,rsp
    221f:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    2223:	mov    rax,QWORD PTR [rbp-0x8]
    2227:	mov    rdx,QWORD PTR [rax+0x10]
    222b:	mov    rax,QWORD PTR [rbp-0x8]
    222f:	mov    rax,QWORD PTR [rax+0x8]
    2233:	cmp    rdx,rax
    2236:	setb   al
}
    2239:	pop    rbp
    223a:	ret

000000000000223b <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    223b:	push   rbp
    223c:	mov    rbp,rsp
    223f:	push   r12
    2241:	push   rbx
    2242:	sub    rsp,0x20
    2246:	mov    QWORD PTR [rbp-0x18],rdi
    224a:	mov    rax,rsi
    224d:	mov    rcx,rdx
    2250:	mov    rax,rax
    2253:	mov    edx,0x0
    2258:	mov    rdx,rcx
    225b:	mov    QWORD PTR [rbp-0x30],rax
    225f:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    2263:	mov    rax,QWORD PTR [rbp-0x28]
    2267:	mov    r12,rax
    226a:	mov    rbx,QWORD PTR [rbp-0x30]
    226e:	mov    rax,QWORD PTR [rbp-0x18]
    2272:	mov    rdi,rax
    2275:	call   2176 <parser_at>
    227a:	mov    rdx,r12
    227d:	mov    rsi,rbx
    2280:	mov    rdi,rax
    2283:	call   10d0 <memcmp@plt>
    2288:	test   eax,eax
    228a:	sete   al
}
    228d:	add    rsp,0x20
    2291:	pop    rbx
    2292:	pop    r12
    2294:	pop    rbp
    2295:	ret

0000000000002296 <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    2296:	push   rbp
    2297:	mov    rbp,rsp
    229a:	mov    eax,edi
    229c:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    229f:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    22a3:	movzx  eax,BYTE PTR [rbp-0x14]
    22a7:	cmp    eax,0x2e
    22aa:	jg     22b3 <is_numeric+0x1d>
    22ac:	cmp    eax,0x2d
    22af:	jge    22bb <is_numeric+0x25>
    22b1:	jmp    22c0 <is_numeric+0x2a>
    22b3:	sub    eax,0x30
    22b6:	cmp    eax,0x9
    22b9:	ja     22c0 <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    22bb:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    22bf:	nop
  }


  return result;
    22c0:	movzx  eax,BYTE PTR [rbp-0x1]
}
    22c4:	pop    rbp
    22c5:	ret

00000000000022c6 <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    22c6:	push   rbp
    22c7:	mov    rbp,rsp
    22ca:	sub    rsp,0x50
    22ce:	mov    QWORD PTR [rbp-0x48],rdi
    22d2:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    22d6:	pxor   xmm0,xmm0
    22da:	movaps XMMWORD PTR [rbp-0x20],xmm0
    22de:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    22e3:	jmp    22f6 <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    22e5:	mov    rax,QWORD PTR [rbp-0x50]
    22e9:	mov    esi,0x1
    22ee:	mov    rdi,rax
    22f1:	call   21f5 <parser_advance>
  while (parser_incomplete(parser)  &&
    22f6:	mov    rax,QWORD PTR [rbp-0x50]
    22fa:	mov    rdi,rax
    22fd:	call   221b <parser_incomplete>
    2302:	test   al,al
    2304:	je     2352 <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    2306:	mov    rax,QWORD PTR [rbp-0x50]
    230a:	mov    rdi,rax
    230d:	call   2176 <parser_at>
    2312:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    2315:	cmp    al,0x20
    2317:	je     22e5 <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    2319:	mov    rax,QWORD PTR [rbp-0x50]
    231d:	mov    rdi,rax
    2320:	call   2176 <parser_at>
    2325:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    2328:	cmp    al,0xa
    232a:	je     22e5 <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    232c:	mov    rax,QWORD PTR [rbp-0x50]
    2330:	mov    rdi,rax
    2333:	call   2176 <parser_at>
    2338:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    233b:	cmp    al,0xd
    233d:	je     22e5 <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    233f:	mov    rax,QWORD PTR [rbp-0x50]
    2343:	mov    rdi,rax
    2346:	call   2176 <parser_at>
    234b:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    234e:	cmp    al,0x9
    2350:	je     22e5 <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    2352:	mov    rax,QWORD PTR [rbp-0x50]
    2356:	mov    rdi,rax
    2359:	call   221b <parser_incomplete>
    235e:	test   al,al
    2360:	je     278d <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    2366:	mov    rax,QWORD PTR [rbp-0x50]
    236a:	mov    rdi,rax
    236d:	call   2176 <parser_at>
    2372:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    2376:	mov    rax,QWORD PTR [rbp-0x50]
    237a:	mov    rdi,rax
    237d:	call   2176 <parser_at>
    2382:	movzx  eax,BYTE PTR [rax]
    2385:	movzx  eax,al
    2388:	cmp    eax,0x7d
    238b:	je     2478 <get_json_token+0x1b2>
    2391:	cmp    eax,0x7d
    2394:	jg     279e <get_json_token+0x4d8>
    239a:	cmp    eax,0x7b
    239d:	je     2453 <get_json_token+0x18d>
    23a3:	cmp    eax,0x7b
    23a6:	jg     279e <get_json_token+0x4d8>
    23ac:	cmp    eax,0x74
    23af:	je     25fb <get_json_token+0x335>
    23b5:	cmp    eax,0x74
    23b8:	jg     279e <get_json_token+0x4d8>
    23be:	cmp    eax,0x6e
    23c1:	je     270b <get_json_token+0x445>
    23c7:	cmp    eax,0x6e
    23ca:	jg     279e <get_json_token+0x4d8>
    23d0:	cmp    eax,0x66
    23d3:	je     2683 <get_json_token+0x3bd>
    23d9:	cmp    eax,0x66
    23dc:	jg     279e <get_json_token+0x4d8>
    23e2:	cmp    eax,0x5d
    23e5:	je     24c2 <get_json_token+0x1fc>
    23eb:	cmp    eax,0x5d
    23ee:	jg     279e <get_json_token+0x4d8>
    23f4:	cmp    eax,0x5b
    23f7:	je     249d <get_json_token+0x1d7>
    23fd:	cmp    eax,0x5b
    2400:	jg     279e <get_json_token+0x4d8>
    2406:	cmp    eax,0x3a
    2409:	je     250c <get_json_token+0x246>
    240f:	cmp    eax,0x3a
    2412:	jg     279e <get_json_token+0x4d8>
    2418:	cmp    eax,0x39
    241b:	jg     279e <get_json_token+0x4d8>
    2421:	cmp    eax,0x30
    2424:	jge    25aa <get_json_token+0x2e4>
    242a:	cmp    eax,0x2e
    242d:	jg     279e <get_json_token+0x4d8>
    2433:	cmp    eax,0x2d
    2436:	jge    25aa <get_json_token+0x2e4>
    243c:	cmp    eax,0x22
    243f:	je     2531 <get_json_token+0x26b>
    2445:	cmp    eax,0x2c
    2448:	je     24e7 <get_json_token+0x221>
    244e:	jmp    279e <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    2453:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    245a:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2462:	mov    rax,QWORD PTR [rbp-0x50]
    2466:	mov    esi,0x1
    246b:	mov    rdi,rax
    246e:	call   21f5 <parser_advance>
      }
      break;
    2473:	jmp    279e <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2478:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    247f:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2487:	mov    rax,QWORD PTR [rbp-0x50]
    248b:	mov    esi,0x1
    2490:	mov    rdi,rax
    2493:	call   21f5 <parser_advance>
      }
      break;
    2498:	jmp    279e <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    249d:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    24a4:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24ac:	mov    rax,QWORD PTR [rbp-0x50]
    24b0:	mov    esi,0x1
    24b5:	mov    rdi,rax
    24b8:	call   21f5 <parser_advance>
      }
      break;
    24bd:	jmp    279e <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    24c2:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    24c9:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24d1:	mov    rax,QWORD PTR [rbp-0x50]
    24d5:	mov    esi,0x1
    24da:	mov    rdi,rax
    24dd:	call   21f5 <parser_advance>
      }
      break;
    24e2:	jmp    279e <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    24e7:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    24ee:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24f6:	mov    rax,QWORD PTR [rbp-0x50]
    24fa:	mov    esi,0x1
    24ff:	mov    rdi,rax
    2502:	call   21f5 <parser_advance>
      }
      break;
    2507:	jmp    279e <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    250c:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    2513:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    251b:	mov    rax,QWORD PTR [rbp-0x50]
    251f:	mov    esi,0x1
    2524:	mov    rdi,rax
    2527:	call   21f5 <parser_advance>
      }
      break;
    252c:	jmp    279e <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    2531:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    2538:	mov    rax,QWORD PTR [rbp-0x50]
    253c:	mov    esi,0x1
    2541:	mov    rdi,rax
    2544:	call   21f5 <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    2549:	mov    rax,QWORD PTR [rbp-0x50]
    254d:	mov    rdi,rax
    2550:	call   2176 <parser_at>
    2555:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    2559:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    2561:	jmp    2579 <get_json_token+0x2b3>
        {
          string_count += 1;
    2563:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    2568:	mov    rax,QWORD PTR [rbp-0x50]
    256c:	mov    esi,0x1
    2571:	mov    rdi,rax
    2574:	call   21f5 <parser_advance>
        while (*parser_at(parser) != '"')
    2579:	mov    rax,QWORD PTR [rbp-0x50]
    257d:	mov    rdi,rax
    2580:	call   2176 <parser_at>
    2585:	movzx  eax,BYTE PTR [rax]
    2588:	cmp    al,0x22
    258a:	jne    2563 <get_json_token+0x29d>
        }
        token.value.count = string_count;
    258c:	mov    rax,QWORD PTR [rbp-0x40]
    2590:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    2594:	mov    rax,QWORD PTR [rbp-0x50]
    2598:	mov    esi,0x1
    259d:	mov    rdi,rax
    25a0:	call   21f5 <parser_advance>
      }
      break;
    25a5:	jmp    279e <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    25aa:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    25b1:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    25b9:	jmp    25d1 <get_json_token+0x30b>
        {
          digit_count += 1;
    25bb:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    25c0:	mov    rax,QWORD PTR [rbp-0x50]
    25c4:	mov    esi,0x1
    25c9:	mov    rdi,rax
    25cc:	call   21f5 <parser_advance>
        while (is_numeric(*parser_at(parser)))
    25d1:	mov    rax,QWORD PTR [rbp-0x50]
    25d5:	mov    rdi,rax
    25d8:	call   2176 <parser_at>
    25dd:	movzx  eax,BYTE PTR [rax]
    25e0:	movzx  eax,al
    25e3:	mov    edi,eax
    25e5:	call   2296 <is_numeric>
    25ea:	test   al,al
    25ec:	jne    25bb <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    25ee:	mov    rax,QWORD PTR [rbp-0x38]
    25f2:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    25f6:	jmp    279e <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    25fb:	lea    rax,[rip+0x1eca]        # 44cc <_IO_stdin_used+0x4cc>
    2602:	mov    QWORD PTR [rbp-0x30],rax
    2606:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    260e:	mov    rcx,QWORD PTR [rbp-0x30]
    2612:	mov    rdx,QWORD PTR [rbp-0x28]
    2616:	mov    rax,QWORD PTR [rbp-0x50]
    261a:	mov    rsi,rcx
    261d:	mov    rdi,rax
    2620:	call   223b <parser_token_is_literal>
    2625:	test   al,al
    2627:	je     264b <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    2629:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    2630:	mov    rax,QWORD PTR [rbp-0x28]
    2634:	mov    rdx,rax
    2637:	mov    rax,QWORD PTR [rbp-0x50]
    263b:	mov    rsi,rdx
    263e:	mov    rdi,rax
    2641:	call   21f5 <parser_advance>
    2646:	jmp    279e <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    264b:	mov    rax,QWORD PTR [rbp-0x50]
    264f:	mov    rcx,QWORD PTR [rax+0x10]
    2653:	lea    rdx,[rip+0x1e7e]        # 44d8 <_IO_stdin_used+0x4d8>
    265a:	lea    rax,[rip+0x1e0a]        # 446b <_IO_stdin_used+0x46b>
    2661:	mov    r8,rcx
    2664:	mov    rcx,rdx
    2667:	mov    edx,0xdf
    266c:	mov    rsi,rax
    266f:	mov    edi,0x1
    2674:	mov    eax,0x0
    2679:	call   14a1 <log_message>
        }
      }
      break;
    267e:	jmp    279e <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    2683:	lea    rax,[rip+0x1e7b]        # 4505 <_IO_stdin_used+0x505>
    268a:	mov    QWORD PTR [rbp-0x30],rax
    268e:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    2696:	mov    rcx,QWORD PTR [rbp-0x30]
    269a:	mov    rdx,QWORD PTR [rbp-0x28]
    269e:	mov    rax,QWORD PTR [rbp-0x50]
    26a2:	mov    rsi,rcx
    26a5:	mov    rdi,rax
    26a8:	call   223b <parser_token_is_literal>
    26ad:	test   al,al
    26af:	je     26d3 <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    26b1:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    26b8:	mov    rax,QWORD PTR [rbp-0x28]
    26bc:	mov    rdx,rax
    26bf:	mov    rax,QWORD PTR [rbp-0x50]
    26c3:	mov    rsi,rdx
    26c6:	mov    rdi,rax
    26c9:	call   21f5 <parser_advance>
    26ce:	jmp    279e <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    26d3:	mov    rax,QWORD PTR [rbp-0x50]
    26d7:	mov    rcx,QWORD PTR [rax+0x10]
    26db:	lea    rdx,[rip+0x1df6]        # 44d8 <_IO_stdin_used+0x4d8>
    26e2:	lea    rax,[rip+0x1d82]        # 446b <_IO_stdin_used+0x46b>
    26e9:	mov    r8,rcx
    26ec:	mov    rcx,rdx
    26ef:	mov    edx,0xee
    26f4:	mov    rsi,rax
    26f7:	mov    edi,0x1
    26fc:	mov    eax,0x0
    2701:	call   14a1 <log_message>
        }
      }
      break;
    2706:	jmp    279e <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    270b:	lea    rax,[rip+0x1df9]        # 450b <_IO_stdin_used+0x50b>
    2712:	mov    QWORD PTR [rbp-0x30],rax
    2716:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    271e:	mov    rcx,QWORD PTR [rbp-0x30]
    2722:	mov    rdx,QWORD PTR [rbp-0x28]
    2726:	mov    rax,QWORD PTR [rbp-0x50]
    272a:	mov    rsi,rcx
    272d:	mov    rdi,rax
    2730:	call   223b <parser_token_is_literal>
    2735:	test   al,al
    2737:	je     2758 <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    2739:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    2740:	mov    rax,QWORD PTR [rbp-0x28]
    2744:	mov    rdx,rax
    2747:	mov    rax,QWORD PTR [rbp-0x50]
    274b:	mov    rsi,rdx
    274e:	mov    rdi,rax
    2751:	call   21f5 <parser_advance>
    2756:	jmp    279e <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2758:	mov    rax,QWORD PTR [rbp-0x50]
    275c:	mov    rcx,QWORD PTR [rax+0x10]
    2760:	lea    rdx,[rip+0x1d71]        # 44d8 <_IO_stdin_used+0x4d8>
    2767:	lea    rax,[rip+0x1cfd]        # 446b <_IO_stdin_used+0x46b>
    276e:	mov    r8,rcx
    2771:	mov    rcx,rdx
    2774:	mov    edx,0xfd
    2779:	mov    rsi,rax
    277c:	mov    edi,0x1
    2781:	mov    eax,0x0
    2786:	call   14a1 <log_message>
        }
      }
      break;
    278b:	jmp    279e <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    278d:	mov    rax,QWORD PTR [rbp-0x50]
    2791:	mov    esi,0x1
    2796:	mov    rdi,rax
    2799:	call   21f5 <parser_advance>
  }

  return token;
    279e:	mov    rcx,QWORD PTR [rbp-0x48]
    27a2:	mov    rax,QWORD PTR [rbp-0x20]
    27a6:	mov    rdx,QWORD PTR [rbp-0x18]
    27aa:	mov    QWORD PTR [rcx],rax
    27ad:	mov    QWORD PTR [rcx+0x8],rdx
    27b1:	mov    rax,QWORD PTR [rbp-0x10]
    27b5:	mov    QWORD PTR [rcx+0x10],rax
}
    27b9:	mov    rax,QWORD PTR [rbp-0x48]
    27bd:	leave
    27be:	ret

00000000000027bf <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    27bf:	push   rbp
    27c0:	mov    rbp,rsp
    27c3:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    27c6:	cmp    DWORD PTR [rbp-0x14],0x7
    27ca:	je     27e4 <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    27cc:	cmp    DWORD PTR [rbp-0x14],0x9
    27d0:	je     27e4 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    27d2:	cmp    DWORD PTR [rbp-0x14],0xa
    27d6:	je     27e4 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    27d8:	cmp    DWORD PTR [rbp-0x14],0xb
    27dc:	je     27e4 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    27de:	cmp    DWORD PTR [rbp-0x14],0x8
    27e2:	jne    27eb <json_token_type_is_value_type+0x2c>
    27e4:	mov    eax,0x1
    27e9:	jmp    27f0 <json_token_type_is_value_type+0x31>
    27eb:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    27f0:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    27f3:	mov    eax,DWORD PTR [rbp-0x4]
}
    27f6:	pop    rbp
    27f7:	ret

00000000000027f8 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    27f8:	push   rbp
    27f9:	mov    rbp,rsp
    27fc:	push   rbx
    27fd:	sub    rsp,0x88
    2804:	mov    QWORD PTR [rbp-0x78],rdi
    2808:	mov    QWORD PTR [rbp-0x80],rsi
    280c:	mov    QWORD PTR [rbp-0x90],rdx
    2813:	mov    QWORD PTR [rbp-0x88],rcx
    281a:	mov    rax,QWORD PTR fs:0x28
    2823:	mov    QWORD PTR [rbp-0x18],rax
    2827:	xor    eax,eax
  profile_begin_func();
    2829:	lea    r8,[rip+0x1fe0]        # 4810 <__func__.4>
    2830:	mov    r9d,0x11
    2836:	lea    rax,[rbp-0x50]
    283a:	mov    rsi,r8
    283d:	mov    rdx,r9
    2840:	mov    r8d,0x0
    2846:	mov    ecx,0x1
    284b:	mov    rdi,rax
    284e:	call   1f9e <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    2853:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    285b:	mov    eax,DWORD PTR [rbp+0x10]
    285e:	cmp    eax,0x1
    2861:	jne    288d <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    2863:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    286a:	mov    edx,DWORD PTR [rbp-0x64]
    286d:	mov    rsi,QWORD PTR [rbp-0x80]
    2871:	mov    rax,QWORD PTR [rbp-0x78]
    2875:	mov    ecx,edx
    2877:	mov    edx,0x2
    287c:	mov    rdi,rax
    287f:	call   29df <parse_json_children>
    2884:	mov    QWORD PTR [rbp-0x60],rax
    2888:	jmp    2917 <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    288d:	mov    eax,DWORD PTR [rbp+0x10]
    2890:	cmp    eax,0x3
    2893:	jne    28bc <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    2895:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    289c:	mov    edx,DWORD PTR [rbp-0x68]
    289f:	mov    rsi,QWORD PTR [rbp-0x80]
    28a3:	mov    rax,QWORD PTR [rbp-0x78]
    28a7:	mov    ecx,edx
    28a9:	mov    edx,0x4
    28ae:	mov    rdi,rax
    28b1:	call   29df <parse_json_children>
    28b6:	mov    QWORD PTR [rbp-0x60],rax
    28ba:	jmp    2917 <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    28bc:	mov    eax,DWORD PTR [rbp+0x10]
    28bf:	mov    edi,eax
    28c1:	call   27bf <json_token_type_is_value_type>
    28c6:	test   eax,eax
    28c8:	jne    2917 <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    28ca:	mov    eax,DWORD PTR [rbp+0x10]
    28cd:	mov    eax,eax
    28cf:	lea    rdx,[rax*8+0x0]
    28d7:	lea    rax,[rip+0x4802]        # 70e0 <JSON_Token_Type_strings>
    28de:	mov    rcx,QWORD PTR [rdx+rax*1]
    28e2:	lea    rdx,[rip+0x1c27]        # 4510 <_IO_stdin_used+0x510>
    28e9:	lea    rax,[rip+0x1b7b]        # 446b <_IO_stdin_used+0x46b>
    28f0:	push   QWORD PTR [rbp+0x20]
    28f3:	push   QWORD PTR [rbp+0x18]
    28f6:	mov    r8,rcx
    28f9:	mov    rcx,rdx
    28fc:	mov    edx,0x134
    2901:	mov    rsi,rax
    2904:	mov    edi,0x1
    2909:	mov    eax,0x0
    290e:	call   14a1 <log_message>
    2913:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    2917:	mov    rax,QWORD PTR [rbp-0x78]
    291b:	mov    edx,0x8
    2920:	mov    esi,0x30
    2925:	mov    rdi,rax
    2928:	call   17d3 <arena_alloc>
    292d:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    2931:	mov    rcx,QWORD PTR [rbp-0x58]
    2935:	mov    rax,QWORD PTR [rbp-0x90]
    293c:	mov    rdx,QWORD PTR [rbp-0x88]
    2943:	mov    QWORD PTR [rcx],rax
    2946:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    294a:	mov    rax,QWORD PTR [rbp-0x58]
    294e:	mov    rdx,QWORD PTR [rbp-0x60]
    2952:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    2956:	mov    rax,QWORD PTR [rbp-0x58]
    295a:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    2962:	mov    rcx,QWORD PTR [rbp-0x58]
    2966:	mov    rax,QWORD PTR [rbp+0x18]
    296a:	mov    rdx,QWORD PTR [rbp+0x20]
    296e:	mov    QWORD PTR [rcx+0x10],rax
    2972:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    2976:	sub    rsp,0x8
    297a:	sub    rsp,0x38
    297e:	mov    rax,rsp
    2981:	mov    rcx,QWORD PTR [rbp-0x50]
    2985:	mov    rbx,QWORD PTR [rbp-0x48]
    2989:	mov    QWORD PTR [rax],rcx
    298c:	mov    QWORD PTR [rax+0x8],rbx
    2990:	mov    rcx,QWORD PTR [rbp-0x40]
    2994:	mov    rbx,QWORD PTR [rbp-0x38]
    2998:	mov    QWORD PTR [rax+0x10],rcx
    299c:	mov    QWORD PTR [rax+0x18],rbx
    29a0:	mov    rcx,QWORD PTR [rbp-0x30]
    29a4:	mov    rbx,QWORD PTR [rbp-0x28]
    29a8:	mov    QWORD PTR [rax+0x20],rcx
    29ac:	mov    QWORD PTR [rax+0x28],rbx
    29b0:	mov    rdx,QWORD PTR [rbp-0x20]
    29b4:	mov    QWORD PTR [rax+0x30],rdx
    29b8:	call   2088 <__profile_end_pass>
    29bd:	add    rsp,0x40

  return result;
    29c1:	mov    rax,QWORD PTR [rbp-0x58]
}
    29c5:	mov    rdx,QWORD PTR [rbp-0x18]
    29c9:	sub    rdx,QWORD PTR fs:0x28
    29d2:	je     29d9 <parse_json_object+0x1e1>
    29d4:	call   1060 <__stack_chk_fail@plt>
    29d9:	mov    rbx,QWORD PTR [rbp-0x8]
    29dd:	leave
    29de:	ret

00000000000029df <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    29df:	push   rbp
    29e0:	mov    rbp,rsp
    29e3:	push   rbx
    29e4:	sub    rsp,0x108
    29eb:	mov    QWORD PTR [rbp-0xd8],rdi
    29f2:	mov    QWORD PTR [rbp-0xe0],rsi
    29f9:	mov    DWORD PTR [rbp-0xe4],edx
    29ff:	mov    DWORD PTR [rbp-0xe8],ecx
    2a05:	mov    rax,QWORD PTR fs:0x28
    2a0e:	mov    QWORD PTR [rbp-0x18],rax
    2a12:	xor    eax,eax
  profile_begin_func();
    2a14:	lea    r8,[rip+0x1e15]        # 4830 <__func__.3>
    2a1b:	mov    r9d,0x13
    2a21:	lea    rax,[rbp-0x50]
    2a25:	mov    rsi,r8
    2a28:	mov    rdx,r9
    2a2b:	mov    r8d,0x0
    2a31:	mov    ecx,0x2
    2a36:	mov    rdi,rax
    2a39:	call   1f9e <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2a3e:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    2a49:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2a54:	jmp    2d2d <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2a59:	pxor   xmm0,xmm0
    2a5d:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2a64:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2a6c:	pxor   xmm0,xmm0
    2a70:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2a77:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2a7c:	cmp    DWORD PTR [rbp-0xe8],0x0
    2a83:	je     2b90 <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2a89:	lea    rax,[rbp-0xb0]
    2a90:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a97:	mov    rsi,rdx
    2a9a:	mov    rdi,rax
    2a9d:	call   22c6 <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2aa2:	mov    eax,DWORD PTR [rbp-0xb0]
    2aa8:	cmp    eax,0x7
    2aab:	jne    2b2c <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2aad:	lea    rax,[rbp-0x70]
    2ab1:	mov    rdx,QWORD PTR [rbp-0xe0]
    2ab8:	mov    rsi,rdx
    2abb:	mov    rdi,rax
    2abe:	call   22c6 <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2ac3:	mov    eax,DWORD PTR [rbp-0x70]
    2ac6:	cmp    eax,0x6
    2ac9:	jne    2ae9 <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2acb:	lea    rax,[rbp-0x90]
    2ad2:	mov    rdx,QWORD PTR [rbp-0xe0]
    2ad9:	mov    rsi,rdx
    2adc:	mov    rdi,rax
    2adf:	call   22c6 <get_json_token>
    2ae4:	jmp    2bd0 <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2ae9:	mov    rcx,QWORD PTR [rbp-0xa8]
    2af0:	mov    rax,QWORD PTR [rbp-0xa0]
    2af7:	mov    esi,eax
    2af9:	lea    rdx,[rip+0x1a60]        # 4560 <_IO_stdin_used+0x560>
    2b00:	lea    rax,[rip+0x1964]        # 446b <_IO_stdin_used+0x46b>
    2b07:	mov    r9,rcx
    2b0a:	mov    r8d,esi
    2b0d:	mov    rcx,rdx
    2b10:	mov    edx,0x15f
    2b15:	mov    rsi,rax
    2b18:	mov    edi,0x1
    2b1d:	mov    eax,0x0
    2b22:	call   14a1 <log_message>
    2b27:	jmp    2bd0 <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2b2c:	mov    rcx,QWORD PTR [rbp-0xa8]
    2b33:	mov    rax,QWORD PTR [rbp-0xa0]
    2b3a:	mov    edi,eax
    2b3c:	mov    eax,DWORD PTR [rbp-0xb0]
    2b42:	mov    eax,eax
    2b44:	lea    rdx,[rax*8+0x0]
    2b4c:	lea    rax,[rip+0x458d]        # 70e0 <JSON_Token_Type_strings>
    2b53:	mov    rsi,QWORD PTR [rdx+rax*1]
    2b57:	lea    rdx,[rip+0x1a22]        # 4580 <_IO_stdin_used+0x580>
    2b5e:	lea    rax,[rip+0x1906]        # 446b <_IO_stdin_used+0x46b>
    2b65:	sub    rsp,0x8
    2b69:	push   rcx
    2b6a:	mov    r9d,edi
    2b6d:	mov    r8,rsi
    2b70:	mov    rcx,rdx
    2b73:	mov    edx,0x164
    2b78:	mov    rsi,rax
    2b7b:	mov    edi,0x1
    2b80:	mov    eax,0x0
    2b85:	call   14a1 <log_message>
    2b8a:	add    rsp,0x10
    2b8e:	jmp    2bd0 <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2b90:	lea    rax,[rbp-0x110]
    2b97:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b9e:	mov    rsi,rdx
    2ba1:	mov    rdi,rax
    2ba4:	call   22c6 <get_json_token>
    2ba9:	mov    rax,QWORD PTR [rbp-0x110]
    2bb0:	mov    rdx,QWORD PTR [rbp-0x108]
    2bb7:	mov    QWORD PTR [rbp-0x90],rax
    2bbe:	mov    QWORD PTR [rbp-0x88],rdx
    2bc5:	mov    rax,QWORD PTR [rbp-0x100]
    2bcc:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2bd0:	mov    eax,DWORD PTR [rbp-0x90]
    2bd6:	cmp    DWORD PTR [rbp-0xe4],eax
    2bdc:	je     2d46 <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2be2:	mov    rax,QWORD PTR [rbp-0xa8]
    2be9:	mov    rdx,QWORD PTR [rbp-0xa0]
    2bf0:	mov    r8,QWORD PTR [rbp-0xe0]
    2bf7:	mov    rdi,QWORD PTR [rbp-0xd8]
    2bfe:	sub    rsp,0x8
    2c02:	sub    rsp,0x18
    2c06:	mov    rsi,rsp
    2c09:	mov    rcx,QWORD PTR [rbp-0x90]
    2c10:	mov    rbx,QWORD PTR [rbp-0x88]
    2c17:	mov    QWORD PTR [rsi],rcx
    2c1a:	mov    QWORD PTR [rsi+0x8],rbx
    2c1e:	mov    rcx,QWORD PTR [rbp-0x80]
    2c22:	mov    QWORD PTR [rsi+0x10],rcx
    2c26:	mov    rcx,rdx
    2c29:	mov    rdx,rax
    2c2c:	mov    rsi,r8
    2c2f:	call   27f8 <parse_json_object>
    2c34:	add    rsp,0x20
    2c38:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2c3f:	cmp    QWORD PTR [rbp-0xb8],0x0
    2c47:	je     2c91 <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2c49:	cmp    QWORD PTR [rbp-0xc8],0x0
    2c51:	jne    2c71 <parse_json_children+0x292>
      {
        first_child        = object;
    2c53:	mov    rax,QWORD PTR [rbp-0xb8]
    2c5a:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2c61:	mov    rax,QWORD PTR [rbp-0xb8]
    2c68:	mov    QWORD PTR [rbp-0xc0],rax
    2c6f:	jmp    2c91 <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2c71:	mov    rax,QWORD PTR [rbp-0xc0]
    2c78:	mov    rdx,QWORD PTR [rbp-0xb8]
    2c7f:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2c83:	mov    rax,QWORD PTR [rbp-0xb8]
    2c8a:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2c91:	lea    rax,[rbp-0x70]
    2c95:	mov    rdx,QWORD PTR [rbp-0xe0]
    2c9c:	mov    rsi,rdx
    2c9f:	mov    rdi,rax
    2ca2:	call   22c6 <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2ca7:	mov    eax,DWORD PTR [rbp-0x70]
    2caa:	cmp    DWORD PTR [rbp-0xe4],eax
    2cb0:	je     2d49 <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2cb6:	mov    eax,DWORD PTR [rbp-0x70]
    2cb9:	cmp    eax,0x5
    2cbc:	je     2d2d <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2cbe:	mov    r8,QWORD PTR [rbp-0x68]
    2cc2:	mov    rax,QWORD PTR [rbp-0x60]
    2cc6:	mov    r9d,eax
    2cc9:	mov    eax,DWORD PTR [rbp-0x70]
    2ccc:	mov    eax,eax
    2cce:	lea    rdx,[rax*8+0x0]
    2cd6:	lea    rax,[rip+0x4403]        # 70e0 <JSON_Token_Type_strings>
    2cdd:	mov    r10,QWORD PTR [rdx+rax*1]
    2ce1:	lea    rdi,[rip+0x18c0]        # 45a8 <_IO_stdin_used+0x5a8>
    2ce8:	lea    rsi,[rip+0x177c]        # 446b <_IO_stdin_used+0x46b>
    2cef:	sub    rsp,0x18
    2cf3:	mov    rcx,rsp
    2cf6:	mov    rax,QWORD PTR [rbp-0x70]
    2cfa:	mov    rdx,QWORD PTR [rbp-0x68]
    2cfe:	mov    QWORD PTR [rcx],rax
    2d01:	mov    QWORD PTR [rcx+0x8],rdx
    2d05:	mov    rax,QWORD PTR [rbp-0x60]
    2d09:	mov    QWORD PTR [rcx+0x10],rax
    2d0d:	push   r8
    2d0f:	mov    r8,r10
    2d12:	mov    rcx,rdi
    2d15:	mov    edx,0x18b
    2d1a:	mov    edi,0x1
    2d1f:	mov    eax,0x0
    2d24:	call   14a1 <log_message>
    2d29:	add    rsp,0x20
  while (parser_incomplete(parser))
    2d2d:	mov    rax,QWORD PTR [rbp-0xe0]
    2d34:	mov    rdi,rax
    2d37:	call   221b <parser_incomplete>
    2d3c:	test   al,al
    2d3e:	jne    2a59 <parse_json_children+0x7a>
    2d44:	jmp    2d4a <parse_json_children+0x36b>
      break;
    2d46:	nop
    2d47:	jmp    2d4a <parse_json_children+0x36b>
      break;
    2d49:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2d4a:	sub    rsp,0x8
    2d4e:	sub    rsp,0x38
    2d52:	mov    rax,rsp
    2d55:	mov    rcx,QWORD PTR [rbp-0x50]
    2d59:	mov    rbx,QWORD PTR [rbp-0x48]
    2d5d:	mov    QWORD PTR [rax],rcx
    2d60:	mov    QWORD PTR [rax+0x8],rbx
    2d64:	mov    rcx,QWORD PTR [rbp-0x40]
    2d68:	mov    rbx,QWORD PTR [rbp-0x38]
    2d6c:	mov    QWORD PTR [rax+0x10],rcx
    2d70:	mov    QWORD PTR [rax+0x18],rbx
    2d74:	mov    rcx,QWORD PTR [rbp-0x30]
    2d78:	mov    rbx,QWORD PTR [rbp-0x28]
    2d7c:	mov    QWORD PTR [rax+0x20],rcx
    2d80:	mov    QWORD PTR [rax+0x28],rbx
    2d84:	mov    rdx,QWORD PTR [rbp-0x20]
    2d88:	mov    QWORD PTR [rax+0x30],rdx
    2d8c:	call   2088 <__profile_end_pass>
    2d91:	add    rsp,0x40

  return first_child;
    2d95:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2d9c:	mov    rdx,QWORD PTR [rbp-0x18]
    2da0:	sub    rdx,QWORD PTR fs:0x28
    2da9:	je     2db0 <parse_json_children+0x3d1>
    2dab:	call   1060 <__stack_chk_fail@plt>
    2db0:	mov    rbx,QWORD PTR [rbp-0x8]
    2db4:	leave
    2db5:	ret

0000000000002db6 <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2db6:	push   rbp
    2db7:	mov    rbp,rsp
    2dba:	push   rbx
    2dbb:	sub    rsp,0xb8
    2dc2:	mov    QWORD PTR [rbp-0xa8],rdi
    2dc9:	mov    rax,rsi
    2dcc:	mov    rsi,rdx
    2dcf:	mov    rax,rax
    2dd2:	mov    edx,0x0
    2dd7:	mov    rdx,rsi
    2dda:	mov    QWORD PTR [rbp-0xc0],rax
    2de1:	mov    QWORD PTR [rbp-0xb8],rdx
    2de8:	mov    rax,QWORD PTR fs:0x28
    2df1:	mov    QWORD PTR [rbp-0x18],rax
    2df5:	xor    eax,eax
  profile_begin_func();
    2df7:	lea    rcx,[rip+0x1a4a]        # 4848 <__func__.2>
    2dfe:	mov    ebx,0xa
    2e03:	lea    rax,[rbp-0x50]
    2e07:	mov    rsi,rcx
    2e0a:	mov    rdx,rbx
    2e0d:	mov    r8d,0x0
    2e13:	mov    ecx,0x3
    2e18:	mov    rdi,rax
    2e1b:	call   1f9e <__profile_begin_pass>

  JSON_Parser parser =
    2e20:	mov    rax,QWORD PTR [rbp-0xc0]
    2e27:	mov    rdx,QWORD PTR [rbp-0xb8]
    2e2e:	mov    QWORD PTR [rbp-0x90],rax
    2e35:	mov    QWORD PTR [rbp-0x88],rdx
    2e3c:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2e44:	lea    rax,[rbp-0x70]
    2e48:	lea    rdx,[rbp-0x90]
    2e4f:	mov    rsi,rdx
    2e52:	mov    rdi,rax
    2e55:	call   22c6 <get_json_token>
    2e5a:	mov    ecx,0x0
    2e5f:	mov    ebx,0x0
    2e64:	lea    r8,[rbp-0x90]
    2e6b:	mov    rdi,QWORD PTR [rbp-0xa8]
    2e72:	sub    rsp,0x8
    2e76:	sub    rsp,0x18
    2e7a:	mov    rsi,rsp
    2e7d:	mov    rax,QWORD PTR [rbp-0x70]
    2e81:	mov    rdx,QWORD PTR [rbp-0x68]
    2e85:	mov    QWORD PTR [rsi],rax
    2e88:	mov    QWORD PTR [rsi+0x8],rdx
    2e8c:	mov    rax,QWORD PTR [rbp-0x60]
    2e90:	mov    QWORD PTR [rsi+0x10],rax
    2e94:	mov    rdx,rcx
    2e97:	mov    rcx,rbx
    2e9a:	mov    rsi,r8
    2e9d:	call   27f8 <parse_json_object>
    2ea2:	add    rsp,0x20
    2ea6:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2ead:	sub    rsp,0x8
    2eb1:	sub    rsp,0x38
    2eb5:	mov    rax,rsp
    2eb8:	mov    rcx,QWORD PTR [rbp-0x50]
    2ebc:	mov    rbx,QWORD PTR [rbp-0x48]
    2ec0:	mov    QWORD PTR [rax],rcx
    2ec3:	mov    QWORD PTR [rax+0x8],rbx
    2ec7:	mov    rcx,QWORD PTR [rbp-0x40]
    2ecb:	mov    rbx,QWORD PTR [rbp-0x38]
    2ecf:	mov    QWORD PTR [rax+0x10],rcx
    2ed3:	mov    QWORD PTR [rax+0x18],rbx
    2ed7:	mov    rcx,QWORD PTR [rbp-0x30]
    2edb:	mov    rbx,QWORD PTR [rbp-0x28]
    2edf:	mov    QWORD PTR [rax+0x20],rcx
    2ee3:	mov    QWORD PTR [rax+0x28],rbx
    2ee7:	mov    rdx,QWORD PTR [rbp-0x20]
    2eeb:	mov    QWORD PTR [rax+0x30],rdx
    2eef:	call   2088 <__profile_end_pass>
    2ef4:	add    rsp,0x40

  return outer;
    2ef8:	mov    rax,QWORD PTR [rbp-0x98]
}
    2eff:	mov    rdx,QWORD PTR [rbp-0x18]
    2f03:	sub    rdx,QWORD PTR fs:0x28
    2f0c:	je     2f13 <parse_json+0x15d>
    2f0e:	call   1060 <__stack_chk_fail@plt>
    2f13:	mov    rbx,QWORD PTR [rbp-0x8]
    2f17:	leave
    2f18:	ret

0000000000002f19 <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2f19:	push   rbp
    2f1a:	mov    rbp,rsp
    2f1d:	push   rbx
    2f1e:	sub    rsp,0x78
    2f22:	mov    QWORD PTR [rbp-0x68],rdi
    2f26:	mov    rax,rsi
    2f29:	mov    rsi,rdx
    2f2c:	mov    rax,rax
    2f2f:	mov    edx,0x0
    2f34:	mov    rdx,rsi
    2f37:	mov    QWORD PTR [rbp-0x80],rax
    2f3b:	mov    QWORD PTR [rbp-0x78],rdx
    2f3f:	mov    rax,QWORD PTR fs:0x28
    2f48:	mov    QWORD PTR [rbp-0x18],rax
    2f4c:	xor    eax,eax
  profile_begin_func();
    2f4e:	lea    rcx,[rip+0x190b]        # 4860 <__func__.1>
    2f55:	mov    ebx,0x12
    2f5a:	lea    rax,[rbp-0x50]
    2f5e:	mov    rsi,rcx
    2f61:	mov    rdx,rbx
    2f64:	mov    r8d,0x0
    2f6a:	mov    ecx,0x4
    2f6f:	mov    rdi,rax
    2f72:	call   1f9e <__profile_begin_pass>

  JSON_Object *result = NULL;
    2f77:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2f7f:	cmp    QWORD PTR [rbp-0x68],0x0
    2f84:	je     2fd3 <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f86:	mov    rax,QWORD PTR [rbp-0x68]
    2f8a:	mov    rax,QWORD PTR [rax+0x20]
    2f8e:	mov    QWORD PTR [rbp-0x58],rax
    2f92:	jmp    2fcc <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2f94:	mov    rax,QWORD PTR [rbp-0x58]
    2f98:	mov    rdx,QWORD PTR [rax+0x8]
    2f9c:	mov    rax,QWORD PTR [rax]
    2f9f:	mov    rdi,QWORD PTR [rbp-0x80]
    2fa3:	mov    rsi,QWORD PTR [rbp-0x78]
    2fa7:	mov    rcx,rdx
    2faa:	mov    rdx,rax
    2fad:	call   143f <strings_equal>
    2fb2:	test   al,al
    2fb4:	je     2fc0 <lookup_json_object+0xa7>
      {
        result = cursor;
    2fb6:	mov    rax,QWORD PTR [rbp-0x58]
    2fba:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2fbe:	jmp    2fd3 <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2fc0:	mov    rax,QWORD PTR [rbp-0x58]
    2fc4:	mov    rax,QWORD PTR [rax+0x28]
    2fc8:	mov    QWORD PTR [rbp-0x58],rax
    2fcc:	cmp    QWORD PTR [rbp-0x58],0x0
    2fd1:	jne    2f94 <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2fd3:	sub    rsp,0x8
    2fd7:	sub    rsp,0x38
    2fdb:	mov    rax,rsp
    2fde:	mov    rcx,QWORD PTR [rbp-0x50]
    2fe2:	mov    rbx,QWORD PTR [rbp-0x48]
    2fe6:	mov    QWORD PTR [rax],rcx
    2fe9:	mov    QWORD PTR [rax+0x8],rbx
    2fed:	mov    rcx,QWORD PTR [rbp-0x40]
    2ff1:	mov    rbx,QWORD PTR [rbp-0x38]
    2ff5:	mov    QWORD PTR [rax+0x10],rcx
    2ff9:	mov    QWORD PTR [rax+0x18],rbx
    2ffd:	mov    rcx,QWORD PTR [rbp-0x30]
    3001:	mov    rbx,QWORD PTR [rbp-0x28]
    3005:	mov    QWORD PTR [rax+0x20],rcx
    3009:	mov    QWORD PTR [rax+0x28],rbx
    300d:	mov    rdx,QWORD PTR [rbp-0x20]
    3011:	mov    QWORD PTR [rax+0x30],rdx
    3015:	call   2088 <__profile_end_pass>
    301a:	add    rsp,0x40

  return result;
    301e:	mov    rax,QWORD PTR [rbp-0x60]
}
    3022:	mov    rdx,QWORD PTR [rbp-0x18]
    3026:	sub    rdx,QWORD PTR fs:0x28
    302f:	je     3036 <lookup_json_object+0x11d>
    3031:	call   1060 <__stack_chk_fail@plt>
    3036:	mov    rbx,QWORD PTR [rbp-0x8]
    303a:	leave
    303b:	ret

000000000000303c <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    303c:	push   rbp
    303d:	mov    rbp,rsp
    3040:	sub    rsp,0x50
    3044:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    3048:	cmp    QWORD PTR [rbp-0x48],0x0
    304d:	jne    3074 <json_object_to_f64+0x38>
    304f:	lea    rdx,[rip+0x182a]        # 4880 <__PRETTY_FUNCTION__.0>
    3056:	lea    rsi,[rip+0x140e]        # 446b <_IO_stdin_used+0x46b>
    305d:	lea    rax,[rip+0x1584]        # 45e8 <_IO_stdin_used+0x5e8>
    3064:	mov    rcx,rdx
    3067:	mov    edx,0x1c2
    306c:	mov    rdi,rax
    306f:	call   1090 <__assert_fail@plt>

  String val = object->value;
    3074:	mov    rax,QWORD PTR [rbp-0x48]
    3078:	mov    rdx,QWORD PTR [rax+0x18]
    307c:	mov    rax,QWORD PTR [rax+0x10]
    3080:	mov    QWORD PTR [rbp-0x10],rax
    3084:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    3088:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    3090:	movsd  xmm0,QWORD PTR [rip+0x1820]        # 48b8 <__PRETTY_FUNCTION__.0+0x38>
    3098:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    309d:	mov    rax,QWORD PTR [rbp-0x8]
    30a1:	cmp    QWORD PTR [rbp-0x30],rax
    30a5:	jae    30cb <json_object_to_f64+0x8f>
    30a7:	mov    rdx,QWORD PTR [rbp-0x10]
    30ab:	mov    rax,QWORD PTR [rbp-0x30]
    30af:	add    rax,rdx
    30b2:	movzx  eax,BYTE PTR [rax]
    30b5:	cmp    al,0x2d
    30b7:	jne    30cb <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    30b9:	movsd  xmm0,QWORD PTR [rip+0x17ff]        # 48c0 <__PRETTY_FUNCTION__.0+0x40>
    30c1:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    30c6:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    30cb:	pxor   xmm0,xmm0
    30cf:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    30d4:	jmp    311b <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    30d6:	mov    rdx,QWORD PTR [rbp-0x10]
    30da:	mov    rax,QWORD PTR [rbp-0x30]
    30de:	add    rax,rdx
    30e1:	movzx  eax,BYTE PTR [rax]
    30e4:	sub    eax,0x30
    30e7:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    30ea:	cmp    BYTE PTR [rbp-0x32],0x9
    30ee:	ja     3127 <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    30f0:	movsd  xmm1,QWORD PTR [rbp-0x20]
    30f5:	movsd  xmm0,QWORD PTR [rip+0x17cb]        # 48c8 <__PRETTY_FUNCTION__.0+0x48>
    30fd:	mulsd  xmm1,xmm0
    3101:	movzx  eax,BYTE PTR [rbp-0x32]
    3105:	pxor   xmm0,xmm0
    3109:	cvtsi2sd xmm0,eax
    310d:	addsd  xmm0,xmm1
    3111:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    3116:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    311b:	mov    rax,QWORD PTR [rbp-0x8]
    311f:	cmp    QWORD PTR [rbp-0x30],rax
    3123:	jb     30d6 <json_object_to_f64+0x9a>
    3125:	jmp    3128 <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    3127:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    3128:	mov    rax,QWORD PTR [rbp-0x8]
    312c:	cmp    QWORD PTR [rbp-0x30],rax
    3130:	jae    31bd <json_object_to_f64+0x181>
    3136:	mov    rdx,QWORD PTR [rbp-0x10]
    313a:	mov    rax,QWORD PTR [rbp-0x30]
    313e:	add    rax,rdx
    3141:	movzx  eax,BYTE PTR [rax]
    3144:	cmp    al,0x2e
    3146:	jne    31bd <json_object_to_f64+0x181>
  {
    at += 1;
    3148:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    314d:	movsd  xmm0,QWORD PTR [rip+0x177b]        # 48d0 <__PRETTY_FUNCTION__.0+0x50>
    3155:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    315a:	jmp    31b0 <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    315c:	mov    rdx,QWORD PTR [rbp-0x10]
    3160:	mov    rax,QWORD PTR [rbp-0x30]
    3164:	add    rax,rdx
    3167:	movzx  eax,BYTE PTR [rax]
    316a:	sub    eax,0x30
    316d:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    3170:	cmp    BYTE PTR [rbp-0x31],0x9
    3174:	ja     31bc <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    3176:	movzx  eax,BYTE PTR [rbp-0x31]
    317a:	pxor   xmm0,xmm0
    317e:	cvtsi2sd xmm0,eax
    3182:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    3187:	movsd  xmm1,QWORD PTR [rbp-0x20]
    318c:	addsd  xmm0,xmm1
    3190:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    3195:	movsd  xmm1,QWORD PTR [rbp-0x18]
    319a:	movsd  xmm0,QWORD PTR [rip+0x172e]        # 48d0 <__PRETTY_FUNCTION__.0+0x50>
    31a2:	mulsd  xmm0,xmm1
    31a6:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    31ab:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    31b0:	mov    rax,QWORD PTR [rbp-0x8]
    31b4:	cmp    QWORD PTR [rbp-0x30],rax
    31b8:	jb     315c <json_object_to_f64+0x120>
    31ba:	jmp    31bd <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    31bc:	nop
      }
    }
  }

  return sign * result;
    31bd:	movsd  xmm0,QWORD PTR [rbp-0x28]
    31c2:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    31c7:	leave
    31c8:	ret

00000000000031c9 <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    31c9:	push   rbp
    31ca:	mov    rbp,rsp
    31cd:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    31d2:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31d7:	movsd  xmm1,QWORD PTR [rip+0x16f9]        # 48d8 <__PRETTY_FUNCTION__.0+0x58>
    31df:	divsd  xmm0,xmm1
}
    31e3:	pop    rbp
    31e4:	ret

00000000000031e5 <square>:

static
f64 square(f64 x)
{
    31e5:	push   rbp
    31e6:	mov    rbp,rsp
    31e9:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    31ee:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31f3:	mulsd  xmm0,xmm0
}
    31f7:	pop    rbp
    31f8:	ret

00000000000031f9 <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    31f9:	push   rbp
    31fa:	mov    rbp,rsp
    31fd:	sub    rsp,0x90
    3204:	movsd  QWORD PTR [rbp-0x58],xmm0
    3209:	movsd  QWORD PTR [rbp-0x60],xmm1
    320e:	movsd  QWORD PTR [rbp-0x68],xmm2
    3213:	movsd  QWORD PTR [rbp-0x70],xmm3
    3218:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    321d:	movsd  xmm0,QWORD PTR [rbp-0x60]
    3222:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    3227:	movsd  xmm0,QWORD PTR [rbp-0x70]
    322c:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    3231:	movsd  xmm0,QWORD PTR [rbp-0x58]
    3236:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    323b:	movsd  xmm0,QWORD PTR [rbp-0x68]
    3240:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    3245:	movsd  xmm0,QWORD PTR [rbp-0x40]
    324a:	subsd  xmm0,QWORD PTR [rbp-0x48]
    324f:	movq   rax,xmm0
    3254:	movq   xmm0,rax
    3259:	call   31c9 <to_radians>
    325e:	movq   rax,xmm0
    3263:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    3267:	movsd  xmm0,QWORD PTR [rbp-0x30]
    326c:	subsd  xmm0,QWORD PTR [rbp-0x38]
    3271:	movq   rax,xmm0
    3276:	movq   xmm0,rax
    327b:	call   31c9 <to_radians>
    3280:	movq   rax,xmm0
    3285:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    3289:	mov    rax,QWORD PTR [rbp-0x48]
    328d:	movq   xmm0,rax
    3292:	call   31c9 <to_radians>
    3297:	movq   rax,xmm0
    329c:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    32a0:	mov    rax,QWORD PTR [rbp-0x40]
    32a4:	movq   xmm0,rax
    32a9:	call   31c9 <to_radians>
    32ae:	movq   rax,xmm0
    32b3:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    32b7:	movsd  xmm0,QWORD PTR [rbp-0x28]
    32bc:	movsd  xmm1,QWORD PTR [rip+0x161c]        # 48e0 <__PRETTY_FUNCTION__.0+0x60>
    32c4:	divsd  xmm0,xmm1
    32c8:	movq   rax,xmm0
    32cd:	movq   xmm0,rax
    32d2:	call   1130 <sin@plt>
    32d7:	movq   rax,xmm0
    32dc:	movq   xmm0,rax
    32e1:	call   31e5 <square>
    32e6:	movsd  QWORD PTR [rbp-0x80],xmm0
    32eb:	mov    rax,QWORD PTR [rbp-0x48]
    32ef:	movq   xmm0,rax
    32f4:	call   10b0 <cos@plt>
    32f9:	movsd  QWORD PTR [rbp-0x88],xmm0
    3301:	mov    rax,QWORD PTR [rbp-0x40]
    3305:	movq   xmm0,rax
    330a:	call   10b0 <cos@plt>
    330f:	movapd xmm5,xmm0
    3313:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    331b:	movsd  QWORD PTR [rbp-0x88],xmm5
    3323:	movsd  xmm0,QWORD PTR [rbp-0x20]
    3328:	movsd  xmm1,QWORD PTR [rip+0x15b0]        # 48e0 <__PRETTY_FUNCTION__.0+0x60>
    3330:	movapd xmm6,xmm0
    3334:	divsd  xmm6,xmm1
    3338:	movq   rax,xmm6
    333d:	movq   xmm0,rax
    3342:	call   1130 <sin@plt>
    3347:	movq   rax,xmm0
    334c:	movq   xmm0,rax
    3351:	call   31e5 <square>
    3356:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    335e:	addsd  xmm0,QWORD PTR [rbp-0x80]
    3363:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    3368:	mov    rax,QWORD PTR [rbp-0x18]
    336c:	movq   xmm0,rax
    3371:	call   1160 <sqrt@plt>
    3376:	movq   rax,xmm0
    337b:	movq   xmm0,rax
    3380:	call   1140 <asin@plt>
    3385:	addsd  xmm0,xmm0
    3389:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    338e:	movsd  xmm0,QWORD PTR [rbp-0x78]
    3393:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    3398:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    339d:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    33a2:	leave
    33a3:	ret

00000000000033a4 <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    33a4:	push   rbp
    33a5:	mov    rbp,rsp
    33a8:	movsd  QWORD PTR [rbp-0x18],xmm0
    33ad:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    33b2:	movsd  xmm0,QWORD PTR [rip+0x152e]        # 48e8 <__PRETTY_FUNCTION__.0+0x68>
    33ba:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    33bf:	movsd  xmm0,QWORD PTR [rbp-0x18]
    33c4:	movq   xmm1,QWORD PTR [rip+0x1524]        # 48f0 <__PRETTY_FUNCTION__.0+0x70>
    33cc:	andpd  xmm0,xmm1
    33d0:	movsd  xmm1,QWORD PTR [rbp-0x20]
    33d5:	movq   xmm2,QWORD PTR [rip+0x1513]        # 48f0 <__PRETTY_FUNCTION__.0+0x70>
    33dd:	andpd  xmm2,xmm1
    33e1:	movapd xmm1,xmm0
    33e5:	subsd  xmm1,xmm2
    33e9:	movsd  xmm0,QWORD PTR [rbp-0x8]
    33ee:	comisd xmm0,xmm1
    33f2:	setae  al
    33f5:	movzx  eax,al
}
    33f8:	pop    rbp
    33f9:	ret

00000000000033fa <main>:

int main(int args_count, char **args)
{
    33fa:	push   rbp
    33fb:	mov    rbp,rsp
    33fe:	push   r15
    3400:	push   r14
    3402:	push   r13
    3404:	push   r12
    3406:	push   rbx
    3407:	sub    rsp,0x2d8
    340e:	mov    DWORD PTR [rbp-0x244],edi
    3414:	mov    QWORD PTR [rbp-0x250],rsi
    341b:	mov    rax,QWORD PTR fs:0x28
    3424:	mov    QWORD PTR [rbp-0x38],rax
    3428:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    342a:	cmp    DWORD PTR [rbp-0x244],0x3
    3431:	je     345e <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    3433:	mov    rax,QWORD PTR [rbp-0x250]
    343a:	mov    rax,QWORD PTR [rax]
    343d:	lea    rdx,[rip+0x11dc]        # 4620 <_IO_stdin_used+0x620>
    3444:	mov    rsi,rax
    3447:	mov    rdi,rdx
    344a:	mov    eax,0x0
    344f:	call   1070 <printf@plt>
    return 1;
    3454:	mov    eax,0x1
    3459:	jmp    3f12 <main+0xb18>
  }

  begin_profiling();
    345e:	call   1b3d <begin_profiling>

  Arena arena = {0};
    3463:	pxor   xmm0,xmm0
    3467:	movaps XMMWORD PTR [rbp-0x190],xmm0
    346e:	movaps XMMWORD PTR [rbp-0x180],xmm0
  arena = arena_make(GB(4));
    3475:	lea    rdx,[rbp-0x270]
    347c:	movabs rax,0x100000000
    3486:	mov    rsi,rax
    3489:	mov    rdi,rdx
    348c:	call   1632 <arena_make>
    3491:	mov    rax,QWORD PTR [rbp-0x270]
    3498:	mov    rdx,QWORD PTR [rbp-0x268]
    349f:	mov    QWORD PTR [rbp-0x190],rax
    34a6:	mov    QWORD PTR [rbp-0x188],rdx
    34ad:	mov    rax,QWORD PTR [rbp-0x260]
    34b4:	mov    rdx,QWORD PTR [rbp-0x258]
    34bb:	mov    QWORD PTR [rbp-0x180],rax
    34c2:	mov    QWORD PTR [rbp-0x178],rdx

  String source = {0};
    34c9:	mov    QWORD PTR [rbp-0x1a0],0x0
    34d4:	mov    QWORD PTR [rbp-0x198],0x0
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    34df:	mov    rax,QWORD PTR [rbp-0x250]
    34e6:	add    rax,0x8
    34ea:	mov    rax,QWORD PTR [rax]
    34ed:	mov    rdi,rax
    34f0:	call   1303 <file_size>
    34f5:	mov    rcx,rax
    34f8:	lea    r12,[rip+0x114d]        # 464c <_IO_stdin_used+0x64c>
    34ff:	mov    r13d,0x4
    3505:	lea    rdi,[rbp-0x170]
    350c:	mov    rdx,r12
    350f:	mov    rax,r13
    3512:	mov    r8,rcx
    3515:	mov    ecx,0x5
    351a:	mov    rsi,rdx
    351d:	mov    rdx,rax
    3520:	call   1f9e <__profile_begin_pass>
    3525:	mov    QWORD PTR [rbp-0x230],0x0
    3530:	jmp    35cb <main+0x1d1>
  {
    source = read_file_to_arena(&arena, args[1]);
    3535:	mov    rax,QWORD PTR [rbp-0x250]
    353c:	add    rax,0x8
    3540:	mov    rdx,QWORD PTR [rax]
    3543:	lea    rax,[rbp-0x190]
    354a:	mov    rsi,rdx
    354d:	mov    rdi,rax
    3550:	call   1357 <read_file_to_arena>
    3555:	mov    QWORD PTR [rbp-0x1a0],rax
    355c:	mov    QWORD PTR [rbp-0x198],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    3563:	add    QWORD PTR [rbp-0x230],0x1
    356b:	sub    rsp,0x8
    356f:	sub    rsp,0x38
    3573:	mov    rcx,rsp
    3576:	mov    rax,QWORD PTR [rbp-0x170]
    357d:	mov    rdx,QWORD PTR [rbp-0x168]
    3584:	mov    QWORD PTR [rcx],rax
    3587:	mov    QWORD PTR [rcx+0x8],rdx
    358b:	mov    rax,QWORD PTR [rbp-0x160]
    3592:	mov    rdx,QWORD PTR [rbp-0x158]
    3599:	mov    QWORD PTR [rcx+0x10],rax
    359d:	mov    QWORD PTR [rcx+0x18],rdx
    35a1:	mov    rax,QWORD PTR [rbp-0x150]
    35a8:	mov    rdx,QWORD PTR [rbp-0x148]
    35af:	mov    QWORD PTR [rcx+0x20],rax
    35b3:	mov    QWORD PTR [rcx+0x28],rdx
    35b7:	mov    rax,QWORD PTR [rbp-0x140]
    35be:	mov    QWORD PTR [rcx+0x30],rax
    35c2:	call   2088 <__profile_end_pass>
    35c7:	add    rsp,0x40
    35cb:	cmp    QWORD PTR [rbp-0x230],0x0
    35d3:	je     3535 <main+0x13b>
  }

  Haversine_Pair *pairs = NULL;
    35d9:	mov    QWORD PTR [rbp-0x228],0x0
  i32 pair_count = 0;
    35e4:	mov    DWORD PTR [rbp-0x238],0x0
  usize max_pairs = 0;
    35ee:	mov    QWORD PTR [rbp-0x220],0x0
  PROFILE_SCOPE("haversine alloc")
    35f9:	lea    r14,[rip+0x1051]        # 4651 <_IO_stdin_used+0x651>
    3600:	mov    r15d,0xf
    3606:	lea    rdi,[rbp-0x130]
    360d:	mov    rdx,r14
    3610:	mov    rax,r15
    3613:	mov    r8d,0x0
    3619:	mov    ecx,0x6
    361e:	mov    rsi,rdx
    3621:	mov    rdx,rax
    3624:	call   1f9e <__profile_begin_pass>
    3629:	mov    QWORD PTR [rbp-0x218],0x0
    3634:	jmp    36fc <main+0x302>
  {
    usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    3639:	mov    QWORD PTR [rbp-0x1a8],0x18
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    3644:	mov    rax,QWORD PTR [rbp-0x198]
    364b:	mov    edx,0x0
    3650:	div    QWORD PTR [rbp-0x1a8]
    3657:	mov    QWORD PTR [rbp-0x220],rax

    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    365e:	mov    rax,QWORD PTR [rbp-0x220]
    3665:	shl    rax,0x5
    3669:	mov    rcx,rax
    366c:	lea    rax,[rbp-0x190]
    3673:	mov    edx,0x8
    3678:	mov    rsi,rcx
    367b:	mov    rdi,rax
    367e:	call   17d3 <arena_alloc>
    3683:	mov    QWORD PTR [rbp-0x228],rax
    pair_count = 0;
    368a:	mov    DWORD PTR [rbp-0x238],0x0
  PROFILE_SCOPE("haversine alloc")
    3694:	add    QWORD PTR [rbp-0x218],0x1
    369c:	sub    rsp,0x8
    36a0:	sub    rsp,0x38
    36a4:	mov    rcx,rsp
    36a7:	mov    rax,QWORD PTR [rbp-0x130]
    36ae:	mov    rdx,QWORD PTR [rbp-0x128]
    36b5:	mov    QWORD PTR [rcx],rax
    36b8:	mov    QWORD PTR [rcx+0x8],rdx
    36bc:	mov    rax,QWORD PTR [rbp-0x120]
    36c3:	mov    rdx,QWORD PTR [rbp-0x118]
    36ca:	mov    QWORD PTR [rcx+0x10],rax
    36ce:	mov    QWORD PTR [rcx+0x18],rdx
    36d2:	mov    rax,QWORD PTR [rbp-0x110]
    36d9:	mov    rdx,QWORD PTR [rbp-0x108]
    36e0:	mov    QWORD PTR [rcx+0x20],rax
    36e4:	mov    QWORD PTR [rcx+0x28],rdx
    36e8:	mov    rax,QWORD PTR [rbp-0x100]
    36ef:	mov    QWORD PTR [rcx+0x30],rax
    36f3:	call   2088 <__profile_end_pass>
    36f8:	add    rsp,0x40
    36fc:	cmp    QWORD PTR [rbp-0x218],0x0
    3704:	je     3639 <main+0x23f>
  }

  JSON_Object *root = NULL;
    370a:	mov    QWORD PTR [rbp-0x1d8],0x0
  root = parse_json(&arena, source);
    3715:	mov    rcx,QWORD PTR [rbp-0x1a0]
    371c:	mov    rdx,QWORD PTR [rbp-0x198]
    3723:	lea    rax,[rbp-0x190]
    372a:	mov    rsi,rcx
    372d:	mov    rdi,rax
    3730:	call   2db6 <parse_json>
    3735:	mov    QWORD PTR [rbp-0x1d8],rax

  f64 haversine_sum = 0.0;
    373c:	pxor   xmm0,xmm0
    3740:	movsd  QWORD PTR [rbp-0x1d0],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    3748:	lea    rax,[rip+0xf12]        # 4661 <_IO_stdin_used+0x661>
    374f:	mov    QWORD PTR [rbp-0x280],rax
    3756:	mov    QWORD PTR [rbp-0x278],0x5
    3761:	mov    rax,QWORD PTR [rbp-0x280]
    3768:	mov    rdx,QWORD PTR [rbp-0x278]
    376f:	mov    rcx,rax
    3772:	mov    rax,QWORD PTR [rbp-0x1d8]
    3779:	mov    rsi,rcx
    377c:	mov    rdi,rax
    377f:	call   2f19 <lookup_json_object>
    3784:	mov    QWORD PTR [rbp-0x1c8],rax
  if (pairs)
    378b:	cmp    QWORD PTR [rbp-0x228],0x0
    3793:	je     3a28 <main+0x62e>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    3799:	mov    rax,QWORD PTR [rbp-0x1c8]
    37a0:	mov    rax,QWORD PTR [rax+0x20]
    37a4:	mov    QWORD PTR [rbp-0x210],rax
    37ab:	jmp    3a09 <main+0x60f>
    {
      PROFILE_SCOPE("child convert")
    37b0:	lea    rax,[rip+0xeb0]        # 4667 <_IO_stdin_used+0x667>
    37b7:	mov    QWORD PTR [rbp-0x2c0],rax
    37be:	mov    QWORD PTR [rbp-0x2b8],0xd
    37c9:	lea    rdi,[rbp-0x70]
    37cd:	mov    rbx,QWORD PTR [rbp-0x2c0]
    37d4:	mov    rsi,QWORD PTR [rbp-0x2b8]
    37db:	mov    rdx,rbx
    37de:	mov    rax,rsi
    37e1:	mov    r8d,0x0
    37e7:	mov    ecx,0x7
    37ec:	mov    rsi,rdx
    37ef:	mov    rdx,rax
    37f2:	call   1f9e <__profile_begin_pass>
    37f7:	mov    QWORD PTR [rbp-0x208],0x0
    3802:	jmp    39e9 <main+0x5ef>
      {
        Haversine_Pair pair =
        {
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    3807:	lea    rax,[rip+0xe67]        # 4675 <_IO_stdin_used+0x675>
    380e:	mov    QWORD PTR [rbp-0x2d0],rax
    3815:	mov    QWORD PTR [rbp-0x2c8],0x2
    3820:	mov    rbx,QWORD PTR [rbp-0x2d0]
    3827:	mov    rsi,QWORD PTR [rbp-0x2c8]
    382e:	mov    rax,rbx
    3831:	mov    rdx,rsi
    3834:	mov    rcx,QWORD PTR [rbp-0x210]
    383b:	mov    rsi,rax
    383e:	mov    rdi,rcx
    3841:	call   2f19 <lookup_json_object>
    3846:	mov    rdi,rax
    3849:	call   303c <json_object_to_f64>
    384e:	movq   rax,xmm0
        Haversine_Pair pair =
    3853:	mov    QWORD PTR [rbp-0xb0],rax
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    385a:	lea    rax,[rip+0xe17]        # 4678 <_IO_stdin_used+0x678>
    3861:	mov    QWORD PTR [rbp-0x2e0],rax
    3868:	mov    QWORD PTR [rbp-0x2d8],0x2
    3873:	mov    rax,QWORD PTR [rbp-0x2e0]
    387a:	mov    rdx,QWORD PTR [rbp-0x2d8]
    3881:	mov    rcx,rax
    3884:	mov    rax,QWORD PTR [rbp-0x210]
    388b:	mov    rsi,rcx
    388e:	mov    rdi,rax
    3891:	call   2f19 <lookup_json_object>
    3896:	mov    rdi,rax
    3899:	call   303c <json_object_to_f64>
    389e:	movq   rax,xmm0
        Haversine_Pair pair =
    38a3:	mov    QWORD PTR [rbp-0xa8],rax
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    38aa:	lea    rax,[rip+0xdca]        # 467b <_IO_stdin_used+0x67b>
    38b1:	mov    QWORD PTR [rbp-0x2f0],rax
    38b8:	mov    QWORD PTR [rbp-0x2e8],0x2
    38c3:	mov    rax,QWORD PTR [rbp-0x2f0]
    38ca:	mov    rdx,QWORD PTR [rbp-0x2e8]
    38d1:	mov    rcx,rax
    38d4:	mov    rax,QWORD PTR [rbp-0x210]
    38db:	mov    rsi,rcx
    38de:	mov    rdi,rax
    38e1:	call   2f19 <lookup_json_object>
    38e6:	mov    rdi,rax
    38e9:	call   303c <json_object_to_f64>
    38ee:	movq   rax,xmm0
        Haversine_Pair pair =
    38f3:	mov    QWORD PTR [rbp-0xa0],rax
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    38fa:	lea    rax,[rip+0xd7d]        # 467e <_IO_stdin_used+0x67e>
    3901:	mov    QWORD PTR [rbp-0x300],rax
    3908:	mov    QWORD PTR [rbp-0x2f8],0x2
    3913:	mov    rax,QWORD PTR [rbp-0x300]
    391a:	mov    rdx,QWORD PTR [rbp-0x2f8]
    3921:	mov    rcx,rax
    3924:	mov    rax,QWORD PTR [rbp-0x210]
    392b:	mov    rsi,rcx
    392e:	mov    rdi,rax
    3931:	call   2f19 <lookup_json_object>
    3936:	mov    rdi,rax
    3939:	call   303c <json_object_to_f64>
    393e:	movq   rax,xmm0
        Haversine_Pair pair =
    3943:	mov    QWORD PTR [rbp-0x98],rax
        };

        pairs[pair_count] = pair;
    394a:	mov    eax,DWORD PTR [rbp-0x238]
    3950:	cdqe
    3952:	shl    rax,0x5
    3956:	mov    rdx,rax
    3959:	mov    rax,QWORD PTR [rbp-0x228]
    3960:	lea    rcx,[rdx+rax*1]
    3964:	mov    rax,QWORD PTR [rbp-0xb0]
    396b:	mov    rdx,QWORD PTR [rbp-0xa8]
    3972:	mov    QWORD PTR [rcx],rax
    3975:	mov    QWORD PTR [rcx+0x8],rdx
    3979:	mov    rax,QWORD PTR [rbp-0xa0]
    3980:	mov    rdx,QWORD PTR [rbp-0x98]
    3987:	mov    QWORD PTR [rcx+0x10],rax
    398b:	mov    QWORD PTR [rcx+0x18],rdx
        pair_count += 1;
    398f:	add    DWORD PTR [rbp-0x238],0x1
      PROFILE_SCOPE("child convert")
    3996:	add    QWORD PTR [rbp-0x208],0x1
    399e:	sub    rsp,0x8
    39a2:	sub    rsp,0x38
    39a6:	mov    rcx,rsp
    39a9:	mov    rax,QWORD PTR [rbp-0x70]
    39ad:	mov    rdx,QWORD PTR [rbp-0x68]
    39b1:	mov    QWORD PTR [rcx],rax
    39b4:	mov    QWORD PTR [rcx+0x8],rdx
    39b8:	mov    rax,QWORD PTR [rbp-0x60]
    39bc:	mov    rdx,QWORD PTR [rbp-0x58]
    39c0:	mov    QWORD PTR [rcx+0x10],rax
    39c4:	mov    QWORD PTR [rcx+0x18],rdx
    39c8:	mov    rax,QWORD PTR [rbp-0x50]
    39cc:	mov    rdx,QWORD PTR [rbp-0x48]
    39d0:	mov    QWORD PTR [rcx+0x20],rax
    39d4:	mov    QWORD PTR [rcx+0x28],rdx
    39d8:	mov    rax,QWORD PTR [rbp-0x40]
    39dc:	mov    QWORD PTR [rcx+0x30],rax
    39e0:	call   2088 <__profile_end_pass>
    39e5:	add    rsp,0x40
    39e9:	cmp    QWORD PTR [rbp-0x208],0x0
    39f1:	je     3807 <main+0x40d>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    39f7:	mov    rax,QWORD PTR [rbp-0x210]
    39fe:	mov    rax,QWORD PTR [rax+0x28]
    3a02:	mov    QWORD PTR [rbp-0x210],rax
    3a09:	cmp    QWORD PTR [rbp-0x210],0x0
    3a11:	je     3a28 <main+0x62e>
    3a13:	mov    eax,DWORD PTR [rbp-0x238]
    3a19:	cdqe
    3a1b:	cmp    rax,QWORD PTR [rbp-0x220]
    3a22:	jb     37b0 <main+0x3b6>
      }
    }
  }

  f64 sum = 0.0;
    3a28:	pxor   xmm0,xmm0
    3a2c:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3a34:	lea    rax,[rip+0xc46]        # 4681 <_IO_stdin_used+0x681>
    3a3b:	mov    QWORD PTR [rbp-0x290],rax
    3a42:	mov    QWORD PTR [rbp-0x288],0x3
    3a4d:	lea    rax,[rbp-0xf0]
    3a54:	mov    rcx,QWORD PTR [rbp-0x290]
    3a5b:	mov    rbx,QWORD PTR [rbp-0x288]
    3a62:	mov    rsi,rcx
    3a65:	mov    rdx,rbx
    3a68:	mov    r8d,0x0
    3a6e:	mov    ecx,0x8
    3a73:	mov    rdi,rax
    3a76:	call   1f9e <__profile_begin_pass>
    3a7b:	mov    QWORD PTR [rbp-0x1f8],0x0
    3a86:	jmp    3c08 <main+0x80e>
  {
    for (usize i = 0; i < pair_count; i++)
    3a8b:	mov    QWORD PTR [rbp-0x1f0],0x0
    3a96:	jmp    3b6b <main+0x771>
    {
      f64 earth_radius = 6372.8;
    3a9b:	movsd  xmm0,QWORD PTR [rip+0xe5d]        # 4900 <__PRETTY_FUNCTION__.0+0x80>
    3aa3:	movsd  QWORD PTR [rbp-0x1b8],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    3aab:	mov    rax,QWORD PTR [rbp-0x1f0]
    3ab2:	shl    rax,0x5
    3ab6:	mov    rdx,rax
    3ab9:	mov    rax,QWORD PTR [rbp-0x228]
    3ac0:	add    rax,rdx
    3ac3:	movsd  xmm2,QWORD PTR [rax+0x18]
    3ac8:	mov    rax,QWORD PTR [rbp-0x1f0]
    3acf:	shl    rax,0x5
    3ad3:	mov    rdx,rax
    3ad6:	mov    rax,QWORD PTR [rbp-0x228]
    3add:	add    rax,rdx
    3ae0:	movsd  xmm1,QWORD PTR [rax+0x10]
    3ae5:	mov    rax,QWORD PTR [rbp-0x1f0]
    3aec:	shl    rax,0x5
    3af0:	mov    rdx,rax
    3af3:	mov    rax,QWORD PTR [rbp-0x228]
    3afa:	add    rax,rdx
    3afd:	movsd  xmm0,QWORD PTR [rax+0x8]
    3b02:	mov    rax,QWORD PTR [rbp-0x1f0]
    3b09:	shl    rax,0x5
    3b0d:	mov    rdx,rax
    3b10:	mov    rax,QWORD PTR [rbp-0x228]
    3b17:	add    rax,rdx
    3b1a:	mov    rax,QWORD PTR [rax]
    3b1d:	movsd  xmm3,QWORD PTR [rbp-0x1b8]
    3b25:	movapd xmm4,xmm3
    3b29:	movapd xmm3,xmm2
    3b2d:	movapd xmm2,xmm1
    3b31:	movapd xmm1,xmm0
    3b35:	movq   xmm0,rax
    3b3a:	call   31f9 <reference_haversine>
    3b3f:	movq   rax,xmm0
    3b44:	mov    QWORD PTR [rbp-0x1b0],rax
      sum += result;
    3b4b:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b53:	addsd  xmm0,QWORD PTR [rbp-0x1b0]
    3b5b:	movsd  QWORD PTR [rbp-0x200],xmm0
    for (usize i = 0; i < pair_count; i++)
    3b63:	add    QWORD PTR [rbp-0x1f0],0x1
    3b6b:	mov    eax,DWORD PTR [rbp-0x238]
    3b71:	cdqe
    3b73:	cmp    QWORD PTR [rbp-0x1f0],rax
    3b7a:	jb     3a9b <main+0x6a1>
    }
    sum /= pair_count;
    3b80:	pxor   xmm1,xmm1
    3b84:	cvtsi2sd xmm1,DWORD PTR [rbp-0x238]
    3b8c:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b94:	divsd  xmm0,xmm1
    3b98:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3ba0:	add    QWORD PTR [rbp-0x1f8],0x1
    3ba8:	sub    rsp,0x8
    3bac:	sub    rsp,0x38
    3bb0:	mov    rax,rsp
    3bb3:	mov    rcx,QWORD PTR [rbp-0xf0]
    3bba:	mov    rbx,QWORD PTR [rbp-0xe8]
    3bc1:	mov    QWORD PTR [rax],rcx
    3bc4:	mov    QWORD PTR [rax+0x8],rbx
    3bc8:	mov    rcx,QWORD PTR [rbp-0xe0]
    3bcf:	mov    rbx,QWORD PTR [rbp-0xd8]
    3bd6:	mov    QWORD PTR [rax+0x10],rcx
    3bda:	mov    QWORD PTR [rax+0x18],rbx
    3bde:	mov    rcx,QWORD PTR [rbp-0xd0]
    3be5:	mov    rbx,QWORD PTR [rbp-0xc8]
    3bec:	mov    QWORD PTR [rax+0x20],rcx
    3bf0:	mov    QWORD PTR [rax+0x28],rbx
    3bf4:	mov    rdx,QWORD PTR [rbp-0xc0]
    3bfb:	mov    QWORD PTR [rax+0x30],rdx
    3bff:	call   2088 <__profile_end_pass>
    3c04:	add    rsp,0x40
    3c08:	cmp    QWORD PTR [rbp-0x1f8],0x0
    3c10:	je     3a8b <main+0x691>
  }

  PROFILE_SCOPE("check")
    3c16:	lea    rax,[rip+0xa68]        # 4685 <_IO_stdin_used+0x685>
    3c1d:	mov    QWORD PTR [rbp-0x2a0],rax
    3c24:	mov    QWORD PTR [rbp-0x298],0x5
    3c2f:	lea    rax,[rbp-0xb0]
    3c36:	mov    rcx,QWORD PTR [rbp-0x2a0]
    3c3d:	mov    rbx,QWORD PTR [rbp-0x298]
    3c44:	mov    rsi,rcx
    3c47:	mov    rdx,rbx
    3c4a:	mov    r8d,0x0
    3c50:	mov    ecx,0x9
    3c55:	mov    rdi,rax
    3c58:	call   1f9e <__profile_begin_pass>
    3c5d:	mov    QWORD PTR [rbp-0x1e8],0x0
    3c68:	jmp    3e3d <main+0xa43>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3c6d:	mov    rax,QWORD PTR [rbp-0x250]
    3c74:	add    rax,0x10
    3c78:	mov    rdx,QWORD PTR [rax]
    3c7b:	lea    rax,[rbp-0x190]
    3c82:	mov    rsi,rdx
    3c85:	mov    rdi,rax
    3c88:	call   1357 <read_file_to_arena>
    3c8d:	mov    QWORD PTR [rbp-0x70],rax
    3c91:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3c95:	mov    rax,QWORD PTR [rbp-0x68]
    3c99:	cmp    rax,0xb
    3c9d:	jbe    3db0 <main+0x9b6>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3ca3:	mov    rax,QWORD PTR [rbp-0x70]
    3ca7:	movsd  xmm0,QWORD PTR [rax]
    3cab:	movsd  QWORD PTR [rbp-0x1c0],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3cb3:	mov    rax,QWORD PTR [rbp-0x70]
    3cb7:	mov    eax,DWORD PTR [rax+0x8]
    3cba:	mov    DWORD PTR [rbp-0x234],eax

      if (solution_pairs == pair_count)
    3cc0:	mov    eax,DWORD PTR [rbp-0x234]
    3cc6:	cmp    eax,DWORD PTR [rbp-0x238]
    3ccc:	jne    3d74 <main+0x97a>
      {
        if (epsilon_equal(solution_sum, sum))
    3cd2:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3cda:	mov    rax,QWORD PTR [rbp-0x1c0]
    3ce1:	movapd xmm1,xmm0
    3ce5:	movq   xmm0,rax
    3cea:	call   33a4 <epsilon_equal>
    3cef:	test   eax,eax
    3cf1:	je     3d35 <main+0x93b>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3cf3:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3cfb:	mov    rax,QWORD PTR [rbp-0x1c0]
    3d02:	lea    rdx,[rip+0x987]        # 4690 <_IO_stdin_used+0x690>
    3d09:	lea    rsi,[rip+0x9b3]        # 46c3 <_IO_stdin_used+0x6c3>
    3d10:	movapd xmm1,xmm0
    3d14:	movq   xmm0,rax
    3d19:	mov    rcx,rdx
    3d1c:	mov    edx,0x64
    3d21:	mov    edi,0x3
    3d26:	mov    eax,0x2
    3d2b:	call   14a1 <log_message>
    3d30:	jmp    3dd8 <main+0x9de>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3d35:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3d3d:	mov    rax,QWORD PTR [rbp-0x1c0]
    3d44:	lea    rdx,[rip+0x98d]        # 46d8 <_IO_stdin_used+0x6d8>
    3d4b:	lea    rsi,[rip+0x971]        # 46c3 <_IO_stdin_used+0x6c3>
    3d52:	movapd xmm1,xmm0
    3d56:	movq   xmm0,rax
    3d5b:	mov    rcx,rdx
    3d5e:	mov    edx,0x68
    3d63:	mov    edi,0x1
    3d68:	mov    eax,0x2
    3d6d:	call   14a1 <log_message>
    3d72:	jmp    3dd8 <main+0x9de>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3d74:	mov    esi,DWORD PTR [rbp-0x238]
    3d7a:	mov    ecx,DWORD PTR [rbp-0x234]
    3d80:	lea    rdx,[rip+0x989]        # 4710 <_IO_stdin_used+0x710>
    3d87:	lea    rax,[rip+0x935]        # 46c3 <_IO_stdin_used+0x6c3>
    3d8e:	mov    r9d,esi
    3d91:	mov    r8d,ecx
    3d94:	mov    rcx,rdx
    3d97:	mov    edx,0x6d
    3d9c:	mov    rsi,rax
    3d9f:	mov    edi,0x1
    3da4:	mov    eax,0x0
    3da9:	call   14a1 <log_message>
    3dae:	jmp    3dd8 <main+0x9de>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3db0:	lea    rdx,[rip+0x9a1]        # 4758 <_IO_stdin_used+0x758>
    3db7:	lea    rax,[rip+0x905]        # 46c3 <_IO_stdin_used+0x6c3>
    3dbe:	mov    rcx,rdx
    3dc1:	mov    edx,0x72
    3dc6:	mov    rsi,rax
    3dc9:	mov    edi,0x1
    3dce:	mov    eax,0x0
    3dd3:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3dd8:	add    QWORD PTR [rbp-0x1e8],0x1
    3de0:	sub    rsp,0x8
    3de4:	sub    rsp,0x38
    3de8:	mov    rax,rsp
    3deb:	mov    rcx,QWORD PTR [rbp-0xb0]
    3df2:	mov    rbx,QWORD PTR [rbp-0xa8]
    3df9:	mov    QWORD PTR [rax],rcx
    3dfc:	mov    QWORD PTR [rax+0x8],rbx
    3e00:	mov    rcx,QWORD PTR [rbp-0xa0]
    3e07:	mov    rbx,QWORD PTR [rbp-0x98]
    3e0e:	mov    QWORD PTR [rax+0x10],rcx
    3e12:	mov    QWORD PTR [rax+0x18],rbx
    3e16:	mov    rcx,QWORD PTR [rbp-0x90]
    3e1d:	mov    rbx,QWORD PTR [rbp-0x88]
    3e24:	mov    QWORD PTR [rax+0x20],rcx
    3e28:	mov    QWORD PTR [rax+0x28],rbx
    3e2c:	mov    rdx,QWORD PTR [rbp-0x80]
    3e30:	mov    QWORD PTR [rax+0x30],rdx
    3e34:	call   2088 <__profile_end_pass>
    3e39:	add    rsp,0x40
    3e3d:	cmp    QWORD PTR [rbp-0x1e8],0x0
    3e45:	je     3c6d <main+0x873>
    }
  }

  PROFILE_SCOPE("free")
    3e4b:	lea    rax,[rip+0x941]        # 4793 <_IO_stdin_used+0x793>
    3e52:	mov    QWORD PTR [rbp-0x2b0],rax
    3e59:	mov    QWORD PTR [rbp-0x2a8],0x4
    3e64:	lea    rax,[rbp-0x70]
    3e68:	mov    rcx,QWORD PTR [rbp-0x2b0]
    3e6f:	mov    rbx,QWORD PTR [rbp-0x2a8]
    3e76:	mov    rsi,rcx
    3e79:	mov    rdx,rbx
    3e7c:	mov    r8d,0x0
    3e82:	mov    ecx,0xa
    3e87:	mov    rdi,rax
    3e8a:	call   1f9e <__profile_begin_pass>
    3e8f:	mov    QWORD PTR [rbp-0x1e0],0x0
    3e9a:	jmp    3efe <main+0xb04>
  {
    arena_free(&arena);
    3e9c:	lea    rax,[rbp-0x190]
    3ea3:	mov    rdi,rax
    3ea6:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3eab:	add    QWORD PTR [rbp-0x1e0],0x1
    3eb3:	sub    rsp,0x8
    3eb7:	sub    rsp,0x38
    3ebb:	mov    rax,rsp
    3ebe:	mov    rcx,QWORD PTR [rbp-0x70]
    3ec2:	mov    rbx,QWORD PTR [rbp-0x68]
    3ec6:	mov    QWORD PTR [rax],rcx
    3ec9:	mov    QWORD PTR [rax+0x8],rbx
    3ecd:	mov    rcx,QWORD PTR [rbp-0x60]
    3ed1:	mov    rbx,QWORD PTR [rbp-0x58]
    3ed5:	mov    QWORD PTR [rax+0x10],rcx
    3ed9:	mov    QWORD PTR [rax+0x18],rbx
    3edd:	mov    rcx,QWORD PTR [rbp-0x50]
    3ee1:	mov    rbx,QWORD PTR [rbp-0x48]
    3ee5:	mov    QWORD PTR [rax+0x20],rcx
    3ee9:	mov    QWORD PTR [rax+0x28],rbx
    3eed:	mov    rdx,QWORD PTR [rbp-0x40]
    3ef1:	mov    QWORD PTR [rax+0x30],rdx
    3ef5:	call   2088 <__profile_end_pass>
    3efa:	add    rsp,0x40
    3efe:	cmp    QWORD PTR [rbp-0x1e0],0x0
    3f06:	je     3e9c <main+0xaa2>
  }

  end_profiling();
    3f08:	call   1b9b <end_profiling>
    3f0d:	mov    eax,0x0
}
    3f12:	mov    rdx,QWORD PTR [rbp-0x38]
    3f16:	sub    rdx,QWORD PTR fs:0x28
    3f1f:	je     3f26 <main+0xb2c>
    3f21:	call   1060 <__stack_chk_fail@plt>
    3f26:	lea    rsp,[rbp-0x28]
    3f2a:	pop    rbx
    3f2b:	pop    r12
    3f2d:	pop    r13
    3f2f:	pop    r14
    3f31:	pop    r15
    3f33:	pop    rbp
    3f34:	ret

Disassembly of section .fini:

0000000000003f38 <_fini>:
    3f38:	endbr64
    3f3c:	sub    rsp,0x8
    3f40:	add    rsp,0x8
    3f44:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x5fc1]        # 6fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x5fca]        # 6ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x5fcc]        # 6ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x5fca]        # 7000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x5fc2]        # 7008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x5fba]        # 7010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x5fb2]        # 7018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x5faa]        # 7020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x5fa2]        # 7028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x5f9a]        # 7030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x5f92]        # 7038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x5f8a]        # 7040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x5f82]        # 7048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x5f7a]        # 7050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x5f72]        # 7058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x5f6a]        # 7060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x5f62]        # 7068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x5f5a]        # 7070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x5f52]        # 7078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x5f4a]        # 7080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x5f42]        # 7088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x5f3a]        # 7090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x5f32]        # 7098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2239]        # 33c8 <main>
    118f:	call   QWORD PTR [rip+0x5e2b]        # 6fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x5fa1]        # 7148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x5f9a]        # 7148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x5e0e]        # 6fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x5f71]        # 7148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x5f6a]        # 7148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x5ddd]        # 6fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x5f6d],0x0        # 7188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x5dba],0x0        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x5e76]        # 70a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x5da8]        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x5f44],0x1        # 7188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x5c6e]        # 7180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x5b89]        # 70c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x5be7]        # 7160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x5b2b]        # 70c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x30b7]        # 47b0 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x308b]        # 47b0 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fce]        # 47c8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2ecf]        # 47d8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2ced]        # 47f0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x5639]        # 71a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x5620],rbx        # 71a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x50
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x55ee]        # 71a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x40],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x40],0x0
    1bbe:	je     1f69 <end_profiling+0x3ce>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x38],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x40]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x38]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c71]        # 48a8 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x38]
    1c44:	mov    rax,QWORD PTR [rbp-0x40]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x50],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x48],0x0
    1c72:	jmp    1f5b <end_profiling+0x3c0>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x48]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x550d]        # 71a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x30],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x30]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1f56 <end_profiling+0x3bb>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x30]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x40]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b97]        # 48b0 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x28],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x30]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x30]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x30]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x30]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x28]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x30]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x30]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x30]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x40]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2abf]        # 48b0 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x20],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x30]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x20]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x50]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x28]
    1e2c:	movsd  QWORD PTR [rbp-0x50],xmm0

        if (zone->bytes_processed)
    1e31:	mov    rax,QWORD PTR [rbp-0x30]
    1e35:	mov    rax,QWORD PTR [rax+0x28]
    1e39:	test   rax,rax
    1e3c:	je     1f56 <end_profiling+0x3bb>
        {
          u64 gigabytes = zone->bytes_processed / BILLION(1);
    1e42:	mov    rax,QWORD PTR [rbp-0x30]
    1e46:	mov    rax,QWORD PTR [rax+0x28]
    1e4a:	shr    rax,0x9
    1e4e:	movabs rdx,0x44b82fa09b5a53
    1e58:	mul    rdx
    1e5b:	mov    rax,rdx
    1e5e:	shr    rax,0xb
    1e62:	mov    QWORD PTR [rbp-0x18],rax
          u64 megabytes = zone->bytes_processed / MILLION(1);
    1e66:	mov    rax,QWORD PTR [rbp-0x30]
    1e6a:	mov    rax,QWORD PTR [rax+0x28]
    1e6e:	movabs rdx,0x431bde82d7b634db
    1e78:	mul    rdx
    1e7b:	mov    rax,rdx
    1e7e:	shr    rax,0x12
    1e82:	mov    QWORD PTR [rbp-0x10],rax

          f64 gb_per_s = gigabytes / (f64)zone->elapsed_exclusive / (f64)freq * MILLION(1);
    1e86:	mov    rax,QWORD PTR [rbp-0x18]
    1e8a:	test   rax,rax
    1e8d:	js     1e9a <end_profiling+0x2ff>
    1e8f:	pxor   xmm0,xmm0
    1e93:	cvtsi2sd xmm0,rax
    1e98:	jmp    1eb3 <end_profiling+0x318>
    1e9a:	mov    rdx,rax
    1e9d:	shr    rdx,1
    1ea0:	and    eax,0x1
    1ea3:	or     rdx,rax
    1ea6:	pxor   xmm0,xmm0
    1eaa:	cvtsi2sd xmm0,rdx
    1eaf:	addsd  xmm0,xmm0
    1eb3:	mov    rax,QWORD PTR [rbp-0x30]
    1eb7:	mov    rax,QWORD PTR [rax+0x10]
    1ebb:	test   rax,rax
    1ebe:	js     1ecb <end_profiling+0x330>
    1ec0:	pxor   xmm1,xmm1
    1ec4:	cvtsi2sd xmm1,rax
    1ec9:	jmp    1ee4 <end_profiling+0x349>
    1ecb:	mov    rdx,rax
    1ece:	shr    rdx,1
    1ed1:	and    eax,0x1
    1ed4:	or     rdx,rax
    1ed7:	pxor   xmm1,xmm1
    1edb:	cvtsi2sd xmm1,rdx
    1ee0:	addsd  xmm1,xmm1
    1ee4:	movapd xmm2,xmm0
    1ee8:	divsd  xmm2,xmm1
    1eec:	mov    rax,QWORD PTR [rbp-0x38]
    1ef0:	test   rax,rax
    1ef3:	js     1f00 <end_profiling+0x365>
    1ef5:	pxor   xmm0,xmm0
    1ef9:	cvtsi2sd xmm0,rax
    1efe:	jmp    1f19 <end_profiling+0x37e>
    1f00:	mov    rdx,rax
    1f03:	shr    rdx,1
    1f06:	and    eax,0x1
    1f09:	or     rdx,rax
    1f0c:	pxor   xmm0,xmm0
    1f10:	cvtsi2sd xmm0,rdx
    1f15:	addsd  xmm0,xmm0
    1f19:	movapd xmm1,xmm2
    1f1d:	divsd  xmm1,xmm0
    1f21:	movsd  xmm0,QWORD PTR [rip+0x298f]        # 48b8 <__PRETTY_FUNCTION__.0+0x28>
    1f29:	mulsd  xmm0,xmm1
    1f2d:	movsd  QWORD PTR [rbp-0x8],xmm0

          printf("  Megabytes Processed: %lu @ %f GB/s\n", megabytes, gb_per_s);
    1f32:	mov    rdx,QWORD PTR [rbp-0x8]
    1f36:	mov    rax,QWORD PTR [rbp-0x10]
    1f3a:	lea    rcx,[rip+0x2407]        # 4348 <_IO_stdin_used+0x348>
    1f41:	movq   xmm0,rdx
    1f46:	mov    rsi,rax
    1f49:	mov    rdi,rcx
    1f4c:	mov    eax,0x1
    1f51:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1f56:	add    QWORD PTR [rbp-0x48],0x1
    1f5b:	cmp    QWORD PTR [rbp-0x48],0xfff
    1f63:	jbe    1c77 <end_profiling+0xdc>
        }
      }
    }
  }
}
    1f69:	nop
    1f6a:	leave
    1f6b:	ret

0000000000001f6c <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1f6c:	push   rbp
    1f6d:	mov    rbp,rsp
    1f70:	push   rbx
    1f71:	sub    rsp,0x78
    1f75:	mov    QWORD PTR [rbp-0x58],rdi
    1f79:	mov    rax,rsi
    1f7c:	mov    rsi,rdx
    1f7f:	mov    rax,rax
    1f82:	mov    edx,0x0
    1f87:	mov    rdx,rsi
    1f8a:	mov    QWORD PTR [rbp-0x70],rax
    1f8e:	mov    QWORD PTR [rbp-0x68],rdx
    1f92:	mov    QWORD PTR [rbp-0x60],rcx
    1f96:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1f9a:	pxor   xmm0,xmm0
    1f9e:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1fa2:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1fa6:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1faa:	movq   QWORD PTR [rbp-0x20],xmm0
    1faf:	mov    rax,QWORD PTR [rbp-0x70]
    1fb3:	mov    rdx,QWORD PTR [rbp-0x68]
    1fb7:	mov    QWORD PTR [rbp-0x50],rax
    1fbb:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1fbf:	mov    rdx,QWORD PTR [rbp-0x60]
    1fc3:	mov    rax,rdx
    1fc6:	add    rax,rax
    1fc9:	add    rax,rdx
    1fcc:	shl    rax,0x4
    1fd0:	mov    rdx,rax
    1fd3:	lea    rax,[rip+0x51ee]        # 71c8 <g_profiler+0x28>
    1fda:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1fde:	mov    QWORD PTR [rbp-0x38],rax
    1fe2:	mov    rax,QWORD PTR [rbp-0x60]
    1fe6:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1fea:	mov    rax,QWORD PTR [rip+0x51b7]        # 71a8 <g_profiler+0x8>
  Profile_Pass pass =
    1ff1:	mov    QWORD PTR [rbp-0x28],rax
    1ff5:	mov    rax,QWORD PTR [rbp-0x78]
    1ff9:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    1ffd:	mov    rax,QWORD PTR [rbp-0x60]
    2001:	mov    QWORD PTR [rip+0x51a0],rax        # 71a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    2008:	call   1a48 <read_cpu_timer>
    200d:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    2011:	mov    rax,QWORD PTR [rbp-0x58]
    2015:	mov    rcx,QWORD PTR [rbp-0x50]
    2019:	mov    rbx,QWORD PTR [rbp-0x48]
    201d:	mov    QWORD PTR [rax],rcx
    2020:	mov    QWORD PTR [rax+0x8],rbx
    2024:	mov    rcx,QWORD PTR [rbp-0x40]
    2028:	mov    rbx,QWORD PTR [rbp-0x38]
    202c:	mov    QWORD PTR [rax+0x10],rcx
    2030:	mov    QWORD PTR [rax+0x18],rbx
    2034:	mov    rcx,QWORD PTR [rbp-0x30]
    2038:	mov    rbx,QWORD PTR [rbp-0x28]
    203c:	mov    QWORD PTR [rax+0x20],rcx
    2040:	mov    QWORD PTR [rax+0x28],rbx
    2044:	mov    rdx,QWORD PTR [rbp-0x20]
    2048:	mov    QWORD PTR [rax+0x30],rdx
}
    204c:	mov    rax,QWORD PTR [rbp-0x58]
    2050:	mov    rbx,QWORD PTR [rbp-0x8]
    2054:	leave
    2055:	ret

0000000000002056 <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    2056:	push   rbp
    2057:	mov    rbp,rsp
    205a:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    205e:	call   1a48 <read_cpu_timer>
    2063:	mov    rdx,rax
    2066:	mov    rax,QWORD PTR [rbp+0x20]
    206a:	sub    rdx,rax
    206d:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    2071:	mov    rax,QWORD PTR [rbp+0x38]
    2075:	mov    QWORD PTR [rip+0x512c],rax        # 71a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    207c:	mov    rdx,QWORD PTR [rbp+0x30]
    2080:	mov    rax,rdx
    2083:	add    rax,rax
    2086:	add    rax,rdx
    2089:	shl    rax,0x4
    208d:	lea    rdx,[rax+0x10]
    2091:	lea    rax,[rip+0x5108]        # 71a0 <g_profiler>
    2098:	add    rax,rdx
    209b:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    209f:	mov    rax,QWORD PTR [rbp-0x10]
    20a3:	mov    rdx,QWORD PTR [rax+0x10]
    20a7:	mov    rax,QWORD PTR [rbp-0x18]
    20ab:	add    rdx,rax
    20ae:	mov    rax,QWORD PTR [rbp-0x10]
    20b2:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    20b6:	mov    rax,QWORD PTR [rbp-0x10]
    20ba:	mov    rax,QWORD PTR [rax+0x20]
    20be:	lea    rdx,[rax+0x1]
    20c2:	mov    rax,QWORD PTR [rbp-0x10]
    20c6:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    20ca:	mov    rcx,QWORD PTR [rbp-0x10]
    20ce:	mov    rax,QWORD PTR [rbp+0x10]
    20d2:	mov    rdx,QWORD PTR [rbp+0x18]
    20d6:	mov    QWORD PTR [rcx],rax
    20d9:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    20dd:	mov    rdx,QWORD PTR [rbp+0x28]
    20e1:	mov    rax,QWORD PTR [rbp-0x18]
    20e5:	add    rdx,rax
    20e8:	mov    rax,QWORD PTR [rbp-0x10]
    20ec:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    20f0:	mov    rax,QWORD PTR [rbp-0x10]
    20f4:	mov    rdx,QWORD PTR [rax+0x28]
    20f8:	mov    rax,QWORD PTR [rbp+0x40]
    20fc:	add    rdx,rax
    20ff:	mov    rax,QWORD PTR [rbp-0x10]
    2103:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    2107:	mov    rdx,QWORD PTR [rbp+0x38]
    210b:	mov    rax,rdx
    210e:	add    rax,rax
    2111:	add    rax,rdx
    2114:	shl    rax,0x4
    2118:	lea    rdx,[rax+0x10]
    211c:	lea    rax,[rip+0x507d]        # 71a0 <g_profiler>
    2123:	add    rax,rdx
    2126:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    212a:	mov    rax,QWORD PTR [rbp-0x8]
    212e:	mov    rax,QWORD PTR [rax+0x10]
    2132:	sub    rax,QWORD PTR [rbp-0x18]
    2136:	mov    rdx,rax
    2139:	mov    rax,QWORD PTR [rbp-0x8]
    213d:	mov    QWORD PTR [rax+0x10],rdx
}
    2141:	nop
    2142:	leave
    2143:	ret

0000000000002144 <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    2144:	push   rbp
    2145:	mov    rbp,rsp
    2148:	sub    rsp,0x10
    214c:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2150:	mov    rax,QWORD PTR [rbp-0x8]
    2154:	mov    rdx,QWORD PTR [rax+0x10]
    2158:	mov    rax,QWORD PTR [rbp-0x8]
    215c:	mov    rax,QWORD PTR [rax+0x8]
    2160:	cmp    rdx,rax
    2163:	jb     218a <parser_at+0x46>
    2165:	lea    rdx,[rip+0x269c]        # 4808 <__PRETTY_FUNCTION__.5>
    216c:	lea    rsi,[rip+0x2306]        # 4479 <_IO_stdin_used+0x479>
    2173:	lea    rax,[rip+0x2316]        # 4490 <_IO_stdin_used+0x490>
    217a:	mov    rcx,rdx
    217d:	mov    edx,0x2f
    2182:	mov    rdi,rax
    2185:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    218a:	mov    rax,QWORD PTR [rbp-0x8]
    218e:	mov    rdx,QWORD PTR [rax]
    2191:	mov    rax,QWORD PTR [rbp-0x8]
    2195:	mov    rax,QWORD PTR [rax+0x10]
    2199:	add    rax,rdx
}
    219c:	leave
    219d:	ret

000000000000219e <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    219e:	push   rbp
    219f:	mov    rbp,rsp
    21a2:	sub    rsp,0x10
    21a6:	mov    QWORD PTR [rbp-0x8],rdi
    21aa:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    21ae:	mov    rax,QWORD PTR [rbp-0x8]
    21b2:	mov    rdi,rax
    21b5:	call   2144 <parser_at>
    21ba:	mov    rdx,QWORD PTR [rbp-0x10]
    21be:	add    rax,rdx
}
    21c1:	leave
    21c2:	ret

00000000000021c3 <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    21c3:	push   rbp
    21c4:	mov    rbp,rsp
    21c7:	mov    QWORD PTR [rbp-0x8],rdi
    21cb:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    21cf:	mov    rax,QWORD PTR [rbp-0x8]
    21d3:	mov    rdx,QWORD PTR [rax+0x10]
    21d7:	mov    rax,QWORD PTR [rbp-0x10]
    21db:	add    rdx,rax
    21de:	mov    rax,QWORD PTR [rbp-0x8]
    21e2:	mov    QWORD PTR [rax+0x10],rdx
}
    21e6:	nop
    21e7:	pop    rbp
    21e8:	ret

00000000000021e9 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    21e9:	push   rbp
    21ea:	mov    rbp,rsp
    21ed:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    21f1:	mov    rax,QWORD PTR [rbp-0x8]
    21f5:	mov    rdx,QWORD PTR [rax+0x10]
    21f9:	mov    rax,QWORD PTR [rbp-0x8]
    21fd:	mov    rax,QWORD PTR [rax+0x8]
    2201:	cmp    rdx,rax
    2204:	setb   al
}
    2207:	pop    rbp
    2208:	ret

0000000000002209 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    2209:	push   rbp
    220a:	mov    rbp,rsp
    220d:	push   r12
    220f:	push   rbx
    2210:	sub    rsp,0x20
    2214:	mov    QWORD PTR [rbp-0x18],rdi
    2218:	mov    rax,rsi
    221b:	mov    rcx,rdx
    221e:	mov    rax,rax
    2221:	mov    edx,0x0
    2226:	mov    rdx,rcx
    2229:	mov    QWORD PTR [rbp-0x30],rax
    222d:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    2231:	mov    rax,QWORD PTR [rbp-0x28]
    2235:	mov    r12,rax
    2238:	mov    rbx,QWORD PTR [rbp-0x30]
    223c:	mov    rax,QWORD PTR [rbp-0x18]
    2240:	mov    rdi,rax
    2243:	call   2144 <parser_at>
    2248:	mov    rdx,r12
    224b:	mov    rsi,rbx
    224e:	mov    rdi,rax
    2251:	call   10d0 <memcmp@plt>
    2256:	test   eax,eax
    2258:	sete   al
}
    225b:	add    rsp,0x20
    225f:	pop    rbx
    2260:	pop    r12
    2262:	pop    rbp
    2263:	ret

0000000000002264 <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    2264:	push   rbp
    2265:	mov    rbp,rsp
    2268:	mov    eax,edi
    226a:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    226d:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    2271:	movzx  eax,BYTE PTR [rbp-0x14]
    2275:	cmp    eax,0x2e
    2278:	jg     2281 <is_numeric+0x1d>
    227a:	cmp    eax,0x2d
    227d:	jge    2289 <is_numeric+0x25>
    227f:	jmp    228e <is_numeric+0x2a>
    2281:	sub    eax,0x30
    2284:	cmp    eax,0x9
    2287:	ja     228e <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2289:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    228d:	nop
  }


  return result;
    228e:	movzx  eax,BYTE PTR [rbp-0x1]
}
    2292:	pop    rbp
    2293:	ret

0000000000002294 <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    2294:	push   rbp
    2295:	mov    rbp,rsp
    2298:	sub    rsp,0x50
    229c:	mov    QWORD PTR [rbp-0x48],rdi
    22a0:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    22a4:	pxor   xmm0,xmm0
    22a8:	movaps XMMWORD PTR [rbp-0x20],xmm0
    22ac:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    22b1:	jmp    22c4 <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    22b3:	mov    rax,QWORD PTR [rbp-0x50]
    22b7:	mov    esi,0x1
    22bc:	mov    rdi,rax
    22bf:	call   21c3 <parser_advance>
  while (parser_incomplete(parser)  &&
    22c4:	mov    rax,QWORD PTR [rbp-0x50]
    22c8:	mov    rdi,rax
    22cb:	call   21e9 <parser_incomplete>
    22d0:	test   al,al
    22d2:	je     2320 <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    22d4:	mov    rax,QWORD PTR [rbp-0x50]
    22d8:	mov    rdi,rax
    22db:	call   2144 <parser_at>
    22e0:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    22e3:	cmp    al,0x20
    22e5:	je     22b3 <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    22e7:	mov    rax,QWORD PTR [rbp-0x50]
    22eb:	mov    rdi,rax
    22ee:	call   2144 <parser_at>
    22f3:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    22f6:	cmp    al,0xa
    22f8:	je     22b3 <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    22fa:	mov    rax,QWORD PTR [rbp-0x50]
    22fe:	mov    rdi,rax
    2301:	call   2144 <parser_at>
    2306:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    2309:	cmp    al,0xd
    230b:	je     22b3 <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    230d:	mov    rax,QWORD PTR [rbp-0x50]
    2311:	mov    rdi,rax
    2314:	call   2144 <parser_at>
    2319:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    231c:	cmp    al,0x9
    231e:	je     22b3 <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    2320:	mov    rax,QWORD PTR [rbp-0x50]
    2324:	mov    rdi,rax
    2327:	call   21e9 <parser_incomplete>
    232c:	test   al,al
    232e:	je     275b <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    2334:	mov    rax,QWORD PTR [rbp-0x50]
    2338:	mov    rdi,rax
    233b:	call   2144 <parser_at>
    2340:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    2344:	mov    rax,QWORD PTR [rbp-0x50]
    2348:	mov    rdi,rax
    234b:	call   2144 <parser_at>
    2350:	movzx  eax,BYTE PTR [rax]
    2353:	movzx  eax,al
    2356:	cmp    eax,0x7d
    2359:	je     2446 <get_json_token+0x1b2>
    235f:	cmp    eax,0x7d
    2362:	jg     276c <get_json_token+0x4d8>
    2368:	cmp    eax,0x7b
    236b:	je     2421 <get_json_token+0x18d>
    2371:	cmp    eax,0x7b
    2374:	jg     276c <get_json_token+0x4d8>
    237a:	cmp    eax,0x74
    237d:	je     25c9 <get_json_token+0x335>
    2383:	cmp    eax,0x74
    2386:	jg     276c <get_json_token+0x4d8>
    238c:	cmp    eax,0x6e
    238f:	je     26d9 <get_json_token+0x445>
    2395:	cmp    eax,0x6e
    2398:	jg     276c <get_json_token+0x4d8>
    239e:	cmp    eax,0x66
    23a1:	je     2651 <get_json_token+0x3bd>
    23a7:	cmp    eax,0x66
    23aa:	jg     276c <get_json_token+0x4d8>
    23b0:	cmp    eax,0x5d
    23b3:	je     2490 <get_json_token+0x1fc>
    23b9:	cmp    eax,0x5d
    23bc:	jg     276c <get_json_token+0x4d8>
    23c2:	cmp    eax,0x5b
    23c5:	je     246b <get_json_token+0x1d7>
    23cb:	cmp    eax,0x5b
    23ce:	jg     276c <get_json_token+0x4d8>
    23d4:	cmp    eax,0x3a
    23d7:	je     24da <get_json_token+0x246>
    23dd:	cmp    eax,0x3a
    23e0:	jg     276c <get_json_token+0x4d8>
    23e6:	cmp    eax,0x39
    23e9:	jg     276c <get_json_token+0x4d8>
    23ef:	cmp    eax,0x30
    23f2:	jge    2578 <get_json_token+0x2e4>
    23f8:	cmp    eax,0x2e
    23fb:	jg     276c <get_json_token+0x4d8>
    2401:	cmp    eax,0x2d
    2404:	jge    2578 <get_json_token+0x2e4>
    240a:	cmp    eax,0x22
    240d:	je     24ff <get_json_token+0x26b>
    2413:	cmp    eax,0x2c
    2416:	je     24b5 <get_json_token+0x221>
    241c:	jmp    276c <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    2421:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    2428:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2430:	mov    rax,QWORD PTR [rbp-0x50]
    2434:	mov    esi,0x1
    2439:	mov    rdi,rax
    243c:	call   21c3 <parser_advance>
      }
      break;
    2441:	jmp    276c <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2446:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    244d:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2455:	mov    rax,QWORD PTR [rbp-0x50]
    2459:	mov    esi,0x1
    245e:	mov    rdi,rax
    2461:	call   21c3 <parser_advance>
      }
      break;
    2466:	jmp    276c <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    246b:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    2472:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    247a:	mov    rax,QWORD PTR [rbp-0x50]
    247e:	mov    esi,0x1
    2483:	mov    rdi,rax
    2486:	call   21c3 <parser_advance>
      }
      break;
    248b:	jmp    276c <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    2490:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    2497:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    249f:	mov    rax,QWORD PTR [rbp-0x50]
    24a3:	mov    esi,0x1
    24a8:	mov    rdi,rax
    24ab:	call   21c3 <parser_advance>
      }
      break;
    24b0:	jmp    276c <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    24b5:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    24bc:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24c4:	mov    rax,QWORD PTR [rbp-0x50]
    24c8:	mov    esi,0x1
    24cd:	mov    rdi,rax
    24d0:	call   21c3 <parser_advance>
      }
      break;
    24d5:	jmp    276c <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    24da:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    24e1:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24e9:	mov    rax,QWORD PTR [rbp-0x50]
    24ed:	mov    esi,0x1
    24f2:	mov    rdi,rax
    24f5:	call   21c3 <parser_advance>
      }
      break;
    24fa:	jmp    276c <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    24ff:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    2506:	mov    rax,QWORD PTR [rbp-0x50]
    250a:	mov    esi,0x1
    250f:	mov    rdi,rax
    2512:	call   21c3 <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    2517:	mov    rax,QWORD PTR [rbp-0x50]
    251b:	mov    rdi,rax
    251e:	call   2144 <parser_at>
    2523:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    2527:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    252f:	jmp    2547 <get_json_token+0x2b3>
        {
          string_count += 1;
    2531:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    2536:	mov    rax,QWORD PTR [rbp-0x50]
    253a:	mov    esi,0x1
    253f:	mov    rdi,rax
    2542:	call   21c3 <parser_advance>
        while (*parser_at(parser) != '"')
    2547:	mov    rax,QWORD PTR [rbp-0x50]
    254b:	mov    rdi,rax
    254e:	call   2144 <parser_at>
    2553:	movzx  eax,BYTE PTR [rax]
    2556:	cmp    al,0x22
    2558:	jne    2531 <get_json_token+0x29d>
        }
        token.value.count = string_count;
    255a:	mov    rax,QWORD PTR [rbp-0x40]
    255e:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    2562:	mov    rax,QWORD PTR [rbp-0x50]
    2566:	mov    esi,0x1
    256b:	mov    rdi,rax
    256e:	call   21c3 <parser_advance>
      }
      break;
    2573:	jmp    276c <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2578:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    257f:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2587:	jmp    259f <get_json_token+0x30b>
        {
          digit_count += 1;
    2589:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    258e:	mov    rax,QWORD PTR [rbp-0x50]
    2592:	mov    esi,0x1
    2597:	mov    rdi,rax
    259a:	call   21c3 <parser_advance>
        while (is_numeric(*parser_at(parser)))
    259f:	mov    rax,QWORD PTR [rbp-0x50]
    25a3:	mov    rdi,rax
    25a6:	call   2144 <parser_at>
    25ab:	movzx  eax,BYTE PTR [rax]
    25ae:	movzx  eax,al
    25b1:	mov    edi,eax
    25b3:	call   2264 <is_numeric>
    25b8:	test   al,al
    25ba:	jne    2589 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    25bc:	mov    rax,QWORD PTR [rbp-0x38]
    25c0:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    25c4:	jmp    276c <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    25c9:	lea    rax,[rip+0x1f0c]        # 44dc <_IO_stdin_used+0x4dc>
    25d0:	mov    QWORD PTR [rbp-0x30],rax
    25d4:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25dc:	mov    rcx,QWORD PTR [rbp-0x30]
    25e0:	mov    rdx,QWORD PTR [rbp-0x28]
    25e4:	mov    rax,QWORD PTR [rbp-0x50]
    25e8:	mov    rsi,rcx
    25eb:	mov    rdi,rax
    25ee:	call   2209 <parser_token_is_literal>
    25f3:	test   al,al
    25f5:	je     2619 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    25f7:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    25fe:	mov    rax,QWORD PTR [rbp-0x28]
    2602:	mov    rdx,rax
    2605:	mov    rax,QWORD PTR [rbp-0x50]
    2609:	mov    rsi,rdx
    260c:	mov    rdi,rax
    260f:	call   21c3 <parser_advance>
    2614:	jmp    276c <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2619:	mov    rax,QWORD PTR [rbp-0x50]
    261d:	mov    rcx,QWORD PTR [rax+0x10]
    2621:	lea    rdx,[rip+0x1ec0]        # 44e8 <_IO_stdin_used+0x4e8>
    2628:	lea    rax,[rip+0x1e4a]        # 4479 <_IO_stdin_used+0x479>
    262f:	mov    r8,rcx
    2632:	mov    rcx,rdx
    2635:	mov    edx,0xdf
    263a:	mov    rsi,rax
    263d:	mov    edi,0x1
    2642:	mov    eax,0x0
    2647:	call   14a1 <log_message>
        }
      }
      break;
    264c:	jmp    276c <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    2651:	lea    rax,[rip+0x1ebd]        # 4515 <_IO_stdin_used+0x515>
    2658:	mov    QWORD PTR [rbp-0x30],rax
    265c:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    2664:	mov    rcx,QWORD PTR [rbp-0x30]
    2668:	mov    rdx,QWORD PTR [rbp-0x28]
    266c:	mov    rax,QWORD PTR [rbp-0x50]
    2670:	mov    rsi,rcx
    2673:	mov    rdi,rax
    2676:	call   2209 <parser_token_is_literal>
    267b:	test   al,al
    267d:	je     26a1 <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    267f:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    2686:	mov    rax,QWORD PTR [rbp-0x28]
    268a:	mov    rdx,rax
    268d:	mov    rax,QWORD PTR [rbp-0x50]
    2691:	mov    rsi,rdx
    2694:	mov    rdi,rax
    2697:	call   21c3 <parser_advance>
    269c:	jmp    276c <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    26a1:	mov    rax,QWORD PTR [rbp-0x50]
    26a5:	mov    rcx,QWORD PTR [rax+0x10]
    26a9:	lea    rdx,[rip+0x1e38]        # 44e8 <_IO_stdin_used+0x4e8>
    26b0:	lea    rax,[rip+0x1dc2]        # 4479 <_IO_stdin_used+0x479>
    26b7:	mov    r8,rcx
    26ba:	mov    rcx,rdx
    26bd:	mov    edx,0xee
    26c2:	mov    rsi,rax
    26c5:	mov    edi,0x1
    26ca:	mov    eax,0x0
    26cf:	call   14a1 <log_message>
        }
      }
      break;
    26d4:	jmp    276c <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    26d9:	lea    rax,[rip+0x1e3b]        # 451b <_IO_stdin_used+0x51b>
    26e0:	mov    QWORD PTR [rbp-0x30],rax
    26e4:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    26ec:	mov    rcx,QWORD PTR [rbp-0x30]
    26f0:	mov    rdx,QWORD PTR [rbp-0x28]
    26f4:	mov    rax,QWORD PTR [rbp-0x50]
    26f8:	mov    rsi,rcx
    26fb:	mov    rdi,rax
    26fe:	call   2209 <parser_token_is_literal>
    2703:	test   al,al
    2705:	je     2726 <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    2707:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    270e:	mov    rax,QWORD PTR [rbp-0x28]
    2712:	mov    rdx,rax
    2715:	mov    rax,QWORD PTR [rbp-0x50]
    2719:	mov    rsi,rdx
    271c:	mov    rdi,rax
    271f:	call   21c3 <parser_advance>
    2724:	jmp    276c <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2726:	mov    rax,QWORD PTR [rbp-0x50]
    272a:	mov    rcx,QWORD PTR [rax+0x10]
    272e:	lea    rdx,[rip+0x1db3]        # 44e8 <_IO_stdin_used+0x4e8>
    2735:	lea    rax,[rip+0x1d3d]        # 4479 <_IO_stdin_used+0x479>
    273c:	mov    r8,rcx
    273f:	mov    rcx,rdx
    2742:	mov    edx,0xfd
    2747:	mov    rsi,rax
    274a:	mov    edi,0x1
    274f:	mov    eax,0x0
    2754:	call   14a1 <log_message>
        }
      }
      break;
    2759:	jmp    276c <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    275b:	mov    rax,QWORD PTR [rbp-0x50]
    275f:	mov    esi,0x1
    2764:	mov    rdi,rax
    2767:	call   21c3 <parser_advance>
  }

  return token;
    276c:	mov    rcx,QWORD PTR [rbp-0x48]
    2770:	mov    rax,QWORD PTR [rbp-0x20]
    2774:	mov    rdx,QWORD PTR [rbp-0x18]
    2778:	mov    QWORD PTR [rcx],rax
    277b:	mov    QWORD PTR [rcx+0x8],rdx
    277f:	mov    rax,QWORD PTR [rbp-0x10]
    2783:	mov    QWORD PTR [rcx+0x10],rax
}
    2787:	mov    rax,QWORD PTR [rbp-0x48]
    278b:	leave
    278c:	ret

000000000000278d <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    278d:	push   rbp
    278e:	mov    rbp,rsp
    2791:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    2794:	cmp    DWORD PTR [rbp-0x14],0x7
    2798:	je     27b2 <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    279a:	cmp    DWORD PTR [rbp-0x14],0x9
    279e:	je     27b2 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    27a0:	cmp    DWORD PTR [rbp-0x14],0xa
    27a4:	je     27b2 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    27a6:	cmp    DWORD PTR [rbp-0x14],0xb
    27aa:	je     27b2 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    27ac:	cmp    DWORD PTR [rbp-0x14],0x8
    27b0:	jne    27b9 <json_token_type_is_value_type+0x2c>
    27b2:	mov    eax,0x1
    27b7:	jmp    27be <json_token_type_is_value_type+0x31>
    27b9:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    27be:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    27c1:	mov    eax,DWORD PTR [rbp-0x4]
}
    27c4:	pop    rbp
    27c5:	ret

00000000000027c6 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    27c6:	push   rbp
    27c7:	mov    rbp,rsp
    27ca:	push   rbx
    27cb:	sub    rsp,0x88
    27d2:	mov    QWORD PTR [rbp-0x78],rdi
    27d6:	mov    QWORD PTR [rbp-0x80],rsi
    27da:	mov    QWORD PTR [rbp-0x90],rdx
    27e1:	mov    QWORD PTR [rbp-0x88],rcx
    27e8:	mov    rax,QWORD PTR fs:0x28
    27f1:	mov    QWORD PTR [rbp-0x18],rax
    27f5:	xor    eax,eax
  profile_begin_func();
    27f7:	lea    r8,[rip+0x2022]        # 4820 <__func__.4>
    27fe:	mov    r9d,0x11
    2804:	lea    rax,[rbp-0x50]
    2808:	mov    rsi,r8
    280b:	mov    rdx,r9
    280e:	mov    r8d,0x0
    2814:	mov    ecx,0x1
    2819:	mov    rdi,rax
    281c:	call   1f6c <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    2821:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2829:	mov    eax,DWORD PTR [rbp+0x10]
    282c:	cmp    eax,0x1
    282f:	jne    285b <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    2831:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    2838:	mov    edx,DWORD PTR [rbp-0x64]
    283b:	mov    rsi,QWORD PTR [rbp-0x80]
    283f:	mov    rax,QWORD PTR [rbp-0x78]
    2843:	mov    ecx,edx
    2845:	mov    edx,0x2
    284a:	mov    rdi,rax
    284d:	call   29ad <parse_json_children>
    2852:	mov    QWORD PTR [rbp-0x60],rax
    2856:	jmp    28e5 <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    285b:	mov    eax,DWORD PTR [rbp+0x10]
    285e:	cmp    eax,0x3
    2861:	jne    288a <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    2863:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    286a:	mov    edx,DWORD PTR [rbp-0x68]
    286d:	mov    rsi,QWORD PTR [rbp-0x80]
    2871:	mov    rax,QWORD PTR [rbp-0x78]
    2875:	mov    ecx,edx
    2877:	mov    edx,0x4
    287c:	mov    rdi,rax
    287f:	call   29ad <parse_json_children>
    2884:	mov    QWORD PTR [rbp-0x60],rax
    2888:	jmp    28e5 <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    288a:	mov    eax,DWORD PTR [rbp+0x10]
    288d:	mov    edi,eax
    288f:	call   278d <json_token_type_is_value_type>
    2894:	test   eax,eax
    2896:	jne    28e5 <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2898:	mov    eax,DWORD PTR [rbp+0x10]
    289b:	mov    eax,eax
    289d:	lea    rdx,[rax*8+0x0]
    28a5:	lea    rax,[rip+0x4834]        # 70e0 <JSON_Token_Type_strings>
    28ac:	mov    rcx,QWORD PTR [rdx+rax*1]
    28b0:	lea    rdx,[rip+0x1c69]        # 4520 <_IO_stdin_used+0x520>
    28b7:	lea    rax,[rip+0x1bbb]        # 4479 <_IO_stdin_used+0x479>
    28be:	push   QWORD PTR [rbp+0x20]
    28c1:	push   QWORD PTR [rbp+0x18]
    28c4:	mov    r8,rcx
    28c7:	mov    rcx,rdx
    28ca:	mov    edx,0x134
    28cf:	mov    rsi,rax
    28d2:	mov    edi,0x1
    28d7:	mov    eax,0x0
    28dc:	call   14a1 <log_message>
    28e1:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    28e5:	mov    rax,QWORD PTR [rbp-0x78]
    28e9:	mov    edx,0x8
    28ee:	mov    esi,0x30
    28f3:	mov    rdi,rax
    28f6:	call   17d3 <arena_alloc>
    28fb:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    28ff:	mov    rcx,QWORD PTR [rbp-0x58]
    2903:	mov    rax,QWORD PTR [rbp-0x90]
    290a:	mov    rdx,QWORD PTR [rbp-0x88]
    2911:	mov    QWORD PTR [rcx],rax
    2914:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    2918:	mov    rax,QWORD PTR [rbp-0x58]
    291c:	mov    rdx,QWORD PTR [rbp-0x60]
    2920:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    2924:	mov    rax,QWORD PTR [rbp-0x58]
    2928:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    2930:	mov    rcx,QWORD PTR [rbp-0x58]
    2934:	mov    rax,QWORD PTR [rbp+0x18]
    2938:	mov    rdx,QWORD PTR [rbp+0x20]
    293c:	mov    QWORD PTR [rcx+0x10],rax
    2940:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    2944:	sub    rsp,0x8
    2948:	sub    rsp,0x38
    294c:	mov    rax,rsp
    294f:	mov    rcx,QWORD PTR [rbp-0x50]
    2953:	mov    rbx,QWORD PTR [rbp-0x48]
    2957:	mov    QWORD PTR [rax],rcx
    295a:	mov    QWORD PTR [rax+0x8],rbx
    295e:	mov    rcx,QWORD PTR [rbp-0x40]
    2962:	mov    rbx,QWORD PTR [rbp-0x38]
    2966:	mov    QWORD PTR [rax+0x10],rcx
    296a:	mov    QWORD PTR [rax+0x18],rbx
    296e:	mov    rcx,QWORD PTR [rbp-0x30]
    2972:	mov    rbx,QWORD PTR [rbp-0x28]
    2976:	mov    QWORD PTR [rax+0x20],rcx
    297a:	mov    QWORD PTR [rax+0x28],rbx
    297e:	mov    rdx,QWORD PTR [rbp-0x20]
    2982:	mov    QWORD PTR [rax+0x30],rdx
    2986:	call   2056 <__profile_end_pass>
    298b:	add    rsp,0x40

  return result;
    298f:	mov    rax,QWORD PTR [rbp-0x58]
}
    2993:	mov    rdx,QWORD PTR [rbp-0x18]
    2997:	sub    rdx,QWORD PTR fs:0x28
    29a0:	je     29a7 <parse_json_object+0x1e1>
    29a2:	call   1060 <__stack_chk_fail@plt>
    29a7:	mov    rbx,QWORD PTR [rbp-0x8]
    29ab:	leave
    29ac:	ret

00000000000029ad <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    29ad:	push   rbp
    29ae:	mov    rbp,rsp
    29b1:	push   rbx
    29b2:	sub    rsp,0x108
    29b9:	mov    QWORD PTR [rbp-0xd8],rdi
    29c0:	mov    QWORD PTR [rbp-0xe0],rsi
    29c7:	mov    DWORD PTR [rbp-0xe4],edx
    29cd:	mov    DWORD PTR [rbp-0xe8],ecx
    29d3:	mov    rax,QWORD PTR fs:0x28
    29dc:	mov    QWORD PTR [rbp-0x18],rax
    29e0:	xor    eax,eax
  profile_begin_func();
    29e2:	lea    r8,[rip+0x1e57]        # 4840 <__func__.3>
    29e9:	mov    r9d,0x13
    29ef:	lea    rax,[rbp-0x50]
    29f3:	mov    rsi,r8
    29f6:	mov    rdx,r9
    29f9:	mov    r8d,0x0
    29ff:	mov    ecx,0x2
    2a04:	mov    rdi,rax
    2a07:	call   1f6c <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2a0c:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    2a17:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2a22:	jmp    2cfb <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2a27:	pxor   xmm0,xmm0
    2a2b:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2a32:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2a3a:	pxor   xmm0,xmm0
    2a3e:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2a45:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2a4a:	cmp    DWORD PTR [rbp-0xe8],0x0
    2a51:	je     2b5e <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2a57:	lea    rax,[rbp-0xb0]
    2a5e:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a65:	mov    rsi,rdx
    2a68:	mov    rdi,rax
    2a6b:	call   2294 <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2a70:	mov    eax,DWORD PTR [rbp-0xb0]
    2a76:	cmp    eax,0x7
    2a79:	jne    2afa <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2a7b:	lea    rax,[rbp-0x70]
    2a7f:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a86:	mov    rsi,rdx
    2a89:	mov    rdi,rax
    2a8c:	call   2294 <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2a91:	mov    eax,DWORD PTR [rbp-0x70]
    2a94:	cmp    eax,0x6
    2a97:	jne    2ab7 <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2a99:	lea    rax,[rbp-0x90]
    2aa0:	mov    rdx,QWORD PTR [rbp-0xe0]
    2aa7:	mov    rsi,rdx
    2aaa:	mov    rdi,rax
    2aad:	call   2294 <get_json_token>
    2ab2:	jmp    2b9e <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2ab7:	mov    rcx,QWORD PTR [rbp-0xa8]
    2abe:	mov    rax,QWORD PTR [rbp-0xa0]
    2ac5:	mov    esi,eax
    2ac7:	lea    rdx,[rip+0x1aa2]        # 4570 <_IO_stdin_used+0x570>
    2ace:	lea    rax,[rip+0x19a4]        # 4479 <_IO_stdin_used+0x479>
    2ad5:	mov    r9,rcx
    2ad8:	mov    r8d,esi
    2adb:	mov    rcx,rdx
    2ade:	mov    edx,0x15f
    2ae3:	mov    rsi,rax
    2ae6:	mov    edi,0x1
    2aeb:	mov    eax,0x0
    2af0:	call   14a1 <log_message>
    2af5:	jmp    2b9e <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2afa:	mov    rcx,QWORD PTR [rbp-0xa8]
    2b01:	mov    rax,QWORD PTR [rbp-0xa0]
    2b08:	mov    edi,eax
    2b0a:	mov    eax,DWORD PTR [rbp-0xb0]
    2b10:	mov    eax,eax
    2b12:	lea    rdx,[rax*8+0x0]
    2b1a:	lea    rax,[rip+0x45bf]        # 70e0 <JSON_Token_Type_strings>
    2b21:	mov    rsi,QWORD PTR [rdx+rax*1]
    2b25:	lea    rdx,[rip+0x1a64]        # 4590 <_IO_stdin_used+0x590>
    2b2c:	lea    rax,[rip+0x1946]        # 4479 <_IO_stdin_used+0x479>
    2b33:	sub    rsp,0x8
    2b37:	push   rcx
    2b38:	mov    r9d,edi
    2b3b:	mov    r8,rsi
    2b3e:	mov    rcx,rdx
    2b41:	mov    edx,0x164
    2b46:	mov    rsi,rax
    2b49:	mov    edi,0x1
    2b4e:	mov    eax,0x0
    2b53:	call   14a1 <log_message>
    2b58:	add    rsp,0x10
    2b5c:	jmp    2b9e <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2b5e:	lea    rax,[rbp-0x110]
    2b65:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b6c:	mov    rsi,rdx
    2b6f:	mov    rdi,rax
    2b72:	call   2294 <get_json_token>
    2b77:	mov    rax,QWORD PTR [rbp-0x110]
    2b7e:	mov    rdx,QWORD PTR [rbp-0x108]
    2b85:	mov    QWORD PTR [rbp-0x90],rax
    2b8c:	mov    QWORD PTR [rbp-0x88],rdx
    2b93:	mov    rax,QWORD PTR [rbp-0x100]
    2b9a:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2b9e:	mov    eax,DWORD PTR [rbp-0x90]
    2ba4:	cmp    DWORD PTR [rbp-0xe4],eax
    2baa:	je     2d14 <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2bb0:	mov    rax,QWORD PTR [rbp-0xa8]
    2bb7:	mov    rdx,QWORD PTR [rbp-0xa0]
    2bbe:	mov    r8,QWORD PTR [rbp-0xe0]
    2bc5:	mov    rdi,QWORD PTR [rbp-0xd8]
    2bcc:	sub    rsp,0x8
    2bd0:	sub    rsp,0x18
    2bd4:	mov    rsi,rsp
    2bd7:	mov    rcx,QWORD PTR [rbp-0x90]
    2bde:	mov    rbx,QWORD PTR [rbp-0x88]
    2be5:	mov    QWORD PTR [rsi],rcx
    2be8:	mov    QWORD PTR [rsi+0x8],rbx
    2bec:	mov    rcx,QWORD PTR [rbp-0x80]
    2bf0:	mov    QWORD PTR [rsi+0x10],rcx
    2bf4:	mov    rcx,rdx
    2bf7:	mov    rdx,rax
    2bfa:	mov    rsi,r8
    2bfd:	call   27c6 <parse_json_object>
    2c02:	add    rsp,0x20
    2c06:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2c0d:	cmp    QWORD PTR [rbp-0xb8],0x0
    2c15:	je     2c5f <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2c17:	cmp    QWORD PTR [rbp-0xc8],0x0
    2c1f:	jne    2c3f <parse_json_children+0x292>
      {
        first_child        = object;
    2c21:	mov    rax,QWORD PTR [rbp-0xb8]
    2c28:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2c2f:	mov    rax,QWORD PTR [rbp-0xb8]
    2c36:	mov    QWORD PTR [rbp-0xc0],rax
    2c3d:	jmp    2c5f <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2c3f:	mov    rax,QWORD PTR [rbp-0xc0]
    2c46:	mov    rdx,QWORD PTR [rbp-0xb8]
    2c4d:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2c51:	mov    rax,QWORD PTR [rbp-0xb8]
    2c58:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2c5f:	lea    rax,[rbp-0x70]
    2c63:	mov    rdx,QWORD PTR [rbp-0xe0]
    2c6a:	mov    rsi,rdx
    2c6d:	mov    rdi,rax
    2c70:	call   2294 <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2c75:	mov    eax,DWORD PTR [rbp-0x70]
    2c78:	cmp    DWORD PTR [rbp-0xe4],eax
    2c7e:	je     2d17 <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2c84:	mov    eax,DWORD PTR [rbp-0x70]
    2c87:	cmp    eax,0x5
    2c8a:	je     2cfb <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2c8c:	mov    r8,QWORD PTR [rbp-0x68]
    2c90:	mov    rax,QWORD PTR [rbp-0x60]
    2c94:	mov    r9d,eax
    2c97:	mov    eax,DWORD PTR [rbp-0x70]
    2c9a:	mov    eax,eax
    2c9c:	lea    rdx,[rax*8+0x0]
    2ca4:	lea    rax,[rip+0x4435]        # 70e0 <JSON_Token_Type_strings>
    2cab:	mov    r10,QWORD PTR [rdx+rax*1]
    2caf:	lea    rdi,[rip+0x1902]        # 45b8 <_IO_stdin_used+0x5b8>
    2cb6:	lea    rsi,[rip+0x17bc]        # 4479 <_IO_stdin_used+0x479>
    2cbd:	sub    rsp,0x18
    2cc1:	mov    rcx,rsp
    2cc4:	mov    rax,QWORD PTR [rbp-0x70]
    2cc8:	mov    rdx,QWORD PTR [rbp-0x68]
    2ccc:	mov    QWORD PTR [rcx],rax
    2ccf:	mov    QWORD PTR [rcx+0x8],rdx
    2cd3:	mov    rax,QWORD PTR [rbp-0x60]
    2cd7:	mov    QWORD PTR [rcx+0x10],rax
    2cdb:	push   r8
    2cdd:	mov    r8,r10
    2ce0:	mov    rcx,rdi
    2ce3:	mov    edx,0x18b
    2ce8:	mov    edi,0x1
    2ced:	mov    eax,0x0
    2cf2:	call   14a1 <log_message>
    2cf7:	add    rsp,0x20
  while (parser_incomplete(parser))
    2cfb:	mov    rax,QWORD PTR [rbp-0xe0]
    2d02:	mov    rdi,rax
    2d05:	call   21e9 <parser_incomplete>
    2d0a:	test   al,al
    2d0c:	jne    2a27 <parse_json_children+0x7a>
    2d12:	jmp    2d18 <parse_json_children+0x36b>
      break;
    2d14:	nop
    2d15:	jmp    2d18 <parse_json_children+0x36b>
      break;
    2d17:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2d18:	sub    rsp,0x8
    2d1c:	sub    rsp,0x38
    2d20:	mov    rax,rsp
    2d23:	mov    rcx,QWORD PTR [rbp-0x50]
    2d27:	mov    rbx,QWORD PTR [rbp-0x48]
    2d2b:	mov    QWORD PTR [rax],rcx
    2d2e:	mov    QWORD PTR [rax+0x8],rbx
    2d32:	mov    rcx,QWORD PTR [rbp-0x40]
    2d36:	mov    rbx,QWORD PTR [rbp-0x38]
    2d3a:	mov    QWORD PTR [rax+0x10],rcx
    2d3e:	mov    QWORD PTR [rax+0x18],rbx
    2d42:	mov    rcx,QWORD PTR [rbp-0x30]
    2d46:	mov    rbx,QWORD PTR [rbp-0x28]
    2d4a:	mov    QWORD PTR [rax+0x20],rcx
    2d4e:	mov    QWORD PTR [rax+0x28],rbx
    2d52:	mov    rdx,QWORD PTR [rbp-0x20]
    2d56:	mov    QWORD PTR [rax+0x30],rdx
    2d5a:	call   2056 <__profile_end_pass>
    2d5f:	add    rsp,0x40

  return first_child;
    2d63:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2d6a:	mov    rdx,QWORD PTR [rbp-0x18]
    2d6e:	sub    rdx,QWORD PTR fs:0x28
    2d77:	je     2d7e <parse_json_children+0x3d1>
    2d79:	call   1060 <__stack_chk_fail@plt>
    2d7e:	mov    rbx,QWORD PTR [rbp-0x8]
    2d82:	leave
    2d83:	ret

0000000000002d84 <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2d84:	push   rbp
    2d85:	mov    rbp,rsp
    2d88:	push   rbx
    2d89:	sub    rsp,0xb8
    2d90:	mov    QWORD PTR [rbp-0xa8],rdi
    2d97:	mov    rax,rsi
    2d9a:	mov    rsi,rdx
    2d9d:	mov    rax,rax
    2da0:	mov    edx,0x0
    2da5:	mov    rdx,rsi
    2da8:	mov    QWORD PTR [rbp-0xc0],rax
    2daf:	mov    QWORD PTR [rbp-0xb8],rdx
    2db6:	mov    rax,QWORD PTR fs:0x28
    2dbf:	mov    QWORD PTR [rbp-0x18],rax
    2dc3:	xor    eax,eax
  profile_begin_func();
    2dc5:	lea    rcx,[rip+0x1a8c]        # 4858 <__func__.2>
    2dcc:	mov    ebx,0xa
    2dd1:	lea    rax,[rbp-0x50]
    2dd5:	mov    rsi,rcx
    2dd8:	mov    rdx,rbx
    2ddb:	mov    r8d,0x0
    2de1:	mov    ecx,0x3
    2de6:	mov    rdi,rax
    2de9:	call   1f6c <__profile_begin_pass>

  JSON_Parser parser =
    2dee:	mov    rax,QWORD PTR [rbp-0xc0]
    2df5:	mov    rdx,QWORD PTR [rbp-0xb8]
    2dfc:	mov    QWORD PTR [rbp-0x90],rax
    2e03:	mov    QWORD PTR [rbp-0x88],rdx
    2e0a:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2e12:	lea    rax,[rbp-0x70]
    2e16:	lea    rdx,[rbp-0x90]
    2e1d:	mov    rsi,rdx
    2e20:	mov    rdi,rax
    2e23:	call   2294 <get_json_token>
    2e28:	mov    ecx,0x0
    2e2d:	mov    ebx,0x0
    2e32:	lea    r8,[rbp-0x90]
    2e39:	mov    rdi,QWORD PTR [rbp-0xa8]
    2e40:	sub    rsp,0x8
    2e44:	sub    rsp,0x18
    2e48:	mov    rsi,rsp
    2e4b:	mov    rax,QWORD PTR [rbp-0x70]
    2e4f:	mov    rdx,QWORD PTR [rbp-0x68]
    2e53:	mov    QWORD PTR [rsi],rax
    2e56:	mov    QWORD PTR [rsi+0x8],rdx
    2e5a:	mov    rax,QWORD PTR [rbp-0x60]
    2e5e:	mov    QWORD PTR [rsi+0x10],rax
    2e62:	mov    rdx,rcx
    2e65:	mov    rcx,rbx
    2e68:	mov    rsi,r8
    2e6b:	call   27c6 <parse_json_object>
    2e70:	add    rsp,0x20
    2e74:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2e7b:	sub    rsp,0x8
    2e7f:	sub    rsp,0x38
    2e83:	mov    rax,rsp
    2e86:	mov    rcx,QWORD PTR [rbp-0x50]
    2e8a:	mov    rbx,QWORD PTR [rbp-0x48]
    2e8e:	mov    QWORD PTR [rax],rcx
    2e91:	mov    QWORD PTR [rax+0x8],rbx
    2e95:	mov    rcx,QWORD PTR [rbp-0x40]
    2e99:	mov    rbx,QWORD PTR [rbp-0x38]
    2e9d:	mov    QWORD PTR [rax+0x10],rcx
    2ea1:	mov    QWORD PTR [rax+0x18],rbx
    2ea5:	mov    rcx,QWORD PTR [rbp-0x30]
    2ea9:	mov    rbx,QWORD PTR [rbp-0x28]
    2ead:	mov    QWORD PTR [rax+0x20],rcx
    2eb1:	mov    QWORD PTR [rax+0x28],rbx
    2eb5:	mov    rdx,QWORD PTR [rbp-0x20]
    2eb9:	mov    QWORD PTR [rax+0x30],rdx
    2ebd:	call   2056 <__profile_end_pass>
    2ec2:	add    rsp,0x40

  return outer;
    2ec6:	mov    rax,QWORD PTR [rbp-0x98]
}
    2ecd:	mov    rdx,QWORD PTR [rbp-0x18]
    2ed1:	sub    rdx,QWORD PTR fs:0x28
    2eda:	je     2ee1 <parse_json+0x15d>
    2edc:	call   1060 <__stack_chk_fail@plt>
    2ee1:	mov    rbx,QWORD PTR [rbp-0x8]
    2ee5:	leave
    2ee6:	ret

0000000000002ee7 <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2ee7:	push   rbp
    2ee8:	mov    rbp,rsp
    2eeb:	push   rbx
    2eec:	sub    rsp,0x78
    2ef0:	mov    QWORD PTR [rbp-0x68],rdi
    2ef4:	mov    rax,rsi
    2ef7:	mov    rsi,rdx
    2efa:	mov    rax,rax
    2efd:	mov    edx,0x0
    2f02:	mov    rdx,rsi
    2f05:	mov    QWORD PTR [rbp-0x80],rax
    2f09:	mov    QWORD PTR [rbp-0x78],rdx
    2f0d:	mov    rax,QWORD PTR fs:0x28
    2f16:	mov    QWORD PTR [rbp-0x18],rax
    2f1a:	xor    eax,eax
  profile_begin_func();
    2f1c:	lea    rcx,[rip+0x194d]        # 4870 <__func__.1>
    2f23:	mov    ebx,0x12
    2f28:	lea    rax,[rbp-0x50]
    2f2c:	mov    rsi,rcx
    2f2f:	mov    rdx,rbx
    2f32:	mov    r8d,0x0
    2f38:	mov    ecx,0x4
    2f3d:	mov    rdi,rax
    2f40:	call   1f6c <__profile_begin_pass>

  JSON_Object *result = NULL;
    2f45:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2f4d:	cmp    QWORD PTR [rbp-0x68],0x0
    2f52:	je     2fa1 <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f54:	mov    rax,QWORD PTR [rbp-0x68]
    2f58:	mov    rax,QWORD PTR [rax+0x20]
    2f5c:	mov    QWORD PTR [rbp-0x58],rax
    2f60:	jmp    2f9a <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2f62:	mov    rax,QWORD PTR [rbp-0x58]
    2f66:	mov    rdx,QWORD PTR [rax+0x8]
    2f6a:	mov    rax,QWORD PTR [rax]
    2f6d:	mov    rdi,QWORD PTR [rbp-0x80]
    2f71:	mov    rsi,QWORD PTR [rbp-0x78]
    2f75:	mov    rcx,rdx
    2f78:	mov    rdx,rax
    2f7b:	call   143f <strings_equal>
    2f80:	test   al,al
    2f82:	je     2f8e <lookup_json_object+0xa7>
      {
        result = cursor;
    2f84:	mov    rax,QWORD PTR [rbp-0x58]
    2f88:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2f8c:	jmp    2fa1 <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f8e:	mov    rax,QWORD PTR [rbp-0x58]
    2f92:	mov    rax,QWORD PTR [rax+0x28]
    2f96:	mov    QWORD PTR [rbp-0x58],rax
    2f9a:	cmp    QWORD PTR [rbp-0x58],0x0
    2f9f:	jne    2f62 <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2fa1:	sub    rsp,0x8
    2fa5:	sub    rsp,0x38
    2fa9:	mov    rax,rsp
    2fac:	mov    rcx,QWORD PTR [rbp-0x50]
    2fb0:	mov    rbx,QWORD PTR [rbp-0x48]
    2fb4:	mov    QWORD PTR [rax],rcx
    2fb7:	mov    QWORD PTR [rax+0x8],rbx
    2fbb:	mov    rcx,QWORD PTR [rbp-0x40]
    2fbf:	mov    rbx,QWORD PTR [rbp-0x38]
    2fc3:	mov    QWORD PTR [rax+0x10],rcx
    2fc7:	mov    QWORD PTR [rax+0x18],rbx
    2fcb:	mov    rcx,QWORD PTR [rbp-0x30]
    2fcf:	mov    rbx,QWORD PTR [rbp-0x28]
    2fd3:	mov    QWORD PTR [rax+0x20],rcx
    2fd7:	mov    QWORD PTR [rax+0x28],rbx
    2fdb:	mov    rdx,QWORD PTR [rbp-0x20]
    2fdf:	mov    QWORD PTR [rax+0x30],rdx
    2fe3:	call   2056 <__profile_end_pass>
    2fe8:	add    rsp,0x40

  return result;
    2fec:	mov    rax,QWORD PTR [rbp-0x60]
}
    2ff0:	mov    rdx,QWORD PTR [rbp-0x18]
    2ff4:	sub    rdx,QWORD PTR fs:0x28
    2ffd:	je     3004 <lookup_json_object+0x11d>
    2fff:	call   1060 <__stack_chk_fail@plt>
    3004:	mov    rbx,QWORD PTR [rbp-0x8]
    3008:	leave
    3009:	ret

000000000000300a <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    300a:	push   rbp
    300b:	mov    rbp,rsp
    300e:	sub    rsp,0x50
    3012:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    3016:	cmp    QWORD PTR [rbp-0x48],0x0
    301b:	jne    3042 <json_object_to_f64+0x38>
    301d:	lea    rdx,[rip+0x186c]        # 4890 <__PRETTY_FUNCTION__.0>
    3024:	lea    rsi,[rip+0x144e]        # 4479 <_IO_stdin_used+0x479>
    302b:	lea    rax,[rip+0x15c6]        # 45f8 <_IO_stdin_used+0x5f8>
    3032:	mov    rcx,rdx
    3035:	mov    edx,0x1c2
    303a:	mov    rdi,rax
    303d:	call   1090 <__assert_fail@plt>

  String val = object->value;
    3042:	mov    rax,QWORD PTR [rbp-0x48]
    3046:	mov    rdx,QWORD PTR [rax+0x18]
    304a:	mov    rax,QWORD PTR [rax+0x10]
    304e:	mov    QWORD PTR [rbp-0x10],rax
    3052:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    3056:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    305e:	movsd  xmm0,QWORD PTR [rip+0x185a]        # 48c0 <__PRETTY_FUNCTION__.0+0x30>
    3066:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    306b:	mov    rax,QWORD PTR [rbp-0x8]
    306f:	cmp    QWORD PTR [rbp-0x30],rax
    3073:	jae    3099 <json_object_to_f64+0x8f>
    3075:	mov    rdx,QWORD PTR [rbp-0x10]
    3079:	mov    rax,QWORD PTR [rbp-0x30]
    307d:	add    rax,rdx
    3080:	movzx  eax,BYTE PTR [rax]
    3083:	cmp    al,0x2d
    3085:	jne    3099 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    3087:	movsd  xmm0,QWORD PTR [rip+0x1839]        # 48c8 <__PRETTY_FUNCTION__.0+0x38>
    308f:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    3094:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    3099:	pxor   xmm0,xmm0
    309d:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    30a2:	jmp    30e9 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    30a4:	mov    rdx,QWORD PTR [rbp-0x10]
    30a8:	mov    rax,QWORD PTR [rbp-0x30]
    30ac:	add    rax,rdx
    30af:	movzx  eax,BYTE PTR [rax]
    30b2:	sub    eax,0x30
    30b5:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    30b8:	cmp    BYTE PTR [rbp-0x32],0x9
    30bc:	ja     30f5 <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    30be:	movsd  xmm1,QWORD PTR [rbp-0x20]
    30c3:	movsd  xmm0,QWORD PTR [rip+0x1805]        # 48d0 <__PRETTY_FUNCTION__.0+0x40>
    30cb:	mulsd  xmm1,xmm0
    30cf:	movzx  eax,BYTE PTR [rbp-0x32]
    30d3:	pxor   xmm0,xmm0
    30d7:	cvtsi2sd xmm0,eax
    30db:	addsd  xmm0,xmm1
    30df:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    30e4:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    30e9:	mov    rax,QWORD PTR [rbp-0x8]
    30ed:	cmp    QWORD PTR [rbp-0x30],rax
    30f1:	jb     30a4 <json_object_to_f64+0x9a>
    30f3:	jmp    30f6 <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    30f5:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    30f6:	mov    rax,QWORD PTR [rbp-0x8]
    30fa:	cmp    QWORD PTR [rbp-0x30],rax
    30fe:	jae    318b <json_object_to_f64+0x181>
    3104:	mov    rdx,QWORD PTR [rbp-0x10]
    3108:	mov    rax,QWORD PTR [rbp-0x30]
    310c:	add    rax,rdx
    310f:	movzx  eax,BYTE PTR [rax]
    3112:	cmp    al,0x2e
    3114:	jne    318b <json_object_to_f64+0x181>
  {
    at += 1;
    3116:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    311b:	movsd  xmm0,QWORD PTR [rip+0x17b5]        # 48d8 <__PRETTY_FUNCTION__.0+0x48>
    3123:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    3128:	jmp    317e <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    312a:	mov    rdx,QWORD PTR [rbp-0x10]
    312e:	mov    rax,QWORD PTR [rbp-0x30]
    3132:	add    rax,rdx
    3135:	movzx  eax,BYTE PTR [rax]
    3138:	sub    eax,0x30
    313b:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    313e:	cmp    BYTE PTR [rbp-0x31],0x9
    3142:	ja     318a <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    3144:	movzx  eax,BYTE PTR [rbp-0x31]
    3148:	pxor   xmm0,xmm0
    314c:	cvtsi2sd xmm0,eax
    3150:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    3155:	movsd  xmm1,QWORD PTR [rbp-0x20]
    315a:	addsd  xmm0,xmm1
    315e:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    3163:	movsd  xmm1,QWORD PTR [rbp-0x18]
    3168:	movsd  xmm0,QWORD PTR [rip+0x1768]        # 48d8 <__PRETTY_FUNCTION__.0+0x48>
    3170:	mulsd  xmm0,xmm1
    3174:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3179:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    317e:	mov    rax,QWORD PTR [rbp-0x8]
    3182:	cmp    QWORD PTR [rbp-0x30],rax
    3186:	jb     312a <json_object_to_f64+0x120>
    3188:	jmp    318b <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    318a:	nop
      }
    }
  }

  return sign * result;
    318b:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3190:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    3195:	leave
    3196:	ret

0000000000003197 <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    3197:	push   rbp
    3198:	mov    rbp,rsp
    319b:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    31a0:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31a5:	movsd  xmm1,QWORD PTR [rip+0x1733]        # 48e0 <__PRETTY_FUNCTION__.0+0x50>
    31ad:	divsd  xmm0,xmm1
}
    31b1:	pop    rbp
    31b2:	ret

00000000000031b3 <square>:

static
f64 square(f64 x)
{
    31b3:	push   rbp
    31b4:	mov    rbp,rsp
    31b7:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    31bc:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31c1:	mulsd  xmm0,xmm0
}
    31c5:	pop    rbp
    31c6:	ret

00000000000031c7 <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    31c7:	push   rbp
    31c8:	mov    rbp,rsp
    31cb:	sub    rsp,0x90
    31d2:	movsd  QWORD PTR [rbp-0x58],xmm0
    31d7:	movsd  QWORD PTR [rbp-0x60],xmm1
    31dc:	movsd  QWORD PTR [rbp-0x68],xmm2
    31e1:	movsd  QWORD PTR [rbp-0x70],xmm3
    31e6:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    31eb:	movsd  xmm0,QWORD PTR [rbp-0x60]
    31f0:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    31f5:	movsd  xmm0,QWORD PTR [rbp-0x70]
    31fa:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    31ff:	movsd  xmm0,QWORD PTR [rbp-0x58]
    3204:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    3209:	movsd  xmm0,QWORD PTR [rbp-0x68]
    320e:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    3213:	movsd  xmm0,QWORD PTR [rbp-0x40]
    3218:	subsd  xmm0,QWORD PTR [rbp-0x48]
    321d:	movq   rax,xmm0
    3222:	movq   xmm0,rax
    3227:	call   3197 <to_radians>
    322c:	movq   rax,xmm0
    3231:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    3235:	movsd  xmm0,QWORD PTR [rbp-0x30]
    323a:	subsd  xmm0,QWORD PTR [rbp-0x38]
    323f:	movq   rax,xmm0
    3244:	movq   xmm0,rax
    3249:	call   3197 <to_radians>
    324e:	movq   rax,xmm0
    3253:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    3257:	mov    rax,QWORD PTR [rbp-0x48]
    325b:	movq   xmm0,rax
    3260:	call   3197 <to_radians>
    3265:	movq   rax,xmm0
    326a:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    326e:	mov    rax,QWORD PTR [rbp-0x40]
    3272:	movq   xmm0,rax
    3277:	call   3197 <to_radians>
    327c:	movq   rax,xmm0
    3281:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    3285:	movsd  xmm0,QWORD PTR [rbp-0x28]
    328a:	movsd  xmm1,QWORD PTR [rip+0x1656]        # 48e8 <__PRETTY_FUNCTION__.0+0x58>
    3292:	divsd  xmm0,xmm1
    3296:	movq   rax,xmm0
    329b:	movq   xmm0,rax
    32a0:	call   1130 <sin@plt>
    32a5:	movq   rax,xmm0
    32aa:	movq   xmm0,rax
    32af:	call   31b3 <square>
    32b4:	movsd  QWORD PTR [rbp-0x80],xmm0
    32b9:	mov    rax,QWORD PTR [rbp-0x48]
    32bd:	movq   xmm0,rax
    32c2:	call   10b0 <cos@plt>
    32c7:	movsd  QWORD PTR [rbp-0x88],xmm0
    32cf:	mov    rax,QWORD PTR [rbp-0x40]
    32d3:	movq   xmm0,rax
    32d8:	call   10b0 <cos@plt>
    32dd:	movapd xmm5,xmm0
    32e1:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    32e9:	movsd  QWORD PTR [rbp-0x88],xmm5
    32f1:	movsd  xmm0,QWORD PTR [rbp-0x20]
    32f6:	movsd  xmm1,QWORD PTR [rip+0x15ea]        # 48e8 <__PRETTY_FUNCTION__.0+0x58>
    32fe:	movapd xmm6,xmm0
    3302:	divsd  xmm6,xmm1
    3306:	movq   rax,xmm6
    330b:	movq   xmm0,rax
    3310:	call   1130 <sin@plt>
    3315:	movq   rax,xmm0
    331a:	movq   xmm0,rax
    331f:	call   31b3 <square>
    3324:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    332c:	addsd  xmm0,QWORD PTR [rbp-0x80]
    3331:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    3336:	mov    rax,QWORD PTR [rbp-0x18]
    333a:	movq   xmm0,rax
    333f:	call   1160 <sqrt@plt>
    3344:	movq   rax,xmm0
    3349:	movq   xmm0,rax
    334e:	call   1140 <asin@plt>
    3353:	addsd  xmm0,xmm0
    3357:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    335c:	movsd  xmm0,QWORD PTR [rbp-0x78]
    3361:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    3366:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    336b:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    3370:	leave
    3371:	ret

0000000000003372 <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    3372:	push   rbp
    3373:	mov    rbp,rsp
    3376:	movsd  QWORD PTR [rbp-0x18],xmm0
    337b:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    3380:	movsd  xmm0,QWORD PTR [rip+0x1568]        # 48f0 <__PRETTY_FUNCTION__.0+0x60>
    3388:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    338d:	movsd  xmm0,QWORD PTR [rbp-0x18]
    3392:	movq   xmm1,QWORD PTR [rip+0x1566]        # 4900 <__PRETTY_FUNCTION__.0+0x70>
    339a:	andpd  xmm0,xmm1
    339e:	movsd  xmm1,QWORD PTR [rbp-0x20]
    33a3:	movq   xmm2,QWORD PTR [rip+0x1555]        # 4900 <__PRETTY_FUNCTION__.0+0x70>
    33ab:	andpd  xmm2,xmm1
    33af:	movapd xmm1,xmm0
    33b3:	subsd  xmm1,xmm2
    33b7:	movsd  xmm0,QWORD PTR [rbp-0x8]
    33bc:	comisd xmm0,xmm1
    33c0:	setae  al
    33c3:	movzx  eax,al
}
    33c6:	pop    rbp
    33c7:	ret

00000000000033c8 <main>:

int main(int args_count, char **args)
{
    33c8:	push   rbp
    33c9:	mov    rbp,rsp
    33cc:	push   r15
    33ce:	push   r14
    33d0:	push   r13
    33d2:	push   r12
    33d4:	push   rbx
    33d5:	sub    rsp,0x2d8
    33dc:	mov    DWORD PTR [rbp-0x244],edi
    33e2:	mov    QWORD PTR [rbp-0x250],rsi
    33e9:	mov    rax,QWORD PTR fs:0x28
    33f2:	mov    QWORD PTR [rbp-0x38],rax
    33f6:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    33f8:	cmp    DWORD PTR [rbp-0x244],0x3
    33ff:	je     342c <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    3401:	mov    rax,QWORD PTR [rbp-0x250]
    3408:	mov    rax,QWORD PTR [rax]
    340b:	lea    rdx,[rip+0x121e]        # 4630 <_IO_stdin_used+0x630>
    3412:	mov    rsi,rax
    3415:	mov    rdi,rdx
    3418:	mov    eax,0x0
    341d:	call   1070 <printf@plt>
    return 1;
    3422:	mov    eax,0x1
    3427:	jmp    3ee0 <main+0xb18>
  }

  begin_profiling();
    342c:	call   1b3d <begin_profiling>

  Arena arena = {0};
    3431:	pxor   xmm0,xmm0
    3435:	movaps XMMWORD PTR [rbp-0x190],xmm0
    343c:	movaps XMMWORD PTR [rbp-0x180],xmm0
  arena = arena_make(GB(4));
    3443:	lea    rdx,[rbp-0x270]
    344a:	movabs rax,0x100000000
    3454:	mov    rsi,rax
    3457:	mov    rdi,rdx
    345a:	call   1632 <arena_make>
    345f:	mov    rax,QWORD PTR [rbp-0x270]
    3466:	mov    rdx,QWORD PTR [rbp-0x268]
    346d:	mov    QWORD PTR [rbp-0x190],rax
    3474:	mov    QWORD PTR [rbp-0x188],rdx
    347b:	mov    rax,QWORD PTR [rbp-0x260]
    3482:	mov    rdx,QWORD PTR [rbp-0x258]
    3489:	mov    QWORD PTR [rbp-0x180],rax
    3490:	mov    QWORD PTR [rbp-0x178],rdx

  String source = {0};
    3497:	mov    QWORD PTR [rbp-0x1a0],0x0
    34a2:	mov    QWORD PTR [rbp-0x198],0x0
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    34ad:	mov    rax,QWORD PTR [rbp-0x250]
    34b4:	add    rax,0x8
    34b8:	mov    rax,QWORD PTR [rax]
    34bb:	mov    rdi,rax
    34be:	call   1303 <file_size>
    34c3:	mov    rcx,rax
    34c6:	lea    r12,[rip+0x118f]        # 465c <_IO_stdin_used+0x65c>
    34cd:	mov    r13d,0x4
    34d3:	lea    rdi,[rbp-0x170]
    34da:	mov    rdx,r12
    34dd:	mov    rax,r13
    34e0:	mov    r8,rcx
    34e3:	mov    ecx,0x5
    34e8:	mov    rsi,rdx
    34eb:	mov    rdx,rax
    34ee:	call   1f6c <__profile_begin_pass>
    34f3:	mov    QWORD PTR [rbp-0x230],0x0
    34fe:	jmp    3599 <main+0x1d1>
  {
    source = read_file_to_arena(&arena, args[1]);
    3503:	mov    rax,QWORD PTR [rbp-0x250]
    350a:	add    rax,0x8
    350e:	mov    rdx,QWORD PTR [rax]
    3511:	lea    rax,[rbp-0x190]
    3518:	mov    rsi,rdx
    351b:	mov    rdi,rax
    351e:	call   1357 <read_file_to_arena>
    3523:	mov    QWORD PTR [rbp-0x1a0],rax
    352a:	mov    QWORD PTR [rbp-0x198],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    3531:	add    QWORD PTR [rbp-0x230],0x1
    3539:	sub    rsp,0x8
    353d:	sub    rsp,0x38
    3541:	mov    rcx,rsp
    3544:	mov    rax,QWORD PTR [rbp-0x170]
    354b:	mov    rdx,QWORD PTR [rbp-0x168]
    3552:	mov    QWORD PTR [rcx],rax
    3555:	mov    QWORD PTR [rcx+0x8],rdx
    3559:	mov    rax,QWORD PTR [rbp-0x160]
    3560:	mov    rdx,QWORD PTR [rbp-0x158]
    3567:	mov    QWORD PTR [rcx+0x10],rax
    356b:	mov    QWORD PTR [rcx+0x18],rdx
    356f:	mov    rax,QWORD PTR [rbp-0x150]
    3576:	mov    rdx,QWORD PTR [rbp-0x148]
    357d:	mov    QWORD PTR [rcx+0x20],rax
    3581:	mov    QWORD PTR [rcx+0x28],rdx
    3585:	mov    rax,QWORD PTR [rbp-0x140]
    358c:	mov    QWORD PTR [rcx+0x30],rax
    3590:	call   2056 <__profile_end_pass>
    3595:	add    rsp,0x40
    3599:	cmp    QWORD PTR [rbp-0x230],0x0
    35a1:	je     3503 <main+0x13b>
  }

  Haversine_Pair *pairs = NULL;
    35a7:	mov    QWORD PTR [rbp-0x228],0x0
  i32 pair_count = 0;
    35b2:	mov    DWORD PTR [rbp-0x238],0x0
  usize max_pairs = 0;
    35bc:	mov    QWORD PTR [rbp-0x220],0x0
  PROFILE_SCOPE("haversine alloc")
    35c7:	lea    r14,[rip+0x1093]        # 4661 <_IO_stdin_used+0x661>
    35ce:	mov    r15d,0xf
    35d4:	lea    rdi,[rbp-0x130]
    35db:	mov    rdx,r14
    35de:	mov    rax,r15
    35e1:	mov    r8d,0x0
    35e7:	mov    ecx,0x6
    35ec:	mov    rsi,rdx
    35ef:	mov    rdx,rax
    35f2:	call   1f6c <__profile_begin_pass>
    35f7:	mov    QWORD PTR [rbp-0x218],0x0
    3602:	jmp    36ca <main+0x302>
  {
    usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    3607:	mov    QWORD PTR [rbp-0x1a8],0x18
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    3612:	mov    rax,QWORD PTR [rbp-0x198]
    3619:	mov    edx,0x0
    361e:	div    QWORD PTR [rbp-0x1a8]
    3625:	mov    QWORD PTR [rbp-0x220],rax

    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    362c:	mov    rax,QWORD PTR [rbp-0x220]
    3633:	shl    rax,0x5
    3637:	mov    rcx,rax
    363a:	lea    rax,[rbp-0x190]
    3641:	mov    edx,0x8
    3646:	mov    rsi,rcx
    3649:	mov    rdi,rax
    364c:	call   17d3 <arena_alloc>
    3651:	mov    QWORD PTR [rbp-0x228],rax
    pair_count = 0;
    3658:	mov    DWORD PTR [rbp-0x238],0x0
  PROFILE_SCOPE("haversine alloc")
    3662:	add    QWORD PTR [rbp-0x218],0x1
    366a:	sub    rsp,0x8
    366e:	sub    rsp,0x38
    3672:	mov    rcx,rsp
    3675:	mov    rax,QWORD PTR [rbp-0x130]
    367c:	mov    rdx,QWORD PTR [rbp-0x128]
    3683:	mov    QWORD PTR [rcx],rax
    3686:	mov    QWORD PTR [rcx+0x8],rdx
    368a:	mov    rax,QWORD PTR [rbp-0x120]
    3691:	mov    rdx,QWORD PTR [rbp-0x118]
    3698:	mov    QWORD PTR [rcx+0x10],rax
    369c:	mov    QWORD PTR [rcx+0x18],rdx
    36a0:	mov    rax,QWORD PTR [rbp-0x110]
    36a7:	mov    rdx,QWORD PTR [rbp-0x108]
    36ae:	mov    QWORD PTR [rcx+0x20],rax
    36b2:	mov    QWORD PTR [rcx+0x28],rdx
    36b6:	mov    rax,QWORD PTR [rbp-0x100]
    36bd:	mov    QWORD PTR [rcx+0x30],rax
    36c1:	call   2056 <__profile_end_pass>
    36c6:	add    rsp,0x40
    36ca:	cmp    QWORD PTR [rbp-0x218],0x0
    36d2:	je     3607 <main+0x23f>
  }

  JSON_Object *root = NULL;
    36d8:	mov    QWORD PTR [rbp-0x1d8],0x0
  root = parse_json(&arena, source);
    36e3:	mov    rcx,QWORD PTR [rbp-0x1a0]
    36ea:	mov    rdx,QWORD PTR [rbp-0x198]
    36f1:	lea    rax,[rbp-0x190]
    36f8:	mov    rsi,rcx
    36fb:	mov    rdi,rax
    36fe:	call   2d84 <parse_json>
    3703:	mov    QWORD PTR [rbp-0x1d8],rax

  f64 haversine_sum = 0.0;
    370a:	pxor   xmm0,xmm0
    370e:	movsd  QWORD PTR [rbp-0x1d0],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    3716:	lea    rax,[rip+0xf54]        # 4671 <_IO_stdin_used+0x671>
    371d:	mov    QWORD PTR [rbp-0x280],rax
    3724:	mov    QWORD PTR [rbp-0x278],0x5
    372f:	mov    rax,QWORD PTR [rbp-0x280]
    3736:	mov    rdx,QWORD PTR [rbp-0x278]
    373d:	mov    rcx,rax
    3740:	mov    rax,QWORD PTR [rbp-0x1d8]
    3747:	mov    rsi,rcx
    374a:	mov    rdi,rax
    374d:	call   2ee7 <lookup_json_object>
    3752:	mov    QWORD PTR [rbp-0x1c8],rax
  if (pairs)
    3759:	cmp    QWORD PTR [rbp-0x228],0x0
    3761:	je     39f6 <main+0x62e>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    3767:	mov    rax,QWORD PTR [rbp-0x1c8]
    376e:	mov    rax,QWORD PTR [rax+0x20]
    3772:	mov    QWORD PTR [rbp-0x210],rax
    3779:	jmp    39d7 <main+0x60f>
    {
      PROFILE_SCOPE("child convert")
    377e:	lea    rax,[rip+0xef2]        # 4677 <_IO_stdin_used+0x677>
    3785:	mov    QWORD PTR [rbp-0x2c0],rax
    378c:	mov    QWORD PTR [rbp-0x2b8],0xd
    3797:	lea    rdi,[rbp-0x70]
    379b:	mov    rbx,QWORD PTR [rbp-0x2c0]
    37a2:	mov    rsi,QWORD PTR [rbp-0x2b8]
    37a9:	mov    rdx,rbx
    37ac:	mov    rax,rsi
    37af:	mov    r8d,0x0
    37b5:	mov    ecx,0x7
    37ba:	mov    rsi,rdx
    37bd:	mov    rdx,rax
    37c0:	call   1f6c <__profile_begin_pass>
    37c5:	mov    QWORD PTR [rbp-0x208],0x0
    37d0:	jmp    39b7 <main+0x5ef>
      {
        Haversine_Pair pair =
        {
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    37d5:	lea    rax,[rip+0xea9]        # 4685 <_IO_stdin_used+0x685>
    37dc:	mov    QWORD PTR [rbp-0x2d0],rax
    37e3:	mov    QWORD PTR [rbp-0x2c8],0x2
    37ee:	mov    rbx,QWORD PTR [rbp-0x2d0]
    37f5:	mov    rsi,QWORD PTR [rbp-0x2c8]
    37fc:	mov    rax,rbx
    37ff:	mov    rdx,rsi
    3802:	mov    rcx,QWORD PTR [rbp-0x210]
    3809:	mov    rsi,rax
    380c:	mov    rdi,rcx
    380f:	call   2ee7 <lookup_json_object>
    3814:	mov    rdi,rax
    3817:	call   300a <json_object_to_f64>
    381c:	movq   rax,xmm0
        Haversine_Pair pair =
    3821:	mov    QWORD PTR [rbp-0xb0],rax
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    3828:	lea    rax,[rip+0xe59]        # 4688 <_IO_stdin_used+0x688>
    382f:	mov    QWORD PTR [rbp-0x2e0],rax
    3836:	mov    QWORD PTR [rbp-0x2d8],0x2
    3841:	mov    rax,QWORD PTR [rbp-0x2e0]
    3848:	mov    rdx,QWORD PTR [rbp-0x2d8]
    384f:	mov    rcx,rax
    3852:	mov    rax,QWORD PTR [rbp-0x210]
    3859:	mov    rsi,rcx
    385c:	mov    rdi,rax
    385f:	call   2ee7 <lookup_json_object>
    3864:	mov    rdi,rax
    3867:	call   300a <json_object_to_f64>
    386c:	movq   rax,xmm0
        Haversine_Pair pair =
    3871:	mov    QWORD PTR [rbp-0xa8],rax
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    3878:	lea    rax,[rip+0xe0c]        # 468b <_IO_stdin_used+0x68b>
    387f:	mov    QWORD PTR [rbp-0x2f0],rax
    3886:	mov    QWORD PTR [rbp-0x2e8],0x2
    3891:	mov    rax,QWORD PTR [rbp-0x2f0]
    3898:	mov    rdx,QWORD PTR [rbp-0x2e8]
    389f:	mov    rcx,rax
    38a2:	mov    rax,QWORD PTR [rbp-0x210]
    38a9:	mov    rsi,rcx
    38ac:	mov    rdi,rax
    38af:	call   2ee7 <lookup_json_object>
    38b4:	mov    rdi,rax
    38b7:	call   300a <json_object_to_f64>
    38bc:	movq   rax,xmm0
        Haversine_Pair pair =
    38c1:	mov    QWORD PTR [rbp-0xa0],rax
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    38c8:	lea    rax,[rip+0xdbf]        # 468e <_IO_stdin_used+0x68e>
    38cf:	mov    QWORD PTR [rbp-0x300],rax
    38d6:	mov    QWORD PTR [rbp-0x2f8],0x2
    38e1:	mov    rax,QWORD PTR [rbp-0x300]
    38e8:	mov    rdx,QWORD PTR [rbp-0x2f8]
    38ef:	mov    rcx,rax
    38f2:	mov    rax,QWORD PTR [rbp-0x210]
    38f9:	mov    rsi,rcx
    38fc:	mov    rdi,rax
    38ff:	call   2ee7 <lookup_json_object>
    3904:	mov    rdi,rax
    3907:	call   300a <json_object_to_f64>
    390c:	movq   rax,xmm0
        Haversine_Pair pair =
    3911:	mov    QWORD PTR [rbp-0x98],rax
        };

        pairs[pair_count] = pair;
    3918:	mov    eax,DWORD PTR [rbp-0x238]
    391e:	cdqe
    3920:	shl    rax,0x5
    3924:	mov    rdx,rax
    3927:	mov    rax,QWORD PTR [rbp-0x228]
    392e:	lea    rcx,[rdx+rax*1]
    3932:	mov    rax,QWORD PTR [rbp-0xb0]
    3939:	mov    rdx,QWORD PTR [rbp-0xa8]
    3940:	mov    QWORD PTR [rcx],rax
    3943:	mov    QWORD PTR [rcx+0x8],rdx
    3947:	mov    rax,QWORD PTR [rbp-0xa0]
    394e:	mov    rdx,QWORD PTR [rbp-0x98]
    3955:	mov    QWORD PTR [rcx+0x10],rax
    3959:	mov    QWORD PTR [rcx+0x18],rdx
        pair_count += 1;
    395d:	add    DWORD PTR [rbp-0x238],0x1
      PROFILE_SCOPE("child convert")
    3964:	add    QWORD PTR [rbp-0x208],0x1
    396c:	sub    rsp,0x8
    3970:	sub    rsp,0x38
    3974:	mov    rcx,rsp
    3977:	mov    rax,QWORD PTR [rbp-0x70]
    397b:	mov    rdx,QWORD PTR [rbp-0x68]
    397f:	mov    QWORD PTR [rcx],rax
    3982:	mov    QWORD PTR [rcx+0x8],rdx
    3986:	mov    rax,QWORD PTR [rbp-0x60]
    398a:	mov    rdx,QWORD PTR [rbp-0x58]
    398e:	mov    QWORD PTR [rcx+0x10],rax
    3992:	mov    QWORD PTR [rcx+0x18],rdx
    3996:	mov    rax,QWORD PTR [rbp-0x50]
    399a:	mov    rdx,QWORD PTR [rbp-0x48]
    399e:	mov    QWORD PTR [rcx+0x20],rax
    39a2:	mov    QWORD PTR [rcx+0x28],rdx
    39a6:	mov    rax,QWORD PTR [rbp-0x40]
    39aa:	mov    QWORD PTR [rcx+0x30],rax
    39ae:	call   2056 <__profile_end_pass>
    39b3:	add    rsp,0x40
    39b7:	cmp    QWORD PTR [rbp-0x208],0x0
    39bf:	je     37d5 <main+0x40d>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    39c5:	mov    rax,QWORD PTR [rbp-0x210]
    39cc:	mov    rax,QWORD PTR [rax+0x28]
    39d0:	mov    QWORD PTR [rbp-0x210],rax
    39d7:	cmp    QWORD PTR [rbp-0x210],0x0
    39df:	je     39f6 <main+0x62e>
    39e1:	mov    eax,DWORD PTR [rbp-0x238]
    39e7:	cdqe
    39e9:	cmp    rax,QWORD PTR [rbp-0x220]
    39f0:	jb     377e <main+0x3b6>
      }
    }
  }

  f64 sum = 0.0;
    39f6:	pxor   xmm0,xmm0
    39fa:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3a02:	lea    rax,[rip+0xc88]        # 4691 <_IO_stdin_used+0x691>
    3a09:	mov    QWORD PTR [rbp-0x290],rax
    3a10:	mov    QWORD PTR [rbp-0x288],0x3
    3a1b:	lea    rax,[rbp-0xf0]
    3a22:	mov    rcx,QWORD PTR [rbp-0x290]
    3a29:	mov    rbx,QWORD PTR [rbp-0x288]
    3a30:	mov    rsi,rcx
    3a33:	mov    rdx,rbx
    3a36:	mov    r8d,0x0
    3a3c:	mov    ecx,0x8
    3a41:	mov    rdi,rax
    3a44:	call   1f6c <__profile_begin_pass>
    3a49:	mov    QWORD PTR [rbp-0x1f8],0x0
    3a54:	jmp    3bd6 <main+0x80e>
  {
    for (usize i = 0; i < pair_count; i++)
    3a59:	mov    QWORD PTR [rbp-0x1f0],0x0
    3a64:	jmp    3b39 <main+0x771>
    {
      f64 earth_radius = 6372.8;
    3a69:	movsd  xmm0,QWORD PTR [rip+0xe9f]        # 4910 <__PRETTY_FUNCTION__.0+0x80>
    3a71:	movsd  QWORD PTR [rbp-0x1b8],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    3a79:	mov    rax,QWORD PTR [rbp-0x1f0]
    3a80:	shl    rax,0x5
    3a84:	mov    rdx,rax
    3a87:	mov    rax,QWORD PTR [rbp-0x228]
    3a8e:	add    rax,rdx
    3a91:	movsd  xmm2,QWORD PTR [rax+0x18]
    3a96:	mov    rax,QWORD PTR [rbp-0x1f0]
    3a9d:	shl    rax,0x5
    3aa1:	mov    rdx,rax
    3aa4:	mov    rax,QWORD PTR [rbp-0x228]
    3aab:	add    rax,rdx
    3aae:	movsd  xmm1,QWORD PTR [rax+0x10]
    3ab3:	mov    rax,QWORD PTR [rbp-0x1f0]
    3aba:	shl    rax,0x5
    3abe:	mov    rdx,rax
    3ac1:	mov    rax,QWORD PTR [rbp-0x228]
    3ac8:	add    rax,rdx
    3acb:	movsd  xmm0,QWORD PTR [rax+0x8]
    3ad0:	mov    rax,QWORD PTR [rbp-0x1f0]
    3ad7:	shl    rax,0x5
    3adb:	mov    rdx,rax
    3ade:	mov    rax,QWORD PTR [rbp-0x228]
    3ae5:	add    rax,rdx
    3ae8:	mov    rax,QWORD PTR [rax]
    3aeb:	movsd  xmm3,QWORD PTR [rbp-0x1b8]
    3af3:	movapd xmm4,xmm3
    3af7:	movapd xmm3,xmm2
    3afb:	movapd xmm2,xmm1
    3aff:	movapd xmm1,xmm0
    3b03:	movq   xmm0,rax
    3b08:	call   31c7 <reference_haversine>
    3b0d:	movq   rax,xmm0
    3b12:	mov    QWORD PTR [rbp-0x1b0],rax
      sum += result;
    3b19:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b21:	addsd  xmm0,QWORD PTR [rbp-0x1b0]
    3b29:	movsd  QWORD PTR [rbp-0x200],xmm0
    for (usize i = 0; i < pair_count; i++)
    3b31:	add    QWORD PTR [rbp-0x1f0],0x1
    3b39:	mov    eax,DWORD PTR [rbp-0x238]
    3b3f:	cdqe
    3b41:	cmp    QWORD PTR [rbp-0x1f0],rax
    3b48:	jb     3a69 <main+0x6a1>
    }
    sum /= pair_count;
    3b4e:	pxor   xmm1,xmm1
    3b52:	cvtsi2sd xmm1,DWORD PTR [rbp-0x238]
    3b5a:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b62:	divsd  xmm0,xmm1
    3b66:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3b6e:	add    QWORD PTR [rbp-0x1f8],0x1
    3b76:	sub    rsp,0x8
    3b7a:	sub    rsp,0x38
    3b7e:	mov    rax,rsp
    3b81:	mov    rcx,QWORD PTR [rbp-0xf0]
    3b88:	mov    rbx,QWORD PTR [rbp-0xe8]
    3b8f:	mov    QWORD PTR [rax],rcx
    3b92:	mov    QWORD PTR [rax+0x8],rbx
    3b96:	mov    rcx,QWORD PTR [rbp-0xe0]
    3b9d:	mov    rbx,QWORD PTR [rbp-0xd8]
    3ba4:	mov    QWORD PTR [rax+0x10],rcx
    3ba8:	mov    QWORD PTR [rax+0x18],rbx
    3bac:	mov    rcx,QWORD PTR [rbp-0xd0]
    3bb3:	mov    rbx,QWORD PTR [rbp-0xc8]
    3bba:	mov    QWORD PTR [rax+0x20],rcx
    3bbe:	mov    QWORD PTR [rax+0x28],rbx
    3bc2:	mov    rdx,QWORD PTR [rbp-0xc0]
    3bc9:	mov    QWORD PTR [rax+0x30],rdx
    3bcd:	call   2056 <__profile_end_pass>
    3bd2:	add    rsp,0x40
    3bd6:	cmp    QWORD PTR [rbp-0x1f8],0x0
    3bde:	je     3a59 <main+0x691>
  }

  PROFILE_SCOPE("check")
    3be4:	lea    rax,[rip+0xaaa]        # 4695 <_IO_stdin_used+0x695>
    3beb:	mov    QWORD PTR [rbp-0x2a0],rax
    3bf2:	mov    QWORD PTR [rbp-0x298],0x5
    3bfd:	lea    rax,[rbp-0xb0]
    3c04:	mov    rcx,QWORD PTR [rbp-0x2a0]
    3c0b:	mov    rbx,QWORD PTR [rbp-0x298]
    3c12:	mov    rsi,rcx
    3c15:	mov    rdx,rbx
    3c18:	mov    r8d,0x0
    3c1e:	mov    ecx,0x9
    3c23:	mov    rdi,rax
    3c26:	call   1f6c <__profile_begin_pass>
    3c2b:	mov    QWORD PTR [rbp-0x1e8],0x0
    3c36:	jmp    3e0b <main+0xa43>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3c3b:	mov    rax,QWORD PTR [rbp-0x250]
    3c42:	add    rax,0x10
    3c46:	mov    rdx,QWORD PTR [rax]
    3c49:	lea    rax,[rbp-0x190]
    3c50:	mov    rsi,rdx
    3c53:	mov    rdi,rax
    3c56:	call   1357 <read_file_to_arena>
    3c5b:	mov    QWORD PTR [rbp-0x70],rax
    3c5f:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3c63:	mov    rax,QWORD PTR [rbp-0x68]
    3c67:	cmp    rax,0xb
    3c6b:	jbe    3d7e <main+0x9b6>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3c71:	mov    rax,QWORD PTR [rbp-0x70]
    3c75:	movsd  xmm0,QWORD PTR [rax]
    3c79:	movsd  QWORD PTR [rbp-0x1c0],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3c81:	mov    rax,QWORD PTR [rbp-0x70]
    3c85:	mov    eax,DWORD PTR [rax+0x8]
    3c88:	mov    DWORD PTR [rbp-0x234],eax

      if (solution_pairs == pair_count)
    3c8e:	mov    eax,DWORD PTR [rbp-0x234]
    3c94:	cmp    eax,DWORD PTR [rbp-0x238]
    3c9a:	jne    3d42 <main+0x97a>
      {
        if (epsilon_equal(solution_sum, sum))
    3ca0:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3ca8:	mov    rax,QWORD PTR [rbp-0x1c0]
    3caf:	movapd xmm1,xmm0
    3cb3:	movq   xmm0,rax
    3cb8:	call   3372 <epsilon_equal>
    3cbd:	test   eax,eax
    3cbf:	je     3d03 <main+0x93b>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3cc1:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3cc9:	mov    rax,QWORD PTR [rbp-0x1c0]
    3cd0:	lea    rdx,[rip+0x9c9]        # 46a0 <_IO_stdin_used+0x6a0>
    3cd7:	lea    rsi,[rip+0x9f5]        # 46d3 <_IO_stdin_used+0x6d3>
    3cde:	movapd xmm1,xmm0
    3ce2:	movq   xmm0,rax
    3ce7:	mov    rcx,rdx
    3cea:	mov    edx,0x64
    3cef:	mov    edi,0x3
    3cf4:	mov    eax,0x2
    3cf9:	call   14a1 <log_message>
    3cfe:	jmp    3da6 <main+0x9de>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3d03:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3d0b:	mov    rax,QWORD PTR [rbp-0x1c0]
    3d12:	lea    rdx,[rip+0x9cf]        # 46e8 <_IO_stdin_used+0x6e8>
    3d19:	lea    rsi,[rip+0x9b3]        # 46d3 <_IO_stdin_used+0x6d3>
    3d20:	movapd xmm1,xmm0
    3d24:	movq   xmm0,rax
    3d29:	mov    rcx,rdx
    3d2c:	mov    edx,0x68
    3d31:	mov    edi,0x1
    3d36:	mov    eax,0x2
    3d3b:	call   14a1 <log_message>
    3d40:	jmp    3da6 <main+0x9de>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3d42:	mov    esi,DWORD PTR [rbp-0x238]
    3d48:	mov    ecx,DWORD PTR [rbp-0x234]
    3d4e:	lea    rdx,[rip+0x9cb]        # 4720 <_IO_stdin_used+0x720>
    3d55:	lea    rax,[rip+0x977]        # 46d3 <_IO_stdin_used+0x6d3>
    3d5c:	mov    r9d,esi
    3d5f:	mov    r8d,ecx
    3d62:	mov    rcx,rdx
    3d65:	mov    edx,0x6d
    3d6a:	mov    rsi,rax
    3d6d:	mov    edi,0x1
    3d72:	mov    eax,0x0
    3d77:	call   14a1 <log_message>
    3d7c:	jmp    3da6 <main+0x9de>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3d7e:	lea    rdx,[rip+0x9e3]        # 4768 <_IO_stdin_used+0x768>
    3d85:	lea    rax,[rip+0x947]        # 46d3 <_IO_stdin_used+0x6d3>
    3d8c:	mov    rcx,rdx
    3d8f:	mov    edx,0x72
    3d94:	mov    rsi,rax
    3d97:	mov    edi,0x1
    3d9c:	mov    eax,0x0
    3da1:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3da6:	add    QWORD PTR [rbp-0x1e8],0x1
    3dae:	sub    rsp,0x8
    3db2:	sub    rsp,0x38
    3db6:	mov    rax,rsp
    3db9:	mov    rcx,QWORD PTR [rbp-0xb0]
    3dc0:	mov    rbx,QWORD PTR [rbp-0xa8]
    3dc7:	mov    QWORD PTR [rax],rcx
    3dca:	mov    QWORD PTR [rax+0x8],rbx
    3dce:	mov    rcx,QWORD PTR [rbp-0xa0]
    3dd5:	mov    rbx,QWORD PTR [rbp-0x98]
    3ddc:	mov    QWORD PTR [rax+0x10],rcx
    3de0:	mov    QWORD PTR [rax+0x18],rbx
    3de4:	mov    rcx,QWORD PTR [rbp-0x90]
    3deb:	mov    rbx,QWORD PTR [rbp-0x88]
    3df2:	mov    QWORD PTR [rax+0x20],rcx
    3df6:	mov    QWORD PTR [rax+0x28],rbx
    3dfa:	mov    rdx,QWORD PTR [rbp-0x80]
    3dfe:	mov    QWORD PTR [rax+0x30],rdx
    3e02:	call   2056 <__profile_end_pass>
    3e07:	add    rsp,0x40
    3e0b:	cmp    QWORD PTR [rbp-0x1e8],0x0
    3e13:	je     3c3b <main+0x873>
    }
  }

  PROFILE_SCOPE("free")
    3e19:	lea    rax,[rip+0x983]        # 47a3 <_IO_stdin_used+0x7a3>
    3e20:	mov    QWORD PTR [rbp-0x2b0],rax
    3e27:	mov    QWORD PTR [rbp-0x2a8],0x4
    3e32:	lea    rax,[rbp-0x70]
    3e36:	mov    rcx,QWORD PTR [rbp-0x2b0]
    3e3d:	mov    rbx,QWORD PTR [rbp-0x2a8]
    3e44:	mov    rsi,rcx
    3e47:	mov    rdx,rbx
    3e4a:	mov    r8d,0x0
    3e50:	mov    ecx,0xa
    3e55:	mov    rdi,rax
    3e58:	call   1f6c <__profile_begin_pass>
    3e5d:	mov    QWORD PTR [rbp-0x1e0],0x0
    3e68:	jmp    3ecc <main+0xb04>
  {
    arena_free(&arena);
    3e6a:	lea    rax,[rbp-0x190]
    3e71:	mov    rdi,rax
    3e74:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3e79:	add    QWORD PTR [rbp-0x1e0],0x1
    3e81:	sub    rsp,0x8
    3e85:	sub    rsp,0x38
    3e89:	mov    rax,rsp
    3e8c:	mov    rcx,QWORD PTR [rbp-0x70]
    3e90:	mov    rbx,QWORD PTR [rbp-0x68]
    3e94:	mov    QWORD PTR [rax],rcx
    3e97:	mov    QWORD PTR [rax+0x8],rbx
    3e9b:	mov    rcx,QWORD PTR [rbp-0x60]
    3e9f:	mov    rbx,QWORD PTR [rbp-0x58]
    3ea3:	mov    QWORD PTR [rax+0x10],rcx
    3ea7:	mov    QWORD PTR [rax+0x18],rbx
    3eab:	mov    rcx,QWORD PTR [rbp-0x50]
    3eaf:	mov    rbx,QWORD PTR [rbp-0x48]
    3eb3:	mov    QWORD PTR [rax+0x20],rcx
    3eb7:	mov    QWORD PTR [rax+0x28],rbx
    3ebb:	mov    rdx,QWORD PTR [rbp-0x40]
    3ebf:	mov    QWORD PTR [rax+0x30],rdx
    3ec3:	call   2056 <__profile_end_pass>
    3ec8:	add    rsp,0x40
    3ecc:	cmp    QWORD PTR [rbp-0x1e0],0x0
    3ed4:	je     3e6a <main+0xaa2>
  }

  end_profiling();
    3ed6:	call   1b9b <end_profiling>
    3edb:	mov    eax,0x0
}
    3ee0:	mov    rdx,QWORD PTR [rbp-0x38]
    3ee4:	sub    rdx,QWORD PTR fs:0x28
    3eed:	je     3ef4 <main+0xb2c>
    3eef:	call   1060 <__stack_chk_fail@plt>
    3ef4:	lea    rsp,[rbp-0x28]
    3ef8:	pop    rbx
    3ef9:	pop    r12
    3efb:	pop    r13
    3efd:	pop    r14
    3eff:	pop    r15
    3f01:	pop    rbp
    3f02:	ret

Disassembly of section .fini:

0000000000003f04 <_fini>:
    3f04:	endbr64
    3f08:	sub    rsp,0x8
    3f0c:	add    rsp,0x8
    3f10:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x5fc1]        # 6fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x5fca]        # 6ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x5fcc]        # 6ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x5fca]        # 7000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x5fc2]        # 7008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x5fba]        # 7010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x5fb2]        # 7018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x5faa]        # 7020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x5fa2]        # 7028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x5f9a]        # 7030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x5f92]        # 7038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x5f8a]        # 7040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x5f82]        # 7048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x5f7a]        # 7050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x5f72]        # 7058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x5f6a]        # 7060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x5f62]        # 7068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x5f5a]        # 7070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x5f52]        # 7078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x5f4a]        # 7080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x5f42]        # 7088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x5f3a]        # 7090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x5f32]        # 7098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2239]        # 33c8 <main>
    118f:	call   QWORD PTR [rip+0x5e2b]        # 6fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x5fa1]        # 7148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x5f9a]        # 7148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x5e0e]        # 6fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x5f71]        # 7148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x5f6a]        # 7148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x5ddd]        # 6fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x5f6d],0x0        # 7188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x5dba],0x0        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x5e76]        # 70a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x5da8]        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x5f44],0x1        # 7188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x5c6e]        # 7180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x5b89]        # 70c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x5be7]        # 7160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x5b2b]        # 70c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x30b7]        # 47b0 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x308b]        # 47b0 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fce]        # 47c8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2ecf]        # 47d8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2ced]        # 47f0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x5639]        # 71a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x5620],rbx        # 71a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x50
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x55ee]        # 71a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x40],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x40],0x0
    1bbe:	je     1f69 <end_profiling+0x3ce>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x38],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x40]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x38]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c71]        # 48a8 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x38]
    1c44:	mov    rax,QWORD PTR [rbp-0x40]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x50],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x48],0x0
    1c72:	jmp    1f5b <end_profiling+0x3c0>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x48]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x550d]        # 71a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x30],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x30]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1f56 <end_profiling+0x3bb>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x30]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x40]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b97]        # 48b0 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x28],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x30]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x30]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x30]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x30]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x28]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x30]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x30]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x30]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x40]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2abf]        # 48b0 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x20],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x30]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x20]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x50]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x28]
    1e2c:	movsd  QWORD PTR [rbp-0x50],xmm0

        if (zone->bytes_processed)
    1e31:	mov    rax,QWORD PTR [rbp-0x30]
    1e35:	mov    rax,QWORD PTR [rax+0x28]
    1e39:	test   rax,rax
    1e3c:	je     1f56 <end_profiling+0x3bb>
        {
          u64 gigabytes = zone->bytes_processed / BILLION(1);
    1e42:	mov    rax,QWORD PTR [rbp-0x30]
    1e46:	mov    rax,QWORD PTR [rax+0x28]
    1e4a:	shr    rax,0x9
    1e4e:	movabs rdx,0x44b82fa09b5a53
    1e58:	mul    rdx
    1e5b:	mov    rax,rdx
    1e5e:	shr    rax,0xb
    1e62:	mov    QWORD PTR [rbp-0x18],rax
          u64 megabytes = zone->bytes_processed / MILLION(1);
    1e66:	mov    rax,QWORD PTR [rbp-0x30]
    1e6a:	mov    rax,QWORD PTR [rax+0x28]
    1e6e:	movabs rdx,0x431bde82d7b634db
    1e78:	mul    rdx
    1e7b:	mov    rax,rdx
    1e7e:	shr    rax,0x12
    1e82:	mov    QWORD PTR [rbp-0x10],rax

          f64 gb_per_s = gigabytes / (f64)zone->elapsed_inclusive / (f64)freq * MILLION(1);
    1e86:	mov    rax,QWORD PTR [rbp-0x18]
    1e8a:	test   rax,rax
    1e8d:	js     1e9a <end_profiling+0x2ff>
    1e8f:	pxor   xmm0,xmm0
    1e93:	cvtsi2sd xmm0,rax
    1e98:	jmp    1eb3 <end_profiling+0x318>
    1e9a:	mov    rdx,rax
    1e9d:	shr    rdx,1
    1ea0:	and    eax,0x1
    1ea3:	or     rdx,rax
    1ea6:	pxor   xmm0,xmm0
    1eaa:	cvtsi2sd xmm0,rdx
    1eaf:	addsd  xmm0,xmm0
    1eb3:	mov    rax,QWORD PTR [rbp-0x30]
    1eb7:	mov    rax,QWORD PTR [rax+0x18]
    1ebb:	test   rax,rax
    1ebe:	js     1ecb <end_profiling+0x330>
    1ec0:	pxor   xmm1,xmm1
    1ec4:	cvtsi2sd xmm1,rax
    1ec9:	jmp    1ee4 <end_profiling+0x349>
    1ecb:	mov    rdx,rax
    1ece:	shr    rdx,1
    1ed1:	and    eax,0x1
    1ed4:	or     rdx,rax
    1ed7:	pxor   xmm1,xmm1
    1edb:	cvtsi2sd xmm1,rdx
    1ee0:	addsd  xmm1,xmm1
    1ee4:	movapd xmm2,xmm0
    1ee8:	divsd  xmm2,xmm1
    1eec:	mov    rax,QWORD PTR [rbp-0x38]
    1ef0:	test   rax,rax
    1ef3:	js     1f00 <end_profiling+0x365>
    1ef5:	pxor   xmm0,xmm0
    1ef9:	cvtsi2sd xmm0,rax
    1efe:	jmp    1f19 <end_profiling+0x37e>
    1f00:	mov    rdx,rax
    1f03:	shr    rdx,1
    1f06:	and    eax,0x1
    1f09:	or     rdx,rax
    1f0c:	pxor   xmm0,xmm0
    1f10:	cvtsi2sd xmm0,rdx
    1f15:	addsd  xmm0,xmm0
    1f19:	movapd xmm1,xmm2
    1f1d:	divsd  xmm1,xmm0
    1f21:	movsd  xmm0,QWORD PTR [rip+0x298f]        # 48b8 <__PRETTY_FUNCTION__.0+0x28>
    1f29:	mulsd  xmm0,xmm1
    1f2d:	movsd  QWORD PTR [rbp-0x8],xmm0

          printf("  Megabytes Processed: %lu @ %f GB/s\n", megabytes, gb_per_s);
    1f32:	mov    rdx,QWORD PTR [rbp-0x8]
    1f36:	mov    rax,QWORD PTR [rbp-0x10]
    1f3a:	lea    rcx,[rip+0x2407]        # 4348 <_IO_stdin_used+0x348>
    1f41:	movq   xmm0,rdx
    1f46:	mov    rsi,rax
    1f49:	mov    rdi,rcx
    1f4c:	mov    eax,0x1
    1f51:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1f56:	add    QWORD PTR [rbp-0x48],0x1
    1f5b:	cmp    QWORD PTR [rbp-0x48],0xfff
    1f63:	jbe    1c77 <end_profiling+0xdc>
        }
      }
    }
  }
}
    1f69:	nop
    1f6a:	leave
    1f6b:	ret

0000000000001f6c <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1f6c:	push   rbp
    1f6d:	mov    rbp,rsp
    1f70:	push   rbx
    1f71:	sub    rsp,0x78
    1f75:	mov    QWORD PTR [rbp-0x58],rdi
    1f79:	mov    rax,rsi
    1f7c:	mov    rsi,rdx
    1f7f:	mov    rax,rax
    1f82:	mov    edx,0x0
    1f87:	mov    rdx,rsi
    1f8a:	mov    QWORD PTR [rbp-0x70],rax
    1f8e:	mov    QWORD PTR [rbp-0x68],rdx
    1f92:	mov    QWORD PTR [rbp-0x60],rcx
    1f96:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1f9a:	pxor   xmm0,xmm0
    1f9e:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1fa2:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1fa6:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1faa:	movq   QWORD PTR [rbp-0x20],xmm0
    1faf:	mov    rax,QWORD PTR [rbp-0x70]
    1fb3:	mov    rdx,QWORD PTR [rbp-0x68]
    1fb7:	mov    QWORD PTR [rbp-0x50],rax
    1fbb:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1fbf:	mov    rdx,QWORD PTR [rbp-0x60]
    1fc3:	mov    rax,rdx
    1fc6:	add    rax,rax
    1fc9:	add    rax,rdx
    1fcc:	shl    rax,0x4
    1fd0:	mov    rdx,rax
    1fd3:	lea    rax,[rip+0x51ee]        # 71c8 <g_profiler+0x28>
    1fda:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1fde:	mov    QWORD PTR [rbp-0x38],rax
    1fe2:	mov    rax,QWORD PTR [rbp-0x60]
    1fe6:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1fea:	mov    rax,QWORD PTR [rip+0x51b7]        # 71a8 <g_profiler+0x8>
  Profile_Pass pass =
    1ff1:	mov    QWORD PTR [rbp-0x28],rax
    1ff5:	mov    rax,QWORD PTR [rbp-0x78]
    1ff9:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    1ffd:	mov    rax,QWORD PTR [rbp-0x60]
    2001:	mov    QWORD PTR [rip+0x51a0],rax        # 71a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    2008:	call   1a48 <read_cpu_timer>
    200d:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    2011:	mov    rax,QWORD PTR [rbp-0x58]
    2015:	mov    rcx,QWORD PTR [rbp-0x50]
    2019:	mov    rbx,QWORD PTR [rbp-0x48]
    201d:	mov    QWORD PTR [rax],rcx
    2020:	mov    QWORD PTR [rax+0x8],rbx
    2024:	mov    rcx,QWORD PTR [rbp-0x40]
    2028:	mov    rbx,QWORD PTR [rbp-0x38]
    202c:	mov    QWORD PTR [rax+0x10],rcx
    2030:	mov    QWORD PTR [rax+0x18],rbx
    2034:	mov    rcx,QWORD PTR [rbp-0x30]
    2038:	mov    rbx,QWORD PTR [rbp-0x28]
    203c:	mov    QWORD PTR [rax+0x20],rcx
    2040:	mov    QWORD PTR [rax+0x28],rbx
    2044:	mov    rdx,QWORD PTR [rbp-0x20]
    2048:	mov    QWORD PTR [rax+0x30],rdx
}
    204c:	mov    rax,QWORD PTR [rbp-0x58]
    2050:	mov    rbx,QWORD PTR [rbp-0x8]
    2054:	leave
    2055:	ret

0000000000002056 <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    2056:	push   rbp
    2057:	mov    rbp,rsp
    205a:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    205e:	call   1a48 <read_cpu_timer>
    2063:	mov    rdx,rax
    2066:	mov    rax,QWORD PTR [rbp+0x20]
    206a:	sub    rdx,rax
    206d:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    2071:	mov    rax,QWORD PTR [rbp+0x38]
    2075:	mov    QWORD PTR [rip+0x512c],rax        # 71a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    207c:	mov    rdx,QWORD PTR [rbp+0x30]
    2080:	mov    rax,rdx
    2083:	add    rax,rax
    2086:	add    rax,rdx
    2089:	shl    rax,0x4
    208d:	lea    rdx,[rax+0x10]
    2091:	lea    rax,[rip+0x5108]        # 71a0 <g_profiler>
    2098:	add    rax,rdx
    209b:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    209f:	mov    rax,QWORD PTR [rbp-0x10]
    20a3:	mov    rdx,QWORD PTR [rax+0x10]
    20a7:	mov    rax,QWORD PTR [rbp-0x18]
    20ab:	add    rdx,rax
    20ae:	mov    rax,QWORD PTR [rbp-0x10]
    20b2:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    20b6:	mov    rax,QWORD PTR [rbp-0x10]
    20ba:	mov    rax,QWORD PTR [rax+0x20]
    20be:	lea    rdx,[rax+0x1]
    20c2:	mov    rax,QWORD PTR [rbp-0x10]
    20c6:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    20ca:	mov    rcx,QWORD PTR [rbp-0x10]
    20ce:	mov    rax,QWORD PTR [rbp+0x10]
    20d2:	mov    rdx,QWORD PTR [rbp+0x18]
    20d6:	mov    QWORD PTR [rcx],rax
    20d9:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    20dd:	mov    rdx,QWORD PTR [rbp+0x28]
    20e1:	mov    rax,QWORD PTR [rbp-0x18]
    20e5:	add    rdx,rax
    20e8:	mov    rax,QWORD PTR [rbp-0x10]
    20ec:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    20f0:	mov    rax,QWORD PTR [rbp-0x10]
    20f4:	mov    rdx,QWORD PTR [rax+0x28]
    20f8:	mov    rax,QWORD PTR [rbp+0x40]
    20fc:	add    rdx,rax
    20ff:	mov    rax,QWORD PTR [rbp-0x10]
    2103:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    2107:	mov    rdx,QWORD PTR [rbp+0x38]
    210b:	mov    rax,rdx
    210e:	add    rax,rax
    2111:	add    rax,rdx
    2114:	shl    rax,0x4
    2118:	lea    rdx,[rax+0x10]
    211c:	lea    rax,[rip+0x507d]        # 71a0 <g_profiler>
    2123:	add    rax,rdx
    2126:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    212a:	mov    rax,QWORD PTR [rbp-0x8]
    212e:	mov    rax,QWORD PTR [rax+0x10]
    2132:	sub    rax,QWORD PTR [rbp-0x18]
    2136:	mov    rdx,rax
    2139:	mov    rax,QWORD PTR [rbp-0x8]
    213d:	mov    QWORD PTR [rax+0x10],rdx
}
    2141:	nop
    2142:	leave
    2143:	ret

0000000000002144 <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    2144:	push   rbp
    2145:	mov    rbp,rsp
    2148:	sub    rsp,0x10
    214c:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2150:	mov    rax,QWORD PTR [rbp-0x8]
    2154:	mov    rdx,QWORD PTR [rax+0x10]
    2158:	mov    rax,QWORD PTR [rbp-0x8]
    215c:	mov    rax,QWORD PTR [rax+0x8]
    2160:	cmp    rdx,rax
    2163:	jb     218a <parser_at+0x46>
    2165:	lea    rdx,[rip+0x269c]        # 4808 <__PRETTY_FUNCTION__.5>
    216c:	lea    rsi,[rip+0x2306]        # 4479 <_IO_stdin_used+0x479>
    2173:	lea    rax,[rip+0x2316]        # 4490 <_IO_stdin_used+0x490>
    217a:	mov    rcx,rdx
    217d:	mov    edx,0x2f
    2182:	mov    rdi,rax
    2185:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    218a:	mov    rax,QWORD PTR [rbp-0x8]
    218e:	mov    rdx,QWORD PTR [rax]
    2191:	mov    rax,QWORD PTR [rbp-0x8]
    2195:	mov    rax,QWORD PTR [rax+0x10]
    2199:	add    rax,rdx
}
    219c:	leave
    219d:	ret

000000000000219e <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    219e:	push   rbp
    219f:	mov    rbp,rsp
    21a2:	sub    rsp,0x10
    21a6:	mov    QWORD PTR [rbp-0x8],rdi
    21aa:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    21ae:	mov    rax,QWORD PTR [rbp-0x8]
    21b2:	mov    rdi,rax
    21b5:	call   2144 <parser_at>
    21ba:	mov    rdx,QWORD PTR [rbp-0x10]
    21be:	add    rax,rdx
}
    21c1:	leave
    21c2:	ret

00000000000021c3 <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    21c3:	push   rbp
    21c4:	mov    rbp,rsp
    21c7:	mov    QWORD PTR [rbp-0x8],rdi
    21cb:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    21cf:	mov    rax,QWORD PTR [rbp-0x8]
    21d3:	mov    rdx,QWORD PTR [rax+0x10]
    21d7:	mov    rax,QWORD PTR [rbp-0x10]
    21db:	add    rdx,rax
    21de:	mov    rax,QWORD PTR [rbp-0x8]
    21e2:	mov    QWORD PTR [rax+0x10],rdx
}
    21e6:	nop
    21e7:	pop    rbp
    21e8:	ret

00000000000021e9 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    21e9:	push   rbp
    21ea:	mov    rbp,rsp
    21ed:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    21f1:	mov    rax,QWORD PTR [rbp-0x8]
    21f5:	mov    rdx,QWORD PTR [rax+0x10]
    21f9:	mov    rax,QWORD PTR [rbp-0x8]
    21fd:	mov    rax,QWORD PTR [rax+0x8]
    2201:	cmp    rdx,rax
    2204:	setb   al
}
    2207:	pop    rbp
    2208:	ret

0000000000002209 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    2209:	push   rbp
    220a:	mov    rbp,rsp
    220d:	push   r12
    220f:	push   rbx
    2210:	sub    rsp,0x20
    2214:	mov    QWORD PTR [rbp-0x18],rdi
    2218:	mov    rax,rsi
    221b:	mov    rcx,rdx
    221e:	mov    rax,rax
    2221:	mov    edx,0x0
    2226:	mov    rdx,rcx
    2229:	mov    QWORD PTR [rbp-0x30],rax
    222d:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    2231:	mov    rax,QWORD PTR [rbp-0x28]
    2235:	mov    r12,rax
    2238:	mov    rbx,QWORD PTR [rbp-0x30]
    223c:	mov    rax,QWORD PTR [rbp-0x18]
    2240:	mov    rdi,rax
    2243:	call   2144 <parser_at>
    2248:	mov    rdx,r12
    224b:	mov    rsi,rbx
    224e:	mov    rdi,rax
    2251:	call   10d0 <memcmp@plt>
    2256:	test   eax,eax
    2258:	sete   al
}
    225b:	add    rsp,0x20
    225f:	pop    rbx
    2260:	pop    r12
    2262:	pop    rbp
    2263:	ret

0000000000002264 <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    2264:	push   rbp
    2265:	mov    rbp,rsp
    2268:	mov    eax,edi
    226a:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    226d:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    2271:	movzx  eax,BYTE PTR [rbp-0x14]
    2275:	cmp    eax,0x2e
    2278:	jg     2281 <is_numeric+0x1d>
    227a:	cmp    eax,0x2d
    227d:	jge    2289 <is_numeric+0x25>
    227f:	jmp    228e <is_numeric+0x2a>
    2281:	sub    eax,0x30
    2284:	cmp    eax,0x9
    2287:	ja     228e <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2289:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    228d:	nop
  }


  return result;
    228e:	movzx  eax,BYTE PTR [rbp-0x1]
}
    2292:	pop    rbp
    2293:	ret

0000000000002294 <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    2294:	push   rbp
    2295:	mov    rbp,rsp
    2298:	sub    rsp,0x50
    229c:	mov    QWORD PTR [rbp-0x48],rdi
    22a0:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    22a4:	pxor   xmm0,xmm0
    22a8:	movaps XMMWORD PTR [rbp-0x20],xmm0
    22ac:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    22b1:	jmp    22c4 <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    22b3:	mov    rax,QWORD PTR [rbp-0x50]
    22b7:	mov    esi,0x1
    22bc:	mov    rdi,rax
    22bf:	call   21c3 <parser_advance>
  while (parser_incomplete(parser)  &&
    22c4:	mov    rax,QWORD PTR [rbp-0x50]
    22c8:	mov    rdi,rax
    22cb:	call   21e9 <parser_incomplete>
    22d0:	test   al,al
    22d2:	je     2320 <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    22d4:	mov    rax,QWORD PTR [rbp-0x50]
    22d8:	mov    rdi,rax
    22db:	call   2144 <parser_at>
    22e0:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    22e3:	cmp    al,0x20
    22e5:	je     22b3 <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    22e7:	mov    rax,QWORD PTR [rbp-0x50]
    22eb:	mov    rdi,rax
    22ee:	call   2144 <parser_at>
    22f3:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    22f6:	cmp    al,0xa
    22f8:	je     22b3 <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    22fa:	mov    rax,QWORD PTR [rbp-0x50]
    22fe:	mov    rdi,rax
    2301:	call   2144 <parser_at>
    2306:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    2309:	cmp    al,0xd
    230b:	je     22b3 <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    230d:	mov    rax,QWORD PTR [rbp-0x50]
    2311:	mov    rdi,rax
    2314:	call   2144 <parser_at>
    2319:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    231c:	cmp    al,0x9
    231e:	je     22b3 <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    2320:	mov    rax,QWORD PTR [rbp-0x50]
    2324:	mov    rdi,rax
    2327:	call   21e9 <parser_incomplete>
    232c:	test   al,al
    232e:	je     275b <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    2334:	mov    rax,QWORD PTR [rbp-0x50]
    2338:	mov    rdi,rax
    233b:	call   2144 <parser_at>
    2340:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    2344:	mov    rax,QWORD PTR [rbp-0x50]
    2348:	mov    rdi,rax
    234b:	call   2144 <parser_at>
    2350:	movzx  eax,BYTE PTR [rax]
    2353:	movzx  eax,al
    2356:	cmp    eax,0x7d
    2359:	je     2446 <get_json_token+0x1b2>
    235f:	cmp    eax,0x7d
    2362:	jg     276c <get_json_token+0x4d8>
    2368:	cmp    eax,0x7b
    236b:	je     2421 <get_json_token+0x18d>
    2371:	cmp    eax,0x7b
    2374:	jg     276c <get_json_token+0x4d8>
    237a:	cmp    eax,0x74
    237d:	je     25c9 <get_json_token+0x335>
    2383:	cmp    eax,0x74
    2386:	jg     276c <get_json_token+0x4d8>
    238c:	cmp    eax,0x6e
    238f:	je     26d9 <get_json_token+0x445>
    2395:	cmp    eax,0x6e
    2398:	jg     276c <get_json_token+0x4d8>
    239e:	cmp    eax,0x66
    23a1:	je     2651 <get_json_token+0x3bd>
    23a7:	cmp    eax,0x66
    23aa:	jg     276c <get_json_token+0x4d8>
    23b0:	cmp    eax,0x5d
    23b3:	je     2490 <get_json_token+0x1fc>
    23b9:	cmp    eax,0x5d
    23bc:	jg     276c <get_json_token+0x4d8>
    23c2:	cmp    eax,0x5b
    23c5:	je     246b <get_json_token+0x1d7>
    23cb:	cmp    eax,0x5b
    23ce:	jg     276c <get_json_token+0x4d8>
    23d4:	cmp    eax,0x3a
    23d7:	je     24da <get_json_token+0x246>
    23dd:	cmp    eax,0x3a
    23e0:	jg     276c <get_json_token+0x4d8>
    23e6:	cmp    eax,0x39
    23e9:	jg     276c <get_json_token+0x4d8>
    23ef:	cmp    eax,0x30
    23f2:	jge    2578 <get_json_token+0x2e4>
    23f8:	cmp    eax,0x2e
    23fb:	jg     276c <get_json_token+0x4d8>
    2401:	cmp    eax,0x2d
    2404:	jge    2578 <get_json_token+0x2e4>
    240a:	cmp    eax,0x22
    240d:	je     24ff <get_json_token+0x26b>
    2413:	cmp    eax,0x2c
    2416:	je     24b5 <get_json_token+0x221>
    241c:	jmp    276c <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    2421:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    2428:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2430:	mov    rax,QWORD PTR [rbp-0x50]
    2434:	mov    esi,0x1
    2439:	mov    rdi,rax
    243c:	call   21c3 <parser_advance>
      }
      break;
    2441:	jmp    276c <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2446:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    244d:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2455:	mov    rax,QWORD PTR [rbp-0x50]
    2459:	mov    esi,0x1
    245e:	mov    rdi,rax
    2461:	call   21c3 <parser_advance>
      }
      break;
    2466:	jmp    276c <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    246b:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    2472:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    247a:	mov    rax,QWORD PTR [rbp-0x50]
    247e:	mov    esi,0x1
    2483:	mov    rdi,rax
    2486:	call   21c3 <parser_advance>
      }
      break;
    248b:	jmp    276c <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    2490:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    2497:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    249f:	mov    rax,QWORD PTR [rbp-0x50]
    24a3:	mov    esi,0x1
    24a8:	mov    rdi,rax
    24ab:	call   21c3 <parser_advance>
      }
      break;
    24b0:	jmp    276c <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    24b5:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    24bc:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24c4:	mov    rax,QWORD PTR [rbp-0x50]
    24c8:	mov    esi,0x1
    24cd:	mov    rdi,rax
    24d0:	call   21c3 <parser_advance>
      }
      break;
    24d5:	jmp    276c <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    24da:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    24e1:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24e9:	mov    rax,QWORD PTR [rbp-0x50]
    24ed:	mov    esi,0x1
    24f2:	mov    rdi,rax
    24f5:	call   21c3 <parser_advance>
      }
      break;
    24fa:	jmp    276c <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    24ff:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    2506:	mov    rax,QWORD PTR [rbp-0x50]
    250a:	mov    esi,0x1
    250f:	mov    rdi,rax
    2512:	call   21c3 <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    2517:	mov    rax,QWORD PTR [rbp-0x50]
    251b:	mov    rdi,rax
    251e:	call   2144 <parser_at>
    2523:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    2527:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    252f:	jmp    2547 <get_json_token+0x2b3>
        {
          string_count += 1;
    2531:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    2536:	mov    rax,QWORD PTR [rbp-0x50]
    253a:	mov    esi,0x1
    253f:	mov    rdi,rax
    2542:	call   21c3 <parser_advance>
        while (*parser_at(parser) != '"')
    2547:	mov    rax,QWORD PTR [rbp-0x50]
    254b:	mov    rdi,rax
    254e:	call   2144 <parser_at>
    2553:	movzx  eax,BYTE PTR [rax]
    2556:	cmp    al,0x22
    2558:	jne    2531 <get_json_token+0x29d>
        }
        token.value.count = string_count;
    255a:	mov    rax,QWORD PTR [rbp-0x40]
    255e:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    2562:	mov    rax,QWORD PTR [rbp-0x50]
    2566:	mov    esi,0x1
    256b:	mov    rdi,rax
    256e:	call   21c3 <parser_advance>
      }
      break;
    2573:	jmp    276c <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2578:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    257f:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2587:	jmp    259f <get_json_token+0x30b>
        {
          digit_count += 1;
    2589:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    258e:	mov    rax,QWORD PTR [rbp-0x50]
    2592:	mov    esi,0x1
    2597:	mov    rdi,rax
    259a:	call   21c3 <parser_advance>
        while (is_numeric(*parser_at(parser)))
    259f:	mov    rax,QWORD PTR [rbp-0x50]
    25a3:	mov    rdi,rax
    25a6:	call   2144 <parser_at>
    25ab:	movzx  eax,BYTE PTR [rax]
    25ae:	movzx  eax,al
    25b1:	mov    edi,eax
    25b3:	call   2264 <is_numeric>
    25b8:	test   al,al
    25ba:	jne    2589 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    25bc:	mov    rax,QWORD PTR [rbp-0x38]
    25c0:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    25c4:	jmp    276c <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    25c9:	lea    rax,[rip+0x1f0c]        # 44dc <_IO_stdin_used+0x4dc>
    25d0:	mov    QWORD PTR [rbp-0x30],rax
    25d4:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25dc:	mov    rcx,QWORD PTR [rbp-0x30]
    25e0:	mov    rdx,QWORD PTR [rbp-0x28]
    25e4:	mov    rax,QWORD PTR [rbp-0x50]
    25e8:	mov    rsi,rcx
    25eb:	mov    rdi,rax
    25ee:	call   2209 <parser_token_is_literal>
    25f3:	test   al,al
    25f5:	je     2619 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    25f7:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    25fe:	mov    rax,QWORD PTR [rbp-0x28]
    2602:	mov    rdx,rax
    2605:	mov    rax,QWORD PTR [rbp-0x50]
    2609:	mov    rsi,rdx
    260c:	mov    rdi,rax
    260f:	call   21c3 <parser_advance>
    2614:	jmp    276c <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2619:	mov    rax,QWORD PTR [rbp-0x50]
    261d:	mov    rcx,QWORD PTR [rax+0x10]
    2621:	lea    rdx,[rip+0x1ec0]        # 44e8 <_IO_stdin_used+0x4e8>
    2628:	lea    rax,[rip+0x1e4a]        # 4479 <_IO_stdin_used+0x479>
    262f:	mov    r8,rcx
    2632:	mov    rcx,rdx
    2635:	mov    edx,0xdf
    263a:	mov    rsi,rax
    263d:	mov    edi,0x1
    2642:	mov    eax,0x0
    2647:	call   14a1 <log_message>
        }
      }
      break;
    264c:	jmp    276c <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    2651:	lea    rax,[rip+0x1ebd]        # 4515 <_IO_stdin_used+0x515>
    2658:	mov    QWORD PTR [rbp-0x30],rax
    265c:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    2664:	mov    rcx,QWORD PTR [rbp-0x30]
    2668:	mov    rdx,QWORD PTR [rbp-0x28]
    266c:	mov    rax,QWORD PTR [rbp-0x50]
    2670:	mov    rsi,rcx
    2673:	mov    rdi,rax
    2676:	call   2209 <parser_token_is_literal>
    267b:	test   al,al
    267d:	je     26a1 <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    267f:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    2686:	mov    rax,QWORD PTR [rbp-0x28]
    268a:	mov    rdx,rax
    268d:	mov    rax,QWORD PTR [rbp-0x50]
    2691:	mov    rsi,rdx
    2694:	mov    rdi,rax
    2697:	call   21c3 <parser_advance>
    269c:	jmp    276c <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    26a1:	mov    rax,QWORD PTR [rbp-0x50]
    26a5:	mov    rcx,QWORD PTR [rax+0x10]
    26a9:	lea    rdx,[rip+0x1e38]        # 44e8 <_IO_stdin_used+0x4e8>
    26b0:	lea    rax,[rip+0x1dc2]        # 4479 <_IO_stdin_used+0x479>
    26b7:	mov    r8,rcx
    26ba:	mov    rcx,rdx
    26bd:	mov    edx,0xee
    26c2:	mov    rsi,rax
    26c5:	mov    edi,0x1
    26ca:	mov    eax,0x0
    26cf:	call   14a1 <log_message>
        }
      }
      break;
    26d4:	jmp    276c <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    26d9:	lea    rax,[rip+0x1e3b]        # 451b <_IO_stdin_used+0x51b>
    26e0:	mov    QWORD PTR [rbp-0x30],rax
    26e4:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    26ec:	mov    rcx,QWORD PTR [rbp-0x30]
    26f0:	mov    rdx,QWORD PTR [rbp-0x28]
    26f4:	mov    rax,QWORD PTR [rbp-0x50]
    26f8:	mov    rsi,rcx
    26fb:	mov    rdi,rax
    26fe:	call   2209 <parser_token_is_literal>
    2703:	test   al,al
    2705:	je     2726 <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    2707:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    270e:	mov    rax,QWORD PTR [rbp-0x28]
    2712:	mov    rdx,rax
    2715:	mov    rax,QWORD PTR [rbp-0x50]
    2719:	mov    rsi,rdx
    271c:	mov    rdi,rax
    271f:	call   21c3 <parser_advance>
    2724:	jmp    276c <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2726:	mov    rax,QWORD PTR [rbp-0x50]
    272a:	mov    rcx,QWORD PTR [rax+0x10]
    272e:	lea    rdx,[rip+0x1db3]        # 44e8 <_IO_stdin_used+0x4e8>
    2735:	lea    rax,[rip+0x1d3d]        # 4479 <_IO_stdin_used+0x479>
    273c:	mov    r8,rcx
    273f:	mov    rcx,rdx
    2742:	mov    edx,0xfd
    2747:	mov    rsi,rax
    274a:	mov    edi,0x1
    274f:	mov    eax,0x0
    2754:	call   14a1 <log_message>
        }
      }
      break;
    2759:	jmp    276c <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    275b:	mov    rax,QWORD PTR [rbp-0x50]
    275f:	mov    esi,0x1
    2764:	mov    rdi,rax
    2767:	call   21c3 <parser_advance>
  }

  return token;
    276c:	mov    rcx,QWORD PTR [rbp-0x48]
    2770:	mov    rax,QWORD PTR [rbp-0x20]
    2774:	mov    rdx,QWORD PTR [rbp-0x18]
    2778:	mov    QWORD PTR [rcx],rax
    277b:	mov    QWORD PTR [rcx+0x8],rdx
    277f:	mov    rax,QWORD PTR [rbp-0x10]
    2783:	mov    QWORD PTR [rcx+0x10],rax
}
    2787:	mov    rax,QWORD PTR [rbp-0x48]
    278b:	leave
    278c:	ret

000000000000278d <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    278d:	push   rbp
    278e:	mov    rbp,rsp
    2791:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    2794:	cmp    DWORD PTR [rbp-0x14],0x7
    2798:	je     27b2 <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    279a:	cmp    DWORD PTR [rbp-0x14],0x9
    279e:	je     27b2 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    27a0:	cmp    DWORD PTR [rbp-0x14],0xa
    27a4:	je     27b2 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    27a6:	cmp    DWORD PTR [rbp-0x14],0xb
    27aa:	je     27b2 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    27ac:	cmp    DWORD PTR [rbp-0x14],0x8
    27b0:	jne    27b9 <json_token_type_is_value_type+0x2c>
    27b2:	mov    eax,0x1
    27b7:	jmp    27be <json_token_type_is_value_type+0x31>
    27b9:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    27be:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    27c1:	mov    eax,DWORD PTR [rbp-0x4]
}
    27c4:	pop    rbp
    27c5:	ret

00000000000027c6 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    27c6:	push   rbp
    27c7:	mov    rbp,rsp
    27ca:	push   rbx
    27cb:	sub    rsp,0x88
    27d2:	mov    QWORD PTR [rbp-0x78],rdi
    27d6:	mov    QWORD PTR [rbp-0x80],rsi
    27da:	mov    QWORD PTR [rbp-0x90],rdx
    27e1:	mov    QWORD PTR [rbp-0x88],rcx
    27e8:	mov    rax,QWORD PTR fs:0x28
    27f1:	mov    QWORD PTR [rbp-0x18],rax
    27f5:	xor    eax,eax
  profile_begin_func();
    27f7:	lea    r8,[rip+0x2022]        # 4820 <__func__.4>
    27fe:	mov    r9d,0x11
    2804:	lea    rax,[rbp-0x50]
    2808:	mov    rsi,r8
    280b:	mov    rdx,r9
    280e:	mov    r8d,0x0
    2814:	mov    ecx,0x1
    2819:	mov    rdi,rax
    281c:	call   1f6c <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    2821:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2829:	mov    eax,DWORD PTR [rbp+0x10]
    282c:	cmp    eax,0x1
    282f:	jne    285b <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    2831:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    2838:	mov    edx,DWORD PTR [rbp-0x64]
    283b:	mov    rsi,QWORD PTR [rbp-0x80]
    283f:	mov    rax,QWORD PTR [rbp-0x78]
    2843:	mov    ecx,edx
    2845:	mov    edx,0x2
    284a:	mov    rdi,rax
    284d:	call   29ad <parse_json_children>
    2852:	mov    QWORD PTR [rbp-0x60],rax
    2856:	jmp    28e5 <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    285b:	mov    eax,DWORD PTR [rbp+0x10]
    285e:	cmp    eax,0x3
    2861:	jne    288a <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    2863:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    286a:	mov    edx,DWORD PTR [rbp-0x68]
    286d:	mov    rsi,QWORD PTR [rbp-0x80]
    2871:	mov    rax,QWORD PTR [rbp-0x78]
    2875:	mov    ecx,edx
    2877:	mov    edx,0x4
    287c:	mov    rdi,rax
    287f:	call   29ad <parse_json_children>
    2884:	mov    QWORD PTR [rbp-0x60],rax
    2888:	jmp    28e5 <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    288a:	mov    eax,DWORD PTR [rbp+0x10]
    288d:	mov    edi,eax
    288f:	call   278d <json_token_type_is_value_type>
    2894:	test   eax,eax
    2896:	jne    28e5 <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2898:	mov    eax,DWORD PTR [rbp+0x10]
    289b:	mov    eax,eax
    289d:	lea    rdx,[rax*8+0x0]
    28a5:	lea    rax,[rip+0x4834]        # 70e0 <JSON_Token_Type_strings>
    28ac:	mov    rcx,QWORD PTR [rdx+rax*1]
    28b0:	lea    rdx,[rip+0x1c69]        # 4520 <_IO_stdin_used+0x520>
    28b7:	lea    rax,[rip+0x1bbb]        # 4479 <_IO_stdin_used+0x479>
    28be:	push   QWORD PTR [rbp+0x20]
    28c1:	push   QWORD PTR [rbp+0x18]
    28c4:	mov    r8,rcx
    28c7:	mov    rcx,rdx
    28ca:	mov    edx,0x134
    28cf:	mov    rsi,rax
    28d2:	mov    edi,0x1
    28d7:	mov    eax,0x0
    28dc:	call   14a1 <log_message>
    28e1:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    28e5:	mov    rax,QWORD PTR [rbp-0x78]
    28e9:	mov    edx,0x8
    28ee:	mov    esi,0x30
    28f3:	mov    rdi,rax
    28f6:	call   17d3 <arena_alloc>
    28fb:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    28ff:	mov    rcx,QWORD PTR [rbp-0x58]
    2903:	mov    rax,QWORD PTR [rbp-0x90]
    290a:	mov    rdx,QWORD PTR [rbp-0x88]
    2911:	mov    QWORD PTR [rcx],rax
    2914:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    2918:	mov    rax,QWORD PTR [rbp-0x58]
    291c:	mov    rdx,QWORD PTR [rbp-0x60]
    2920:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    2924:	mov    rax,QWORD PTR [rbp-0x58]
    2928:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    2930:	mov    rcx,QWORD PTR [rbp-0x58]
    2934:	mov    rax,QWORD PTR [rbp+0x18]
    2938:	mov    rdx,QWORD PTR [rbp+0x20]
    293c:	mov    QWORD PTR [rcx+0x10],rax
    2940:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    2944:	sub    rsp,0x8
    2948:	sub    rsp,0x38
    294c:	mov    rax,rsp
    294f:	mov    rcx,QWORD PTR [rbp-0x50]
    2953:	mov    rbx,QWORD PTR [rbp-0x48]
    2957:	mov    QWORD PTR [rax],rcx
    295a:	mov    QWORD PTR [rax+0x8],rbx
    295e:	mov    rcx,QWORD PTR [rbp-0x40]
    2962:	mov    rbx,QWORD PTR [rbp-0x38]
    2966:	mov    QWORD PTR [rax+0x10],rcx
    296a:	mov    QWORD PTR [rax+0x18],rbx
    296e:	mov    rcx,QWORD PTR [rbp-0x30]
    2972:	mov    rbx,QWORD PTR [rbp-0x28]
    2976:	mov    QWORD PTR [rax+0x20],rcx
    297a:	mov    QWORD PTR [rax+0x28],rbx
    297e:	mov    rdx,QWORD PTR [rbp-0x20]
    2982:	mov    QWORD PTR [rax+0x30],rdx
    2986:	call   2056 <__profile_end_pass>
    298b:	add    rsp,0x40

  return result;
    298f:	mov    rax,QWORD PTR [rbp-0x58]
}
    2993:	mov    rdx,QWORD PTR [rbp-0x18]
    2997:	sub    rdx,QWORD PTR fs:0x28
    29a0:	je     29a7 <parse_json_object+0x1e1>
    29a2:	call   1060 <__stack_chk_fail@plt>
    29a7:	mov    rbx,QWORD PTR [rbp-0x8]
    29ab:	leave
    29ac:	ret

00000000000029ad <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    29ad:	push   rbp
    29ae:	mov    rbp,rsp
    29b1:	push   rbx
    29b2:	sub    rsp,0x108
    29b9:	mov    QWORD PTR [rbp-0xd8],rdi
    29c0:	mov    QWORD PTR [rbp-0xe0],rsi
    29c7:	mov    DWORD PTR [rbp-0xe4],edx
    29cd:	mov    DWORD PTR [rbp-0xe8],ecx
    29d3:	mov    rax,QWORD PTR fs:0x28
    29dc:	mov    QWORD PTR [rbp-0x18],rax
    29e0:	xor    eax,eax
  profile_begin_func();
    29e2:	lea    r8,[rip+0x1e57]        # 4840 <__func__.3>
    29e9:	mov    r9d,0x13
    29ef:	lea    rax,[rbp-0x50]
    29f3:	mov    rsi,r8
    29f6:	mov    rdx,r9
    29f9:	mov    r8d,0x0
    29ff:	mov    ecx,0x2
    2a04:	mov    rdi,rax
    2a07:	call   1f6c <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2a0c:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    2a17:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2a22:	jmp    2cfb <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2a27:	pxor   xmm0,xmm0
    2a2b:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2a32:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2a3a:	pxor   xmm0,xmm0
    2a3e:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2a45:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2a4a:	cmp    DWORD PTR [rbp-0xe8],0x0
    2a51:	je     2b5e <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2a57:	lea    rax,[rbp-0xb0]
    2a5e:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a65:	mov    rsi,rdx
    2a68:	mov    rdi,rax
    2a6b:	call   2294 <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2a70:	mov    eax,DWORD PTR [rbp-0xb0]
    2a76:	cmp    eax,0x7
    2a79:	jne    2afa <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2a7b:	lea    rax,[rbp-0x70]
    2a7f:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a86:	mov    rsi,rdx
    2a89:	mov    rdi,rax
    2a8c:	call   2294 <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2a91:	mov    eax,DWORD PTR [rbp-0x70]
    2a94:	cmp    eax,0x6
    2a97:	jne    2ab7 <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2a99:	lea    rax,[rbp-0x90]
    2aa0:	mov    rdx,QWORD PTR [rbp-0xe0]
    2aa7:	mov    rsi,rdx
    2aaa:	mov    rdi,rax
    2aad:	call   2294 <get_json_token>
    2ab2:	jmp    2b9e <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2ab7:	mov    rcx,QWORD PTR [rbp-0xa8]
    2abe:	mov    rax,QWORD PTR [rbp-0xa0]
    2ac5:	mov    esi,eax
    2ac7:	lea    rdx,[rip+0x1aa2]        # 4570 <_IO_stdin_used+0x570>
    2ace:	lea    rax,[rip+0x19a4]        # 4479 <_IO_stdin_used+0x479>
    2ad5:	mov    r9,rcx
    2ad8:	mov    r8d,esi
    2adb:	mov    rcx,rdx
    2ade:	mov    edx,0x15f
    2ae3:	mov    rsi,rax
    2ae6:	mov    edi,0x1
    2aeb:	mov    eax,0x0
    2af0:	call   14a1 <log_message>
    2af5:	jmp    2b9e <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2afa:	mov    rcx,QWORD PTR [rbp-0xa8]
    2b01:	mov    rax,QWORD PTR [rbp-0xa0]
    2b08:	mov    edi,eax
    2b0a:	mov    eax,DWORD PTR [rbp-0xb0]
    2b10:	mov    eax,eax
    2b12:	lea    rdx,[rax*8+0x0]
    2b1a:	lea    rax,[rip+0x45bf]        # 70e0 <JSON_Token_Type_strings>
    2b21:	mov    rsi,QWORD PTR [rdx+rax*1]
    2b25:	lea    rdx,[rip+0x1a64]        # 4590 <_IO_stdin_used+0x590>
    2b2c:	lea    rax,[rip+0x1946]        # 4479 <_IO_stdin_used+0x479>
    2b33:	sub    rsp,0x8
    2b37:	push   rcx
    2b38:	mov    r9d,edi
    2b3b:	mov    r8,rsi
    2b3e:	mov    rcx,rdx
    2b41:	mov    edx,0x164
    2b46:	mov    rsi,rax
    2b49:	mov    edi,0x1
    2b4e:	mov    eax,0x0
    2b53:	call   14a1 <log_message>
    2b58:	add    rsp,0x10
    2b5c:	jmp    2b9e <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2b5e:	lea    rax,[rbp-0x110]
    2b65:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b6c:	mov    rsi,rdx
    2b6f:	mov    rdi,rax
    2b72:	call   2294 <get_json_token>
    2b77:	mov    rax,QWORD PTR [rbp-0x110]
    2b7e:	mov    rdx,QWORD PTR [rbp-0x108]
    2b85:	mov    QWORD PTR [rbp-0x90],rax
    2b8c:	mov    QWORD PTR [rbp-0x88],rdx
    2b93:	mov    rax,QWORD PTR [rbp-0x100]
    2b9a:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2b9e:	mov    eax,DWORD PTR [rbp-0x90]
    2ba4:	cmp    DWORD PTR [rbp-0xe4],eax
    2baa:	je     2d14 <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2bb0:	mov    rax,QWORD PTR [rbp-0xa8]
    2bb7:	mov    rdx,QWORD PTR [rbp-0xa0]
    2bbe:	mov    r8,QWORD PTR [rbp-0xe0]
    2bc5:	mov    rdi,QWORD PTR [rbp-0xd8]
    2bcc:	sub    rsp,0x8
    2bd0:	sub    rsp,0x18
    2bd4:	mov    rsi,rsp
    2bd7:	mov    rcx,QWORD PTR [rbp-0x90]
    2bde:	mov    rbx,QWORD PTR [rbp-0x88]
    2be5:	mov    QWORD PTR [rsi],rcx
    2be8:	mov    QWORD PTR [rsi+0x8],rbx
    2bec:	mov    rcx,QWORD PTR [rbp-0x80]
    2bf0:	mov    QWORD PTR [rsi+0x10],rcx
    2bf4:	mov    rcx,rdx
    2bf7:	mov    rdx,rax
    2bfa:	mov    rsi,r8
    2bfd:	call   27c6 <parse_json_object>
    2c02:	add    rsp,0x20
    2c06:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2c0d:	cmp    QWORD PTR [rbp-0xb8],0x0
    2c15:	je     2c5f <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2c17:	cmp    QWORD PTR [rbp-0xc8],0x0
    2c1f:	jne    2c3f <parse_json_children+0x292>
      {
        first_child        = object;
    2c21:	mov    rax,QWORD PTR [rbp-0xb8]
    2c28:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2c2f:	mov    rax,QWORD PTR [rbp-0xb8]
    2c36:	mov    QWORD PTR [rbp-0xc0],rax
    2c3d:	jmp    2c5f <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2c3f:	mov    rax,QWORD PTR [rbp-0xc0]
    2c46:	mov    rdx,QWORD PTR [rbp-0xb8]
    2c4d:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2c51:	mov    rax,QWORD PTR [rbp-0xb8]
    2c58:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2c5f:	lea    rax,[rbp-0x70]
    2c63:	mov    rdx,QWORD PTR [rbp-0xe0]
    2c6a:	mov    rsi,rdx
    2c6d:	mov    rdi,rax
    2c70:	call   2294 <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2c75:	mov    eax,DWORD PTR [rbp-0x70]
    2c78:	cmp    DWORD PTR [rbp-0xe4],eax
    2c7e:	je     2d17 <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2c84:	mov    eax,DWORD PTR [rbp-0x70]
    2c87:	cmp    eax,0x5
    2c8a:	je     2cfb <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2c8c:	mov    r8,QWORD PTR [rbp-0x68]
    2c90:	mov    rax,QWORD PTR [rbp-0x60]
    2c94:	mov    r9d,eax
    2c97:	mov    eax,DWORD PTR [rbp-0x70]
    2c9a:	mov    eax,eax
    2c9c:	lea    rdx,[rax*8+0x0]
    2ca4:	lea    rax,[rip+0x4435]        # 70e0 <JSON_Token_Type_strings>
    2cab:	mov    r10,QWORD PTR [rdx+rax*1]
    2caf:	lea    rdi,[rip+0x1902]        # 45b8 <_IO_stdin_used+0x5b8>
    2cb6:	lea    rsi,[rip+0x17bc]        # 4479 <_IO_stdin_used+0x479>
    2cbd:	sub    rsp,0x18
    2cc1:	mov    rcx,rsp
    2cc4:	mov    rax,QWORD PTR [rbp-0x70]
    2cc8:	mov    rdx,QWORD PTR [rbp-0x68]
    2ccc:	mov    QWORD PTR [rcx],rax
    2ccf:	mov    QWORD PTR [rcx+0x8],rdx
    2cd3:	mov    rax,QWORD PTR [rbp-0x60]
    2cd7:	mov    QWORD PTR [rcx+0x10],rax
    2cdb:	push   r8
    2cdd:	mov    r8,r10
    2ce0:	mov    rcx,rdi
    2ce3:	mov    edx,0x18b
    2ce8:	mov    edi,0x1
    2ced:	mov    eax,0x0
    2cf2:	call   14a1 <log_message>
    2cf7:	add    rsp,0x20
  while (parser_incomplete(parser))
    2cfb:	mov    rax,QWORD PTR [rbp-0xe0]
    2d02:	mov    rdi,rax
    2d05:	call   21e9 <parser_incomplete>
    2d0a:	test   al,al
    2d0c:	jne    2a27 <parse_json_children+0x7a>
    2d12:	jmp    2d18 <parse_json_children+0x36b>
      break;
    2d14:	nop
    2d15:	jmp    2d18 <parse_json_children+0x36b>
      break;
    2d17:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2d18:	sub    rsp,0x8
    2d1c:	sub    rsp,0x38
    2d20:	mov    rax,rsp
    2d23:	mov    rcx,QWORD PTR [rbp-0x50]
    2d27:	mov    rbx,QWORD PTR [rbp-0x48]
    2d2b:	mov    QWORD PTR [rax],rcx
    2d2e:	mov    QWORD PTR [rax+0x8],rbx
    2d32:	mov    rcx,QWORD PTR [rbp-0x40]
    2d36:	mov    rbx,QWORD PTR [rbp-0x38]
    2d3a:	mov    QWORD PTR [rax+0x10],rcx
    2d3e:	mov    QWORD PTR [rax+0x18],rbx
    2d42:	mov    rcx,QWORD PTR [rbp-0x30]
    2d46:	mov    rbx,QWORD PTR [rbp-0x28]
    2d4a:	mov    QWORD PTR [rax+0x20],rcx
    2d4e:	mov    QWORD PTR [rax+0x28],rbx
    2d52:	mov    rdx,QWORD PTR [rbp-0x20]
    2d56:	mov    QWORD PTR [rax+0x30],rdx
    2d5a:	call   2056 <__profile_end_pass>
    2d5f:	add    rsp,0x40

  return first_child;
    2d63:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2d6a:	mov    rdx,QWORD PTR [rbp-0x18]
    2d6e:	sub    rdx,QWORD PTR fs:0x28
    2d77:	je     2d7e <parse_json_children+0x3d1>
    2d79:	call   1060 <__stack_chk_fail@plt>
    2d7e:	mov    rbx,QWORD PTR [rbp-0x8]
    2d82:	leave
    2d83:	ret

0000000000002d84 <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2d84:	push   rbp
    2d85:	mov    rbp,rsp
    2d88:	push   rbx
    2d89:	sub    rsp,0xb8
    2d90:	mov    QWORD PTR [rbp-0xa8],rdi
    2d97:	mov    rax,rsi
    2d9a:	mov    rsi,rdx
    2d9d:	mov    rax,rax
    2da0:	mov    edx,0x0
    2da5:	mov    rdx,rsi
    2da8:	mov    QWORD PTR [rbp-0xc0],rax
    2daf:	mov    QWORD PTR [rbp-0xb8],rdx
    2db6:	mov    rax,QWORD PTR fs:0x28
    2dbf:	mov    QWORD PTR [rbp-0x18],rax
    2dc3:	xor    eax,eax
  profile_begin_func();
    2dc5:	lea    rcx,[rip+0x1a8c]        # 4858 <__func__.2>
    2dcc:	mov    ebx,0xa
    2dd1:	lea    rax,[rbp-0x50]
    2dd5:	mov    rsi,rcx
    2dd8:	mov    rdx,rbx
    2ddb:	mov    r8d,0x0
    2de1:	mov    ecx,0x3
    2de6:	mov    rdi,rax
    2de9:	call   1f6c <__profile_begin_pass>

  JSON_Parser parser =
    2dee:	mov    rax,QWORD PTR [rbp-0xc0]
    2df5:	mov    rdx,QWORD PTR [rbp-0xb8]
    2dfc:	mov    QWORD PTR [rbp-0x90],rax
    2e03:	mov    QWORD PTR [rbp-0x88],rdx
    2e0a:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2e12:	lea    rax,[rbp-0x70]
    2e16:	lea    rdx,[rbp-0x90]
    2e1d:	mov    rsi,rdx
    2e20:	mov    rdi,rax
    2e23:	call   2294 <get_json_token>
    2e28:	mov    ecx,0x0
    2e2d:	mov    ebx,0x0
    2e32:	lea    r8,[rbp-0x90]
    2e39:	mov    rdi,QWORD PTR [rbp-0xa8]
    2e40:	sub    rsp,0x8
    2e44:	sub    rsp,0x18
    2e48:	mov    rsi,rsp
    2e4b:	mov    rax,QWORD PTR [rbp-0x70]
    2e4f:	mov    rdx,QWORD PTR [rbp-0x68]
    2e53:	mov    QWORD PTR [rsi],rax
    2e56:	mov    QWORD PTR [rsi+0x8],rdx
    2e5a:	mov    rax,QWORD PTR [rbp-0x60]
    2e5e:	mov    QWORD PTR [rsi+0x10],rax
    2e62:	mov    rdx,rcx
    2e65:	mov    rcx,rbx
    2e68:	mov    rsi,r8
    2e6b:	call   27c6 <parse_json_object>
    2e70:	add    rsp,0x20
    2e74:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2e7b:	sub    rsp,0x8
    2e7f:	sub    rsp,0x38
    2e83:	mov    rax,rsp
    2e86:	mov    rcx,QWORD PTR [rbp-0x50]
    2e8a:	mov    rbx,QWORD PTR [rbp-0x48]
    2e8e:	mov    QWORD PTR [rax],rcx
    2e91:	mov    QWORD PTR [rax+0x8],rbx
    2e95:	mov    rcx,QWORD PTR [rbp-0x40]
    2e99:	mov    rbx,QWORD PTR [rbp-0x38]
    2e9d:	mov    QWORD PTR [rax+0x10],rcx
    2ea1:	mov    QWORD PTR [rax+0x18],rbx
    2ea5:	mov    rcx,QWORD PTR [rbp-0x30]
    2ea9:	mov    rbx,QWORD PTR [rbp-0x28]
    2ead:	mov    QWORD PTR [rax+0x20],rcx
    2eb1:	mov    QWORD PTR [rax+0x28],rbx
    2eb5:	mov    rdx,QWORD PTR [rbp-0x20]
    2eb9:	mov    QWORD PTR [rax+0x30],rdx
    2ebd:	call   2056 <__profile_end_pass>
    2ec2:	add    rsp,0x40

  return outer;
    2ec6:	mov    rax,QWORD PTR [rbp-0x98]
}
    2ecd:	mov    rdx,QWORD PTR [rbp-0x18]
    2ed1:	sub    rdx,QWORD PTR fs:0x28
    2eda:	je     2ee1 <parse_json+0x15d>
    2edc:	call   1060 <__stack_chk_fail@plt>
    2ee1:	mov    rbx,QWORD PTR [rbp-0x8]
    2ee5:	leave
    2ee6:	ret

0000000000002ee7 <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2ee7:	push   rbp
    2ee8:	mov    rbp,rsp
    2eeb:	push   rbx
    2eec:	sub    rsp,0x78
    2ef0:	mov    QWORD PTR [rbp-0x68],rdi
    2ef4:	mov    rax,rsi
    2ef7:	mov    rsi,rdx
    2efa:	mov    rax,rax
    2efd:	mov    edx,0x0
    2f02:	mov    rdx,rsi
    2f05:	mov    QWORD PTR [rbp-0x80],rax
    2f09:	mov    QWORD PTR [rbp-0x78],rdx
    2f0d:	mov    rax,QWORD PTR fs:0x28
    2f16:	mov    QWORD PTR [rbp-0x18],rax
    2f1a:	xor    eax,eax
  profile_begin_func();
    2f1c:	lea    rcx,[rip+0x194d]        # 4870 <__func__.1>
    2f23:	mov    ebx,0x12
    2f28:	lea    rax,[rbp-0x50]
    2f2c:	mov    rsi,rcx
    2f2f:	mov    rdx,rbx
    2f32:	mov    r8d,0x0
    2f38:	mov    ecx,0x4
    2f3d:	mov    rdi,rax
    2f40:	call   1f6c <__profile_begin_pass>

  JSON_Object *result = NULL;
    2f45:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2f4d:	cmp    QWORD PTR [rbp-0x68],0x0
    2f52:	je     2fa1 <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f54:	mov    rax,QWORD PTR [rbp-0x68]
    2f58:	mov    rax,QWORD PTR [rax+0x20]
    2f5c:	mov    QWORD PTR [rbp-0x58],rax
    2f60:	jmp    2f9a <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2f62:	mov    rax,QWORD PTR [rbp-0x58]
    2f66:	mov    rdx,QWORD PTR [rax+0x8]
    2f6a:	mov    rax,QWORD PTR [rax]
    2f6d:	mov    rdi,QWORD PTR [rbp-0x80]
    2f71:	mov    rsi,QWORD PTR [rbp-0x78]
    2f75:	mov    rcx,rdx
    2f78:	mov    rdx,rax
    2f7b:	call   143f <strings_equal>
    2f80:	test   al,al
    2f82:	je     2f8e <lookup_json_object+0xa7>
      {
        result = cursor;
    2f84:	mov    rax,QWORD PTR [rbp-0x58]
    2f88:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2f8c:	jmp    2fa1 <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f8e:	mov    rax,QWORD PTR [rbp-0x58]
    2f92:	mov    rax,QWORD PTR [rax+0x28]
    2f96:	mov    QWORD PTR [rbp-0x58],rax
    2f9a:	cmp    QWORD PTR [rbp-0x58],0x0
    2f9f:	jne    2f62 <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2fa1:	sub    rsp,0x8
    2fa5:	sub    rsp,0x38
    2fa9:	mov    rax,rsp
    2fac:	mov    rcx,QWORD PTR [rbp-0x50]
    2fb0:	mov    rbx,QWORD PTR [rbp-0x48]
    2fb4:	mov    QWORD PTR [rax],rcx
    2fb7:	mov    QWORD PTR [rax+0x8],rbx
    2fbb:	mov    rcx,QWORD PTR [rbp-0x40]
    2fbf:	mov    rbx,QWORD PTR [rbp-0x38]
    2fc3:	mov    QWORD PTR [rax+0x10],rcx
    2fc7:	mov    QWORD PTR [rax+0x18],rbx
    2fcb:	mov    rcx,QWORD PTR [rbp-0x30]
    2fcf:	mov    rbx,QWORD PTR [rbp-0x28]
    2fd3:	mov    QWORD PTR [rax+0x20],rcx
    2fd7:	mov    QWORD PTR [rax+0x28],rbx
    2fdb:	mov    rdx,QWORD PTR [rbp-0x20]
    2fdf:	mov    QWORD PTR [rax+0x30],rdx
    2fe3:	call   2056 <__profile_end_pass>
    2fe8:	add    rsp,0x40

  return result;
    2fec:	mov    rax,QWORD PTR [rbp-0x60]
}
    2ff0:	mov    rdx,QWORD PTR [rbp-0x18]
    2ff4:	sub    rdx,QWORD PTR fs:0x28
    2ffd:	je     3004 <lookup_json_object+0x11d>
    2fff:	call   1060 <__stack_chk_fail@plt>
    3004:	mov    rbx,QWORD PTR [rbp-0x8]
    3008:	leave
    3009:	ret

000000000000300a <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    300a:	push   rbp
    300b:	mov    rbp,rsp
    300e:	sub    rsp,0x50
    3012:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    3016:	cmp    QWORD PTR [rbp-0x48],0x0
    301b:	jne    3042 <json_object_to_f64+0x38>
    301d:	lea    rdx,[rip+0x186c]        # 4890 <__PRETTY_FUNCTION__.0>
    3024:	lea    rsi,[rip+0x144e]        # 4479 <_IO_stdin_used+0x479>
    302b:	lea    rax,[rip+0x15c6]        # 45f8 <_IO_stdin_used+0x5f8>
    3032:	mov    rcx,rdx
    3035:	mov    edx,0x1c2
    303a:	mov    rdi,rax
    303d:	call   1090 <__assert_fail@plt>

  String val = object->value;
    3042:	mov    rax,QWORD PTR [rbp-0x48]
    3046:	mov    rdx,QWORD PTR [rax+0x18]
    304a:	mov    rax,QWORD PTR [rax+0x10]
    304e:	mov    QWORD PTR [rbp-0x10],rax
    3052:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    3056:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    305e:	movsd  xmm0,QWORD PTR [rip+0x185a]        # 48c0 <__PRETTY_FUNCTION__.0+0x30>
    3066:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    306b:	mov    rax,QWORD PTR [rbp-0x8]
    306f:	cmp    QWORD PTR [rbp-0x30],rax
    3073:	jae    3099 <json_object_to_f64+0x8f>
    3075:	mov    rdx,QWORD PTR [rbp-0x10]
    3079:	mov    rax,QWORD PTR [rbp-0x30]
    307d:	add    rax,rdx
    3080:	movzx  eax,BYTE PTR [rax]
    3083:	cmp    al,0x2d
    3085:	jne    3099 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    3087:	movsd  xmm0,QWORD PTR [rip+0x1839]        # 48c8 <__PRETTY_FUNCTION__.0+0x38>
    308f:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    3094:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    3099:	pxor   xmm0,xmm0
    309d:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    30a2:	jmp    30e9 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    30a4:	mov    rdx,QWORD PTR [rbp-0x10]
    30a8:	mov    rax,QWORD PTR [rbp-0x30]
    30ac:	add    rax,rdx
    30af:	movzx  eax,BYTE PTR [rax]
    30b2:	sub    eax,0x30
    30b5:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    30b8:	cmp    BYTE PTR [rbp-0x32],0x9
    30bc:	ja     30f5 <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    30be:	movsd  xmm1,QWORD PTR [rbp-0x20]
    30c3:	movsd  xmm0,QWORD PTR [rip+0x1805]        # 48d0 <__PRETTY_FUNCTION__.0+0x40>
    30cb:	mulsd  xmm1,xmm0
    30cf:	movzx  eax,BYTE PTR [rbp-0x32]
    30d3:	pxor   xmm0,xmm0
    30d7:	cvtsi2sd xmm0,eax
    30db:	addsd  xmm0,xmm1
    30df:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    30e4:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    30e9:	mov    rax,QWORD PTR [rbp-0x8]
    30ed:	cmp    QWORD PTR [rbp-0x30],rax
    30f1:	jb     30a4 <json_object_to_f64+0x9a>
    30f3:	jmp    30f6 <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    30f5:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    30f6:	mov    rax,QWORD PTR [rbp-0x8]
    30fa:	cmp    QWORD PTR [rbp-0x30],rax
    30fe:	jae    318b <json_object_to_f64+0x181>
    3104:	mov    rdx,QWORD PTR [rbp-0x10]
    3108:	mov    rax,QWORD PTR [rbp-0x30]
    310c:	add    rax,rdx
    310f:	movzx  eax,BYTE PTR [rax]
    3112:	cmp    al,0x2e
    3114:	jne    318b <json_object_to_f64+0x181>
  {
    at += 1;
    3116:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    311b:	movsd  xmm0,QWORD PTR [rip+0x17b5]        # 48d8 <__PRETTY_FUNCTION__.0+0x48>
    3123:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    3128:	jmp    317e <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    312a:	mov    rdx,QWORD PTR [rbp-0x10]
    312e:	mov    rax,QWORD PTR [rbp-0x30]
    3132:	add    rax,rdx
    3135:	movzx  eax,BYTE PTR [rax]
    3138:	sub    eax,0x30
    313b:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    313e:	cmp    BYTE PTR [rbp-0x31],0x9
    3142:	ja     318a <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    3144:	movzx  eax,BYTE PTR [rbp-0x31]
    3148:	pxor   xmm0,xmm0
    314c:	cvtsi2sd xmm0,eax
    3150:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    3155:	movsd  xmm1,QWORD PTR [rbp-0x20]
    315a:	addsd  xmm0,xmm1
    315e:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    3163:	movsd  xmm1,QWORD PTR [rbp-0x18]
    3168:	movsd  xmm0,QWORD PTR [rip+0x1768]        # 48d8 <__PRETTY_FUNCTION__.0+0x48>
    3170:	mulsd  xmm0,xmm1
    3174:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3179:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    317e:	mov    rax,QWORD PTR [rbp-0x8]
    3182:	cmp    QWORD PTR [rbp-0x30],rax
    3186:	jb     312a <json_object_to_f64+0x120>
    3188:	jmp    318b <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    318a:	nop
      }
    }
  }

  return sign * result;
    318b:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3190:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    3195:	leave
    3196:	ret

0000000000003197 <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    3197:	push   rbp
    3198:	mov    rbp,rsp
    319b:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    31a0:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31a5:	movsd  xmm1,QWORD PTR [rip+0x1733]        # 48e0 <__PRETTY_FUNCTION__.0+0x50>
    31ad:	divsd  xmm0,xmm1
}
    31b1:	pop    rbp
    31b2:	ret

00000000000031b3 <square>:

static
f64 square(f64 x)
{
    31b3:	push   rbp
    31b4:	mov    rbp,rsp
    31b7:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    31bc:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31c1:	mulsd  xmm0,xmm0
}
    31c5:	pop    rbp
    31c6:	ret

00000000000031c7 <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    31c7:	push   rbp
    31c8:	mov    rbp,rsp
    31cb:	sub    rsp,0x90
    31d2:	movsd  QWORD PTR [rbp-0x58],xmm0
    31d7:	movsd  QWORD PTR [rbp-0x60],xmm1
    31dc:	movsd  QWORD PTR [rbp-0x68],xmm2
    31e1:	movsd  QWORD PTR [rbp-0x70],xmm3
    31e6:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    31eb:	movsd  xmm0,QWORD PTR [rbp-0x60]
    31f0:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    31f5:	movsd  xmm0,QWORD PTR [rbp-0x70]
    31fa:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    31ff:	movsd  xmm0,QWORD PTR [rbp-0x58]
    3204:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    3209:	movsd  xmm0,QWORD PTR [rbp-0x68]
    320e:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    3213:	movsd  xmm0,QWORD PTR [rbp-0x40]
    3218:	subsd  xmm0,QWORD PTR [rbp-0x48]
    321d:	movq   rax,xmm0
    3222:	movq   xmm0,rax
    3227:	call   3197 <to_radians>
    322c:	movq   rax,xmm0
    3231:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    3235:	movsd  xmm0,QWORD PTR [rbp-0x30]
    323a:	subsd  xmm0,QWORD PTR [rbp-0x38]
    323f:	movq   rax,xmm0
    3244:	movq   xmm0,rax
    3249:	call   3197 <to_radians>
    324e:	movq   rax,xmm0
    3253:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    3257:	mov    rax,QWORD PTR [rbp-0x48]
    325b:	movq   xmm0,rax
    3260:	call   3197 <to_radians>
    3265:	movq   rax,xmm0
    326a:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    326e:	mov    rax,QWORD PTR [rbp-0x40]
    3272:	movq   xmm0,rax
    3277:	call   3197 <to_radians>
    327c:	movq   rax,xmm0
    3281:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    3285:	movsd  xmm0,QWORD PTR [rbp-0x28]
    328a:	movsd  xmm1,QWORD PTR [rip+0x1656]        # 48e8 <__PRETTY_FUNCTION__.0+0x58>
    3292:	divsd  xmm0,xmm1
    3296:	movq   rax,xmm0
    329b:	movq   xmm0,rax
    32a0:	call   1130 <sin@plt>
    32a5:	movq   rax,xmm0
    32aa:	movq   xmm0,rax
    32af:	call   31b3 <square>
    32b4:	movsd  QWORD PTR [rbp-0x80],xmm0
    32b9:	mov    rax,QWORD PTR [rbp-0x48]
    32bd:	movq   xmm0,rax
    32c2:	call   10b0 <cos@plt>
    32c7:	movsd  QWORD PTR [rbp-0x88],xmm0
    32cf:	mov    rax,QWORD PTR [rbp-0x40]
    32d3:	movq   xmm0,rax
    32d8:	call   10b0 <cos@plt>
    32dd:	movapd xmm5,xmm0
    32e1:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    32e9:	movsd  QWORD PTR [rbp-0x88],xmm5
    32f1:	movsd  xmm0,QWORD PTR [rbp-0x20]
    32f6:	movsd  xmm1,QWORD PTR [rip+0x15ea]        # 48e8 <__PRETTY_FUNCTION__.0+0x58>
    32fe:	movapd xmm6,xmm0
    3302:	divsd  xmm6,xmm1
    3306:	movq   rax,xmm6
    330b:	movq   xmm0,rax
    3310:	call   1130 <sin@plt>
    3315:	movq   rax,xmm0
    331a:	movq   xmm0,rax
    331f:	call   31b3 <square>
    3324:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    332c:	addsd  xmm0,QWORD PTR [rbp-0x80]
    3331:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    3336:	mov    rax,QWORD PTR [rbp-0x18]
    333a:	movq   xmm0,rax
    333f:	call   1160 <sqrt@plt>
    3344:	movq   rax,xmm0
    3349:	movq   xmm0,rax
    334e:	call   1140 <asin@plt>
    3353:	addsd  xmm0,xmm0
    3357:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    335c:	movsd  xmm0,QWORD PTR [rbp-0x78]
    3361:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    3366:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    336b:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    3370:	leave
    3371:	ret

0000000000003372 <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    3372:	push   rbp
    3373:	mov    rbp,rsp
    3376:	movsd  QWORD PTR [rbp-0x18],xmm0
    337b:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    3380:	movsd  xmm0,QWORD PTR [rip+0x1568]        # 48f0 <__PRETTY_FUNCTION__.0+0x60>
    3388:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    338d:	movsd  xmm0,QWORD PTR [rbp-0x18]
    3392:	movq   xmm1,QWORD PTR [rip+0x1566]        # 4900 <__PRETTY_FUNCTION__.0+0x70>
    339a:	andpd  xmm0,xmm1
    339e:	movsd  xmm1,QWORD PTR [rbp-0x20]
    33a3:	movq   xmm2,QWORD PTR [rip+0x1555]        # 4900 <__PRETTY_FUNCTION__.0+0x70>
    33ab:	andpd  xmm2,xmm1
    33af:	movapd xmm1,xmm0
    33b3:	subsd  xmm1,xmm2
    33b7:	movsd  xmm0,QWORD PTR [rbp-0x8]
    33bc:	comisd xmm0,xmm1
    33c0:	setae  al
    33c3:	movzx  eax,al
}
    33c6:	pop    rbp
    33c7:	ret

00000000000033c8 <main>:

int main(int args_count, char **args)
{
    33c8:	push   rbp
    33c9:	mov    rbp,rsp
    33cc:	push   r15
    33ce:	push   r14
    33d0:	push   r13
    33d2:	push   r12
    33d4:	push   rbx
    33d5:	sub    rsp,0x2d8
    33dc:	mov    DWORD PTR [rbp-0x244],edi
    33e2:	mov    QWORD PTR [rbp-0x250],rsi
    33e9:	mov    rax,QWORD PTR fs:0x28
    33f2:	mov    QWORD PTR [rbp-0x38],rax
    33f6:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    33f8:	cmp    DWORD PTR [rbp-0x244],0x3
    33ff:	je     342c <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    3401:	mov    rax,QWORD PTR [rbp-0x250]
    3408:	mov    rax,QWORD PTR [rax]
    340b:	lea    rdx,[rip+0x121e]        # 4630 <_IO_stdin_used+0x630>
    3412:	mov    rsi,rax
    3415:	mov    rdi,rdx
    3418:	mov    eax,0x0
    341d:	call   1070 <printf@plt>
    return 1;
    3422:	mov    eax,0x1
    3427:	jmp    3ee0 <main+0xb18>
  }

  begin_profiling();
    342c:	call   1b3d <begin_profiling>

  Arena arena = {0};
    3431:	pxor   xmm0,xmm0
    3435:	movaps XMMWORD PTR [rbp-0x190],xmm0
    343c:	movaps XMMWORD PTR [rbp-0x180],xmm0
  arena = arena_make(GB(4));
    3443:	lea    rdx,[rbp-0x270]
    344a:	movabs rax,0x100000000
    3454:	mov    rsi,rax
    3457:	mov    rdi,rdx
    345a:	call   1632 <arena_make>
    345f:	mov    rax,QWORD PTR [rbp-0x270]
    3466:	mov    rdx,QWORD PTR [rbp-0x268]
    346d:	mov    QWORD PTR [rbp-0x190],rax
    3474:	mov    QWORD PTR [rbp-0x188],rdx
    347b:	mov    rax,QWORD PTR [rbp-0x260]
    3482:	mov    rdx,QWORD PTR [rbp-0x258]
    3489:	mov    QWORD PTR [rbp-0x180],rax
    3490:	mov    QWORD PTR [rbp-0x178],rdx

  String source = {0};
    3497:	mov    QWORD PTR [rbp-0x1a0],0x0
    34a2:	mov    QWORD PTR [rbp-0x198],0x0
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    34ad:	mov    rax,QWORD PTR [rbp-0x250]
    34b4:	add    rax,0x8
    34b8:	mov    rax,QWORD PTR [rax]
    34bb:	mov    rdi,rax
    34be:	call   1303 <file_size>
    34c3:	mov    rcx,rax
    34c6:	lea    r12,[rip+0x118f]        # 465c <_IO_stdin_used+0x65c>
    34cd:	mov    r13d,0x4
    34d3:	lea    rdi,[rbp-0x170]
    34da:	mov    rdx,r12
    34dd:	mov    rax,r13
    34e0:	mov    r8,rcx
    34e3:	mov    ecx,0x5
    34e8:	mov    rsi,rdx
    34eb:	mov    rdx,rax
    34ee:	call   1f6c <__profile_begin_pass>
    34f3:	mov    QWORD PTR [rbp-0x230],0x0
    34fe:	jmp    3599 <main+0x1d1>
  {
    source = read_file_to_arena(&arena, args[1]);
    3503:	mov    rax,QWORD PTR [rbp-0x250]
    350a:	add    rax,0x8
    350e:	mov    rdx,QWORD PTR [rax]
    3511:	lea    rax,[rbp-0x190]
    3518:	mov    rsi,rdx
    351b:	mov    rdi,rax
    351e:	call   1357 <read_file_to_arena>
    3523:	mov    QWORD PTR [rbp-0x1a0],rax
    352a:	mov    QWORD PTR [rbp-0x198],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    3531:	add    QWORD PTR [rbp-0x230],0x1
    3539:	sub    rsp,0x8
    353d:	sub    rsp,0x38
    3541:	mov    rcx,rsp
    3544:	mov    rax,QWORD PTR [rbp-0x170]
    354b:	mov    rdx,QWORD PTR [rbp-0x168]
    3552:	mov    QWORD PTR [rcx],rax
    3555:	mov    QWORD PTR [rcx+0x8],rdx
    3559:	mov    rax,QWORD PTR [rbp-0x160]
    3560:	mov    rdx,QWORD PTR [rbp-0x158]
    3567:	mov    QWORD PTR [rcx+0x10],rax
    356b:	mov    QWORD PTR [rcx+0x18],rdx
    356f:	mov    rax,QWORD PTR [rbp-0x150]
    3576:	mov    rdx,QWORD PTR [rbp-0x148]
    357d:	mov    QWORD PTR [rcx+0x20],rax
    3581:	mov    QWORD PTR [rcx+0x28],rdx
    3585:	mov    rax,QWORD PTR [rbp-0x140]
    358c:	mov    QWORD PTR [rcx+0x30],rax
    3590:	call   2056 <__profile_end_pass>
    3595:	add    rsp,0x40
    3599:	cmp    QWORD PTR [rbp-0x230],0x0
    35a1:	je     3503 <main+0x13b>
  }

  Haversine_Pair *pairs = NULL;
    35a7:	mov    QWORD PTR [rbp-0x228],0x0
  i32 pair_count = 0;
    35b2:	mov    DWORD PTR [rbp-0x238],0x0
  usize max_pairs = 0;
    35bc:	mov    QWORD PTR [rbp-0x220],0x0
  PROFILE_SCOPE("haversine alloc")
    35c7:	lea    r14,[rip+0x1093]        # 4661 <_IO_stdin_used+0x661>
    35ce:	mov    r15d,0xf
    35d4:	lea    rdi,[rbp-0x130]
    35db:	mov    rdx,r14
    35de:	mov    rax,r15
    35e1:	mov    r8d,0x0
    35e7:	mov    ecx,0x6
    35ec:	mov    rsi,rdx
    35ef:	mov    rdx,rax
    35f2:	call   1f6c <__profile_begin_pass>
    35f7:	mov    QWORD PTR [rbp-0x218],0x0
    3602:	jmp    36ca <main+0x302>
  {
    usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    3607:	mov    QWORD PTR [rbp-0x1a8],0x18
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    3612:	mov    rax,QWORD PTR [rbp-0x198]
    3619:	mov    edx,0x0
    361e:	div    QWORD PTR [rbp-0x1a8]
    3625:	mov    QWORD PTR [rbp-0x220],rax

    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    362c:	mov    rax,QWORD PTR [rbp-0x220]
    3633:	shl    rax,0x5
    3637:	mov    rcx,rax
    363a:	lea    rax,[rbp-0x190]
    3641:	mov    edx,0x8
    3646:	mov    rsi,rcx
    3649:	mov    rdi,rax
    364c:	call   17d3 <arena_alloc>
    3651:	mov    QWORD PTR [rbp-0x228],rax
    pair_count = 0;
    3658:	mov    DWORD PTR [rbp-0x238],0x0
  PROFILE_SCOPE("haversine alloc")
    3662:	add    QWORD PTR [rbp-0x218],0x1
    366a:	sub    rsp,0x8
    366e:	sub    rsp,0x38
    3672:	mov    rcx,rsp
    3675:	mov    rax,QWORD PTR [rbp-0x130]
    367c:	mov    rdx,QWORD PTR [rbp-0x128]
    3683:	mov    QWORD PTR [rcx],rax
    3686:	mov    QWORD PTR [rcx+0x8],rdx
    368a:	mov    rax,QWORD PTR [rbp-0x120]
    3691:	mov    rdx,QWORD PTR [rbp-0x118]
    3698:	mov    QWORD PTR [rcx+0x10],rax
    369c:	mov    QWORD PTR [rcx+0x18],rdx
    36a0:	mov    rax,QWORD PTR [rbp-0x110]
    36a7:	mov    rdx,QWORD PTR [rbp-0x108]
    36ae:	mov    QWORD PTR [rcx+0x20],rax
    36b2:	mov    QWORD PTR [rcx+0x28],rdx
    36b6:	mov    rax,QWORD PTR [rbp-0x100]
    36bd:	mov    QWORD PTR [rcx+0x30],rax
    36c1:	call   2056 <__profile_end_pass>
    36c6:	add    rsp,0x40
    36ca:	cmp    QWORD PTR [rbp-0x218],0x0
    36d2:	je     3607 <main+0x23f>
  }

  JSON_Object *root = NULL;
    36d8:	mov    QWORD PTR [rbp-0x1d8],0x0
  root = parse_json(&arena, source);
    36e3:	mov    rcx,QWORD PTR [rbp-0x1a0]
    36ea:	mov    rdx,QWORD PTR [rbp-0x198]
    36f1:	lea    rax,[rbp-0x190]
    36f8:	mov    rsi,rcx
    36fb:	mov    rdi,rax
    36fe:	call   2d84 <parse_json>
    3703:	mov    QWORD PTR [rbp-0x1d8],rax

  f64 haversine_sum = 0.0;
    370a:	pxor   xmm0,xmm0
    370e:	movsd  QWORD PTR [rbp-0x1d0],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    3716:	lea    rax,[rip+0xf54]        # 4671 <_IO_stdin_used+0x671>
    371d:	mov    QWORD PTR [rbp-0x280],rax
    3724:	mov    QWORD PTR [rbp-0x278],0x5
    372f:	mov    rax,QWORD PTR [rbp-0x280]
    3736:	mov    rdx,QWORD PTR [rbp-0x278]
    373d:	mov    rcx,rax
    3740:	mov    rax,QWORD PTR [rbp-0x1d8]
    3747:	mov    rsi,rcx
    374a:	mov    rdi,rax
    374d:	call   2ee7 <lookup_json_object>
    3752:	mov    QWORD PTR [rbp-0x1c8],rax
  if (pairs)
    3759:	cmp    QWORD PTR [rbp-0x228],0x0
    3761:	je     39f6 <main+0x62e>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    3767:	mov    rax,QWORD PTR [rbp-0x1c8]
    376e:	mov    rax,QWORD PTR [rax+0x20]
    3772:	mov    QWORD PTR [rbp-0x210],rax
    3779:	jmp    39d7 <main+0x60f>
    {
      PROFILE_SCOPE("child convert")
    377e:	lea    rax,[rip+0xef2]        # 4677 <_IO_stdin_used+0x677>
    3785:	mov    QWORD PTR [rbp-0x2c0],rax
    378c:	mov    QWORD PTR [rbp-0x2b8],0xd
    3797:	lea    rdi,[rbp-0x70]
    379b:	mov    rbx,QWORD PTR [rbp-0x2c0]
    37a2:	mov    rsi,QWORD PTR [rbp-0x2b8]
    37a9:	mov    rdx,rbx
    37ac:	mov    rax,rsi
    37af:	mov    r8d,0x0
    37b5:	mov    ecx,0x7
    37ba:	mov    rsi,rdx
    37bd:	mov    rdx,rax
    37c0:	call   1f6c <__profile_begin_pass>
    37c5:	mov    QWORD PTR [rbp-0x208],0x0
    37d0:	jmp    39b7 <main+0x5ef>
      {
        Haversine_Pair pair =
        {
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    37d5:	lea    rax,[rip+0xea9]        # 4685 <_IO_stdin_used+0x685>
    37dc:	mov    QWORD PTR [rbp-0x2d0],rax
    37e3:	mov    QWORD PTR [rbp-0x2c8],0x2
    37ee:	mov    rbx,QWORD PTR [rbp-0x2d0]
    37f5:	mov    rsi,QWORD PTR [rbp-0x2c8]
    37fc:	mov    rax,rbx
    37ff:	mov    rdx,rsi
    3802:	mov    rcx,QWORD PTR [rbp-0x210]
    3809:	mov    rsi,rax
    380c:	mov    rdi,rcx
    380f:	call   2ee7 <lookup_json_object>
    3814:	mov    rdi,rax
    3817:	call   300a <json_object_to_f64>
    381c:	movq   rax,xmm0
        Haversine_Pair pair =
    3821:	mov    QWORD PTR [rbp-0xb0],rax
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    3828:	lea    rax,[rip+0xe59]        # 4688 <_IO_stdin_used+0x688>
    382f:	mov    QWORD PTR [rbp-0x2e0],rax
    3836:	mov    QWORD PTR [rbp-0x2d8],0x2
    3841:	mov    rax,QWORD PTR [rbp-0x2e0]
    3848:	mov    rdx,QWORD PTR [rbp-0x2d8]
    384f:	mov    rcx,rax
    3852:	mov    rax,QWORD PTR [rbp-0x210]
    3859:	mov    rsi,rcx
    385c:	mov    rdi,rax
    385f:	call   2ee7 <lookup_json_object>
    3864:	mov    rdi,rax
    3867:	call   300a <json_object_to_f64>
    386c:	movq   rax,xmm0
        Haversine_Pair pair =
    3871:	mov    QWORD PTR [rbp-0xa8],rax
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    3878:	lea    rax,[rip+0xe0c]        # 468b <_IO_stdin_used+0x68b>
    387f:	mov    QWORD PTR [rbp-0x2f0],rax
    3886:	mov    QWORD PTR [rbp-0x2e8],0x2
    3891:	mov    rax,QWORD PTR [rbp-0x2f0]
    3898:	mov    rdx,QWORD PTR [rbp-0x2e8]
    389f:	mov    rcx,rax
    38a2:	mov    rax,QWORD PTR [rbp-0x210]
    38a9:	mov    rsi,rcx
    38ac:	mov    rdi,rax
    38af:	call   2ee7 <lookup_json_object>
    38b4:	mov    rdi,rax
    38b7:	call   300a <json_object_to_f64>
    38bc:	movq   rax,xmm0
        Haversine_Pair pair =
    38c1:	mov    QWORD PTR [rbp-0xa0],rax
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    38c8:	lea    rax,[rip+0xdbf]        # 468e <_IO_stdin_used+0x68e>
    38cf:	mov    QWORD PTR [rbp-0x300],rax
    38d6:	mov    QWORD PTR [rbp-0x2f8],0x2
    38e1:	mov    rax,QWORD PTR [rbp-0x300]
    38e8:	mov    rdx,QWORD PTR [rbp-0x2f8]
    38ef:	mov    rcx,rax
    38f2:	mov    rax,QWORD PTR [rbp-0x210]
    38f9:	mov    rsi,rcx
    38fc:	mov    rdi,rax
    38ff:	call   2ee7 <lookup_json_object>
    3904:	mov    rdi,rax
    3907:	call   300a <json_object_to_f64>
    390c:	movq   rax,xmm0
        Haversine_Pair pair =
    3911:	mov    QWORD PTR [rbp-0x98],rax
        };

        pairs[pair_count] = pair;
    3918:	mov    eax,DWORD PTR [rbp-0x238]
    391e:	cdqe
    3920:	shl    rax,0x5
    3924:	mov    rdx,rax
    3927:	mov    rax,QWORD PTR [rbp-0x228]
    392e:	lea    rcx,[rdx+rax*1]
    3932:	mov    rax,QWORD PTR [rbp-0xb0]
    3939:	mov    rdx,QWORD PTR [rbp-0xa8]
    3940:	mov    QWORD PTR [rcx],rax
    3943:	mov    QWORD PTR [rcx+0x8],rdx
    3947:	mov    rax,QWORD PTR [rbp-0xa0]
    394e:	mov    rdx,QWORD PTR [rbp-0x98]
    3955:	mov    QWORD PTR [rcx+0x10],rax
    3959:	mov    QWORD PTR [rcx+0x18],rdx
        pair_count += 1;
    395d:	add    DWORD PTR [rbp-0x238],0x1
      PROFILE_SCOPE("child convert")
    3964:	add    QWORD PTR [rbp-0x208],0x1
    396c:	sub    rsp,0x8
    3970:	sub    rsp,0x38
    3974:	mov    rcx,rsp
    3977:	mov    rax,QWORD PTR [rbp-0x70]
    397b:	mov    rdx,QWORD PTR [rbp-0x68]
    397f:	mov    QWORD PTR [rcx],rax
    3982:	mov    QWORD PTR [rcx+0x8],rdx
    3986:	mov    rax,QWORD PTR [rbp-0x60]
    398a:	mov    rdx,QWORD PTR [rbp-0x58]
    398e:	mov    QWORD PTR [rcx+0x10],rax
    3992:	mov    QWORD PTR [rcx+0x18],rdx
    3996:	mov    rax,QWORD PTR [rbp-0x50]
    399a:	mov    rdx,QWORD PTR [rbp-0x48]
    399e:	mov    QWORD PTR [rcx+0x20],rax
    39a2:	mov    QWORD PTR [rcx+0x28],rdx
    39a6:	mov    rax,QWORD PTR [rbp-0x40]
    39aa:	mov    QWORD PTR [rcx+0x30],rax
    39ae:	call   2056 <__profile_end_pass>
    39b3:	add    rsp,0x40
    39b7:	cmp    QWORD PTR [rbp-0x208],0x0
    39bf:	je     37d5 <main+0x40d>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    39c5:	mov    rax,QWORD PTR [rbp-0x210]
    39cc:	mov    rax,QWORD PTR [rax+0x28]
    39d0:	mov    QWORD PTR [rbp-0x210],rax
    39d7:	cmp    QWORD PTR [rbp-0x210],0x0
    39df:	je     39f6 <main+0x62e>
    39e1:	mov    eax,DWORD PTR [rbp-0x238]
    39e7:	cdqe
    39e9:	cmp    rax,QWORD PTR [rbp-0x220]
    39f0:	jb     377e <main+0x3b6>
      }
    }
  }

  f64 sum = 0.0;
    39f6:	pxor   xmm0,xmm0
    39fa:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3a02:	lea    rax,[rip+0xc88]        # 4691 <_IO_stdin_used+0x691>
    3a09:	mov    QWORD PTR [rbp-0x290],rax
    3a10:	mov    QWORD PTR [rbp-0x288],0x3
    3a1b:	lea    rax,[rbp-0xf0]
    3a22:	mov    rcx,QWORD PTR [rbp-0x290]
    3a29:	mov    rbx,QWORD PTR [rbp-0x288]
    3a30:	mov    rsi,rcx
    3a33:	mov    rdx,rbx
    3a36:	mov    r8d,0x0
    3a3c:	mov    ecx,0x8
    3a41:	mov    rdi,rax
    3a44:	call   1f6c <__profile_begin_pass>
    3a49:	mov    QWORD PTR [rbp-0x1f8],0x0
    3a54:	jmp    3bd6 <main+0x80e>
  {
    for (usize i = 0; i < pair_count; i++)
    3a59:	mov    QWORD PTR [rbp-0x1f0],0x0
    3a64:	jmp    3b39 <main+0x771>
    {
      f64 earth_radius = 6372.8;
    3a69:	movsd  xmm0,QWORD PTR [rip+0xe9f]        # 4910 <__PRETTY_FUNCTION__.0+0x80>
    3a71:	movsd  QWORD PTR [rbp-0x1b8],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    3a79:	mov    rax,QWORD PTR [rbp-0x1f0]
    3a80:	shl    rax,0x5
    3a84:	mov    rdx,rax
    3a87:	mov    rax,QWORD PTR [rbp-0x228]
    3a8e:	add    rax,rdx
    3a91:	movsd  xmm2,QWORD PTR [rax+0x18]
    3a96:	mov    rax,QWORD PTR [rbp-0x1f0]
    3a9d:	shl    rax,0x5
    3aa1:	mov    rdx,rax
    3aa4:	mov    rax,QWORD PTR [rbp-0x228]
    3aab:	add    rax,rdx
    3aae:	movsd  xmm1,QWORD PTR [rax+0x10]
    3ab3:	mov    rax,QWORD PTR [rbp-0x1f0]
    3aba:	shl    rax,0x5
    3abe:	mov    rdx,rax
    3ac1:	mov    rax,QWORD PTR [rbp-0x228]
    3ac8:	add    rax,rdx
    3acb:	movsd  xmm0,QWORD PTR [rax+0x8]
    3ad0:	mov    rax,QWORD PTR [rbp-0x1f0]
    3ad7:	shl    rax,0x5
    3adb:	mov    rdx,rax
    3ade:	mov    rax,QWORD PTR [rbp-0x228]
    3ae5:	add    rax,rdx
    3ae8:	mov    rax,QWORD PTR [rax]
    3aeb:	movsd  xmm3,QWORD PTR [rbp-0x1b8]
    3af3:	movapd xmm4,xmm3
    3af7:	movapd xmm3,xmm2
    3afb:	movapd xmm2,xmm1
    3aff:	movapd xmm1,xmm0
    3b03:	movq   xmm0,rax
    3b08:	call   31c7 <reference_haversine>
    3b0d:	movq   rax,xmm0
    3b12:	mov    QWORD PTR [rbp-0x1b0],rax
      sum += result;
    3b19:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b21:	addsd  xmm0,QWORD PTR [rbp-0x1b0]
    3b29:	movsd  QWORD PTR [rbp-0x200],xmm0
    for (usize i = 0; i < pair_count; i++)
    3b31:	add    QWORD PTR [rbp-0x1f0],0x1
    3b39:	mov    eax,DWORD PTR [rbp-0x238]
    3b3f:	cdqe
    3b41:	cmp    QWORD PTR [rbp-0x1f0],rax
    3b48:	jb     3a69 <main+0x6a1>
    }
    sum /= pair_count;
    3b4e:	pxor   xmm1,xmm1
    3b52:	cvtsi2sd xmm1,DWORD PTR [rbp-0x238]
    3b5a:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b62:	divsd  xmm0,xmm1
    3b66:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3b6e:	add    QWORD PTR [rbp-0x1f8],0x1
    3b76:	sub    rsp,0x8
    3b7a:	sub    rsp,0x38
    3b7e:	mov    rax,rsp
    3b81:	mov    rcx,QWORD PTR [rbp-0xf0]
    3b88:	mov    rbx,QWORD PTR [rbp-0xe8]
    3b8f:	mov    QWORD PTR [rax],rcx
    3b92:	mov    QWORD PTR [rax+0x8],rbx
    3b96:	mov    rcx,QWORD PTR [rbp-0xe0]
    3b9d:	mov    rbx,QWORD PTR [rbp-0xd8]
    3ba4:	mov    QWORD PTR [rax+0x10],rcx
    3ba8:	mov    QWORD PTR [rax+0x18],rbx
    3bac:	mov    rcx,QWORD PTR [rbp-0xd0]
    3bb3:	mov    rbx,QWORD PTR [rbp-0xc8]
    3bba:	mov    QWORD PTR [rax+0x20],rcx
    3bbe:	mov    QWORD PTR [rax+0x28],rbx
    3bc2:	mov    rdx,QWORD PTR [rbp-0xc0]
    3bc9:	mov    QWORD PTR [rax+0x30],rdx
    3bcd:	call   2056 <__profile_end_pass>
    3bd2:	add    rsp,0x40
    3bd6:	cmp    QWORD PTR [rbp-0x1f8],0x0
    3bde:	je     3a59 <main+0x691>
  }

  PROFILE_SCOPE("check")
    3be4:	lea    rax,[rip+0xaaa]        # 4695 <_IO_stdin_used+0x695>
    3beb:	mov    QWORD PTR [rbp-0x2a0],rax
    3bf2:	mov    QWORD PTR [rbp-0x298],0x5
    3bfd:	lea    rax,[rbp-0xb0]
    3c04:	mov    rcx,QWORD PTR [rbp-0x2a0]
    3c0b:	mov    rbx,QWORD PTR [rbp-0x298]
    3c12:	mov    rsi,rcx
    3c15:	mov    rdx,rbx
    3c18:	mov    r8d,0x0
    3c1e:	mov    ecx,0x9
    3c23:	mov    rdi,rax
    3c26:	call   1f6c <__profile_begin_pass>
    3c2b:	mov    QWORD PTR [rbp-0x1e8],0x0
    3c36:	jmp    3e0b <main+0xa43>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3c3b:	mov    rax,QWORD PTR [rbp-0x250]
    3c42:	add    rax,0x10
    3c46:	mov    rdx,QWORD PTR [rax]
    3c49:	lea    rax,[rbp-0x190]
    3c50:	mov    rsi,rdx
    3c53:	mov    rdi,rax
    3c56:	call   1357 <read_file_to_arena>
    3c5b:	mov    QWORD PTR [rbp-0x70],rax
    3c5f:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3c63:	mov    rax,QWORD PTR [rbp-0x68]
    3c67:	cmp    rax,0xb
    3c6b:	jbe    3d7e <main+0x9b6>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3c71:	mov    rax,QWORD PTR [rbp-0x70]
    3c75:	movsd  xmm0,QWORD PTR [rax]
    3c79:	movsd  QWORD PTR [rbp-0x1c0],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3c81:	mov    rax,QWORD PTR [rbp-0x70]
    3c85:	mov    eax,DWORD PTR [rax+0x8]
    3c88:	mov    DWORD PTR [rbp-0x234],eax

      if (solution_pairs == pair_count)
    3c8e:	mov    eax,DWORD PTR [rbp-0x234]
    3c94:	cmp    eax,DWORD PTR [rbp-0x238]
    3c9a:	jne    3d42 <main+0x97a>
      {
        if (epsilon_equal(solution_sum, sum))
    3ca0:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3ca8:	mov    rax,QWORD PTR [rbp-0x1c0]
    3caf:	movapd xmm1,xmm0
    3cb3:	movq   xmm0,rax
    3cb8:	call   3372 <epsilon_equal>
    3cbd:	test   eax,eax
    3cbf:	je     3d03 <main+0x93b>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3cc1:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3cc9:	mov    rax,QWORD PTR [rbp-0x1c0]
    3cd0:	lea    rdx,[rip+0x9c9]        # 46a0 <_IO_stdin_used+0x6a0>
    3cd7:	lea    rsi,[rip+0x9f5]        # 46d3 <_IO_stdin_used+0x6d3>
    3cde:	movapd xmm1,xmm0
    3ce2:	movq   xmm0,rax
    3ce7:	mov    rcx,rdx
    3cea:	mov    edx,0x64
    3cef:	mov    edi,0x3
    3cf4:	mov    eax,0x2
    3cf9:	call   14a1 <log_message>
    3cfe:	jmp    3da6 <main+0x9de>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3d03:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3d0b:	mov    rax,QWORD PTR [rbp-0x1c0]
    3d12:	lea    rdx,[rip+0x9cf]        # 46e8 <_IO_stdin_used+0x6e8>
    3d19:	lea    rsi,[rip+0x9b3]        # 46d3 <_IO_stdin_used+0x6d3>
    3d20:	movapd xmm1,xmm0
    3d24:	movq   xmm0,rax
    3d29:	mov    rcx,rdx
    3d2c:	mov    edx,0x68
    3d31:	mov    edi,0x1
    3d36:	mov    eax,0x2
    3d3b:	call   14a1 <log_message>
    3d40:	jmp    3da6 <main+0x9de>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3d42:	mov    esi,DWORD PTR [rbp-0x238]
    3d48:	mov    ecx,DWORD PTR [rbp-0x234]
    3d4e:	lea    rdx,[rip+0x9cb]        # 4720 <_IO_stdin_used+0x720>
    3d55:	lea    rax,[rip+0x977]        # 46d3 <_IO_stdin_used+0x6d3>
    3d5c:	mov    r9d,esi
    3d5f:	mov    r8d,ecx
    3d62:	mov    rcx,rdx
    3d65:	mov    edx,0x6d
    3d6a:	mov    rsi,rax
    3d6d:	mov    edi,0x1
    3d72:	mov    eax,0x0
    3d77:	call   14a1 <log_message>
    3d7c:	jmp    3da6 <main+0x9de>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3d7e:	lea    rdx,[rip+0x9e3]        # 4768 <_IO_stdin_used+0x768>
    3d85:	lea    rax,[rip+0x947]        # 46d3 <_IO_stdin_used+0x6d3>
    3d8c:	mov    rcx,rdx
    3d8f:	mov    edx,0x72
    3d94:	mov    rsi,rax
    3d97:	mov    edi,0x1
    3d9c:	mov    eax,0x0
    3da1:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3da6:	add    QWORD PTR [rbp-0x1e8],0x1
    3dae:	sub    rsp,0x8
    3db2:	sub    rsp,0x38
    3db6:	mov    rax,rsp
    3db9:	mov    rcx,QWORD PTR [rbp-0xb0]
    3dc0:	mov    rbx,QWORD PTR [rbp-0xa8]
    3dc7:	mov    QWORD PTR [rax],rcx
    3dca:	mov    QWORD PTR [rax+0x8],rbx
    3dce:	mov    rcx,QWORD PTR [rbp-0xa0]
    3dd5:	mov    rbx,QWORD PTR [rbp-0x98]
    3ddc:	mov    QWORD PTR [rax+0x10],rcx
    3de0:	mov    QWORD PTR [rax+0x18],rbx
    3de4:	mov    rcx,QWORD PTR [rbp-0x90]
    3deb:	mov    rbx,QWORD PTR [rbp-0x88]
    3df2:	mov    QWORD PTR [rax+0x20],rcx
    3df6:	mov    QWORD PTR [rax+0x28],rbx
    3dfa:	mov    rdx,QWORD PTR [rbp-0x80]
    3dfe:	mov    QWORD PTR [rax+0x30],rdx
    3e02:	call   2056 <__profile_end_pass>
    3e07:	add    rsp,0x40
    3e0b:	cmp    QWORD PTR [rbp-0x1e8],0x0
    3e13:	je     3c3b <main+0x873>
    }
  }

  PROFILE_SCOPE("free")
    3e19:	lea    rax,[rip+0x983]        # 47a3 <_IO_stdin_used+0x7a3>
    3e20:	mov    QWORD PTR [rbp-0x2b0],rax
    3e27:	mov    QWORD PTR [rbp-0x2a8],0x4
    3e32:	lea    rax,[rbp-0x70]
    3e36:	mov    rcx,QWORD PTR [rbp-0x2b0]
    3e3d:	mov    rbx,QWORD PTR [rbp-0x2a8]
    3e44:	mov    rsi,rcx
    3e47:	mov    rdx,rbx
    3e4a:	mov    r8d,0x0
    3e50:	mov    ecx,0xa
    3e55:	mov    rdi,rax
    3e58:	call   1f6c <__profile_begin_pass>
    3e5d:	mov    QWORD PTR [rbp-0x1e0],0x0
    3e68:	jmp    3ecc <main+0xb04>
  {
    arena_free(&arena);
    3e6a:	lea    rax,[rbp-0x190]
    3e71:	mov    rdi,rax
    3e74:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3e79:	add    QWORD PTR [rbp-0x1e0],0x1
    3e81:	sub    rsp,0x8
    3e85:	sub    rsp,0x38
    3e89:	mov    rax,rsp
    3e8c:	mov    rcx,QWORD PTR [rbp-0x70]
    3e90:	mov    rbx,QWORD PTR [rbp-0x68]
    3e94:	mov    QWORD PTR [rax],rcx
    3e97:	mov    QWORD PTR [rax+0x8],rbx
    3e9b:	mov    rcx,QWORD PTR [rbp-0x60]
    3e9f:	mov    rbx,QWORD PTR [rbp-0x58]
    3ea3:	mov    QWORD PTR [rax+0x10],rcx
    3ea7:	mov    QWORD PTR [rax+0x18],rbx
    3eab:	mov    rcx,QWORD PTR [rbp-0x50]
    3eaf:	mov    rbx,QWORD PTR [rbp-0x48]
    3eb3:	mov    QWORD PTR [rax+0x20],rcx
    3eb7:	mov    QWORD PTR [rax+0x28],rbx
    3ebb:	mov    rdx,QWORD PTR [rbp-0x40]
    3ebf:	mov    QWORD PTR [rax+0x30],rdx
    3ec3:	call   2056 <__profile_end_pass>
    3ec8:	add    rsp,0x40
    3ecc:	cmp    QWORD PTR [rbp-0x1e0],0x0
    3ed4:	je     3e6a <main+0xaa2>
  }

  end_profiling();
    3ed6:	call   1b9b <end_profiling>
    3edb:	mov    eax,0x0
}
    3ee0:	mov    rdx,QWORD PTR [rbp-0x38]
    3ee4:	sub    rdx,QWORD PTR fs:0x28
    3eed:	je     3ef4 <main+0xb2c>
    3eef:	call   1060 <__stack_chk_fail@plt>
    3ef4:	lea    rsp,[rbp-0x28]
    3ef8:	pop    rbx
    3ef9:	pop    r12
    3efb:	pop    r13
    3efd:	pop    r14
    3eff:	pop    r15
    3f01:	pop    rbp
    3f02:	ret

Disassembly of section .fini:

0000000000003f04 <_fini>:
    3f04:	endbr64
    3f08:	sub    rsp,0x8
    3f0c:	add    rsp,0x8
    3f10:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x5fc1]        # 6fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x5fca]        # 6ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x5fcc]        # 6ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x5fca]        # 7000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x5fc2]        # 7008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x5fba]        # 7010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x5fb2]        # 7018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x5faa]        # 7020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x5fa2]        # 7028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x5f9a]        # 7030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x5f92]        # 7038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x5f8a]        # 7040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x5f82]        # 7048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x5f7a]        # 7050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x5f72]        # 7058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x5f6a]        # 7060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x5f62]        # 7068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x5f5a]        # 7070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x5f52]        # 7078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x5f4a]        # 7080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x5f42]        # 7088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x5f3a]        # 7090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x5f32]        # 7098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2239]        # 33c8 <main>
    118f:	call   QWORD PTR [rip+0x5e2b]        # 6fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x5fa1]        # 7148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x5f9a]        # 7148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x5e0e]        # 6fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x5f71]        # 7148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x5f6a]        # 7148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x5ddd]        # 6fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x5f6d],0x0        # 7188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x5dba],0x0        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x5e76]        # 70a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x5da8]        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x5f44],0x1        # 7188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x5c6e]        # 7180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x5b89]        # 70c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x5be7]        # 7160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x5b2b]        # 70c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x30b7]        # 47b0 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x308b]        # 47b0 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fce]        # 47c8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2ecf]        # 47d8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2ced]        # 47f0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x5639]        # 71a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x5620],rbx        # 71a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x50
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x55ee]        # 71a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x40],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x40],0x0
    1bbe:	je     1f69 <end_profiling+0x3ce>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x38],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x40]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x38]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c71]        # 48a8 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x38]
    1c44:	mov    rax,QWORD PTR [rbp-0x40]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x50],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x48],0x0
    1c72:	jmp    1f5b <end_profiling+0x3c0>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x48]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x550d]        # 71a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x30],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x30]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1f56 <end_profiling+0x3bb>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x30]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x40]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b97]        # 48b0 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x28],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x30]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x30]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x30]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x30]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x28]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x30]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x30]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x30]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x40]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2abf]        # 48b0 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x20],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x30]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x20]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x50]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x28]
    1e2c:	movsd  QWORD PTR [rbp-0x50],xmm0

        if (zone->bytes_processed)
    1e31:	mov    rax,QWORD PTR [rbp-0x30]
    1e35:	mov    rax,QWORD PTR [rax+0x28]
    1e39:	test   rax,rax
    1e3c:	je     1f56 <end_profiling+0x3bb>
        {
          u64 gigabytes = zone->bytes_processed / BILLION(1);
    1e42:	mov    rax,QWORD PTR [rbp-0x30]
    1e46:	mov    rax,QWORD PTR [rax+0x28]
    1e4a:	shr    rax,0x9
    1e4e:	movabs rdx,0x44b82fa09b5a53
    1e58:	mul    rdx
    1e5b:	mov    rax,rdx
    1e5e:	shr    rax,0xb
    1e62:	mov    QWORD PTR [rbp-0x18],rax
          u64 megabytes = zone->bytes_processed / MILLION(1);
    1e66:	mov    rax,QWORD PTR [rbp-0x30]
    1e6a:	mov    rax,QWORD PTR [rax+0x28]
    1e6e:	movabs rdx,0x431bde82d7b634db
    1e78:	mul    rdx
    1e7b:	mov    rax,rdx
    1e7e:	shr    rax,0x12
    1e82:	mov    QWORD PTR [rbp-0x10],rax

          f64 gb_per_s = gigabytes / (f64)zone->elapsed_inclusive / (f64)freq * MILLION(1);
    1e86:	mov    rax,QWORD PTR [rbp-0x18]
    1e8a:	test   rax,rax
    1e8d:	js     1e9a <end_profiling+0x2ff>
    1e8f:	pxor   xmm0,xmm0
    1e93:	cvtsi2sd xmm0,rax
    1e98:	jmp    1eb3 <end_profiling+0x318>
    1e9a:	mov    rdx,rax
    1e9d:	shr    rdx,1
    1ea0:	and    eax,0x1
    1ea3:	or     rdx,rax
    1ea6:	pxor   xmm0,xmm0
    1eaa:	cvtsi2sd xmm0,rdx
    1eaf:	addsd  xmm0,xmm0
    1eb3:	mov    rax,QWORD PTR [rbp-0x30]
    1eb7:	mov    rax,QWORD PTR [rax+0x18]
    1ebb:	test   rax,rax
    1ebe:	js     1ecb <end_profiling+0x330>
    1ec0:	pxor   xmm1,xmm1
    1ec4:	cvtsi2sd xmm1,rax
    1ec9:	jmp    1ee4 <end_profiling+0x349>
    1ecb:	mov    rdx,rax
    1ece:	shr    rdx,1
    1ed1:	and    eax,0x1
    1ed4:	or     rdx,rax
    1ed7:	pxor   xmm1,xmm1
    1edb:	cvtsi2sd xmm1,rdx
    1ee0:	addsd  xmm1,xmm1
    1ee4:	movapd xmm2,xmm0
    1ee8:	divsd  xmm2,xmm1
    1eec:	mov    rax,QWORD PTR [rbp-0x38]
    1ef0:	test   rax,rax
    1ef3:	js     1f00 <end_profiling+0x365>
    1ef5:	pxor   xmm0,xmm0
    1ef9:	cvtsi2sd xmm0,rax
    1efe:	jmp    1f19 <end_profiling+0x37e>
    1f00:	mov    rdx,rax
    1f03:	shr    rdx,1
    1f06:	and    eax,0x1
    1f09:	or     rdx,rax
    1f0c:	pxor   xmm0,xmm0
    1f10:	cvtsi2sd xmm0,rdx
    1f15:	addsd  xmm0,xmm0
    1f19:	movapd xmm1,xmm2
    1f1d:	divsd  xmm1,xmm0
    1f21:	movsd  xmm0,QWORD PTR [rip+0x298f]        # 48b8 <__PRETTY_FUNCTION__.0+0x28>
    1f29:	mulsd  xmm0,xmm1
    1f2d:	movsd  QWORD PTR [rbp-0x8],xmm0

          printf("  Megabytes Processed: %lu @ %f GB/s\n", megabytes, gb_per_s);
    1f32:	mov    rdx,QWORD PTR [rbp-0x8]
    1f36:	mov    rax,QWORD PTR [rbp-0x10]
    1f3a:	lea    rcx,[rip+0x2407]        # 4348 <_IO_stdin_used+0x348>
    1f41:	movq   xmm0,rdx
    1f46:	mov    rsi,rax
    1f49:	mov    rdi,rcx
    1f4c:	mov    eax,0x1
    1f51:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1f56:	add    QWORD PTR [rbp-0x48],0x1
    1f5b:	cmp    QWORD PTR [rbp-0x48],0xfff
    1f63:	jbe    1c77 <end_profiling+0xdc>
        }
      }
    }
  }
}
    1f69:	nop
    1f6a:	leave
    1f6b:	ret

0000000000001f6c <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1f6c:	push   rbp
    1f6d:	mov    rbp,rsp
    1f70:	push   rbx
    1f71:	sub    rsp,0x78
    1f75:	mov    QWORD PTR [rbp-0x58],rdi
    1f79:	mov    rax,rsi
    1f7c:	mov    rsi,rdx
    1f7f:	mov    rax,rax
    1f82:	mov    edx,0x0
    1f87:	mov    rdx,rsi
    1f8a:	mov    QWORD PTR [rbp-0x70],rax
    1f8e:	mov    QWORD PTR [rbp-0x68],rdx
    1f92:	mov    QWORD PTR [rbp-0x60],rcx
    1f96:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1f9a:	pxor   xmm0,xmm0
    1f9e:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1fa2:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1fa6:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1faa:	movq   QWORD PTR [rbp-0x20],xmm0
    1faf:	mov    rax,QWORD PTR [rbp-0x70]
    1fb3:	mov    rdx,QWORD PTR [rbp-0x68]
    1fb7:	mov    QWORD PTR [rbp-0x50],rax
    1fbb:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1fbf:	mov    rdx,QWORD PTR [rbp-0x60]
    1fc3:	mov    rax,rdx
    1fc6:	add    rax,rax
    1fc9:	add    rax,rdx
    1fcc:	shl    rax,0x4
    1fd0:	mov    rdx,rax
    1fd3:	lea    rax,[rip+0x51ee]        # 71c8 <g_profiler+0x28>
    1fda:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1fde:	mov    QWORD PTR [rbp-0x38],rax
    1fe2:	mov    rax,QWORD PTR [rbp-0x60]
    1fe6:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1fea:	mov    rax,QWORD PTR [rip+0x51b7]        # 71a8 <g_profiler+0x8>
  Profile_Pass pass =
    1ff1:	mov    QWORD PTR [rbp-0x28],rax
    1ff5:	mov    rax,QWORD PTR [rbp-0x78]
    1ff9:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    1ffd:	mov    rax,QWORD PTR [rbp-0x60]
    2001:	mov    QWORD PTR [rip+0x51a0],rax        # 71a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    2008:	call   1a48 <read_cpu_timer>
    200d:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    2011:	mov    rax,QWORD PTR [rbp-0x58]
    2015:	mov    rcx,QWORD PTR [rbp-0x50]
    2019:	mov    rbx,QWORD PTR [rbp-0x48]
    201d:	mov    QWORD PTR [rax],rcx
    2020:	mov    QWORD PTR [rax+0x8],rbx
    2024:	mov    rcx,QWORD PTR [rbp-0x40]
    2028:	mov    rbx,QWORD PTR [rbp-0x38]
    202c:	mov    QWORD PTR [rax+0x10],rcx
    2030:	mov    QWORD PTR [rax+0x18],rbx
    2034:	mov    rcx,QWORD PTR [rbp-0x30]
    2038:	mov    rbx,QWORD PTR [rbp-0x28]
    203c:	mov    QWORD PTR [rax+0x20],rcx
    2040:	mov    QWORD PTR [rax+0x28],rbx
    2044:	mov    rdx,QWORD PTR [rbp-0x20]
    2048:	mov    QWORD PTR [rax+0x30],rdx
}
    204c:	mov    rax,QWORD PTR [rbp-0x58]
    2050:	mov    rbx,QWORD PTR [rbp-0x8]
    2054:	leave
    2055:	ret

0000000000002056 <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    2056:	push   rbp
    2057:	mov    rbp,rsp
    205a:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    205e:	call   1a48 <read_cpu_timer>
    2063:	mov    rdx,rax
    2066:	mov    rax,QWORD PTR [rbp+0x20]
    206a:	sub    rdx,rax
    206d:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    2071:	mov    rax,QWORD PTR [rbp+0x38]
    2075:	mov    QWORD PTR [rip+0x512c],rax        # 71a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    207c:	mov    rdx,QWORD PTR [rbp+0x30]
    2080:	mov    rax,rdx
    2083:	add    rax,rax
    2086:	add    rax,rdx
    2089:	shl    rax,0x4
    208d:	lea    rdx,[rax+0x10]
    2091:	lea    rax,[rip+0x5108]        # 71a0 <g_profiler>
    2098:	add    rax,rdx
    209b:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    209f:	mov    rax,QWORD PTR [rbp-0x10]
    20a3:	mov    rdx,QWORD PTR [rax+0x10]
    20a7:	mov    rax,QWORD PTR [rbp-0x18]
    20ab:	add    rdx,rax
    20ae:	mov    rax,QWORD PTR [rbp-0x10]
    20b2:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    20b6:	mov    rax,QWORD PTR [rbp-0x10]
    20ba:	mov    rax,QWORD PTR [rax+0x20]
    20be:	lea    rdx,[rax+0x1]
    20c2:	mov    rax,QWORD PTR [rbp-0x10]
    20c6:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    20ca:	mov    rcx,QWORD PTR [rbp-0x10]
    20ce:	mov    rax,QWORD PTR [rbp+0x10]
    20d2:	mov    rdx,QWORD PTR [rbp+0x18]
    20d6:	mov    QWORD PTR [rcx],rax
    20d9:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    20dd:	mov    rdx,QWORD PTR [rbp+0x28]
    20e1:	mov    rax,QWORD PTR [rbp-0x18]
    20e5:	add    rdx,rax
    20e8:	mov    rax,QWORD PTR [rbp-0x10]
    20ec:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    20f0:	mov    rax,QWORD PTR [rbp-0x10]
    20f4:	mov    rdx,QWORD PTR [rax+0x28]
    20f8:	mov    rax,QWORD PTR [rbp+0x40]
    20fc:	add    rdx,rax
    20ff:	mov    rax,QWORD PTR [rbp-0x10]
    2103:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    2107:	mov    rdx,QWORD PTR [rbp+0x38]
    210b:	mov    rax,rdx
    210e:	add    rax,rax
    2111:	add    rax,rdx
    2114:	shl    rax,0x4
    2118:	lea    rdx,[rax+0x10]
    211c:	lea    rax,[rip+0x507d]        # 71a0 <g_profiler>
    2123:	add    rax,rdx
    2126:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    212a:	mov    rax,QWORD PTR [rbp-0x8]
    212e:	mov    rax,QWORD PTR [rax+0x10]
    2132:	sub    rax,QWORD PTR [rbp-0x18]
    2136:	mov    rdx,rax
    2139:	mov    rax,QWORD PTR [rbp-0x8]
    213d:	mov    QWORD PTR [rax+0x10],rdx
}
    2141:	nop
    2142:	leave
    2143:	ret

0000000000002144 <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    2144:	push   rbp
    2145:	mov    rbp,rsp
    2148:	sub    rsp,0x10
    214c:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2150:	mov    rax,QWORD PTR [rbp-0x8]
    2154:	mov    rdx,QWORD PTR [rax+0x10]
    2158:	mov    rax,QWORD PTR [rbp-0x8]
    215c:	mov    rax,QWORD PTR [rax+0x8]
    2160:	cmp    rdx,rax
    2163:	jb     218a <parser_at+0x46>
    2165:	lea    rdx,[rip+0x269c]        # 4808 <__PRETTY_FUNCTION__.5>
    216c:	lea    rsi,[rip+0x2306]        # 4479 <_IO_stdin_used+0x479>
    2173:	lea    rax,[rip+0x2316]        # 4490 <_IO_stdin_used+0x490>
    217a:	mov    rcx,rdx
    217d:	mov    edx,0x2f
    2182:	mov    rdi,rax
    2185:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    218a:	mov    rax,QWORD PTR [rbp-0x8]
    218e:	mov    rdx,QWORD PTR [rax]
    2191:	mov    rax,QWORD PTR [rbp-0x8]
    2195:	mov    rax,QWORD PTR [rax+0x10]
    2199:	add    rax,rdx
}
    219c:	leave
    219d:	ret

000000000000219e <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    219e:	push   rbp
    219f:	mov    rbp,rsp
    21a2:	sub    rsp,0x10
    21a6:	mov    QWORD PTR [rbp-0x8],rdi
    21aa:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    21ae:	mov    rax,QWORD PTR [rbp-0x8]
    21b2:	mov    rdi,rax
    21b5:	call   2144 <parser_at>
    21ba:	mov    rdx,QWORD PTR [rbp-0x10]
    21be:	add    rax,rdx
}
    21c1:	leave
    21c2:	ret

00000000000021c3 <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    21c3:	push   rbp
    21c4:	mov    rbp,rsp
    21c7:	mov    QWORD PTR [rbp-0x8],rdi
    21cb:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    21cf:	mov    rax,QWORD PTR [rbp-0x8]
    21d3:	mov    rdx,QWORD PTR [rax+0x10]
    21d7:	mov    rax,QWORD PTR [rbp-0x10]
    21db:	add    rdx,rax
    21de:	mov    rax,QWORD PTR [rbp-0x8]
    21e2:	mov    QWORD PTR [rax+0x10],rdx
}
    21e6:	nop
    21e7:	pop    rbp
    21e8:	ret

00000000000021e9 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    21e9:	push   rbp
    21ea:	mov    rbp,rsp
    21ed:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    21f1:	mov    rax,QWORD PTR [rbp-0x8]
    21f5:	mov    rdx,QWORD PTR [rax+0x10]
    21f9:	mov    rax,QWORD PTR [rbp-0x8]
    21fd:	mov    rax,QWORD PTR [rax+0x8]
    2201:	cmp    rdx,rax
    2204:	setb   al
}
    2207:	pop    rbp
    2208:	ret

0000000000002209 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    2209:	push   rbp
    220a:	mov    rbp,rsp
    220d:	push   r12
    220f:	push   rbx
    2210:	sub    rsp,0x20
    2214:	mov    QWORD PTR [rbp-0x18],rdi
    2218:	mov    rax,rsi
    221b:	mov    rcx,rdx
    221e:	mov    rax,rax
    2221:	mov    edx,0x0
    2226:	mov    rdx,rcx
    2229:	mov    QWORD PTR [rbp-0x30],rax
    222d:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    2231:	mov    rax,QWORD PTR [rbp-0x28]
    2235:	mov    r12,rax
    2238:	mov    rbx,QWORD PTR [rbp-0x30]
    223c:	mov    rax,QWORD PTR [rbp-0x18]
    2240:	mov    rdi,rax
    2243:	call   2144 <parser_at>
    2248:	mov    rdx,r12
    224b:	mov    rsi,rbx
    224e:	mov    rdi,rax
    2251:	call   10d0 <memcmp@plt>
    2256:	test   eax,eax
    2258:	sete   al
}
    225b:	add    rsp,0x20
    225f:	pop    rbx
    2260:	pop    r12
    2262:	pop    rbp
    2263:	ret

0000000000002264 <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    2264:	push   rbp
    2265:	mov    rbp,rsp
    2268:	mov    eax,edi
    226a:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    226d:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    2271:	movzx  eax,BYTE PTR [rbp-0x14]
    2275:	cmp    eax,0x2e
    2278:	jg     2281 <is_numeric+0x1d>
    227a:	cmp    eax,0x2d
    227d:	jge    2289 <is_numeric+0x25>
    227f:	jmp    228e <is_numeric+0x2a>
    2281:	sub    eax,0x30
    2284:	cmp    eax,0x9
    2287:	ja     228e <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2289:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    228d:	nop
  }


  return result;
    228e:	movzx  eax,BYTE PTR [rbp-0x1]
}
    2292:	pop    rbp
    2293:	ret

0000000000002294 <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    2294:	push   rbp
    2295:	mov    rbp,rsp
    2298:	sub    rsp,0x50
    229c:	mov    QWORD PTR [rbp-0x48],rdi
    22a0:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    22a4:	pxor   xmm0,xmm0
    22a8:	movaps XMMWORD PTR [rbp-0x20],xmm0
    22ac:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    22b1:	jmp    22c4 <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    22b3:	mov    rax,QWORD PTR [rbp-0x50]
    22b7:	mov    esi,0x1
    22bc:	mov    rdi,rax
    22bf:	call   21c3 <parser_advance>
  while (parser_incomplete(parser)  &&
    22c4:	mov    rax,QWORD PTR [rbp-0x50]
    22c8:	mov    rdi,rax
    22cb:	call   21e9 <parser_incomplete>
    22d0:	test   al,al
    22d2:	je     2320 <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    22d4:	mov    rax,QWORD PTR [rbp-0x50]
    22d8:	mov    rdi,rax
    22db:	call   2144 <parser_at>
    22e0:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    22e3:	cmp    al,0x20
    22e5:	je     22b3 <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    22e7:	mov    rax,QWORD PTR [rbp-0x50]
    22eb:	mov    rdi,rax
    22ee:	call   2144 <parser_at>
    22f3:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    22f6:	cmp    al,0xa
    22f8:	je     22b3 <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    22fa:	mov    rax,QWORD PTR [rbp-0x50]
    22fe:	mov    rdi,rax
    2301:	call   2144 <parser_at>
    2306:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    2309:	cmp    al,0xd
    230b:	je     22b3 <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    230d:	mov    rax,QWORD PTR [rbp-0x50]
    2311:	mov    rdi,rax
    2314:	call   2144 <parser_at>
    2319:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    231c:	cmp    al,0x9
    231e:	je     22b3 <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    2320:	mov    rax,QWORD PTR [rbp-0x50]
    2324:	mov    rdi,rax
    2327:	call   21e9 <parser_incomplete>
    232c:	test   al,al
    232e:	je     275b <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    2334:	mov    rax,QWORD PTR [rbp-0x50]
    2338:	mov    rdi,rax
    233b:	call   2144 <parser_at>
    2340:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    2344:	mov    rax,QWORD PTR [rbp-0x50]
    2348:	mov    rdi,rax
    234b:	call   2144 <parser_at>
    2350:	movzx  eax,BYTE PTR [rax]
    2353:	movzx  eax,al
    2356:	cmp    eax,0x7d
    2359:	je     2446 <get_json_token+0x1b2>
    235f:	cmp    eax,0x7d
    2362:	jg     276c <get_json_token+0x4d8>
    2368:	cmp    eax,0x7b
    236b:	je     2421 <get_json_token+0x18d>
    2371:	cmp    eax,0x7b
    2374:	jg     276c <get_json_token+0x4d8>
    237a:	cmp    eax,0x74
    237d:	je     25c9 <get_json_token+0x335>
    2383:	cmp    eax,0x74
    2386:	jg     276c <get_json_token+0x4d8>
    238c:	cmp    eax,0x6e
    238f:	je     26d9 <get_json_token+0x445>
    2395:	cmp    eax,0x6e
    2398:	jg     276c <get_json_token+0x4d8>
    239e:	cmp    eax,0x66
    23a1:	je     2651 <get_json_token+0x3bd>
    23a7:	cmp    eax,0x66
    23aa:	jg     276c <get_json_token+0x4d8>
    23b0:	cmp    eax,0x5d
    23b3:	je     2490 <get_json_token+0x1fc>
    23b9:	cmp    eax,0x5d
    23bc:	jg     276c <get_json_token+0x4d8>
    23c2:	cmp    eax,0x5b
    23c5:	je     246b <get_json_token+0x1d7>
    23cb:	cmp    eax,0x5b
    23ce:	jg     276c <get_json_token+0x4d8>
    23d4:	cmp    eax,0x3a
    23d7:	je     24da <get_json_token+0x246>
    23dd:	cmp    eax,0x3a
    23e0:	jg     276c <get_json_token+0x4d8>
    23e6:	cmp    eax,0x39
    23e9:	jg     276c <get_json_token+0x4d8>
    23ef:	cmp    eax,0x30
    23f2:	jge    2578 <get_json_token+0x2e4>
    23f8:	cmp    eax,0x2e
    23fb:	jg     276c <get_json_token+0x4d8>
    2401:	cmp    eax,0x2d
    2404:	jge    2578 <get_json_token+0x2e4>
    240a:	cmp    eax,0x22
    240d:	je     24ff <get_json_token+0x26b>
    2413:	cmp    eax,0x2c
    2416:	je     24b5 <get_json_token+0x221>
    241c:	jmp    276c <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    2421:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    2428:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2430:	mov    rax,QWORD PTR [rbp-0x50]
    2434:	mov    esi,0x1
    2439:	mov    rdi,rax
    243c:	call   21c3 <parser_advance>
      }
      break;
    2441:	jmp    276c <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2446:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    244d:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2455:	mov    rax,QWORD PTR [rbp-0x50]
    2459:	mov    esi,0x1
    245e:	mov    rdi,rax
    2461:	call   21c3 <parser_advance>
      }
      break;
    2466:	jmp    276c <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    246b:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    2472:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    247a:	mov    rax,QWORD PTR [rbp-0x50]
    247e:	mov    esi,0x1
    2483:	mov    rdi,rax
    2486:	call   21c3 <parser_advance>
      }
      break;
    248b:	jmp    276c <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    2490:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    2497:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    249f:	mov    rax,QWORD PTR [rbp-0x50]
    24a3:	mov    esi,0x1
    24a8:	mov    rdi,rax
    24ab:	call   21c3 <parser_advance>
      }
      break;
    24b0:	jmp    276c <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    24b5:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    24bc:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24c4:	mov    rax,QWORD PTR [rbp-0x50]
    24c8:	mov    esi,0x1
    24cd:	mov    rdi,rax
    24d0:	call   21c3 <parser_advance>
      }
      break;
    24d5:	jmp    276c <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    24da:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    24e1:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24e9:	mov    rax,QWORD PTR [rbp-0x50]
    24ed:	mov    esi,0x1
    24f2:	mov    rdi,rax
    24f5:	call   21c3 <parser_advance>
      }
      break;
    24fa:	jmp    276c <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    24ff:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    2506:	mov    rax,QWORD PTR [rbp-0x50]
    250a:	mov    esi,0x1
    250f:	mov    rdi,rax
    2512:	call   21c3 <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    2517:	mov    rax,QWORD PTR [rbp-0x50]
    251b:	mov    rdi,rax
    251e:	call   2144 <parser_at>
    2523:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    2527:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    252f:	jmp    2547 <get_json_token+0x2b3>
        {
          string_count += 1;
    2531:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    2536:	mov    rax,QWORD PTR [rbp-0x50]
    253a:	mov    esi,0x1
    253f:	mov    rdi,rax
    2542:	call   21c3 <parser_advance>
        while (*parser_at(parser) != '"')
    2547:	mov    rax,QWORD PTR [rbp-0x50]
    254b:	mov    rdi,rax
    254e:	call   2144 <parser_at>
    2553:	movzx  eax,BYTE PTR [rax]
    2556:	cmp    al,0x22
    2558:	jne    2531 <get_json_token+0x29d>
        }
        token.value.count = string_count;
    255a:	mov    rax,QWORD PTR [rbp-0x40]
    255e:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    2562:	mov    rax,QWORD PTR [rbp-0x50]
    2566:	mov    esi,0x1
    256b:	mov    rdi,rax
    256e:	call   21c3 <parser_advance>
      }
      break;
    2573:	jmp    276c <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2578:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    257f:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2587:	jmp    259f <get_json_token+0x30b>
        {
          digit_count += 1;
    2589:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    258e:	mov    rax,QWORD PTR [rbp-0x50]
    2592:	mov    esi,0x1
    2597:	mov    rdi,rax
    259a:	call   21c3 <parser_advance>
        while (is_numeric(*parser_at(parser)))
    259f:	mov    rax,QWORD PTR [rbp-0x50]
    25a3:	mov    rdi,rax
    25a6:	call   2144 <parser_at>
    25ab:	movzx  eax,BYTE PTR [rax]
    25ae:	movzx  eax,al
    25b1:	mov    edi,eax
    25b3:	call   2264 <is_numeric>
    25b8:	test   al,al
    25ba:	jne    2589 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    25bc:	mov    rax,QWORD PTR [rbp-0x38]
    25c0:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    25c4:	jmp    276c <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    25c9:	lea    rax,[rip+0x1f0c]        # 44dc <_IO_stdin_used+0x4dc>
    25d0:	mov    QWORD PTR [rbp-0x30],rax
    25d4:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25dc:	mov    rcx,QWORD PTR [rbp-0x30]
    25e0:	mov    rdx,QWORD PTR [rbp-0x28]
    25e4:	mov    rax,QWORD PTR [rbp-0x50]
    25e8:	mov    rsi,rcx
    25eb:	mov    rdi,rax
    25ee:	call   2209 <parser_token_is_literal>
    25f3:	test   al,al
    25f5:	je     2619 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    25f7:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    25fe:	mov    rax,QWORD PTR [rbp-0x28]
    2602:	mov    rdx,rax
    2605:	mov    rax,QWORD PTR [rbp-0x50]
    2609:	mov    rsi,rdx
    260c:	mov    rdi,rax
    260f:	call   21c3 <parser_advance>
    2614:	jmp    276c <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2619:	mov    rax,QWORD PTR [rbp-0x50]
    261d:	mov    rcx,QWORD PTR [rax+0x10]
    2621:	lea    rdx,[rip+0x1ec0]        # 44e8 <_IO_stdin_used+0x4e8>
    2628:	lea    rax,[rip+0x1e4a]        # 4479 <_IO_stdin_used+0x479>
    262f:	mov    r8,rcx
    2632:	mov    rcx,rdx
    2635:	mov    edx,0xdf
    263a:	mov    rsi,rax
    263d:	mov    edi,0x1
    2642:	mov    eax,0x0
    2647:	call   14a1 <log_message>
        }
      }
      break;
    264c:	jmp    276c <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    2651:	lea    rax,[rip+0x1ebd]        # 4515 <_IO_stdin_used+0x515>
    2658:	mov    QWORD PTR [rbp-0x30],rax
    265c:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    2664:	mov    rcx,QWORD PTR [rbp-0x30]
    2668:	mov    rdx,QWORD PTR [rbp-0x28]
    266c:	mov    rax,QWORD PTR [rbp-0x50]
    2670:	mov    rsi,rcx
    2673:	mov    rdi,rax
    2676:	call   2209 <parser_token_is_literal>
    267b:	test   al,al
    267d:	je     26a1 <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    267f:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    2686:	mov    rax,QWORD PTR [rbp-0x28]
    268a:	mov    rdx,rax
    268d:	mov    rax,QWORD PTR [rbp-0x50]
    2691:	mov    rsi,rdx
    2694:	mov    rdi,rax
    2697:	call   21c3 <parser_advance>
    269c:	jmp    276c <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    26a1:	mov    rax,QWORD PTR [rbp-0x50]
    26a5:	mov    rcx,QWORD PTR [rax+0x10]
    26a9:	lea    rdx,[rip+0x1e38]        # 44e8 <_IO_stdin_used+0x4e8>
    26b0:	lea    rax,[rip+0x1dc2]        # 4479 <_IO_stdin_used+0x479>
    26b7:	mov    r8,rcx
    26ba:	mov    rcx,rdx
    26bd:	mov    edx,0xee
    26c2:	mov    rsi,rax
    26c5:	mov    edi,0x1
    26ca:	mov    eax,0x0
    26cf:	call   14a1 <log_message>
        }
      }
      break;
    26d4:	jmp    276c <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    26d9:	lea    rax,[rip+0x1e3b]        # 451b <_IO_stdin_used+0x51b>
    26e0:	mov    QWORD PTR [rbp-0x30],rax
    26e4:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    26ec:	mov    rcx,QWORD PTR [rbp-0x30]
    26f0:	mov    rdx,QWORD PTR [rbp-0x28]
    26f4:	mov    rax,QWORD PTR [rbp-0x50]
    26f8:	mov    rsi,rcx
    26fb:	mov    rdi,rax
    26fe:	call   2209 <parser_token_is_literal>
    2703:	test   al,al
    2705:	je     2726 <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    2707:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    270e:	mov    rax,QWORD PTR [rbp-0x28]
    2712:	mov    rdx,rax
    2715:	mov    rax,QWORD PTR [rbp-0x50]
    2719:	mov    rsi,rdx
    271c:	mov    rdi,rax
    271f:	call   21c3 <parser_advance>
    2724:	jmp    276c <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2726:	mov    rax,QWORD PTR [rbp-0x50]
    272a:	mov    rcx,QWORD PTR [rax+0x10]
    272e:	lea    rdx,[rip+0x1db3]        # 44e8 <_IO_stdin_used+0x4e8>
    2735:	lea    rax,[rip+0x1d3d]        # 4479 <_IO_stdin_used+0x479>
    273c:	mov    r8,rcx
    273f:	mov    rcx,rdx
    2742:	mov    edx,0xfd
    2747:	mov    rsi,rax
    274a:	mov    edi,0x1
    274f:	mov    eax,0x0
    2754:	call   14a1 <log_message>
        }
      }
      break;
    2759:	jmp    276c <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    275b:	mov    rax,QWORD PTR [rbp-0x50]
    275f:	mov    esi,0x1
    2764:	mov    rdi,rax
    2767:	call   21c3 <parser_advance>
  }

  return token;
    276c:	mov    rcx,QWORD PTR [rbp-0x48]
    2770:	mov    rax,QWORD PTR [rbp-0x20]
    2774:	mov    rdx,QWORD PTR [rbp-0x18]
    2778:	mov    QWORD PTR [rcx],rax
    277b:	mov    QWORD PTR [rcx+0x8],rdx
    277f:	mov    rax,QWORD PTR [rbp-0x10]
    2783:	mov    QWORD PTR [rcx+0x10],rax
}
    2787:	mov    rax,QWORD PTR [rbp-0x48]
    278b:	leave
    278c:	ret

000000000000278d <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    278d:	push   rbp
    278e:	mov    rbp,rsp
    2791:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    2794:	cmp    DWORD PTR [rbp-0x14],0x7
    2798:	je     27b2 <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    279a:	cmp    DWORD PTR [rbp-0x14],0x9
    279e:	je     27b2 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    27a0:	cmp    DWORD PTR [rbp-0x14],0xa
    27a4:	je     27b2 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    27a6:	cmp    DWORD PTR [rbp-0x14],0xb
    27aa:	je     27b2 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    27ac:	cmp    DWORD PTR [rbp-0x14],0x8
    27b0:	jne    27b9 <json_token_type_is_value_type+0x2c>
    27b2:	mov    eax,0x1
    27b7:	jmp    27be <json_token_type_is_value_type+0x31>
    27b9:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    27be:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    27c1:	mov    eax,DWORD PTR [rbp-0x4]
}
    27c4:	pop    rbp
    27c5:	ret

00000000000027c6 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    27c6:	push   rbp
    27c7:	mov    rbp,rsp
    27ca:	push   rbx
    27cb:	sub    rsp,0x88
    27d2:	mov    QWORD PTR [rbp-0x78],rdi
    27d6:	mov    QWORD PTR [rbp-0x80],rsi
    27da:	mov    QWORD PTR [rbp-0x90],rdx
    27e1:	mov    QWORD PTR [rbp-0x88],rcx
    27e8:	mov    rax,QWORD PTR fs:0x28
    27f1:	mov    QWORD PTR [rbp-0x18],rax
    27f5:	xor    eax,eax
  profile_begin_func();
    27f7:	lea    r8,[rip+0x2022]        # 4820 <__func__.4>
    27fe:	mov    r9d,0x11
    2804:	lea    rax,[rbp-0x50]
    2808:	mov    rsi,r8
    280b:	mov    rdx,r9
    280e:	mov    r8d,0x0
    2814:	mov    ecx,0x1
    2819:	mov    rdi,rax
    281c:	call   1f6c <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    2821:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2829:	mov    eax,DWORD PTR [rbp+0x10]
    282c:	cmp    eax,0x1
    282f:	jne    285b <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    2831:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    2838:	mov    edx,DWORD PTR [rbp-0x64]
    283b:	mov    rsi,QWORD PTR [rbp-0x80]
    283f:	mov    rax,QWORD PTR [rbp-0x78]
    2843:	mov    ecx,edx
    2845:	mov    edx,0x2
    284a:	mov    rdi,rax
    284d:	call   29ad <parse_json_children>
    2852:	mov    QWORD PTR [rbp-0x60],rax
    2856:	jmp    28e5 <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    285b:	mov    eax,DWORD PTR [rbp+0x10]
    285e:	cmp    eax,0x3
    2861:	jne    288a <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    2863:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    286a:	mov    edx,DWORD PTR [rbp-0x68]
    286d:	mov    rsi,QWORD PTR [rbp-0x80]
    2871:	mov    rax,QWORD PTR [rbp-0x78]
    2875:	mov    ecx,edx
    2877:	mov    edx,0x4
    287c:	mov    rdi,rax
    287f:	call   29ad <parse_json_children>
    2884:	mov    QWORD PTR [rbp-0x60],rax
    2888:	jmp    28e5 <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    288a:	mov    eax,DWORD PTR [rbp+0x10]
    288d:	mov    edi,eax
    288f:	call   278d <json_token_type_is_value_type>
    2894:	test   eax,eax
    2896:	jne    28e5 <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2898:	mov    eax,DWORD PTR [rbp+0x10]
    289b:	mov    eax,eax
    289d:	lea    rdx,[rax*8+0x0]
    28a5:	lea    rax,[rip+0x4834]        # 70e0 <JSON_Token_Type_strings>
    28ac:	mov    rcx,QWORD PTR [rdx+rax*1]
    28b0:	lea    rdx,[rip+0x1c69]        # 4520 <_IO_stdin_used+0x520>
    28b7:	lea    rax,[rip+0x1bbb]        # 4479 <_IO_stdin_used+0x479>
    28be:	push   QWORD PTR [rbp+0x20]
    28c1:	push   QWORD PTR [rbp+0x18]
    28c4:	mov    r8,rcx
    28c7:	mov    rcx,rdx
    28ca:	mov    edx,0x134
    28cf:	mov    rsi,rax
    28d2:	mov    edi,0x1
    28d7:	mov    eax,0x0
    28dc:	call   14a1 <log_message>
    28e1:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    28e5:	mov    rax,QWORD PTR [rbp-0x78]
    28e9:	mov    edx,0x8
    28ee:	mov    esi,0x30
    28f3:	mov    rdi,rax
    28f6:	call   17d3 <arena_alloc>
    28fb:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    28ff:	mov    rcx,QWORD PTR [rbp-0x58]
    2903:	mov    rax,QWORD PTR [rbp-0x90]
    290a:	mov    rdx,QWORD PTR [rbp-0x88]
    2911:	mov    QWORD PTR [rcx],rax
    2914:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    2918:	mov    rax,QWORD PTR [rbp-0x58]
    291c:	mov    rdx,QWORD PTR [rbp-0x60]
    2920:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    2924:	mov    rax,QWORD PTR [rbp-0x58]
    2928:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    2930:	mov    rcx,QWORD PTR [rbp-0x58]
    2934:	mov    rax,QWORD PTR [rbp+0x18]
    2938:	mov    rdx,QWORD PTR [rbp+0x20]
    293c:	mov    QWORD PTR [rcx+0x10],rax
    2940:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    2944:	sub    rsp,0x8
    2948:	sub    rsp,0x38
    294c:	mov    rax,rsp
    294f:	mov    rcx,QWORD PTR [rbp-0x50]
    2953:	mov    rbx,QWORD PTR [rbp-0x48]
    2957:	mov    QWORD PTR [rax],rcx
    295a:	mov    QWORD PTR [rax+0x8],rbx
    295e:	mov    rcx,QWORD PTR [rbp-0x40]
    2962:	mov    rbx,QWORD PTR [rbp-0x38]
    2966:	mov    QWORD PTR [rax+0x10],rcx
    296a:	mov    QWORD PTR [rax+0x18],rbx
    296e:	mov    rcx,QWORD PTR [rbp-0x30]
    2972:	mov    rbx,QWORD PTR [rbp-0x28]
    2976:	mov    QWORD PTR [rax+0x20],rcx
    297a:	mov    QWORD PTR [rax+0x28],rbx
    297e:	mov    rdx,QWORD PTR [rbp-0x20]
    2982:	mov    QWORD PTR [rax+0x30],rdx
    2986:	call   2056 <__profile_end_pass>
    298b:	add    rsp,0x40

  return result;
    298f:	mov    rax,QWORD PTR [rbp-0x58]
}
    2993:	mov    rdx,QWORD PTR [rbp-0x18]
    2997:	sub    rdx,QWORD PTR fs:0x28
    29a0:	je     29a7 <parse_json_object+0x1e1>
    29a2:	call   1060 <__stack_chk_fail@plt>
    29a7:	mov    rbx,QWORD PTR [rbp-0x8]
    29ab:	leave
    29ac:	ret

00000000000029ad <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    29ad:	push   rbp
    29ae:	mov    rbp,rsp
    29b1:	push   rbx
    29b2:	sub    rsp,0x108
    29b9:	mov    QWORD PTR [rbp-0xd8],rdi
    29c0:	mov    QWORD PTR [rbp-0xe0],rsi
    29c7:	mov    DWORD PTR [rbp-0xe4],edx
    29cd:	mov    DWORD PTR [rbp-0xe8],ecx
    29d3:	mov    rax,QWORD PTR fs:0x28
    29dc:	mov    QWORD PTR [rbp-0x18],rax
    29e0:	xor    eax,eax
  profile_begin_func();
    29e2:	lea    r8,[rip+0x1e57]        # 4840 <__func__.3>
    29e9:	mov    r9d,0x13
    29ef:	lea    rax,[rbp-0x50]
    29f3:	mov    rsi,r8
    29f6:	mov    rdx,r9
    29f9:	mov    r8d,0x0
    29ff:	mov    ecx,0x2
    2a04:	mov    rdi,rax
    2a07:	call   1f6c <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2a0c:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    2a17:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2a22:	jmp    2cfb <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2a27:	pxor   xmm0,xmm0
    2a2b:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2a32:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2a3a:	pxor   xmm0,xmm0
    2a3e:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2a45:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2a4a:	cmp    DWORD PTR [rbp-0xe8],0x0
    2a51:	je     2b5e <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2a57:	lea    rax,[rbp-0xb0]
    2a5e:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a65:	mov    rsi,rdx
    2a68:	mov    rdi,rax
    2a6b:	call   2294 <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2a70:	mov    eax,DWORD PTR [rbp-0xb0]
    2a76:	cmp    eax,0x7
    2a79:	jne    2afa <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2a7b:	lea    rax,[rbp-0x70]
    2a7f:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a86:	mov    rsi,rdx
    2a89:	mov    rdi,rax
    2a8c:	call   2294 <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2a91:	mov    eax,DWORD PTR [rbp-0x70]
    2a94:	cmp    eax,0x6
    2a97:	jne    2ab7 <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2a99:	lea    rax,[rbp-0x90]
    2aa0:	mov    rdx,QWORD PTR [rbp-0xe0]
    2aa7:	mov    rsi,rdx
    2aaa:	mov    rdi,rax
    2aad:	call   2294 <get_json_token>
    2ab2:	jmp    2b9e <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2ab7:	mov    rcx,QWORD PTR [rbp-0xa8]
    2abe:	mov    rax,QWORD PTR [rbp-0xa0]
    2ac5:	mov    esi,eax
    2ac7:	lea    rdx,[rip+0x1aa2]        # 4570 <_IO_stdin_used+0x570>
    2ace:	lea    rax,[rip+0x19a4]        # 4479 <_IO_stdin_used+0x479>
    2ad5:	mov    r9,rcx
    2ad8:	mov    r8d,esi
    2adb:	mov    rcx,rdx
    2ade:	mov    edx,0x15f
    2ae3:	mov    rsi,rax
    2ae6:	mov    edi,0x1
    2aeb:	mov    eax,0x0
    2af0:	call   14a1 <log_message>
    2af5:	jmp    2b9e <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2afa:	mov    rcx,QWORD PTR [rbp-0xa8]
    2b01:	mov    rax,QWORD PTR [rbp-0xa0]
    2b08:	mov    edi,eax
    2b0a:	mov    eax,DWORD PTR [rbp-0xb0]
    2b10:	mov    eax,eax
    2b12:	lea    rdx,[rax*8+0x0]
    2b1a:	lea    rax,[rip+0x45bf]        # 70e0 <JSON_Token_Type_strings>
    2b21:	mov    rsi,QWORD PTR [rdx+rax*1]
    2b25:	lea    rdx,[rip+0x1a64]        # 4590 <_IO_stdin_used+0x590>
    2b2c:	lea    rax,[rip+0x1946]        # 4479 <_IO_stdin_used+0x479>
    2b33:	sub    rsp,0x8
    2b37:	push   rcx
    2b38:	mov    r9d,edi
    2b3b:	mov    r8,rsi
    2b3e:	mov    rcx,rdx
    2b41:	mov    edx,0x164
    2b46:	mov    rsi,rax
    2b49:	mov    edi,0x1
    2b4e:	mov    eax,0x0
    2b53:	call   14a1 <log_message>
    2b58:	add    rsp,0x10
    2b5c:	jmp    2b9e <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2b5e:	lea    rax,[rbp-0x110]
    2b65:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b6c:	mov    rsi,rdx
    2b6f:	mov    rdi,rax
    2b72:	call   2294 <get_json_token>
    2b77:	mov    rax,QWORD PTR [rbp-0x110]
    2b7e:	mov    rdx,QWORD PTR [rbp-0x108]
    2b85:	mov    QWORD PTR [rbp-0x90],rax
    2b8c:	mov    QWORD PTR [rbp-0x88],rdx
    2b93:	mov    rax,QWORD PTR [rbp-0x100]
    2b9a:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2b9e:	mov    eax,DWORD PTR [rbp-0x90]
    2ba4:	cmp    DWORD PTR [rbp-0xe4],eax
    2baa:	je     2d14 <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2bb0:	mov    rax,QWORD PTR [rbp-0xa8]
    2bb7:	mov    rdx,QWORD PTR [rbp-0xa0]
    2bbe:	mov    r8,QWORD PTR [rbp-0xe0]
    2bc5:	mov    rdi,QWORD PTR [rbp-0xd8]
    2bcc:	sub    rsp,0x8
    2bd0:	sub    rsp,0x18
    2bd4:	mov    rsi,rsp
    2bd7:	mov    rcx,QWORD PTR [rbp-0x90]
    2bde:	mov    rbx,QWORD PTR [rbp-0x88]
    2be5:	mov    QWORD PTR [rsi],rcx
    2be8:	mov    QWORD PTR [rsi+0x8],rbx
    2bec:	mov    rcx,QWORD PTR [rbp-0x80]
    2bf0:	mov    QWORD PTR [rsi+0x10],rcx
    2bf4:	mov    rcx,rdx
    2bf7:	mov    rdx,rax
    2bfa:	mov    rsi,r8
    2bfd:	call   27c6 <parse_json_object>
    2c02:	add    rsp,0x20
    2c06:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2c0d:	cmp    QWORD PTR [rbp-0xb8],0x0
    2c15:	je     2c5f <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2c17:	cmp    QWORD PTR [rbp-0xc8],0x0
    2c1f:	jne    2c3f <parse_json_children+0x292>
      {
        first_child        = object;
    2c21:	mov    rax,QWORD PTR [rbp-0xb8]
    2c28:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2c2f:	mov    rax,QWORD PTR [rbp-0xb8]
    2c36:	mov    QWORD PTR [rbp-0xc0],rax
    2c3d:	jmp    2c5f <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2c3f:	mov    rax,QWORD PTR [rbp-0xc0]
    2c46:	mov    rdx,QWORD PTR [rbp-0xb8]
    2c4d:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2c51:	mov    rax,QWORD PTR [rbp-0xb8]
    2c58:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2c5f:	lea    rax,[rbp-0x70]
    2c63:	mov    rdx,QWORD PTR [rbp-0xe0]
    2c6a:	mov    rsi,rdx
    2c6d:	mov    rdi,rax
    2c70:	call   2294 <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2c75:	mov    eax,DWORD PTR [rbp-0x70]
    2c78:	cmp    DWORD PTR [rbp-0xe4],eax
    2c7e:	je     2d17 <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2c84:	mov    eax,DWORD PTR [rbp-0x70]
    2c87:	cmp    eax,0x5
    2c8a:	je     2cfb <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2c8c:	mov    r8,QWORD PTR [rbp-0x68]
    2c90:	mov    rax,QWORD PTR [rbp-0x60]
    2c94:	mov    r9d,eax
    2c97:	mov    eax,DWORD PTR [rbp-0x70]
    2c9a:	mov    eax,eax
    2c9c:	lea    rdx,[rax*8+0x0]
    2ca4:	lea    rax,[rip+0x4435]        # 70e0 <JSON_Token_Type_strings>
    2cab:	mov    r10,QWORD PTR [rdx+rax*1]
    2caf:	lea    rdi,[rip+0x1902]        # 45b8 <_IO_stdin_used+0x5b8>
    2cb6:	lea    rsi,[rip+0x17bc]        # 4479 <_IO_stdin_used+0x479>
    2cbd:	sub    rsp,0x18
    2cc1:	mov    rcx,rsp
    2cc4:	mov    rax,QWORD PTR [rbp-0x70]
    2cc8:	mov    rdx,QWORD PTR [rbp-0x68]
    2ccc:	mov    QWORD PTR [rcx],rax
    2ccf:	mov    QWORD PTR [rcx+0x8],rdx
    2cd3:	mov    rax,QWORD PTR [rbp-0x60]
    2cd7:	mov    QWORD PTR [rcx+0x10],rax
    2cdb:	push   r8
    2cdd:	mov    r8,r10
    2ce0:	mov    rcx,rdi
    2ce3:	mov    edx,0x18b
    2ce8:	mov    edi,0x1
    2ced:	mov    eax,0x0
    2cf2:	call   14a1 <log_message>
    2cf7:	add    rsp,0x20
  while (parser_incomplete(parser))
    2cfb:	mov    rax,QWORD PTR [rbp-0xe0]
    2d02:	mov    rdi,rax
    2d05:	call   21e9 <parser_incomplete>
    2d0a:	test   al,al
    2d0c:	jne    2a27 <parse_json_children+0x7a>
    2d12:	jmp    2d18 <parse_json_children+0x36b>
      break;
    2d14:	nop
    2d15:	jmp    2d18 <parse_json_children+0x36b>
      break;
    2d17:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2d18:	sub    rsp,0x8
    2d1c:	sub    rsp,0x38
    2d20:	mov    rax,rsp
    2d23:	mov    rcx,QWORD PTR [rbp-0x50]
    2d27:	mov    rbx,QWORD PTR [rbp-0x48]
    2d2b:	mov    QWORD PTR [rax],rcx
    2d2e:	mov    QWORD PTR [rax+0x8],rbx
    2d32:	mov    rcx,QWORD PTR [rbp-0x40]
    2d36:	mov    rbx,QWORD PTR [rbp-0x38]
    2d3a:	mov    QWORD PTR [rax+0x10],rcx
    2d3e:	mov    QWORD PTR [rax+0x18],rbx
    2d42:	mov    rcx,QWORD PTR [rbp-0x30]
    2d46:	mov    rbx,QWORD PTR [rbp-0x28]
    2d4a:	mov    QWORD PTR [rax+0x20],rcx
    2d4e:	mov    QWORD PTR [rax+0x28],rbx
    2d52:	mov    rdx,QWORD PTR [rbp-0x20]
    2d56:	mov    QWORD PTR [rax+0x30],rdx
    2d5a:	call   2056 <__profile_end_pass>
    2d5f:	add    rsp,0x40

  return first_child;
    2d63:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2d6a:	mov    rdx,QWORD PTR [rbp-0x18]
    2d6e:	sub    rdx,QWORD PTR fs:0x28
    2d77:	je     2d7e <parse_json_children+0x3d1>
    2d79:	call   1060 <__stack_chk_fail@plt>
    2d7e:	mov    rbx,QWORD PTR [rbp-0x8]
    2d82:	leave
    2d83:	ret

0000000000002d84 <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2d84:	push   rbp
    2d85:	mov    rbp,rsp
    2d88:	push   rbx
    2d89:	sub    rsp,0xb8
    2d90:	mov    QWORD PTR [rbp-0xa8],rdi
    2d97:	mov    rax,rsi
    2d9a:	mov    rsi,rdx
    2d9d:	mov    rax,rax
    2da0:	mov    edx,0x0
    2da5:	mov    rdx,rsi
    2da8:	mov    QWORD PTR [rbp-0xc0],rax
    2daf:	mov    QWORD PTR [rbp-0xb8],rdx
    2db6:	mov    rax,QWORD PTR fs:0x28
    2dbf:	mov    QWORD PTR [rbp-0x18],rax
    2dc3:	xor    eax,eax
  profile_begin_func();
    2dc5:	lea    rcx,[rip+0x1a8c]        # 4858 <__func__.2>
    2dcc:	mov    ebx,0xa
    2dd1:	lea    rax,[rbp-0x50]
    2dd5:	mov    rsi,rcx
    2dd8:	mov    rdx,rbx
    2ddb:	mov    r8d,0x0
    2de1:	mov    ecx,0x3
    2de6:	mov    rdi,rax
    2de9:	call   1f6c <__profile_begin_pass>

  JSON_Parser parser =
    2dee:	mov    rax,QWORD PTR [rbp-0xc0]
    2df5:	mov    rdx,QWORD PTR [rbp-0xb8]
    2dfc:	mov    QWORD PTR [rbp-0x90],rax
    2e03:	mov    QWORD PTR [rbp-0x88],rdx
    2e0a:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2e12:	lea    rax,[rbp-0x70]
    2e16:	lea    rdx,[rbp-0x90]
    2e1d:	mov    rsi,rdx
    2e20:	mov    rdi,rax
    2e23:	call   2294 <get_json_token>
    2e28:	mov    ecx,0x0
    2e2d:	mov    ebx,0x0
    2e32:	lea    r8,[rbp-0x90]
    2e39:	mov    rdi,QWORD PTR [rbp-0xa8]
    2e40:	sub    rsp,0x8
    2e44:	sub    rsp,0x18
    2e48:	mov    rsi,rsp
    2e4b:	mov    rax,QWORD PTR [rbp-0x70]
    2e4f:	mov    rdx,QWORD PTR [rbp-0x68]
    2e53:	mov    QWORD PTR [rsi],rax
    2e56:	mov    QWORD PTR [rsi+0x8],rdx
    2e5a:	mov    rax,QWORD PTR [rbp-0x60]
    2e5e:	mov    QWORD PTR [rsi+0x10],rax
    2e62:	mov    rdx,rcx
    2e65:	mov    rcx,rbx
    2e68:	mov    rsi,r8
    2e6b:	call   27c6 <parse_json_object>
    2e70:	add    rsp,0x20
    2e74:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2e7b:	sub    rsp,0x8
    2e7f:	sub    rsp,0x38
    2e83:	mov    rax,rsp
    2e86:	mov    rcx,QWORD PTR [rbp-0x50]
    2e8a:	mov    rbx,QWORD PTR [rbp-0x48]
    2e8e:	mov    QWORD PTR [rax],rcx
    2e91:	mov    QWORD PTR [rax+0x8],rbx
    2e95:	mov    rcx,QWORD PTR [rbp-0x40]
    2e99:	mov    rbx,QWORD PTR [rbp-0x38]
    2e9d:	mov    QWORD PTR [rax+0x10],rcx
    2ea1:	mov    QWORD PTR [rax+0x18],rbx
    2ea5:	mov    rcx,QWORD PTR [rbp-0x30]
    2ea9:	mov    rbx,QWORD PTR [rbp-0x28]
    2ead:	mov    QWORD PTR [rax+0x20],rcx
    2eb1:	mov    QWORD PTR [rax+0x28],rbx
    2eb5:	mov    rdx,QWORD PTR [rbp-0x20]
    2eb9:	mov    QWORD PTR [rax+0x30],rdx
    2ebd:	call   2056 <__profile_end_pass>
    2ec2:	add    rsp,0x40

  return outer;
    2ec6:	mov    rax,QWORD PTR [rbp-0x98]
}
    2ecd:	mov    rdx,QWORD PTR [rbp-0x18]
    2ed1:	sub    rdx,QWORD PTR fs:0x28
    2eda:	je     2ee1 <parse_json+0x15d>
    2edc:	call   1060 <__stack_chk_fail@plt>
    2ee1:	mov    rbx,QWORD PTR [rbp-0x8]
    2ee5:	leave
    2ee6:	ret

0000000000002ee7 <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2ee7:	push   rbp
    2ee8:	mov    rbp,rsp
    2eeb:	push   rbx
    2eec:	sub    rsp,0x78
    2ef0:	mov    QWORD PTR [rbp-0x68],rdi
    2ef4:	mov    rax,rsi
    2ef7:	mov    rsi,rdx
    2efa:	mov    rax,rax
    2efd:	mov    edx,0x0
    2f02:	mov    rdx,rsi
    2f05:	mov    QWORD PTR [rbp-0x80],rax
    2f09:	mov    QWORD PTR [rbp-0x78],rdx
    2f0d:	mov    rax,QWORD PTR fs:0x28
    2f16:	mov    QWORD PTR [rbp-0x18],rax
    2f1a:	xor    eax,eax
  profile_begin_func();
    2f1c:	lea    rcx,[rip+0x194d]        # 4870 <__func__.1>
    2f23:	mov    ebx,0x12
    2f28:	lea    rax,[rbp-0x50]
    2f2c:	mov    rsi,rcx
    2f2f:	mov    rdx,rbx
    2f32:	mov    r8d,0x0
    2f38:	mov    ecx,0x4
    2f3d:	mov    rdi,rax
    2f40:	call   1f6c <__profile_begin_pass>

  JSON_Object *result = NULL;
    2f45:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2f4d:	cmp    QWORD PTR [rbp-0x68],0x0
    2f52:	je     2fa1 <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f54:	mov    rax,QWORD PTR [rbp-0x68]
    2f58:	mov    rax,QWORD PTR [rax+0x20]
    2f5c:	mov    QWORD PTR [rbp-0x58],rax
    2f60:	jmp    2f9a <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2f62:	mov    rax,QWORD PTR [rbp-0x58]
    2f66:	mov    rdx,QWORD PTR [rax+0x8]
    2f6a:	mov    rax,QWORD PTR [rax]
    2f6d:	mov    rdi,QWORD PTR [rbp-0x80]
    2f71:	mov    rsi,QWORD PTR [rbp-0x78]
    2f75:	mov    rcx,rdx
    2f78:	mov    rdx,rax
    2f7b:	call   143f <strings_equal>
    2f80:	test   al,al
    2f82:	je     2f8e <lookup_json_object+0xa7>
      {
        result = cursor;
    2f84:	mov    rax,QWORD PTR [rbp-0x58]
    2f88:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2f8c:	jmp    2fa1 <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f8e:	mov    rax,QWORD PTR [rbp-0x58]
    2f92:	mov    rax,QWORD PTR [rax+0x28]
    2f96:	mov    QWORD PTR [rbp-0x58],rax
    2f9a:	cmp    QWORD PTR [rbp-0x58],0x0
    2f9f:	jne    2f62 <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2fa1:	sub    rsp,0x8
    2fa5:	sub    rsp,0x38
    2fa9:	mov    rax,rsp
    2fac:	mov    rcx,QWORD PTR [rbp-0x50]
    2fb0:	mov    rbx,QWORD PTR [rbp-0x48]
    2fb4:	mov    QWORD PTR [rax],rcx
    2fb7:	mov    QWORD PTR [rax+0x8],rbx
    2fbb:	mov    rcx,QWORD PTR [rbp-0x40]
    2fbf:	mov    rbx,QWORD PTR [rbp-0x38]
    2fc3:	mov    QWORD PTR [rax+0x10],rcx
    2fc7:	mov    QWORD PTR [rax+0x18],rbx
    2fcb:	mov    rcx,QWORD PTR [rbp-0x30]
    2fcf:	mov    rbx,QWORD PTR [rbp-0x28]
    2fd3:	mov    QWORD PTR [rax+0x20],rcx
    2fd7:	mov    QWORD PTR [rax+0x28],rbx
    2fdb:	mov    rdx,QWORD PTR [rbp-0x20]
    2fdf:	mov    QWORD PTR [rax+0x30],rdx
    2fe3:	call   2056 <__profile_end_pass>
    2fe8:	add    rsp,0x40

  return result;
    2fec:	mov    rax,QWORD PTR [rbp-0x60]
}
    2ff0:	mov    rdx,QWORD PTR [rbp-0x18]
    2ff4:	sub    rdx,QWORD PTR fs:0x28
    2ffd:	je     3004 <lookup_json_object+0x11d>
    2fff:	call   1060 <__stack_chk_fail@plt>
    3004:	mov    rbx,QWORD PTR [rbp-0x8]
    3008:	leave
    3009:	ret

000000000000300a <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    300a:	push   rbp
    300b:	mov    rbp,rsp
    300e:	sub    rsp,0x50
    3012:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    3016:	cmp    QWORD PTR [rbp-0x48],0x0
    301b:	jne    3042 <json_object_to_f64+0x38>
    301d:	lea    rdx,[rip+0x186c]        # 4890 <__PRETTY_FUNCTION__.0>
    3024:	lea    rsi,[rip+0x144e]        # 4479 <_IO_stdin_used+0x479>
    302b:	lea    rax,[rip+0x15c6]        # 45f8 <_IO_stdin_used+0x5f8>
    3032:	mov    rcx,rdx
    3035:	mov    edx,0x1c2
    303a:	mov    rdi,rax
    303d:	call   1090 <__assert_fail@plt>

  String val = object->value;
    3042:	mov    rax,QWORD PTR [rbp-0x48]
    3046:	mov    rdx,QWORD PTR [rax+0x18]
    304a:	mov    rax,QWORD PTR [rax+0x10]
    304e:	mov    QWORD PTR [rbp-0x10],rax
    3052:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    3056:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    305e:	movsd  xmm0,QWORD PTR [rip+0x185a]        # 48c0 <__PRETTY_FUNCTION__.0+0x30>
    3066:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    306b:	mov    rax,QWORD PTR [rbp-0x8]
    306f:	cmp    QWORD PTR [rbp-0x30],rax
    3073:	jae    3099 <json_object_to_f64+0x8f>
    3075:	mov    rdx,QWORD PTR [rbp-0x10]
    3079:	mov    rax,QWORD PTR [rbp-0x30]
    307d:	add    rax,rdx
    3080:	movzx  eax,BYTE PTR [rax]
    3083:	cmp    al,0x2d
    3085:	jne    3099 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    3087:	movsd  xmm0,QWORD PTR [rip+0x1839]        # 48c8 <__PRETTY_FUNCTION__.0+0x38>
    308f:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    3094:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    3099:	pxor   xmm0,xmm0
    309d:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    30a2:	jmp    30e9 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    30a4:	mov    rdx,QWORD PTR [rbp-0x10]
    30a8:	mov    rax,QWORD PTR [rbp-0x30]
    30ac:	add    rax,rdx
    30af:	movzx  eax,BYTE PTR [rax]
    30b2:	sub    eax,0x30
    30b5:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    30b8:	cmp    BYTE PTR [rbp-0x32],0x9
    30bc:	ja     30f5 <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    30be:	movsd  xmm1,QWORD PTR [rbp-0x20]
    30c3:	movsd  xmm0,QWORD PTR [rip+0x1805]        # 48d0 <__PRETTY_FUNCTION__.0+0x40>
    30cb:	mulsd  xmm1,xmm0
    30cf:	movzx  eax,BYTE PTR [rbp-0x32]
    30d3:	pxor   xmm0,xmm0
    30d7:	cvtsi2sd xmm0,eax
    30db:	addsd  xmm0,xmm1
    30df:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    30e4:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    30e9:	mov    rax,QWORD PTR [rbp-0x8]
    30ed:	cmp    QWORD PTR [rbp-0x30],rax
    30f1:	jb     30a4 <json_object_to_f64+0x9a>
    30f3:	jmp    30f6 <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    30f5:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    30f6:	mov    rax,QWORD PTR [rbp-0x8]
    30fa:	cmp    QWORD PTR [rbp-0x30],rax
    30fe:	jae    318b <json_object_to_f64+0x181>
    3104:	mov    rdx,QWORD PTR [rbp-0x10]
    3108:	mov    rax,QWORD PTR [rbp-0x30]
    310c:	add    rax,rdx
    310f:	movzx  eax,BYTE PTR [rax]
    3112:	cmp    al,0x2e
    3114:	jne    318b <json_object_to_f64+0x181>
  {
    at += 1;
    3116:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    311b:	movsd  xmm0,QWORD PTR [rip+0x17b5]        # 48d8 <__PRETTY_FUNCTION__.0+0x48>
    3123:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    3128:	jmp    317e <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    312a:	mov    rdx,QWORD PTR [rbp-0x10]
    312e:	mov    rax,QWORD PTR [rbp-0x30]
    3132:	add    rax,rdx
    3135:	movzx  eax,BYTE PTR [rax]
    3138:	sub    eax,0x30
    313b:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    313e:	cmp    BYTE PTR [rbp-0x31],0x9
    3142:	ja     318a <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    3144:	movzx  eax,BYTE PTR [rbp-0x31]
    3148:	pxor   xmm0,xmm0
    314c:	cvtsi2sd xmm0,eax
    3150:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    3155:	movsd  xmm1,QWORD PTR [rbp-0x20]
    315a:	addsd  xmm0,xmm1
    315e:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    3163:	movsd  xmm1,QWORD PTR [rbp-0x18]
    3168:	movsd  xmm0,QWORD PTR [rip+0x1768]        # 48d8 <__PRETTY_FUNCTION__.0+0x48>
    3170:	mulsd  xmm0,xmm1
    3174:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3179:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    317e:	mov    rax,QWORD PTR [rbp-0x8]
    3182:	cmp    QWORD PTR [rbp-0x30],rax
    3186:	jb     312a <json_object_to_f64+0x120>
    3188:	jmp    318b <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    318a:	nop
      }
    }
  }

  return sign * result;
    318b:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3190:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    3195:	leave
    3196:	ret

0000000000003197 <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    3197:	push   rbp
    3198:	mov    rbp,rsp
    319b:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    31a0:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31a5:	movsd  xmm1,QWORD PTR [rip+0x1733]        # 48e0 <__PRETTY_FUNCTION__.0+0x50>
    31ad:	divsd  xmm0,xmm1
}
    31b1:	pop    rbp
    31b2:	ret

00000000000031b3 <square>:

static
f64 square(f64 x)
{
    31b3:	push   rbp
    31b4:	mov    rbp,rsp
    31b7:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    31bc:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31c1:	mulsd  xmm0,xmm0
}
    31c5:	pop    rbp
    31c6:	ret

00000000000031c7 <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    31c7:	push   rbp
    31c8:	mov    rbp,rsp
    31cb:	sub    rsp,0x90
    31d2:	movsd  QWORD PTR [rbp-0x58],xmm0
    31d7:	movsd  QWORD PTR [rbp-0x60],xmm1
    31dc:	movsd  QWORD PTR [rbp-0x68],xmm2
    31e1:	movsd  QWORD PTR [rbp-0x70],xmm3
    31e6:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    31eb:	movsd  xmm0,QWORD PTR [rbp-0x60]
    31f0:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    31f5:	movsd  xmm0,QWORD PTR [rbp-0x70]
    31fa:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    31ff:	movsd  xmm0,QWORD PTR [rbp-0x58]
    3204:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    3209:	movsd  xmm0,QWORD PTR [rbp-0x68]
    320e:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    3213:	movsd  xmm0,QWORD PTR [rbp-0x40]
    3218:	subsd  xmm0,QWORD PTR [rbp-0x48]
    321d:	movq   rax,xmm0
    3222:	movq   xmm0,rax
    3227:	call   3197 <to_radians>
    322c:	movq   rax,xmm0
    3231:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    3235:	movsd  xmm0,QWORD PTR [rbp-0x30]
    323a:	subsd  xmm0,QWORD PTR [rbp-0x38]
    323f:	movq   rax,xmm0
    3244:	movq   xmm0,rax
    3249:	call   3197 <to_radians>
    324e:	movq   rax,xmm0
    3253:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    3257:	mov    rax,QWORD PTR [rbp-0x48]
    325b:	movq   xmm0,rax
    3260:	call   3197 <to_radians>
    3265:	movq   rax,xmm0
    326a:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    326e:	mov    rax,QWORD PTR [rbp-0x40]
    3272:	movq   xmm0,rax
    3277:	call   3197 <to_radians>
    327c:	movq   rax,xmm0
    3281:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    3285:	movsd  xmm0,QWORD PTR [rbp-0x28]
    328a:	movsd  xmm1,QWORD PTR [rip+0x1656]        # 48e8 <__PRETTY_FUNCTION__.0+0x58>
    3292:	divsd  xmm0,xmm1
    3296:	movq   rax,xmm0
    329b:	movq   xmm0,rax
    32a0:	call   1130 <sin@plt>
    32a5:	movq   rax,xmm0
    32aa:	movq   xmm0,rax
    32af:	call   31b3 <square>
    32b4:	movsd  QWORD PTR [rbp-0x80],xmm0
    32b9:	mov    rax,QWORD PTR [rbp-0x48]
    32bd:	movq   xmm0,rax
    32c2:	call   10b0 <cos@plt>
    32c7:	movsd  QWORD PTR [rbp-0x88],xmm0
    32cf:	mov    rax,QWORD PTR [rbp-0x40]
    32d3:	movq   xmm0,rax
    32d8:	call   10b0 <cos@plt>
    32dd:	movapd xmm5,xmm0
    32e1:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    32e9:	movsd  QWORD PTR [rbp-0x88],xmm5
    32f1:	movsd  xmm0,QWORD PTR [rbp-0x20]
    32f6:	movsd  xmm1,QWORD PTR [rip+0x15ea]        # 48e8 <__PRETTY_FUNCTION__.0+0x58>
    32fe:	movapd xmm6,xmm0
    3302:	divsd  xmm6,xmm1
    3306:	movq   rax,xmm6
    330b:	movq   xmm0,rax
    3310:	call   1130 <sin@plt>
    3315:	movq   rax,xmm0
    331a:	movq   xmm0,rax
    331f:	call   31b3 <square>
    3324:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    332c:	addsd  xmm0,QWORD PTR [rbp-0x80]
    3331:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    3336:	mov    rax,QWORD PTR [rbp-0x18]
    333a:	movq   xmm0,rax
    333f:	call   1160 <sqrt@plt>
    3344:	movq   rax,xmm0
    3349:	movq   xmm0,rax
    334e:	call   1140 <asin@plt>
    3353:	addsd  xmm0,xmm0
    3357:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    335c:	movsd  xmm0,QWORD PTR [rbp-0x78]
    3361:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    3366:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    336b:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    3370:	leave
    3371:	ret

0000000000003372 <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    3372:	push   rbp
    3373:	mov    rbp,rsp
    3376:	movsd  QWORD PTR [rbp-0x18],xmm0
    337b:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    3380:	movsd  xmm0,QWORD PTR [rip+0x1568]        # 48f0 <__PRETTY_FUNCTION__.0+0x60>
    3388:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    338d:	movsd  xmm0,QWORD PTR [rbp-0x18]
    3392:	movq   xmm1,QWORD PTR [rip+0x1566]        # 4900 <__PRETTY_FUNCTION__.0+0x70>
    339a:	andpd  xmm0,xmm1
    339e:	movsd  xmm1,QWORD PTR [rbp-0x20]
    33a3:	movq   xmm2,QWORD PTR [rip+0x1555]        # 4900 <__PRETTY_FUNCTION__.0+0x70>
    33ab:	andpd  xmm2,xmm1
    33af:	movapd xmm1,xmm0
    33b3:	subsd  xmm1,xmm2
    33b7:	movsd  xmm0,QWORD PTR [rbp-0x8]
    33bc:	comisd xmm0,xmm1
    33c0:	setae  al
    33c3:	movzx  eax,al
}
    33c6:	pop    rbp
    33c7:	ret

00000000000033c8 <main>:

int main(int args_count, char **args)
{
    33c8:	push   rbp
    33c9:	mov    rbp,rsp
    33cc:	push   r15
    33ce:	push   r14
    33d0:	push   r13
    33d2:	push   r12
    33d4:	push   rbx
    33d5:	sub    rsp,0x2d8
    33dc:	mov    DWORD PTR [rbp-0x244],edi
    33e2:	mov    QWORD PTR [rbp-0x250],rsi
    33e9:	mov    rax,QWORD PTR fs:0x28
    33f2:	mov    QWORD PTR [rbp-0x38],rax
    33f6:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    33f8:	cmp    DWORD PTR [rbp-0x244],0x3
    33ff:	je     342c <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    3401:	mov    rax,QWORD PTR [rbp-0x250]
    3408:	mov    rax,QWORD PTR [rax]
    340b:	lea    rdx,[rip+0x121e]        # 4630 <_IO_stdin_used+0x630>
    3412:	mov    rsi,rax
    3415:	mov    rdi,rdx
    3418:	mov    eax,0x0
    341d:	call   1070 <printf@plt>
    return 1;
    3422:	mov    eax,0x1
    3427:	jmp    3ee0 <main+0xb18>
  }

  begin_profiling();
    342c:	call   1b3d <begin_profiling>

  Arena arena = {0};
    3431:	pxor   xmm0,xmm0
    3435:	movaps XMMWORD PTR [rbp-0x190],xmm0
    343c:	movaps XMMWORD PTR [rbp-0x180],xmm0
  arena = arena_make(GB(4));
    3443:	lea    rdx,[rbp-0x270]
    344a:	movabs rax,0x100000000
    3454:	mov    rsi,rax
    3457:	mov    rdi,rdx
    345a:	call   1632 <arena_make>
    345f:	mov    rax,QWORD PTR [rbp-0x270]
    3466:	mov    rdx,QWORD PTR [rbp-0x268]
    346d:	mov    QWORD PTR [rbp-0x190],rax
    3474:	mov    QWORD PTR [rbp-0x188],rdx
    347b:	mov    rax,QWORD PTR [rbp-0x260]
    3482:	mov    rdx,QWORD PTR [rbp-0x258]
    3489:	mov    QWORD PTR [rbp-0x180],rax
    3490:	mov    QWORD PTR [rbp-0x178],rdx

  String source = {0};
    3497:	mov    QWORD PTR [rbp-0x1a0],0x0
    34a2:	mov    QWORD PTR [rbp-0x198],0x0
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    34ad:	mov    rax,QWORD PTR [rbp-0x250]
    34b4:	add    rax,0x8
    34b8:	mov    rax,QWORD PTR [rax]
    34bb:	mov    rdi,rax
    34be:	call   1303 <file_size>
    34c3:	mov    rcx,rax
    34c6:	lea    r12,[rip+0x118f]        # 465c <_IO_stdin_used+0x65c>
    34cd:	mov    r13d,0x4
    34d3:	lea    rdi,[rbp-0x170]
    34da:	mov    rdx,r12
    34dd:	mov    rax,r13
    34e0:	mov    r8,rcx
    34e3:	mov    ecx,0x5
    34e8:	mov    rsi,rdx
    34eb:	mov    rdx,rax
    34ee:	call   1f6c <__profile_begin_pass>
    34f3:	mov    QWORD PTR [rbp-0x230],0x0
    34fe:	jmp    3599 <main+0x1d1>
  {
    source = read_file_to_arena(&arena, args[1]);
    3503:	mov    rax,QWORD PTR [rbp-0x250]
    350a:	add    rax,0x8
    350e:	mov    rdx,QWORD PTR [rax]
    3511:	lea    rax,[rbp-0x190]
    3518:	mov    rsi,rdx
    351b:	mov    rdi,rax
    351e:	call   1357 <read_file_to_arena>
    3523:	mov    QWORD PTR [rbp-0x1a0],rax
    352a:	mov    QWORD PTR [rbp-0x198],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    3531:	add    QWORD PTR [rbp-0x230],0x1
    3539:	sub    rsp,0x8
    353d:	sub    rsp,0x38
    3541:	mov    rcx,rsp
    3544:	mov    rax,QWORD PTR [rbp-0x170]
    354b:	mov    rdx,QWORD PTR [rbp-0x168]
    3552:	mov    QWORD PTR [rcx],rax
    3555:	mov    QWORD PTR [rcx+0x8],rdx
    3559:	mov    rax,QWORD PTR [rbp-0x160]
    3560:	mov    rdx,QWORD PTR [rbp-0x158]
    3567:	mov    QWORD PTR [rcx+0x10],rax
    356b:	mov    QWORD PTR [rcx+0x18],rdx
    356f:	mov    rax,QWORD PTR [rbp-0x150]
    3576:	mov    rdx,QWORD PTR [rbp-0x148]
    357d:	mov    QWORD PTR [rcx+0x20],rax
    3581:	mov    QWORD PTR [rcx+0x28],rdx
    3585:	mov    rax,QWORD PTR [rbp-0x140]
    358c:	mov    QWORD PTR [rcx+0x30],rax
    3590:	call   2056 <__profile_end_pass>
    3595:	add    rsp,0x40
    3599:	cmp    QWORD PTR [rbp-0x230],0x0
    35a1:	je     3503 <main+0x13b>
  }

  Haversine_Pair *pairs = NULL;
    35a7:	mov    QWORD PTR [rbp-0x228],0x0
  i32 pair_count = 0;
    35b2:	mov    DWORD PTR [rbp-0x238],0x0
  usize max_pairs = 0;
    35bc:	mov    QWORD PTR [rbp-0x220],0x0
  PROFILE_SCOPE("haversine alloc")
    35c7:	lea    r14,[rip+0x1093]        # 4661 <_IO_stdin_used+0x661>
    35ce:	mov    r15d,0xf
    35d4:	lea    rdi,[rbp-0x130]
    35db:	mov    rdx,r14
    35de:	mov    rax,r15
    35e1:	mov    r8d,0x0
    35e7:	mov    ecx,0x6
    35ec:	mov    rsi,rdx
    35ef:	mov    rdx,rax
    35f2:	call   1f6c <__profile_begin_pass>
    35f7:	mov    QWORD PTR [rbp-0x218],0x0
    3602:	jmp    36ca <main+0x302>
  {
    usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    3607:	mov    QWORD PTR [rbp-0x1a8],0x18
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    3612:	mov    rax,QWORD PTR [rbp-0x198]
    3619:	mov    edx,0x0
    361e:	div    QWORD PTR [rbp-0x1a8]
    3625:	mov    QWORD PTR [rbp-0x220],rax

    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    362c:	mov    rax,QWORD PTR [rbp-0x220]
    3633:	shl    rax,0x5
    3637:	mov    rcx,rax
    363a:	lea    rax,[rbp-0x190]
    3641:	mov    edx,0x8
    3646:	mov    rsi,rcx
    3649:	mov    rdi,rax
    364c:	call   17d3 <arena_alloc>
    3651:	mov    QWORD PTR [rbp-0x228],rax
    pair_count = 0;
    3658:	mov    DWORD PTR [rbp-0x238],0x0
  PROFILE_SCOPE("haversine alloc")
    3662:	add    QWORD PTR [rbp-0x218],0x1
    366a:	sub    rsp,0x8
    366e:	sub    rsp,0x38
    3672:	mov    rcx,rsp
    3675:	mov    rax,QWORD PTR [rbp-0x130]
    367c:	mov    rdx,QWORD PTR [rbp-0x128]
    3683:	mov    QWORD PTR [rcx],rax
    3686:	mov    QWORD PTR [rcx+0x8],rdx
    368a:	mov    rax,QWORD PTR [rbp-0x120]
    3691:	mov    rdx,QWORD PTR [rbp-0x118]
    3698:	mov    QWORD PTR [rcx+0x10],rax
    369c:	mov    QWORD PTR [rcx+0x18],rdx
    36a0:	mov    rax,QWORD PTR [rbp-0x110]
    36a7:	mov    rdx,QWORD PTR [rbp-0x108]
    36ae:	mov    QWORD PTR [rcx+0x20],rax
    36b2:	mov    QWORD PTR [rcx+0x28],rdx
    36b6:	mov    rax,QWORD PTR [rbp-0x100]
    36bd:	mov    QWORD PTR [rcx+0x30],rax
    36c1:	call   2056 <__profile_end_pass>
    36c6:	add    rsp,0x40
    36ca:	cmp    QWORD PTR [rbp-0x218],0x0
    36d2:	je     3607 <main+0x23f>
  }

  JSON_Object *root = NULL;
    36d8:	mov    QWORD PTR [rbp-0x1d8],0x0
  root = parse_json(&arena, source);
    36e3:	mov    rcx,QWORD PTR [rbp-0x1a0]
    36ea:	mov    rdx,QWORD PTR [rbp-0x198]
    36f1:	lea    rax,[rbp-0x190]
    36f8:	mov    rsi,rcx
    36fb:	mov    rdi,rax
    36fe:	call   2d84 <parse_json>
    3703:	mov    QWORD PTR [rbp-0x1d8],rax

  f64 haversine_sum = 0.0;
    370a:	pxor   xmm0,xmm0
    370e:	movsd  QWORD PTR [rbp-0x1d0],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    3716:	lea    rax,[rip+0xf54]        # 4671 <_IO_stdin_used+0x671>
    371d:	mov    QWORD PTR [rbp-0x280],rax
    3724:	mov    QWORD PTR [rbp-0x278],0x5
    372f:	mov    rax,QWORD PTR [rbp-0x280]
    3736:	mov    rdx,QWORD PTR [rbp-0x278]
    373d:	mov    rcx,rax
    3740:	mov    rax,QWORD PTR [rbp-0x1d8]
    3747:	mov    rsi,rcx
    374a:	mov    rdi,rax
    374d:	call   2ee7 <lookup_json_object>
    3752:	mov    QWORD PTR [rbp-0x1c8],rax
  if (pairs)
    3759:	cmp    QWORD PTR [rbp-0x228],0x0
    3761:	je     39f6 <main+0x62e>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    3767:	mov    rax,QWORD PTR [rbp-0x1c8]
    376e:	mov    rax,QWORD PTR [rax+0x20]
    3772:	mov    QWORD PTR [rbp-0x210],rax
    3779:	jmp    39d7 <main+0x60f>
    {
      PROFILE_SCOPE("child convert")
    377e:	lea    rax,[rip+0xef2]        # 4677 <_IO_stdin_used+0x677>
    3785:	mov    QWORD PTR [rbp-0x2c0],rax
    378c:	mov    QWORD PTR [rbp-0x2b8],0xd
    3797:	lea    rdi,[rbp-0x70]
    379b:	mov    rbx,QWORD PTR [rbp-0x2c0]
    37a2:	mov    rsi,QWORD PTR [rbp-0x2b8]
    37a9:	mov    rdx,rbx
    37ac:	mov    rax,rsi
    37af:	mov    r8d,0x0
    37b5:	mov    ecx,0x7
    37ba:	mov    rsi,rdx
    37bd:	mov    rdx,rax
    37c0:	call   1f6c <__profile_begin_pass>
    37c5:	mov    QWORD PTR [rbp-0x208],0x0
    37d0:	jmp    39b7 <main+0x5ef>
      {
        Haversine_Pair pair =
        {
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    37d5:	lea    rax,[rip+0xea9]        # 4685 <_IO_stdin_used+0x685>
    37dc:	mov    QWORD PTR [rbp-0x2d0],rax
    37e3:	mov    QWORD PTR [rbp-0x2c8],0x2
    37ee:	mov    rbx,QWORD PTR [rbp-0x2d0]
    37f5:	mov    rsi,QWORD PTR [rbp-0x2c8]
    37fc:	mov    rax,rbx
    37ff:	mov    rdx,rsi
    3802:	mov    rcx,QWORD PTR [rbp-0x210]
    3809:	mov    rsi,rax
    380c:	mov    rdi,rcx
    380f:	call   2ee7 <lookup_json_object>
    3814:	mov    rdi,rax
    3817:	call   300a <json_object_to_f64>
    381c:	movq   rax,xmm0
        Haversine_Pair pair =
    3821:	mov    QWORD PTR [rbp-0xb0],rax
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    3828:	lea    rax,[rip+0xe59]        # 4688 <_IO_stdin_used+0x688>
    382f:	mov    QWORD PTR [rbp-0x2e0],rax
    3836:	mov    QWORD PTR [rbp-0x2d8],0x2
    3841:	mov    rax,QWORD PTR [rbp-0x2e0]
    3848:	mov    rdx,QWORD PTR [rbp-0x2d8]
    384f:	mov    rcx,rax
    3852:	mov    rax,QWORD PTR [rbp-0x210]
    3859:	mov    rsi,rcx
    385c:	mov    rdi,rax
    385f:	call   2ee7 <lookup_json_object>
    3864:	mov    rdi,rax
    3867:	call   300a <json_object_to_f64>
    386c:	movq   rax,xmm0
        Haversine_Pair pair =
    3871:	mov    QWORD PTR [rbp-0xa8],rax
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    3878:	lea    rax,[rip+0xe0c]        # 468b <_IO_stdin_used+0x68b>
    387f:	mov    QWORD PTR [rbp-0x2f0],rax
    3886:	mov    QWORD PTR [rbp-0x2e8],0x2
    3891:	mov    rax,QWORD PTR [rbp-0x2f0]
    3898:	mov    rdx,QWORD PTR [rbp-0x2e8]
    389f:	mov    rcx,rax
    38a2:	mov    rax,QWORD PTR [rbp-0x210]
    38a9:	mov    rsi,rcx
    38ac:	mov    rdi,rax
    38af:	call   2ee7 <lookup_json_object>
    38b4:	mov    rdi,rax
    38b7:	call   300a <json_object_to_f64>
    38bc:	movq   rax,xmm0
        Haversine_Pair pair =
    38c1:	mov    QWORD PTR [rbp-0xa0],rax
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    38c8:	lea    rax,[rip+0xdbf]        # 468e <_IO_stdin_used+0x68e>
    38cf:	mov    QWORD PTR [rbp-0x300],rax
    38d6:	mov    QWORD PTR [rbp-0x2f8],0x2
    38e1:	mov    rax,QWORD PTR [rbp-0x300]
    38e8:	mov    rdx,QWORD PTR [rbp-0x2f8]
    38ef:	mov    rcx,rax
    38f2:	mov    rax,QWORD PTR [rbp-0x210]
    38f9:	mov    rsi,rcx
    38fc:	mov    rdi,rax
    38ff:	call   2ee7 <lookup_json_object>
    3904:	mov    rdi,rax
    3907:	call   300a <json_object_to_f64>
    390c:	movq   rax,xmm0
        Haversine_Pair pair =
    3911:	mov    QWORD PTR [rbp-0x98],rax
        };

        pairs[pair_count] = pair;
    3918:	mov    eax,DWORD PTR [rbp-0x238]
    391e:	cdqe
    3920:	shl    rax,0x5
    3924:	mov    rdx,rax
    3927:	mov    rax,QWORD PTR [rbp-0x228]
    392e:	lea    rcx,[rdx+rax*1]
    3932:	mov    rax,QWORD PTR [rbp-0xb0]
    3939:	mov    rdx,QWORD PTR [rbp-0xa8]
    3940:	mov    QWORD PTR [rcx],rax
    3943:	mov    QWORD PTR [rcx+0x8],rdx
    3947:	mov    rax,QWORD PTR [rbp-0xa0]
    394e:	mov    rdx,QWORD PTR [rbp-0x98]
    3955:	mov    QWORD PTR [rcx+0x10],rax
    3959:	mov    QWORD PTR [rcx+0x18],rdx
        pair_count += 1;
    395d:	add    DWORD PTR [rbp-0x238],0x1
      PROFILE_SCOPE("child convert")
    3964:	add    QWORD PTR [rbp-0x208],0x1
    396c:	sub    rsp,0x8
    3970:	sub    rsp,0x38
    3974:	mov    rcx,rsp
    3977:	mov    rax,QWORD PTR [rbp-0x70]
    397b:	mov    rdx,QWORD PTR [rbp-0x68]
    397f:	mov    QWORD PTR [rcx],rax
    3982:	mov    QWORD PTR [rcx+0x8],rdx
    3986:	mov    rax,QWORD PTR [rbp-0x60]
    398a:	mov    rdx,QWORD PTR [rbp-0x58]
    398e:	mov    QWORD PTR [rcx+0x10],rax
    3992:	mov    QWORD PTR [rcx+0x18],rdx
    3996:	mov    rax,QWORD PTR [rbp-0x50]
    399a:	mov    rdx,QWORD PTR [rbp-0x48]
    399e:	mov    QWORD PTR [rcx+0x20],rax
    39a2:	mov    QWORD PTR [rcx+0x28],rdx
    39a6:	mov    rax,QWORD PTR [rbp-0x40]
    39aa:	mov    QWORD PTR [rcx+0x30],rax
    39ae:	call   2056 <__profile_end_pass>
    39b3:	add    rsp,0x40
    39b7:	cmp    QWORD PTR [rbp-0x208],0x0
    39bf:	je     37d5 <main+0x40d>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    39c5:	mov    rax,QWORD PTR [rbp-0x210]
    39cc:	mov    rax,QWORD PTR [rax+0x28]
    39d0:	mov    QWORD PTR [rbp-0x210],rax
    39d7:	cmp    QWORD PTR [rbp-0x210],0x0
    39df:	je     39f6 <main+0x62e>
    39e1:	mov    eax,DWORD PTR [rbp-0x238]
    39e7:	cdqe
    39e9:	cmp    rax,QWORD PTR [rbp-0x220]
    39f0:	jb     377e <main+0x3b6>
      }
    }
  }

  f64 sum = 0.0;
    39f6:	pxor   xmm0,xmm0
    39fa:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3a02:	lea    rax,[rip+0xc88]        # 4691 <_IO_stdin_used+0x691>
    3a09:	mov    QWORD PTR [rbp-0x290],rax
    3a10:	mov    QWORD PTR [rbp-0x288],0x3
    3a1b:	lea    rax,[rbp-0xf0]
    3a22:	mov    rcx,QWORD PTR [rbp-0x290]
    3a29:	mov    rbx,QWORD PTR [rbp-0x288]
    3a30:	mov    rsi,rcx
    3a33:	mov    rdx,rbx
    3a36:	mov    r8d,0x0
    3a3c:	mov    ecx,0x8
    3a41:	mov    rdi,rax
    3a44:	call   1f6c <__profile_begin_pass>
    3a49:	mov    QWORD PTR [rbp-0x1f8],0x0
    3a54:	jmp    3bd6 <main+0x80e>
  {
    for (usize i = 0; i < pair_count; i++)
    3a59:	mov    QWORD PTR [rbp-0x1f0],0x0
    3a64:	jmp    3b39 <main+0x771>
    {
      f64 earth_radius = 6372.8;
    3a69:	movsd  xmm0,QWORD PTR [rip+0xe9f]        # 4910 <__PRETTY_FUNCTION__.0+0x80>
    3a71:	movsd  QWORD PTR [rbp-0x1b8],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    3a79:	mov    rax,QWORD PTR [rbp-0x1f0]
    3a80:	shl    rax,0x5
    3a84:	mov    rdx,rax
    3a87:	mov    rax,QWORD PTR [rbp-0x228]
    3a8e:	add    rax,rdx
    3a91:	movsd  xmm2,QWORD PTR [rax+0x18]
    3a96:	mov    rax,QWORD PTR [rbp-0x1f0]
    3a9d:	shl    rax,0x5
    3aa1:	mov    rdx,rax
    3aa4:	mov    rax,QWORD PTR [rbp-0x228]
    3aab:	add    rax,rdx
    3aae:	movsd  xmm1,QWORD PTR [rax+0x10]
    3ab3:	mov    rax,QWORD PTR [rbp-0x1f0]
    3aba:	shl    rax,0x5
    3abe:	mov    rdx,rax
    3ac1:	mov    rax,QWORD PTR [rbp-0x228]
    3ac8:	add    rax,rdx
    3acb:	movsd  xmm0,QWORD PTR [rax+0x8]
    3ad0:	mov    rax,QWORD PTR [rbp-0x1f0]
    3ad7:	shl    rax,0x5
    3adb:	mov    rdx,rax
    3ade:	mov    rax,QWORD PTR [rbp-0x228]
    3ae5:	add    rax,rdx
    3ae8:	mov    rax,QWORD PTR [rax]
    3aeb:	movsd  xmm3,QWORD PTR [rbp-0x1b8]
    3af3:	movapd xmm4,xmm3
    3af7:	movapd xmm3,xmm2
    3afb:	movapd xmm2,xmm1
    3aff:	movapd xmm1,xmm0
    3b03:	movq   xmm0,rax
    3b08:	call   31c7 <reference_haversine>
    3b0d:	movq   rax,xmm0
    3b12:	mov    QWORD PTR [rbp-0x1b0],rax
      sum += result;
    3b19:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b21:	addsd  xmm0,QWORD PTR [rbp-0x1b0]
    3b29:	movsd  QWORD PTR [rbp-0x200],xmm0
    for (usize i = 0; i < pair_count; i++)
    3b31:	add    QWORD PTR [rbp-0x1f0],0x1
    3b39:	mov    eax,DWORD PTR [rbp-0x238]
    3b3f:	cdqe
    3b41:	cmp    QWORD PTR [rbp-0x1f0],rax
    3b48:	jb     3a69 <main+0x6a1>
    }
    sum /= pair_count;
    3b4e:	pxor   xmm1,xmm1
    3b52:	cvtsi2sd xmm1,DWORD PTR [rbp-0x238]
    3b5a:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b62:	divsd  xmm0,xmm1
    3b66:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3b6e:	add    QWORD PTR [rbp-0x1f8],0x1
    3b76:	sub    rsp,0x8
    3b7a:	sub    rsp,0x38
    3b7e:	mov    rax,rsp
    3b81:	mov    rcx,QWORD PTR [rbp-0xf0]
    3b88:	mov    rbx,QWORD PTR [rbp-0xe8]
    3b8f:	mov    QWORD PTR [rax],rcx
    3b92:	mov    QWORD PTR [rax+0x8],rbx
    3b96:	mov    rcx,QWORD PTR [rbp-0xe0]
    3b9d:	mov    rbx,QWORD PTR [rbp-0xd8]
    3ba4:	mov    QWORD PTR [rax+0x10],rcx
    3ba8:	mov    QWORD PTR [rax+0x18],rbx
    3bac:	mov    rcx,QWORD PTR [rbp-0xd0]
    3bb3:	mov    rbx,QWORD PTR [rbp-0xc8]
    3bba:	mov    QWORD PTR [rax+0x20],rcx
    3bbe:	mov    QWORD PTR [rax+0x28],rbx
    3bc2:	mov    rdx,QWORD PTR [rbp-0xc0]
    3bc9:	mov    QWORD PTR [rax+0x30],rdx
    3bcd:	call   2056 <__profile_end_pass>
    3bd2:	add    rsp,0x40
    3bd6:	cmp    QWORD PTR [rbp-0x1f8],0x0
    3bde:	je     3a59 <main+0x691>
  }

  PROFILE_SCOPE("check")
    3be4:	lea    rax,[rip+0xaaa]        # 4695 <_IO_stdin_used+0x695>
    3beb:	mov    QWORD PTR [rbp-0x2a0],rax
    3bf2:	mov    QWORD PTR [rbp-0x298],0x5
    3bfd:	lea    rax,[rbp-0xb0]
    3c04:	mov    rcx,QWORD PTR [rbp-0x2a0]
    3c0b:	mov    rbx,QWORD PTR [rbp-0x298]
    3c12:	mov    rsi,rcx
    3c15:	mov    rdx,rbx
    3c18:	mov    r8d,0x0
    3c1e:	mov    ecx,0x9
    3c23:	mov    rdi,rax
    3c26:	call   1f6c <__profile_begin_pass>
    3c2b:	mov    QWORD PTR [rbp-0x1e8],0x0
    3c36:	jmp    3e0b <main+0xa43>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3c3b:	mov    rax,QWORD PTR [rbp-0x250]
    3c42:	add    rax,0x10
    3c46:	mov    rdx,QWORD PTR [rax]
    3c49:	lea    rax,[rbp-0x190]
    3c50:	mov    rsi,rdx
    3c53:	mov    rdi,rax
    3c56:	call   1357 <read_file_to_arena>
    3c5b:	mov    QWORD PTR [rbp-0x70],rax
    3c5f:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3c63:	mov    rax,QWORD PTR [rbp-0x68]
    3c67:	cmp    rax,0xb
    3c6b:	jbe    3d7e <main+0x9b6>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3c71:	mov    rax,QWORD PTR [rbp-0x70]
    3c75:	movsd  xmm0,QWORD PTR [rax]
    3c79:	movsd  QWORD PTR [rbp-0x1c0],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3c81:	mov    rax,QWORD PTR [rbp-0x70]
    3c85:	mov    eax,DWORD PTR [rax+0x8]
    3c88:	mov    DWORD PTR [rbp-0x234],eax

      if (solution_pairs == pair_count)
    3c8e:	mov    eax,DWORD PTR [rbp-0x234]
    3c94:	cmp    eax,DWORD PTR [rbp-0x238]
    3c9a:	jne    3d42 <main+0x97a>
      {
        if (epsilon_equal(solution_sum, sum))
    3ca0:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3ca8:	mov    rax,QWORD PTR [rbp-0x1c0]
    3caf:	movapd xmm1,xmm0
    3cb3:	movq   xmm0,rax
    3cb8:	call   3372 <epsilon_equal>
    3cbd:	test   eax,eax
    3cbf:	je     3d03 <main+0x93b>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3cc1:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3cc9:	mov    rax,QWORD PTR [rbp-0x1c0]
    3cd0:	lea    rdx,[rip+0x9c9]        # 46a0 <_IO_stdin_used+0x6a0>
    3cd7:	lea    rsi,[rip+0x9f5]        # 46d3 <_IO_stdin_used+0x6d3>
    3cde:	movapd xmm1,xmm0
    3ce2:	movq   xmm0,rax
    3ce7:	mov    rcx,rdx
    3cea:	mov    edx,0x64
    3cef:	mov    edi,0x3
    3cf4:	mov    eax,0x2
    3cf9:	call   14a1 <log_message>
    3cfe:	jmp    3da6 <main+0x9de>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3d03:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3d0b:	mov    rax,QWORD PTR [rbp-0x1c0]
    3d12:	lea    rdx,[rip+0x9cf]        # 46e8 <_IO_stdin_used+0x6e8>
    3d19:	lea    rsi,[rip+0x9b3]        # 46d3 <_IO_stdin_used+0x6d3>
    3d20:	movapd xmm1,xmm0
    3d24:	movq   xmm0,rax
    3d29:	mov    rcx,rdx
    3d2c:	mov    edx,0x68
    3d31:	mov    edi,0x1
    3d36:	mov    eax,0x2
    3d3b:	call   14a1 <log_message>
    3d40:	jmp    3da6 <main+0x9de>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3d42:	mov    esi,DWORD PTR [rbp-0x238]
    3d48:	mov    ecx,DWORD PTR [rbp-0x234]
    3d4e:	lea    rdx,[rip+0x9cb]        # 4720 <_IO_stdin_used+0x720>
    3d55:	lea    rax,[rip+0x977]        # 46d3 <_IO_stdin_used+0x6d3>
    3d5c:	mov    r9d,esi
    3d5f:	mov    r8d,ecx
    3d62:	mov    rcx,rdx
    3d65:	mov    edx,0x6d
    3d6a:	mov    rsi,rax
    3d6d:	mov    edi,0x1
    3d72:	mov    eax,0x0
    3d77:	call   14a1 <log_message>
    3d7c:	jmp    3da6 <main+0x9de>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3d7e:	lea    rdx,[rip+0x9e3]        # 4768 <_IO_stdin_used+0x768>
    3d85:	lea    rax,[rip+0x947]        # 46d3 <_IO_stdin_used+0x6d3>
    3d8c:	mov    rcx,rdx
    3d8f:	mov    edx,0x72
    3d94:	mov    rsi,rax
    3d97:	mov    edi,0x1
    3d9c:	mov    eax,0x0
    3da1:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3da6:	add    QWORD PTR [rbp-0x1e8],0x1
    3dae:	sub    rsp,0x8
    3db2:	sub    rsp,0x38
    3db6:	mov    rax,rsp
    3db9:	mov    rcx,QWORD PTR [rbp-0xb0]
    3dc0:	mov    rbx,QWORD PTR [rbp-0xa8]
    3dc7:	mov    QWORD PTR [rax],rcx
    3dca:	mov    QWORD PTR [rax+0x8],rbx
    3dce:	mov    rcx,QWORD PTR [rbp-0xa0]
    3dd5:	mov    rbx,QWORD PTR [rbp-0x98]
    3ddc:	mov    QWORD PTR [rax+0x10],rcx
    3de0:	mov    QWORD PTR [rax+0x18],rbx
    3de4:	mov    rcx,QWORD PTR [rbp-0x90]
    3deb:	mov    rbx,QWORD PTR [rbp-0x88]
    3df2:	mov    QWORD PTR [rax+0x20],rcx
    3df6:	mov    QWORD PTR [rax+0x28],rbx
    3dfa:	mov    rdx,QWORD PTR [rbp-0x80]
    3dfe:	mov    QWORD PTR [rax+0x30],rdx
    3e02:	call   2056 <__profile_end_pass>
    3e07:	add    rsp,0x40
    3e0b:	cmp    QWORD PTR [rbp-0x1e8],0x0
    3e13:	je     3c3b <main+0x873>
    }
  }

  PROFILE_SCOPE("free")
    3e19:	lea    rax,[rip+0x983]        # 47a3 <_IO_stdin_used+0x7a3>
    3e20:	mov    QWORD PTR [rbp-0x2b0],rax
    3e27:	mov    QWORD PTR [rbp-0x2a8],0x4
    3e32:	lea    rax,[rbp-0x70]
    3e36:	mov    rcx,QWORD PTR [rbp-0x2b0]
    3e3d:	mov    rbx,QWORD PTR [rbp-0x2a8]
    3e44:	mov    rsi,rcx
    3e47:	mov    rdx,rbx
    3e4a:	mov    r8d,0x0
    3e50:	mov    ecx,0xa
    3e55:	mov    rdi,rax
    3e58:	call   1f6c <__profile_begin_pass>
    3e5d:	mov    QWORD PTR [rbp-0x1e0],0x0
    3e68:	jmp    3ecc <main+0xb04>
  {
    arena_free(&arena);
    3e6a:	lea    rax,[rbp-0x190]
    3e71:	mov    rdi,rax
    3e74:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3e79:	add    QWORD PTR [rbp-0x1e0],0x1
    3e81:	sub    rsp,0x8
    3e85:	sub    rsp,0x38
    3e89:	mov    rax,rsp
    3e8c:	mov    rcx,QWORD PTR [rbp-0x70]
    3e90:	mov    rbx,QWORD PTR [rbp-0x68]
    3e94:	mov    QWORD PTR [rax],rcx
    3e97:	mov    QWORD PTR [rax+0x8],rbx
    3e9b:	mov    rcx,QWORD PTR [rbp-0x60]
    3e9f:	mov    rbx,QWORD PTR [rbp-0x58]
    3ea3:	mov    QWORD PTR [rax+0x10],rcx
    3ea7:	mov    QWORD PTR [rax+0x18],rbx
    3eab:	mov    rcx,QWORD PTR [rbp-0x50]
    3eaf:	mov    rbx,QWORD PTR [rbp-0x48]
    3eb3:	mov    QWORD PTR [rax+0x20],rcx
    3eb7:	mov    QWORD PTR [rax+0x28],rbx
    3ebb:	mov    rdx,QWORD PTR [rbp-0x40]
    3ebf:	mov    QWORD PTR [rax+0x30],rdx
    3ec3:	call   2056 <__profile_end_pass>
    3ec8:	add    rsp,0x40
    3ecc:	cmp    QWORD PTR [rbp-0x1e0],0x0
    3ed4:	je     3e6a <main+0xaa2>
  }

  end_profiling();
    3ed6:	call   1b9b <end_profiling>
    3edb:	mov    eax,0x0
}
    3ee0:	mov    rdx,QWORD PTR [rbp-0x38]
    3ee4:	sub    rdx,QWORD PTR fs:0x28
    3eed:	je     3ef4 <main+0xb2c>
    3eef:	call   1060 <__stack_chk_fail@plt>
    3ef4:	lea    rsp,[rbp-0x28]
    3ef8:	pop    rbx
    3ef9:	pop    r12
    3efb:	pop    r13
    3efd:	pop    r14
    3eff:	pop    r15
    3f01:	pop    rbp
    3f02:	ret

Disassembly of section .fini:

0000000000003f04 <_fini>:
    3f04:	endbr64
    3f08:	sub    rsp,0x8
    3f0c:	add    rsp,0x8
    3f10:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x5fc1]        # 6fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x5fca]        # 6ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x5fcc]        # 6ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x5fca]        # 7000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x5fc2]        # 7008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x5fba]        # 7010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x5fb2]        # 7018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x5faa]        # 7020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x5fa2]        # 7028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x5f9a]        # 7030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x5f92]        # 7038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x5f8a]        # 7040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x5f82]        # 7048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x5f7a]        # 7050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x5f72]        # 7058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x5f6a]        # 7060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x5f62]        # 7068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x5f5a]        # 7070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x5f52]        # 7078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x5f4a]        # 7080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x5f42]        # 7088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x5f3a]        # 7090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x5f32]        # 7098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2239]        # 33c8 <main>
    118f:	call   QWORD PTR [rip+0x5e2b]        # 6fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x5fa1]        # 7148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x5f9a]        # 7148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x5e0e]        # 6fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x5f71]        # 7148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x5f6a]        # 7148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x5ddd]        # 6fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x5f6d],0x0        # 7188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x5dba],0x0        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x5e76]        # 70a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x5da8]        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x5f44],0x1        # 7188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x5c6e]        # 7180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x5b89]        # 70c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x5be7]        # 7160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x5b2b]        # 70c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x30b7]        # 47b0 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x308b]        # 47b0 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fce]        # 47c8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2ecf]        # 47d8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2ced]        # 47f0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x5639]        # 71a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x5620],rbx        # 71a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x50
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x55ee]        # 71a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x40],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x40],0x0
    1bbe:	je     1f69 <end_profiling+0x3ce>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x38],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x40]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x38]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c71]        # 48a8 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x38]
    1c44:	mov    rax,QWORD PTR [rbp-0x40]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x50],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x48],0x0
    1c72:	jmp    1f5b <end_profiling+0x3c0>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x48]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x550d]        # 71a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x30],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x30]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1f56 <end_profiling+0x3bb>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x30]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x40]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b97]        # 48b0 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x28],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x30]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x30]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x30]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x30]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x28]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>
        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x30]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x30]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x30]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x40]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2abf]        # 48b0 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x20],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x30]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x20]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x50]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x28]
    1e2c:	movsd  QWORD PTR [rbp-0x50],xmm0

        if (zone->bytes_processed)
    1e31:	mov    rax,QWORD PTR [rbp-0x30]
    1e35:	mov    rax,QWORD PTR [rax+0x28]
    1e39:	test   rax,rax
    1e3c:	je     1f56 <end_profiling+0x3bb>
        {
          u64 gigabytes = zone->bytes_processed / BILLION(1);
    1e42:	mov    rax,QWORD PTR [rbp-0x30]
    1e46:	mov    rax,QWORD PTR [rax+0x28]
    1e4a:	shr    rax,0x9
    1e4e:	movabs rdx,0x44b82fa09b5a53
    1e58:	mul    rdx
    1e5b:	mov    rax,rdx
    1e5e:	shr    rax,0xb
    1e62:	mov    QWORD PTR [rbp-0x18],rax
          u64 megabytes = zone->bytes_processed / MILLION(1);
    1e66:	mov    rax,QWORD PTR [rbp-0x30]
    1e6a:	mov    rax,QWORD PTR [rax+0x28]
    1e6e:	movabs rdx,0x431bde82d7b634db
    1e78:	mul    rdx
    1e7b:	mov    rax,rdx
    1e7e:	shr    rax,0x12
    1e82:	mov    QWORD PTR [rbp-0x10],rax

          f64 gb_per_s = gigabytes / (f64)zone->elapsed_inclusive / (f64)freq * MILLION(1);
    1e86:	mov    rax,QWORD PTR [rbp-0x18]
    1e8a:	test   rax,rax
    1e8d:	js     1e9a <end_profiling+0x2ff>
    1e8f:	pxor   xmm0,xmm0
    1e93:	cvtsi2sd xmm0,rax
    1e98:	jmp    1eb3 <end_profiling+0x318>
    1e9a:	mov    rdx,rax
    1e9d:	shr    rdx,1
    1ea0:	and    eax,0x1
    1ea3:	or     rdx,rax
    1ea6:	pxor   xmm0,xmm0
    1eaa:	cvtsi2sd xmm0,rdx
    1eaf:	addsd  xmm0,xmm0
    1eb3:	mov    rax,QWORD PTR [rbp-0x30]
    1eb7:	mov    rax,QWORD PTR [rax+0x18]
    1ebb:	test   rax,rax
    1ebe:	js     1ecb <end_profiling+0x330>
    1ec0:	pxor   xmm1,xmm1
    1ec4:	cvtsi2sd xmm1,rax
    1ec9:	jmp    1ee4 <end_profiling+0x349>
    1ecb:	mov    rdx,rax
    1ece:	shr    rdx,1
    1ed1:	and    eax,0x1
    1ed4:	or     rdx,rax
    1ed7:	pxor   xmm1,xmm1
    1edb:	cvtsi2sd xmm1,rdx
    1ee0:	addsd  xmm1,xmm1
    1ee4:	movapd xmm2,xmm0
    1ee8:	divsd  xmm2,xmm1
    1eec:	mov    rax,QWORD PTR [rbp-0x38]
    1ef0:	test   rax,rax
    1ef3:	js     1f00 <end_profiling+0x365>
    1ef5:	pxor   xmm0,xmm0
    1ef9:	cvtsi2sd xmm0,rax
    1efe:	jmp    1f19 <end_profiling+0x37e>
    1f00:	mov    rdx,rax
    1f03:	shr    rdx,1
    1f06:	and    eax,0x1
    1f09:	or     rdx,rax
    1f0c:	pxor   xmm0,xmm0
    1f10:	cvtsi2sd xmm0,rdx
    1f15:	addsd  xmm0,xmm0
    1f19:	movapd xmm1,xmm2
    1f1d:	divsd  xmm1,xmm0
    1f21:	movsd  xmm0,QWORD PTR [rip+0x298f]        # 48b8 <__PRETTY_FUNCTION__.0+0x28>
    1f29:	mulsd  xmm0,xmm1
    1f2d:	movsd  QWORD PTR [rbp-0x8],xmm0

          printf("  Megabytes Processed: %lu @ %f GB/s\n", megabytes, gb_per_s);
    1f32:	mov    rdx,QWORD PTR [rbp-0x8]
    1f36:	mov    rax,QWORD PTR [rbp-0x10]
    1f3a:	lea    rcx,[rip+0x2407]        # 4348 <_IO_stdin_used+0x348>
    1f41:	movq   xmm0,rdx
    1f46:	mov    rsi,rax
    1f49:	mov    rdi,rcx
    1f4c:	mov    eax,0x1
    1f51:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1f56:	add    QWORD PTR [rbp-0x48],0x1
    1f5b:	cmp    QWORD PTR [rbp-0x48],0xfff
    1f63:	jbe    1c77 <end_profiling+0xdc>
        }
      }
    }
  }
}
    1f69:	nop
    1f6a:	leave
    1f6b:	ret

0000000000001f6c <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1f6c:	push   rbp
    1f6d:	mov    rbp,rsp
    1f70:	push   rbx
    1f71:	sub    rsp,0x78
    1f75:	mov    QWORD PTR [rbp-0x58],rdi
    1f79:	mov    rax,rsi
    1f7c:	mov    rsi,rdx
    1f7f:	mov    rax,rax
    1f82:	mov    edx,0x0
    1f87:	mov    rdx,rsi
    1f8a:	mov    QWORD PTR [rbp-0x70],rax
    1f8e:	mov    QWORD PTR [rbp-0x68],rdx
    1f92:	mov    QWORD PTR [rbp-0x60],rcx
    1f96:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1f9a:	pxor   xmm0,xmm0
    1f9e:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1fa2:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1fa6:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1faa:	movq   QWORD PTR [rbp-0x20],xmm0
    1faf:	mov    rax,QWORD PTR [rbp-0x70]
    1fb3:	mov    rdx,QWORD PTR [rbp-0x68]
    1fb7:	mov    QWORD PTR [rbp-0x50],rax
    1fbb:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1fbf:	mov    rdx,QWORD PTR [rbp-0x60]
    1fc3:	mov    rax,rdx
    1fc6:	add    rax,rax
    1fc9:	add    rax,rdx
    1fcc:	shl    rax,0x4
    1fd0:	mov    rdx,rax
    1fd3:	lea    rax,[rip+0x51ee]        # 71c8 <g_profiler+0x28>
    1fda:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1fde:	mov    QWORD PTR [rbp-0x38],rax
    1fe2:	mov    rax,QWORD PTR [rbp-0x60]
    1fe6:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1fea:	mov    rax,QWORD PTR [rip+0x51b7]        # 71a8 <g_profiler+0x8>
  Profile_Pass pass =
    1ff1:	mov    QWORD PTR [rbp-0x28],rax
    1ff5:	mov    rax,QWORD PTR [rbp-0x78]
    1ff9:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    1ffd:	mov    rax,QWORD PTR [rbp-0x60]
    2001:	mov    QWORD PTR [rip+0x51a0],rax        # 71a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    2008:	call   1a48 <read_cpu_timer>
    200d:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    2011:	mov    rax,QWORD PTR [rbp-0x58]
    2015:	mov    rcx,QWORD PTR [rbp-0x50]
    2019:	mov    rbx,QWORD PTR [rbp-0x48]
    201d:	mov    QWORD PTR [rax],rcx
    2020:	mov    QWORD PTR [rax+0x8],rbx
    2024:	mov    rcx,QWORD PTR [rbp-0x40]
    2028:	mov    rbx,QWORD PTR [rbp-0x38]
    202c:	mov    QWORD PTR [rax+0x10],rcx
    2030:	mov    QWORD PTR [rax+0x18],rbx
    2034:	mov    rcx,QWORD PTR [rbp-0x30]
    2038:	mov    rbx,QWORD PTR [rbp-0x28]
    203c:	mov    QWORD PTR [rax+0x20],rcx
    2040:	mov    QWORD PTR [rax+0x28],rbx
    2044:	mov    rdx,QWORD PTR [rbp-0x20]
    2048:	mov    QWORD PTR [rax+0x30],rdx
}
    204c:	mov    rax,QWORD PTR [rbp-0x58]
    2050:	mov    rbx,QWORD PTR [rbp-0x8]
    2054:	leave
    2055:	ret

0000000000002056 <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    2056:	push   rbp
    2057:	mov    rbp,rsp
    205a:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    205e:	call   1a48 <read_cpu_timer>
    2063:	mov    rdx,rax
    2066:	mov    rax,QWORD PTR [rbp+0x20]
    206a:	sub    rdx,rax
    206d:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    2071:	mov    rax,QWORD PTR [rbp+0x38]
    2075:	mov    QWORD PTR [rip+0x512c],rax        # 71a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    207c:	mov    rdx,QWORD PTR [rbp+0x30]
    2080:	mov    rax,rdx
    2083:	add    rax,rax
    2086:	add    rax,rdx
    2089:	shl    rax,0x4
    208d:	lea    rdx,[rax+0x10]
    2091:	lea    rax,[rip+0x5108]        # 71a0 <g_profiler>
    2098:	add    rax,rdx
    209b:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    209f:	mov    rax,QWORD PTR [rbp-0x10]
    20a3:	mov    rdx,QWORD PTR [rax+0x10]
    20a7:	mov    rax,QWORD PTR [rbp-0x18]
    20ab:	add    rdx,rax
    20ae:	mov    rax,QWORD PTR [rbp-0x10]
    20b2:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    20b6:	mov    rax,QWORD PTR [rbp-0x10]
    20ba:	mov    rax,QWORD PTR [rax+0x20]
    20be:	lea    rdx,[rax+0x1]
    20c2:	mov    rax,QWORD PTR [rbp-0x10]
    20c6:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    20ca:	mov    rcx,QWORD PTR [rbp-0x10]
    20ce:	mov    rax,QWORD PTR [rbp+0x10]
    20d2:	mov    rdx,QWORD PTR [rbp+0x18]
    20d6:	mov    QWORD PTR [rcx],rax
    20d9:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    20dd:	mov    rdx,QWORD PTR [rbp+0x28]
    20e1:	mov    rax,QWORD PTR [rbp-0x18]
    20e5:	add    rdx,rax
    20e8:	mov    rax,QWORD PTR [rbp-0x10]
    20ec:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    20f0:	mov    rax,QWORD PTR [rbp-0x10]
    20f4:	mov    rdx,QWORD PTR [rax+0x28]
    20f8:	mov    rax,QWORD PTR [rbp+0x40]
    20fc:	add    rdx,rax
    20ff:	mov    rax,QWORD PTR [rbp-0x10]
    2103:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    2107:	mov    rdx,QWORD PTR [rbp+0x38]
    210b:	mov    rax,rdx
    210e:	add    rax,rax
    2111:	add    rax,rdx
    2114:	shl    rax,0x4
    2118:	lea    rdx,[rax+0x10]
    211c:	lea    rax,[rip+0x507d]        # 71a0 <g_profiler>
    2123:	add    rax,rdx
    2126:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    212a:	mov    rax,QWORD PTR [rbp-0x8]
    212e:	mov    rax,QWORD PTR [rax+0x10]
    2132:	sub    rax,QWORD PTR [rbp-0x18]
    2136:	mov    rdx,rax
    2139:	mov    rax,QWORD PTR [rbp-0x8]
    213d:	mov    QWORD PTR [rax+0x10],rdx
}
    2141:	nop
    2142:	leave
    2143:	ret

0000000000002144 <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    2144:	push   rbp
    2145:	mov    rbp,rsp
    2148:	sub    rsp,0x10
    214c:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2150:	mov    rax,QWORD PTR [rbp-0x8]
    2154:	mov    rdx,QWORD PTR [rax+0x10]
    2158:	mov    rax,QWORD PTR [rbp-0x8]
    215c:	mov    rax,QWORD PTR [rax+0x8]
    2160:	cmp    rdx,rax
    2163:	jb     218a <parser_at+0x46>
    2165:	lea    rdx,[rip+0x269c]        # 4808 <__PRETTY_FUNCTION__.5>
    216c:	lea    rsi,[rip+0x2306]        # 4479 <_IO_stdin_used+0x479>
    2173:	lea    rax,[rip+0x2316]        # 4490 <_IO_stdin_used+0x490>
    217a:	mov    rcx,rdx
    217d:	mov    edx,0x2f
    2182:	mov    rdi,rax
    2185:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    218a:	mov    rax,QWORD PTR [rbp-0x8]
    218e:	mov    rdx,QWORD PTR [rax]
    2191:	mov    rax,QWORD PTR [rbp-0x8]
    2195:	mov    rax,QWORD PTR [rax+0x10]
    2199:	add    rax,rdx
}
    219c:	leave
    219d:	ret

000000000000219e <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    219e:	push   rbp
    219f:	mov    rbp,rsp
    21a2:	sub    rsp,0x10
    21a6:	mov    QWORD PTR [rbp-0x8],rdi
    21aa:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    21ae:	mov    rax,QWORD PTR [rbp-0x8]
    21b2:	mov    rdi,rax
    21b5:	call   2144 <parser_at>
    21ba:	mov    rdx,QWORD PTR [rbp-0x10]
    21be:	add    rax,rdx
}
    21c1:	leave
    21c2:	ret

00000000000021c3 <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    21c3:	push   rbp
    21c4:	mov    rbp,rsp
    21c7:	mov    QWORD PTR [rbp-0x8],rdi
    21cb:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    21cf:	mov    rax,QWORD PTR [rbp-0x8]
    21d3:	mov    rdx,QWORD PTR [rax+0x10]
    21d7:	mov    rax,QWORD PTR [rbp-0x10]
    21db:	add    rdx,rax
    21de:	mov    rax,QWORD PTR [rbp-0x8]
    21e2:	mov    QWORD PTR [rax+0x10],rdx
}
    21e6:	nop
    21e7:	pop    rbp
    21e8:	ret

00000000000021e9 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    21e9:	push   rbp
    21ea:	mov    rbp,rsp
    21ed:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    21f1:	mov    rax,QWORD PTR [rbp-0x8]
    21f5:	mov    rdx,QWORD PTR [rax+0x10]
    21f9:	mov    rax,QWORD PTR [rbp-0x8]
    21fd:	mov    rax,QWORD PTR [rax+0x8]
    2201:	cmp    rdx,rax
    2204:	setb   al
}
    2207:	pop    rbp
    2208:	ret

0000000000002209 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    2209:	push   rbp
    220a:	mov    rbp,rsp
    220d:	push   r12
    220f:	push   rbx
    2210:	sub    rsp,0x20
    2214:	mov    QWORD PTR [rbp-0x18],rdi
    2218:	mov    rax,rsi
    221b:	mov    rcx,rdx
    221e:	mov    rax,rax
    2221:	mov    edx,0x0
    2226:	mov    rdx,rcx
    2229:	mov    QWORD PTR [rbp-0x30],rax
    222d:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    2231:	mov    rax,QWORD PTR [rbp-0x28]
    2235:	mov    r12,rax
    2238:	mov    rbx,QWORD PTR [rbp-0x30]
    223c:	mov    rax,QWORD PTR [rbp-0x18]
    2240:	mov    rdi,rax
    2243:	call   2144 <parser_at>
    2248:	mov    rdx,r12
    224b:	mov    rsi,rbx
    224e:	mov    rdi,rax
    2251:	call   10d0 <memcmp@plt>
    2256:	test   eax,eax
    2258:	sete   al
}
    225b:	add    rsp,0x20
    225f:	pop    rbx
    2260:	pop    r12
    2262:	pop    rbp
    2263:	ret

0000000000002264 <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    2264:	push   rbp
    2265:	mov    rbp,rsp
    2268:	mov    eax,edi
    226a:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    226d:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    2271:	movzx  eax,BYTE PTR [rbp-0x14]
    2275:	cmp    eax,0x2e
    2278:	jg     2281 <is_numeric+0x1d>
    227a:	cmp    eax,0x2d
    227d:	jge    2289 <is_numeric+0x25>
    227f:	jmp    228e <is_numeric+0x2a>
    2281:	sub    eax,0x30
    2284:	cmp    eax,0x9
    2287:	ja     228e <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2289:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    228d:	nop
  }


  return result;
    228e:	movzx  eax,BYTE PTR [rbp-0x1]
}
    2292:	pop    rbp
    2293:	ret

0000000000002294 <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    2294:	push   rbp
    2295:	mov    rbp,rsp
    2298:	sub    rsp,0x50
    229c:	mov    QWORD PTR [rbp-0x48],rdi
    22a0:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    22a4:	pxor   xmm0,xmm0
    22a8:	movaps XMMWORD PTR [rbp-0x20],xmm0
    22ac:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    22b1:	jmp    22c4 <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    22b3:	mov    rax,QWORD PTR [rbp-0x50]
    22b7:	mov    esi,0x1
    22bc:	mov    rdi,rax
    22bf:	call   21c3 <parser_advance>
  while (parser_incomplete(parser)  &&
    22c4:	mov    rax,QWORD PTR [rbp-0x50]
    22c8:	mov    rdi,rax
    22cb:	call   21e9 <parser_incomplete>
    22d0:	test   al,al
    22d2:	je     2320 <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    22d4:	mov    rax,QWORD PTR [rbp-0x50]
    22d8:	mov    rdi,rax
    22db:	call   2144 <parser_at>
    22e0:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    22e3:	cmp    al,0x20
    22e5:	je     22b3 <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    22e7:	mov    rax,QWORD PTR [rbp-0x50]
    22eb:	mov    rdi,rax
    22ee:	call   2144 <parser_at>
    22f3:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    22f6:	cmp    al,0xa
    22f8:	je     22b3 <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    22fa:	mov    rax,QWORD PTR [rbp-0x50]
    22fe:	mov    rdi,rax
    2301:	call   2144 <parser_at>
    2306:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    2309:	cmp    al,0xd
    230b:	je     22b3 <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    230d:	mov    rax,QWORD PTR [rbp-0x50]
    2311:	mov    rdi,rax
    2314:	call   2144 <parser_at>
    2319:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    231c:	cmp    al,0x9
    231e:	je     22b3 <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    2320:	mov    rax,QWORD PTR [rbp-0x50]
    2324:	mov    rdi,rax
    2327:	call   21e9 <parser_incomplete>
    232c:	test   al,al
    232e:	je     275b <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    2334:	mov    rax,QWORD PTR [rbp-0x50]
    2338:	mov    rdi,rax
    233b:	call   2144 <parser_at>
    2340:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    2344:	mov    rax,QWORD PTR [rbp-0x50]
    2348:	mov    rdi,rax
    234b:	call   2144 <parser_at>
    2350:	movzx  eax,BYTE PTR [rax]
    2353:	movzx  eax,al
    2356:	cmp    eax,0x7d
    2359:	je     2446 <get_json_token+0x1b2>
    235f:	cmp    eax,0x7d
    2362:	jg     276c <get_json_token+0x4d8>
    2368:	cmp    eax,0x7b
    236b:	je     2421 <get_json_token+0x18d>
    2371:	cmp    eax,0x7b
    2374:	jg     276c <get_json_token+0x4d8>
    237a:	cmp    eax,0x74
    237d:	je     25c9 <get_json_token+0x335>
    2383:	cmp    eax,0x74
    2386:	jg     276c <get_json_token+0x4d8>
    238c:	cmp    eax,0x6e
    238f:	je     26d9 <get_json_token+0x445>
    2395:	cmp    eax,0x6e
    2398:	jg     276c <get_json_token+0x4d8>
    239e:	cmp    eax,0x66
    23a1:	je     2651 <get_json_token+0x3bd>
    23a7:	cmp    eax,0x66
    23aa:	jg     276c <get_json_token+0x4d8>
    23b0:	cmp    eax,0x5d
    23b3:	je     2490 <get_json_token+0x1fc>
    23b9:	cmp    eax,0x5d
    23bc:	jg     276c <get_json_token+0x4d8>
    23c2:	cmp    eax,0x5b
    23c5:	je     246b <get_json_token+0x1d7>
    23cb:	cmp    eax,0x5b
    23ce:	jg     276c <get_json_token+0x4d8>
    23d4:	cmp    eax,0x3a
    23d7:	je     24da <get_json_token+0x246>
    23dd:	cmp    eax,0x3a
    23e0:	jg     276c <get_json_token+0x4d8>
    23e6:	cmp    eax,0x39
    23e9:	jg     276c <get_json_token+0x4d8>
    23ef:	cmp    eax,0x30
    23f2:	jge    2578 <get_json_token+0x2e4>
    23f8:	cmp    eax,0x2e
    23fb:	jg     276c <get_json_token+0x4d8>
    2401:	cmp    eax,0x2d
    2404:	jge    2578 <get_json_token+0x2e4>
    240a:	cmp    eax,0x22
    240d:	je     24ff <get_json_token+0x26b>
    2413:	cmp    eax,0x2c
    2416:	je     24b5 <get_json_token+0x221>
    241c:	jmp    276c <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    2421:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    2428:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2430:	mov    rax,QWORD PTR [rbp-0x50]
    2434:	mov    esi,0x1
    2439:	mov    rdi,rax
    243c:	call   21c3 <parser_advance>
      }
      break;
    2441:	jmp    276c <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2446:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    244d:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2455:	mov    rax,QWORD PTR [rbp-0x50]
    2459:	mov    esi,0x1
    245e:	mov    rdi,rax
    2461:	call   21c3 <parser_advance>
      }
      break;
    2466:	jmp    276c <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    246b:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    2472:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    247a:	mov    rax,QWORD PTR [rbp-0x50]
    247e:	mov    esi,0x1
    2483:	mov    rdi,rax
    2486:	call   21c3 <parser_advance>
      }
      break;
    248b:	jmp    276c <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    2490:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    2497:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    249f:	mov    rax,QWORD PTR [rbp-0x50]
    24a3:	mov    esi,0x1
    24a8:	mov    rdi,rax
    24ab:	call   21c3 <parser_advance>
      }
      break;
    24b0:	jmp    276c <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    24b5:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    24bc:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24c4:	mov    rax,QWORD PTR [rbp-0x50]
    24c8:	mov    esi,0x1
    24cd:	mov    rdi,rax
    24d0:	call   21c3 <parser_advance>
      }
      break;
    24d5:	jmp    276c <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    24da:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    24e1:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24e9:	mov    rax,QWORD PTR [rbp-0x50]
    24ed:	mov    esi,0x1
    24f2:	mov    rdi,rax
    24f5:	call   21c3 <parser_advance>
      }
      break;
    24fa:	jmp    276c <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    24ff:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    2506:	mov    rax,QWORD PTR [rbp-0x50]
    250a:	mov    esi,0x1
    250f:	mov    rdi,rax
    2512:	call   21c3 <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    2517:	mov    rax,QWORD PTR [rbp-0x50]
    251b:	mov    rdi,rax
    251e:	call   2144 <parser_at>
    2523:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    2527:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    252f:	jmp    2547 <get_json_token+0x2b3>
        {
          string_count += 1;
    2531:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    2536:	mov    rax,QWORD PTR [rbp-0x50]
    253a:	mov    esi,0x1
    253f:	mov    rdi,rax
    2542:	call   21c3 <parser_advance>
        while (*parser_at(parser) != '"')
    2547:	mov    rax,QWORD PTR [rbp-0x50]
    254b:	mov    rdi,rax
    254e:	call   2144 <parser_at>
    2553:	movzx  eax,BYTE PTR [rax]
    2556:	cmp    al,0x22
    2558:	jne    2531 <get_json_token+0x29d>
        }
        token.value.count = string_count;
    255a:	mov    rax,QWORD PTR [rbp-0x40]
    255e:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    2562:	mov    rax,QWORD PTR [rbp-0x50]
    2566:	mov    esi,0x1
    256b:	mov    rdi,rax
    256e:	call   21c3 <parser_advance>
      }
      break;
    2573:	jmp    276c <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2578:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    257f:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2587:	jmp    259f <get_json_token+0x30b>
        {
          digit_count += 1;
    2589:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    258e:	mov    rax,QWORD PTR [rbp-0x50]
    2592:	mov    esi,0x1
    2597:	mov    rdi,rax
    259a:	call   21c3 <parser_advance>
        while (is_numeric(*parser_at(parser)))
    259f:	mov    rax,QWORD PTR [rbp-0x50]
    25a3:	mov    rdi,rax
    25a6:	call   2144 <parser_at>
    25ab:	movzx  eax,BYTE PTR [rax]
    25ae:	movzx  eax,al
    25b1:	mov    edi,eax
    25b3:	call   2264 <is_numeric>
    25b8:	test   al,al
    25ba:	jne    2589 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    25bc:	mov    rax,QWORD PTR [rbp-0x38]
    25c0:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    25c4:	jmp    276c <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    25c9:	lea    rax,[rip+0x1f0c]        # 44dc <_IO_stdin_used+0x4dc>
    25d0:	mov    QWORD PTR [rbp-0x30],rax
    25d4:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25dc:	mov    rcx,QWORD PTR [rbp-0x30]
    25e0:	mov    rdx,QWORD PTR [rbp-0x28]
    25e4:	mov    rax,QWORD PTR [rbp-0x50]
    25e8:	mov    rsi,rcx
    25eb:	mov    rdi,rax
    25ee:	call   2209 <parser_token_is_literal>
    25f3:	test   al,al
    25f5:	je     2619 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    25f7:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    25fe:	mov    rax,QWORD PTR [rbp-0x28]
    2602:	mov    rdx,rax
    2605:	mov    rax,QWORD PTR [rbp-0x50]
    2609:	mov    rsi,rdx
    260c:	mov    rdi,rax
    260f:	call   21c3 <parser_advance>
    2614:	jmp    276c <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2619:	mov    rax,QWORD PTR [rbp-0x50]
    261d:	mov    rcx,QWORD PTR [rax+0x10]
    2621:	lea    rdx,[rip+0x1ec0]        # 44e8 <_IO_stdin_used+0x4e8>
    2628:	lea    rax,[rip+0x1e4a]        # 4479 <_IO_stdin_used+0x479>
    262f:	mov    r8,rcx
    2632:	mov    rcx,rdx
    2635:	mov    edx,0xdf
    263a:	mov    rsi,rax
    263d:	mov    edi,0x1
    2642:	mov    eax,0x0
    2647:	call   14a1 <log_message>
        }
      }
      break;
    264c:	jmp    276c <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    2651:	lea    rax,[rip+0x1ebd]        # 4515 <_IO_stdin_used+0x515>
    2658:	mov    QWORD PTR [rbp-0x30],rax
    265c:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    2664:	mov    rcx,QWORD PTR [rbp-0x30]
    2668:	mov    rdx,QWORD PTR [rbp-0x28]
    266c:	mov    rax,QWORD PTR [rbp-0x50]
    2670:	mov    rsi,rcx
    2673:	mov    rdi,rax
    2676:	call   2209 <parser_token_is_literal>
    267b:	test   al,al
    267d:	je     26a1 <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    267f:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    2686:	mov    rax,QWORD PTR [rbp-0x28]
    268a:	mov    rdx,rax
    268d:	mov    rax,QWORD PTR [rbp-0x50]
    2691:	mov    rsi,rdx
    2694:	mov    rdi,rax
    2697:	call   21c3 <parser_advance>
    269c:	jmp    276c <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    26a1:	mov    rax,QWORD PTR [rbp-0x50]
    26a5:	mov    rcx,QWORD PTR [rax+0x10]
    26a9:	lea    rdx,[rip+0x1e38]        # 44e8 <_IO_stdin_used+0x4e8>
    26b0:	lea    rax,[rip+0x1dc2]        # 4479 <_IO_stdin_used+0x479>
    26b7:	mov    r8,rcx
    26ba:	mov    rcx,rdx
    26bd:	mov    edx,0xee
    26c2:	mov    rsi,rax
    26c5:	mov    edi,0x1
    26ca:	mov    eax,0x0
    26cf:	call   14a1 <log_message>
        }
      }
      break;
    26d4:	jmp    276c <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    26d9:	lea    rax,[rip+0x1e3b]        # 451b <_IO_stdin_used+0x51b>
    26e0:	mov    QWORD PTR [rbp-0x30],rax
    26e4:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    26ec:	mov    rcx,QWORD PTR [rbp-0x30]
    26f0:	mov    rdx,QWORD PTR [rbp-0x28]
    26f4:	mov    rax,QWORD PTR [rbp-0x50]
    26f8:	mov    rsi,rcx
    26fb:	mov    rdi,rax
    26fe:	call   2209 <parser_token_is_literal>
    2703:	test   al,al
    2705:	je     2726 <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    2707:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    270e:	mov    rax,QWORD PTR [rbp-0x28]
    2712:	mov    rdx,rax
    2715:	mov    rax,QWORD PTR [rbp-0x50]
    2719:	mov    rsi,rdx
    271c:	mov    rdi,rax
    271f:	call   21c3 <parser_advance>
    2724:	jmp    276c <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2726:	mov    rax,QWORD PTR [rbp-0x50]
    272a:	mov    rcx,QWORD PTR [rax+0x10]
    272e:	lea    rdx,[rip+0x1db3]        # 44e8 <_IO_stdin_used+0x4e8>
    2735:	lea    rax,[rip+0x1d3d]        # 4479 <_IO_stdin_used+0x479>
    273c:	mov    r8,rcx
    273f:	mov    rcx,rdx
    2742:	mov    edx,0xfd
    2747:	mov    rsi,rax
    274a:	mov    edi,0x1
    274f:	mov    eax,0x0
    2754:	call   14a1 <log_message>
        }
      }
      break;
    2759:	jmp    276c <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    275b:	mov    rax,QWORD PTR [rbp-0x50]
    275f:	mov    esi,0x1
    2764:	mov    rdi,rax
    2767:	call   21c3 <parser_advance>
  }

  return token;
    276c:	mov    rcx,QWORD PTR [rbp-0x48]
    2770:	mov    rax,QWORD PTR [rbp-0x20]
    2774:	mov    rdx,QWORD PTR [rbp-0x18]
    2778:	mov    QWORD PTR [rcx],rax
    277b:	mov    QWORD PTR [rcx+0x8],rdx
    277f:	mov    rax,QWORD PTR [rbp-0x10]
    2783:	mov    QWORD PTR [rcx+0x10],rax
}
    2787:	mov    rax,QWORD PTR [rbp-0x48]
    278b:	leave
    278c:	ret

000000000000278d <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    278d:	push   rbp
    278e:	mov    rbp,rsp
    2791:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    2794:	cmp    DWORD PTR [rbp-0x14],0x7
    2798:	je     27b2 <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    279a:	cmp    DWORD PTR [rbp-0x14],0x9
    279e:	je     27b2 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    27a0:	cmp    DWORD PTR [rbp-0x14],0xa
    27a4:	je     27b2 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    27a6:	cmp    DWORD PTR [rbp-0x14],0xb
    27aa:	je     27b2 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    27ac:	cmp    DWORD PTR [rbp-0x14],0x8
    27b0:	jne    27b9 <json_token_type_is_value_type+0x2c>
    27b2:	mov    eax,0x1
    27b7:	jmp    27be <json_token_type_is_value_type+0x31>
    27b9:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    27be:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    27c1:	mov    eax,DWORD PTR [rbp-0x4]
}
    27c4:	pop    rbp
    27c5:	ret

00000000000027c6 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    27c6:	push   rbp
    27c7:	mov    rbp,rsp
    27ca:	push   rbx
    27cb:	sub    rsp,0x88
    27d2:	mov    QWORD PTR [rbp-0x78],rdi
    27d6:	mov    QWORD PTR [rbp-0x80],rsi
    27da:	mov    QWORD PTR [rbp-0x90],rdx
    27e1:	mov    QWORD PTR [rbp-0x88],rcx
    27e8:	mov    rax,QWORD PTR fs:0x28
    27f1:	mov    QWORD PTR [rbp-0x18],rax
    27f5:	xor    eax,eax
  profile_begin_func();
    27f7:	lea    r8,[rip+0x2022]        # 4820 <__func__.4>
    27fe:	mov    r9d,0x11
    2804:	lea    rax,[rbp-0x50]
    2808:	mov    rsi,r8
    280b:	mov    rdx,r9
    280e:	mov    r8d,0x0
    2814:	mov    ecx,0x1
    2819:	mov    rdi,rax
    281c:	call   1f6c <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    2821:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2829:	mov    eax,DWORD PTR [rbp+0x10]
    282c:	cmp    eax,0x1
    282f:	jne    285b <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    2831:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    2838:	mov    edx,DWORD PTR [rbp-0x64]
    283b:	mov    rsi,QWORD PTR [rbp-0x80]
    283f:	mov    rax,QWORD PTR [rbp-0x78]
    2843:	mov    ecx,edx
    2845:	mov    edx,0x2
    284a:	mov    rdi,rax
    284d:	call   29ad <parse_json_children>
    2852:	mov    QWORD PTR [rbp-0x60],rax
    2856:	jmp    28e5 <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    285b:	mov    eax,DWORD PTR [rbp+0x10]
    285e:	cmp    eax,0x3
    2861:	jne    288a <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    2863:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    286a:	mov    edx,DWORD PTR [rbp-0x68]
    286d:	mov    rsi,QWORD PTR [rbp-0x80]
    2871:	mov    rax,QWORD PTR [rbp-0x78]
    2875:	mov    ecx,edx
    2877:	mov    edx,0x4
    287c:	mov    rdi,rax
    287f:	call   29ad <parse_json_children>
    2884:	mov    QWORD PTR [rbp-0x60],rax
    2888:	jmp    28e5 <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    288a:	mov    eax,DWORD PTR [rbp+0x10]
    288d:	mov    edi,eax
    288f:	call   278d <json_token_type_is_value_type>
    2894:	test   eax,eax
    2896:	jne    28e5 <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2898:	mov    eax,DWORD PTR [rbp+0x10]
    289b:	mov    eax,eax
    289d:	lea    rdx,[rax*8+0x0]
    28a5:	lea    rax,[rip+0x4834]        # 70e0 <JSON_Token_Type_strings>
    28ac:	mov    rcx,QWORD PTR [rdx+rax*1]
    28b0:	lea    rdx,[rip+0x1c69]        # 4520 <_IO_stdin_used+0x520>
    28b7:	lea    rax,[rip+0x1bbb]        # 4479 <_IO_stdin_used+0x479>
    28be:	push   QWORD PTR [rbp+0x20]
    28c1:	push   QWORD PTR [rbp+0x18]
    28c4:	mov    r8,rcx
    28c7:	mov    rcx,rdx
    28ca:	mov    edx,0x134
    28cf:	mov    rsi,rax
    28d2:	mov    edi,0x1
    28d7:	mov    eax,0x0
    28dc:	call   14a1 <log_message>
    28e1:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    28e5:	mov    rax,QWORD PTR [rbp-0x78]
    28e9:	mov    edx,0x8
    28ee:	mov    esi,0x30
    28f3:	mov    rdi,rax
    28f6:	call   17d3 <arena_alloc>
    28fb:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    28ff:	mov    rcx,QWORD PTR [rbp-0x58]
    2903:	mov    rax,QWORD PTR [rbp-0x90]
    290a:	mov    rdx,QWORD PTR [rbp-0x88]
    2911:	mov    QWORD PTR [rcx],rax
    2914:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    2918:	mov    rax,QWORD PTR [rbp-0x58]
    291c:	mov    rdx,QWORD PTR [rbp-0x60]
    2920:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    2924:	mov    rax,QWORD PTR [rbp-0x58]
    2928:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    2930:	mov    rcx,QWORD PTR [rbp-0x58]
    2934:	mov    rax,QWORD PTR [rbp+0x18]
    2938:	mov    rdx,QWORD PTR [rbp+0x20]
    293c:	mov    QWORD PTR [rcx+0x10],rax
    2940:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    2944:	sub    rsp,0x8
    2948:	sub    rsp,0x38
    294c:	mov    rax,rsp
    294f:	mov    rcx,QWORD PTR [rbp-0x50]
    2953:	mov    rbx,QWORD PTR [rbp-0x48]
    2957:	mov    QWORD PTR [rax],rcx
    295a:	mov    QWORD PTR [rax+0x8],rbx
    295e:	mov    rcx,QWORD PTR [rbp-0x40]
    2962:	mov    rbx,QWORD PTR [rbp-0x38]
    2966:	mov    QWORD PTR [rax+0x10],rcx
    296a:	mov    QWORD PTR [rax+0x18],rbx
    296e:	mov    rcx,QWORD PTR [rbp-0x30]
    2972:	mov    rbx,QWORD PTR [rbp-0x28]
    2976:	mov    QWORD PTR [rax+0x20],rcx
    297a:	mov    QWORD PTR [rax+0x28],rbx
    297e:	mov    rdx,QWORD PTR [rbp-0x20]
    2982:	mov    QWORD PTR [rax+0x30],rdx
    2986:	call   2056 <__profile_end_pass>
    298b:	add    rsp,0x40

  return result;
    298f:	mov    rax,QWORD PTR [rbp-0x58]
}
    2993:	mov    rdx,QWORD PTR [rbp-0x18]
    2997:	sub    rdx,QWORD PTR fs:0x28
    29a0:	je     29a7 <parse_json_object+0x1e1>
    29a2:	call   1060 <__stack_chk_fail@plt>
    29a7:	mov    rbx,QWORD PTR [rbp-0x8]
    29ab:	leave
    29ac:	ret

00000000000029ad <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    29ad:	push   rbp
    29ae:	mov    rbp,rsp
    29b1:	push   rbx
    29b2:	sub    rsp,0x108
    29b9:	mov    QWORD PTR [rbp-0xd8],rdi
    29c0:	mov    QWORD PTR [rbp-0xe0],rsi
    29c7:	mov    DWORD PTR [rbp-0xe4],edx
    29cd:	mov    DWORD PTR [rbp-0xe8],ecx
    29d3:	mov    rax,QWORD PTR fs:0x28
    29dc:	mov    QWORD PTR [rbp-0x18],rax
    29e0:	xor    eax,eax
  profile_begin_func();
    29e2:	lea    r8,[rip+0x1e57]        # 4840 <__func__.3>
    29e9:	mov    r9d,0x13
    29ef:	lea    rax,[rbp-0x50]
    29f3:	mov    rsi,r8
    29f6:	mov    rdx,r9
    29f9:	mov    r8d,0x0
    29ff:	mov    ecx,0x2
    2a04:	mov    rdi,rax
    2a07:	call   1f6c <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2a0c:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    2a17:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2a22:	jmp    2cfb <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2a27:	pxor   xmm0,xmm0
    2a2b:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2a32:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2a3a:	pxor   xmm0,xmm0
    2a3e:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2a45:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2a4a:	cmp    DWORD PTR [rbp-0xe8],0x0
    2a51:	je     2b5e <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2a57:	lea    rax,[rbp-0xb0]
    2a5e:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a65:	mov    rsi,rdx
    2a68:	mov    rdi,rax
    2a6b:	call   2294 <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2a70:	mov    eax,DWORD PTR [rbp-0xb0]
    2a76:	cmp    eax,0x7
    2a79:	jne    2afa <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2a7b:	lea    rax,[rbp-0x70]
    2a7f:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a86:	mov    rsi,rdx
    2a89:	mov    rdi,rax
    2a8c:	call   2294 <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2a91:	mov    eax,DWORD PTR [rbp-0x70]
    2a94:	cmp    eax,0x6
    2a97:	jne    2ab7 <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2a99:	lea    rax,[rbp-0x90]
    2aa0:	mov    rdx,QWORD PTR [rbp-0xe0]
    2aa7:	mov    rsi,rdx
    2aaa:	mov    rdi,rax
    2aad:	call   2294 <get_json_token>
    2ab2:	jmp    2b9e <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2ab7:	mov    rcx,QWORD PTR [rbp-0xa8]
    2abe:	mov    rax,QWORD PTR [rbp-0xa0]
    2ac5:	mov    esi,eax
    2ac7:	lea    rdx,[rip+0x1aa2]        # 4570 <_IO_stdin_used+0x570>
    2ace:	lea    rax,[rip+0x19a4]        # 4479 <_IO_stdin_used+0x479>
    2ad5:	mov    r9,rcx
    2ad8:	mov    r8d,esi
    2adb:	mov    rcx,rdx
    2ade:	mov    edx,0x15f
    2ae3:	mov    rsi,rax
    2ae6:	mov    edi,0x1
    2aeb:	mov    eax,0x0
    2af0:	call   14a1 <log_message>
    2af5:	jmp    2b9e <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2afa:	mov    rcx,QWORD PTR [rbp-0xa8]
    2b01:	mov    rax,QWORD PTR [rbp-0xa0]
    2b08:	mov    edi,eax
    2b0a:	mov    eax,DWORD PTR [rbp-0xb0]
    2b10:	mov    eax,eax
    2b12:	lea    rdx,[rax*8+0x0]
    2b1a:	lea    rax,[rip+0x45bf]        # 70e0 <JSON_Token_Type_strings>
    2b21:	mov    rsi,QWORD PTR [rdx+rax*1]
    2b25:	lea    rdx,[rip+0x1a64]        # 4590 <_IO_stdin_used+0x590>
    2b2c:	lea    rax,[rip+0x1946]        # 4479 <_IO_stdin_used+0x479>
    2b33:	sub    rsp,0x8
    2b37:	push   rcx
    2b38:	mov    r9d,edi
    2b3b:	mov    r8,rsi
    2b3e:	mov    rcx,rdx
    2b41:	mov    edx,0x164
    2b46:	mov    rsi,rax
    2b49:	mov    edi,0x1
    2b4e:	mov    eax,0x0
    2b53:	call   14a1 <log_message>
    2b58:	add    rsp,0x10
    2b5c:	jmp    2b9e <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2b5e:	lea    rax,[rbp-0x110]
    2b65:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b6c:	mov    rsi,rdx
    2b6f:	mov    rdi,rax
    2b72:	call   2294 <get_json_token>
    2b77:	mov    rax,QWORD PTR [rbp-0x110]
    2b7e:	mov    rdx,QWORD PTR [rbp-0x108]
    2b85:	mov    QWORD PTR [rbp-0x90],rax
    2b8c:	mov    QWORD PTR [rbp-0x88],rdx
    2b93:	mov    rax,QWORD PTR [rbp-0x100]
    2b9a:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2b9e:	mov    eax,DWORD PTR [rbp-0x90]
    2ba4:	cmp    DWORD PTR [rbp-0xe4],eax
    2baa:	je     2d14 <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2bb0:	mov    rax,QWORD PTR [rbp-0xa8]
    2bb7:	mov    rdx,QWORD PTR [rbp-0xa0]
    2bbe:	mov    r8,QWORD PTR [rbp-0xe0]
    2bc5:	mov    rdi,QWORD PTR [rbp-0xd8]
    2bcc:	sub    rsp,0x8
    2bd0:	sub    rsp,0x18
    2bd4:	mov    rsi,rsp
    2bd7:	mov    rcx,QWORD PTR [rbp-0x90]
    2bde:	mov    rbx,QWORD PTR [rbp-0x88]
    2be5:	mov    QWORD PTR [rsi],rcx
    2be8:	mov    QWORD PTR [rsi+0x8],rbx
    2bec:	mov    rcx,QWORD PTR [rbp-0x80]
    2bf0:	mov    QWORD PTR [rsi+0x10],rcx
    2bf4:	mov    rcx,rdx
    2bf7:	mov    rdx,rax
    2bfa:	mov    rsi,r8
    2bfd:	call   27c6 <parse_json_object>
    2c02:	add    rsp,0x20
    2c06:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2c0d:	cmp    QWORD PTR [rbp-0xb8],0x0
    2c15:	je     2c5f <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2c17:	cmp    QWORD PTR [rbp-0xc8],0x0
    2c1f:	jne    2c3f <parse_json_children+0x292>
      {
        first_child        = object;
    2c21:	mov    rax,QWORD PTR [rbp-0xb8]
    2c28:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2c2f:	mov    rax,QWORD PTR [rbp-0xb8]
    2c36:	mov    QWORD PTR [rbp-0xc0],rax
    2c3d:	jmp    2c5f <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2c3f:	mov    rax,QWORD PTR [rbp-0xc0]
    2c46:	mov    rdx,QWORD PTR [rbp-0xb8]
    2c4d:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2c51:	mov    rax,QWORD PTR [rbp-0xb8]
    2c58:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2c5f:	lea    rax,[rbp-0x70]
    2c63:	mov    rdx,QWORD PTR [rbp-0xe0]
    2c6a:	mov    rsi,rdx
    2c6d:	mov    rdi,rax
    2c70:	call   2294 <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2c75:	mov    eax,DWORD PTR [rbp-0x70]
    2c78:	cmp    DWORD PTR [rbp-0xe4],eax
    2c7e:	je     2d17 <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2c84:	mov    eax,DWORD PTR [rbp-0x70]
    2c87:	cmp    eax,0x5
    2c8a:	je     2cfb <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2c8c:	mov    r8,QWORD PTR [rbp-0x68]
    2c90:	mov    rax,QWORD PTR [rbp-0x60]
    2c94:	mov    r9d,eax
    2c97:	mov    eax,DWORD PTR [rbp-0x70]
    2c9a:	mov    eax,eax
    2c9c:	lea    rdx,[rax*8+0x0]
    2ca4:	lea    rax,[rip+0x4435]        # 70e0 <JSON_Token_Type_strings>
    2cab:	mov    r10,QWORD PTR [rdx+rax*1]
    2caf:	lea    rdi,[rip+0x1902]        # 45b8 <_IO_stdin_used+0x5b8>
    2cb6:	lea    rsi,[rip+0x17bc]        # 4479 <_IO_stdin_used+0x479>
    2cbd:	sub    rsp,0x18
    2cc1:	mov    rcx,rsp
    2cc4:	mov    rax,QWORD PTR [rbp-0x70]
    2cc8:	mov    rdx,QWORD PTR [rbp-0x68]
    2ccc:	mov    QWORD PTR [rcx],rax
    2ccf:	mov    QWORD PTR [rcx+0x8],rdx
    2cd3:	mov    rax,QWORD PTR [rbp-0x60]
    2cd7:	mov    QWORD PTR [rcx+0x10],rax
    2cdb:	push   r8
    2cdd:	mov    r8,r10
    2ce0:	mov    rcx,rdi
    2ce3:	mov    edx,0x18b
    2ce8:	mov    edi,0x1
    2ced:	mov    eax,0x0
    2cf2:	call   14a1 <log_message>
    2cf7:	add    rsp,0x20
  while (parser_incomplete(parser))
    2cfb:	mov    rax,QWORD PTR [rbp-0xe0]
    2d02:	mov    rdi,rax
    2d05:	call   21e9 <parser_incomplete>
    2d0a:	test   al,al
    2d0c:	jne    2a27 <parse_json_children+0x7a>
    2d12:	jmp    2d18 <parse_json_children+0x36b>
      break;
    2d14:	nop
    2d15:	jmp    2d18 <parse_json_children+0x36b>
      break;
    2d17:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2d18:	sub    rsp,0x8
    2d1c:	sub    rsp,0x38
    2d20:	mov    rax,rsp
    2d23:	mov    rcx,QWORD PTR [rbp-0x50]
    2d27:	mov    rbx,QWORD PTR [rbp-0x48]
    2d2b:	mov    QWORD PTR [rax],rcx
    2d2e:	mov    QWORD PTR [rax+0x8],rbx
    2d32:	mov    rcx,QWORD PTR [rbp-0x40]
    2d36:	mov    rbx,QWORD PTR [rbp-0x38]
    2d3a:	mov    QWORD PTR [rax+0x10],rcx
    2d3e:	mov    QWORD PTR [rax+0x18],rbx
    2d42:	mov    rcx,QWORD PTR [rbp-0x30]
    2d46:	mov    rbx,QWORD PTR [rbp-0x28]
    2d4a:	mov    QWORD PTR [rax+0x20],rcx
    2d4e:	mov    QWORD PTR [rax+0x28],rbx
    2d52:	mov    rdx,QWORD PTR [rbp-0x20]
    2d56:	mov    QWORD PTR [rax+0x30],rdx
    2d5a:	call   2056 <__profile_end_pass>
    2d5f:	add    rsp,0x40

  return first_child;
    2d63:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2d6a:	mov    rdx,QWORD PTR [rbp-0x18]
    2d6e:	sub    rdx,QWORD PTR fs:0x28
    2d77:	je     2d7e <parse_json_children+0x3d1>
    2d79:	call   1060 <__stack_chk_fail@plt>
    2d7e:	mov    rbx,QWORD PTR [rbp-0x8]
    2d82:	leave
    2d83:	ret

0000000000002d84 <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2d84:	push   rbp
    2d85:	mov    rbp,rsp
    2d88:	push   rbx
    2d89:	sub    rsp,0xb8
    2d90:	mov    QWORD PTR [rbp-0xa8],rdi
    2d97:	mov    rax,rsi
    2d9a:	mov    rsi,rdx
    2d9d:	mov    rax,rax
    2da0:	mov    edx,0x0
    2da5:	mov    rdx,rsi
    2da8:	mov    QWORD PTR [rbp-0xc0],rax
    2daf:	mov    QWORD PTR [rbp-0xb8],rdx
    2db6:	mov    rax,QWORD PTR fs:0x28
    2dbf:	mov    QWORD PTR [rbp-0x18],rax
    2dc3:	xor    eax,eax
  profile_begin_func();
    2dc5:	lea    rcx,[rip+0x1a8c]        # 4858 <__func__.2>
    2dcc:	mov    ebx,0xa
    2dd1:	lea    rax,[rbp-0x50]
    2dd5:	mov    rsi,rcx
    2dd8:	mov    rdx,rbx
    2ddb:	mov    r8d,0x0
    2de1:	mov    ecx,0x3
    2de6:	mov    rdi,rax
    2de9:	call   1f6c <__profile_begin_pass>

  JSON_Parser parser =
    2dee:	mov    rax,QWORD PTR [rbp-0xc0]
    2df5:	mov    rdx,QWORD PTR [rbp-0xb8]
    2dfc:	mov    QWORD PTR [rbp-0x90],rax
    2e03:	mov    QWORD PTR [rbp-0x88],rdx
    2e0a:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2e12:	lea    rax,[rbp-0x70]
    2e16:	lea    rdx,[rbp-0x90]
    2e1d:	mov    rsi,rdx
    2e20:	mov    rdi,rax
    2e23:	call   2294 <get_json_token>
    2e28:	mov    ecx,0x0
    2e2d:	mov    ebx,0x0
    2e32:	lea    r8,[rbp-0x90]
    2e39:	mov    rdi,QWORD PTR [rbp-0xa8]
    2e40:	sub    rsp,0x8
    2e44:	sub    rsp,0x18
    2e48:	mov    rsi,rsp
    2e4b:	mov    rax,QWORD PTR [rbp-0x70]
    2e4f:	mov    rdx,QWORD PTR [rbp-0x68]
    2e53:	mov    QWORD PTR [rsi],rax
    2e56:	mov    QWORD PTR [rsi+0x8],rdx
    2e5a:	mov    rax,QWORD PTR [rbp-0x60]
    2e5e:	mov    QWORD PTR [rsi+0x10],rax
    2e62:	mov    rdx,rcx
    2e65:	mov    rcx,rbx
    2e68:	mov    rsi,r8
    2e6b:	call   27c6 <parse_json_object>
    2e70:	add    rsp,0x20
    2e74:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2e7b:	sub    rsp,0x8
    2e7f:	sub    rsp,0x38
    2e83:	mov    rax,rsp
    2e86:	mov    rcx,QWORD PTR [rbp-0x50]
    2e8a:	mov    rbx,QWORD PTR [rbp-0x48]
    2e8e:	mov    QWORD PTR [rax],rcx
    2e91:	mov    QWORD PTR [rax+0x8],rbx
    2e95:	mov    rcx,QWORD PTR [rbp-0x40]
    2e99:	mov    rbx,QWORD PTR [rbp-0x38]
    2e9d:	mov    QWORD PTR [rax+0x10],rcx
    2ea1:	mov    QWORD PTR [rax+0x18],rbx
    2ea5:	mov    rcx,QWORD PTR [rbp-0x30]
    2ea9:	mov    rbx,QWORD PTR [rbp-0x28]
    2ead:	mov    QWORD PTR [rax+0x20],rcx
    2eb1:	mov    QWORD PTR [rax+0x28],rbx
    2eb5:	mov    rdx,QWORD PTR [rbp-0x20]
    2eb9:	mov    QWORD PTR [rax+0x30],rdx
    2ebd:	call   2056 <__profile_end_pass>
    2ec2:	add    rsp,0x40

  return outer;
    2ec6:	mov    rax,QWORD PTR [rbp-0x98]
}
    2ecd:	mov    rdx,QWORD PTR [rbp-0x18]
    2ed1:	sub    rdx,QWORD PTR fs:0x28
    2eda:	je     2ee1 <parse_json+0x15d>
    2edc:	call   1060 <__stack_chk_fail@plt>
    2ee1:	mov    rbx,QWORD PTR [rbp-0x8]
    2ee5:	leave
    2ee6:	ret

0000000000002ee7 <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2ee7:	push   rbp
    2ee8:	mov    rbp,rsp
    2eeb:	push   rbx
    2eec:	sub    rsp,0x78
    2ef0:	mov    QWORD PTR [rbp-0x68],rdi
    2ef4:	mov    rax,rsi
    2ef7:	mov    rsi,rdx
    2efa:	mov    rax,rax
    2efd:	mov    edx,0x0
    2f02:	mov    rdx,rsi
    2f05:	mov    QWORD PTR [rbp-0x80],rax
    2f09:	mov    QWORD PTR [rbp-0x78],rdx
    2f0d:	mov    rax,QWORD PTR fs:0x28
    2f16:	mov    QWORD PTR [rbp-0x18],rax
    2f1a:	xor    eax,eax
  profile_begin_func();
    2f1c:	lea    rcx,[rip+0x194d]        # 4870 <__func__.1>
    2f23:	mov    ebx,0x12
    2f28:	lea    rax,[rbp-0x50]
    2f2c:	mov    rsi,rcx
    2f2f:	mov    rdx,rbx
    2f32:	mov    r8d,0x0
    2f38:	mov    ecx,0x4
    2f3d:	mov    rdi,rax
    2f40:	call   1f6c <__profile_begin_pass>

  JSON_Object *result = NULL;
    2f45:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2f4d:	cmp    QWORD PTR [rbp-0x68],0x0
    2f52:	je     2fa1 <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f54:	mov    rax,QWORD PTR [rbp-0x68]
    2f58:	mov    rax,QWORD PTR [rax+0x20]
    2f5c:	mov    QWORD PTR [rbp-0x58],rax
    2f60:	jmp    2f9a <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2f62:	mov    rax,QWORD PTR [rbp-0x58]
    2f66:	mov    rdx,QWORD PTR [rax+0x8]
    2f6a:	mov    rax,QWORD PTR [rax]
    2f6d:	mov    rdi,QWORD PTR [rbp-0x80]
    2f71:	mov    rsi,QWORD PTR [rbp-0x78]
    2f75:	mov    rcx,rdx
    2f78:	mov    rdx,rax
    2f7b:	call   143f <strings_equal>
    2f80:	test   al,al
    2f82:	je     2f8e <lookup_json_object+0xa7>
      {
        result = cursor;
    2f84:	mov    rax,QWORD PTR [rbp-0x58]
    2f88:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2f8c:	jmp    2fa1 <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f8e:	mov    rax,QWORD PTR [rbp-0x58]
    2f92:	mov    rax,QWORD PTR [rax+0x28]
    2f96:	mov    QWORD PTR [rbp-0x58],rax
    2f9a:	cmp    QWORD PTR [rbp-0x58],0x0
    2f9f:	jne    2f62 <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2fa1:	sub    rsp,0x8
    2fa5:	sub    rsp,0x38
    2fa9:	mov    rax,rsp
    2fac:	mov    rcx,QWORD PTR [rbp-0x50]
    2fb0:	mov    rbx,QWORD PTR [rbp-0x48]
    2fb4:	mov    QWORD PTR [rax],rcx
    2fb7:	mov    QWORD PTR [rax+0x8],rbx
    2fbb:	mov    rcx,QWORD PTR [rbp-0x40]
    2fbf:	mov    rbx,QWORD PTR [rbp-0x38]
    2fc3:	mov    QWORD PTR [rax+0x10],rcx
    2fc7:	mov    QWORD PTR [rax+0x18],rbx
    2fcb:	mov    rcx,QWORD PTR [rbp-0x30]
    2fcf:	mov    rbx,QWORD PTR [rbp-0x28]
    2fd3:	mov    QWORD PTR [rax+0x20],rcx
    2fd7:	mov    QWORD PTR [rax+0x28],rbx
    2fdb:	mov    rdx,QWORD PTR [rbp-0x20]
    2fdf:	mov    QWORD PTR [rax+0x30],rdx
    2fe3:	call   2056 <__profile_end_pass>
    2fe8:	add    rsp,0x40

  return result;
    2fec:	mov    rax,QWORD PTR [rbp-0x60]
}
    2ff0:	mov    rdx,QWORD PTR [rbp-0x18]
    2ff4:	sub    rdx,QWORD PTR fs:0x28
    2ffd:	je     3004 <lookup_json_object+0x11d>
    2fff:	call   1060 <__stack_chk_fail@plt>
    3004:	mov    rbx,QWORD PTR [rbp-0x8]
    3008:	leave
    3009:	ret

000000000000300a <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    300a:	push   rbp
    300b:	mov    rbp,rsp
    300e:	sub    rsp,0x50
    3012:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    3016:	cmp    QWORD PTR [rbp-0x48],0x0
    301b:	jne    3042 <json_object_to_f64+0x38>
    301d:	lea    rdx,[rip+0x186c]        # 4890 <__PRETTY_FUNCTION__.0>
    3024:	lea    rsi,[rip+0x144e]        # 4479 <_IO_stdin_used+0x479>
    302b:	lea    rax,[rip+0x15c6]        # 45f8 <_IO_stdin_used+0x5f8>
    3032:	mov    rcx,rdx
    3035:	mov    edx,0x1c2
    303a:	mov    rdi,rax
    303d:	call   1090 <__assert_fail@plt>

  String val = object->value;
    3042:	mov    rax,QWORD PTR [rbp-0x48]
    3046:	mov    rdx,QWORD PTR [rax+0x18]
    304a:	mov    rax,QWORD PTR [rax+0x10]
    304e:	mov    QWORD PTR [rbp-0x10],rax
    3052:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    3056:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    305e:	movsd  xmm0,QWORD PTR [rip+0x185a]        # 48c0 <__PRETTY_FUNCTION__.0+0x30>
    3066:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    306b:	mov    rax,QWORD PTR [rbp-0x8]
    306f:	cmp    QWORD PTR [rbp-0x30],rax
    3073:	jae    3099 <json_object_to_f64+0x8f>
    3075:	mov    rdx,QWORD PTR [rbp-0x10]
    3079:	mov    rax,QWORD PTR [rbp-0x30]
    307d:	add    rax,rdx
    3080:	movzx  eax,BYTE PTR [rax]
    3083:	cmp    al,0x2d
    3085:	jne    3099 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    3087:	movsd  xmm0,QWORD PTR [rip+0x1839]        # 48c8 <__PRETTY_FUNCTION__.0+0x38>
    308f:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    3094:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    3099:	pxor   xmm0,xmm0
    309d:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    30a2:	jmp    30e9 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    30a4:	mov    rdx,QWORD PTR [rbp-0x10]
    30a8:	mov    rax,QWORD PTR [rbp-0x30]
    30ac:	add    rax,rdx
    30af:	movzx  eax,BYTE PTR [rax]
    30b2:	sub    eax,0x30
    30b5:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    30b8:	cmp    BYTE PTR [rbp-0x32],0x9
    30bc:	ja     30f5 <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    30be:	movsd  xmm1,QWORD PTR [rbp-0x20]
    30c3:	movsd  xmm0,QWORD PTR [rip+0x1805]        # 48d0 <__PRETTY_FUNCTION__.0+0x40>
    30cb:	mulsd  xmm1,xmm0
    30cf:	movzx  eax,BYTE PTR [rbp-0x32]
    30d3:	pxor   xmm0,xmm0
    30d7:	cvtsi2sd xmm0,eax
    30db:	addsd  xmm0,xmm1
    30df:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    30e4:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    30e9:	mov    rax,QWORD PTR [rbp-0x8]
    30ed:	cmp    QWORD PTR [rbp-0x30],rax
    30f1:	jb     30a4 <json_object_to_f64+0x9a>
    30f3:	jmp    30f6 <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    30f5:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    30f6:	mov    rax,QWORD PTR [rbp-0x8]
    30fa:	cmp    QWORD PTR [rbp-0x30],rax
    30fe:	jae    318b <json_object_to_f64+0x181>
    3104:	mov    rdx,QWORD PTR [rbp-0x10]
    3108:	mov    rax,QWORD PTR [rbp-0x30]
    310c:	add    rax,rdx
    310f:	movzx  eax,BYTE PTR [rax]
    3112:	cmp    al,0x2e
    3114:	jne    318b <json_object_to_f64+0x181>
  {
    at += 1;
    3116:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    311b:	movsd  xmm0,QWORD PTR [rip+0x17b5]        # 48d8 <__PRETTY_FUNCTION__.0+0x48>
    3123:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    3128:	jmp    317e <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    312a:	mov    rdx,QWORD PTR [rbp-0x10]
    312e:	mov    rax,QWORD PTR [rbp-0x30]
    3132:	add    rax,rdx
    3135:	movzx  eax,BYTE PTR [rax]
    3138:	sub    eax,0x30
    313b:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    313e:	cmp    BYTE PTR [rbp-0x31],0x9
    3142:	ja     318a <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    3144:	movzx  eax,BYTE PTR [rbp-0x31]
    3148:	pxor   xmm0,xmm0
    314c:	cvtsi2sd xmm0,eax
    3150:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    3155:	movsd  xmm1,QWORD PTR [rbp-0x20]
    315a:	addsd  xmm0,xmm1
    315e:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    3163:	movsd  xmm1,QWORD PTR [rbp-0x18]
    3168:	movsd  xmm0,QWORD PTR [rip+0x1768]        # 48d8 <__PRETTY_FUNCTION__.0+0x48>
    3170:	mulsd  xmm0,xmm1
    3174:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3179:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    317e:	mov    rax,QWORD PTR [rbp-0x8]
    3182:	cmp    QWORD PTR [rbp-0x30],rax
    3186:	jb     312a <json_object_to_f64+0x120>
    3188:	jmp    318b <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    318a:	nop
      }
    }
  }

  return sign * result;
    318b:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3190:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    3195:	leave
    3196:	ret

0000000000003197 <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    3197:	push   rbp
    3198:	mov    rbp,rsp
    319b:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    31a0:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31a5:	movsd  xmm1,QWORD PTR [rip+0x1733]        # 48e0 <__PRETTY_FUNCTION__.0+0x50>
    31ad:	divsd  xmm0,xmm1
}
    31b1:	pop    rbp
    31b2:	ret

00000000000031b3 <square>:

static
f64 square(f64 x)
{
    31b3:	push   rbp
    31b4:	mov    rbp,rsp
    31b7:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    31bc:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31c1:	mulsd  xmm0,xmm0
}
    31c5:	pop    rbp
    31c6:	ret

00000000000031c7 <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    31c7:	push   rbp
    31c8:	mov    rbp,rsp
    31cb:	sub    rsp,0x90
    31d2:	movsd  QWORD PTR [rbp-0x58],xmm0
    31d7:	movsd  QWORD PTR [rbp-0x60],xmm1
    31dc:	movsd  QWORD PTR [rbp-0x68],xmm2
    31e1:	movsd  QWORD PTR [rbp-0x70],xmm3
    31e6:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    31eb:	movsd  xmm0,QWORD PTR [rbp-0x60]
    31f0:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    31f5:	movsd  xmm0,QWORD PTR [rbp-0x70]
    31fa:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    31ff:	movsd  xmm0,QWORD PTR [rbp-0x58]
    3204:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    3209:	movsd  xmm0,QWORD PTR [rbp-0x68]
    320e:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    3213:	movsd  xmm0,QWORD PTR [rbp-0x40]
    3218:	subsd  xmm0,QWORD PTR [rbp-0x48]
    321d:	movq   rax,xmm0
    3222:	movq   xmm0,rax
    3227:	call   3197 <to_radians>
    322c:	movq   rax,xmm0
    3231:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    3235:	movsd  xmm0,QWORD PTR [rbp-0x30]
    323a:	subsd  xmm0,QWORD PTR [rbp-0x38]
    323f:	movq   rax,xmm0
    3244:	movq   xmm0,rax
    3249:	call   3197 <to_radians>
    324e:	movq   rax,xmm0
    3253:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    3257:	mov    rax,QWORD PTR [rbp-0x48]
    325b:	movq   xmm0,rax
    3260:	call   3197 <to_radians>
    3265:	movq   rax,xmm0
    326a:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    326e:	mov    rax,QWORD PTR [rbp-0x40]
    3272:	movq   xmm0,rax
    3277:	call   3197 <to_radians>
    327c:	movq   rax,xmm0
    3281:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    3285:	movsd  xmm0,QWORD PTR [rbp-0x28]
    328a:	movsd  xmm1,QWORD PTR [rip+0x1656]        # 48e8 <__PRETTY_FUNCTION__.0+0x58>
    3292:	divsd  xmm0,xmm1
    3296:	movq   rax,xmm0
    329b:	movq   xmm0,rax
    32a0:	call   1130 <sin@plt>
    32a5:	movq   rax,xmm0
    32aa:	movq   xmm0,rax
    32af:	call   31b3 <square>
    32b4:	movsd  QWORD PTR [rbp-0x80],xmm0
    32b9:	mov    rax,QWORD PTR [rbp-0x48]
    32bd:	movq   xmm0,rax
    32c2:	call   10b0 <cos@plt>
    32c7:	movsd  QWORD PTR [rbp-0x88],xmm0
    32cf:	mov    rax,QWORD PTR [rbp-0x40]
    32d3:	movq   xmm0,rax
    32d8:	call   10b0 <cos@plt>
    32dd:	movapd xmm5,xmm0
    32e1:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    32e9:	movsd  QWORD PTR [rbp-0x88],xmm5
    32f1:	movsd  xmm0,QWORD PTR [rbp-0x20]
    32f6:	movsd  xmm1,QWORD PTR [rip+0x15ea]        # 48e8 <__PRETTY_FUNCTION__.0+0x58>
    32fe:	movapd xmm6,xmm0
    3302:	divsd  xmm6,xmm1
    3306:	movq   rax,xmm6
    330b:	movq   xmm0,rax
    3310:	call   1130 <sin@plt>
    3315:	movq   rax,xmm0
    331a:	movq   xmm0,rax
    331f:	call   31b3 <square>
    3324:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    332c:	addsd  xmm0,QWORD PTR [rbp-0x80]
    3331:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    3336:	mov    rax,QWORD PTR [rbp-0x18]
    333a:	movq   xmm0,rax
    333f:	call   1160 <sqrt@plt>
    3344:	movq   rax,xmm0
    3349:	movq   xmm0,rax
    334e:	call   1140 <asin@plt>
    3353:	addsd  xmm0,xmm0
    3357:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    335c:	movsd  xmm0,QWORD PTR [rbp-0x78]
    3361:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    3366:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    336b:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    3370:	leave
    3371:	ret

0000000000003372 <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    3372:	push   rbp
    3373:	mov    rbp,rsp
    3376:	movsd  QWORD PTR [rbp-0x18],xmm0
    337b:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    3380:	movsd  xmm0,QWORD PTR [rip+0x1568]        # 48f0 <__PRETTY_FUNCTION__.0+0x60>
    3388:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    338d:	movsd  xmm0,QWORD PTR [rbp-0x18]
    3392:	movq   xmm1,QWORD PTR [rip+0x1566]        # 4900 <__PRETTY_FUNCTION__.0+0x70>
    339a:	andpd  xmm0,xmm1
    339e:	movsd  xmm1,QWORD PTR [rbp-0x20]
    33a3:	movq   xmm2,QWORD PTR [rip+0x1555]        # 4900 <__PRETTY_FUNCTION__.0+0x70>
    33ab:	andpd  xmm2,xmm1
    33af:	movapd xmm1,xmm0
    33b3:	subsd  xmm1,xmm2
    33b7:	movsd  xmm0,QWORD PTR [rbp-0x8]
    33bc:	comisd xmm0,xmm1
    33c0:	setae  al
    33c3:	movzx  eax,al
}
    33c6:	pop    rbp
    33c7:	ret

00000000000033c8 <main>:

int main(int args_count, char **args)
{
    33c8:	push   rbp
    33c9:	mov    rbp,rsp
    33cc:	push   r15
    33ce:	push   r14
    33d0:	push   r13
    33d2:	push   r12
    33d4:	push   rbx
    33d5:	sub    rsp,0x2d8
    33dc:	mov    DWORD PTR [rbp-0x244],edi
    33e2:	mov    QWORD PTR [rbp-0x250],rsi
    33e9:	mov    rax,QWORD PTR fs:0x28
    33f2:	mov    QWORD PTR [rbp-0x38],rax
    33f6:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    33f8:	cmp    DWORD PTR [rbp-0x244],0x3
    33ff:	je     342c <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    3401:	mov    rax,QWORD PTR [rbp-0x250]
    3408:	mov    rax,QWORD PTR [rax]
    340b:	lea    rdx,[rip+0x121e]        # 4630 <_IO_stdin_used+0x630>
    3412:	mov    rsi,rax
    3415:	mov    rdi,rdx
    3418:	mov    eax,0x0
    341d:	call   1070 <printf@plt>
    return 1;
    3422:	mov    eax,0x1
    3427:	jmp    3f10 <main+0xb48>
  }

  begin_profiling();
    342c:	call   1b3d <begin_profiling>

  Arena arena = {0};
    3431:	pxor   xmm0,xmm0
    3435:	movaps XMMWORD PTR [rbp-0x190],xmm0
    343c:	movaps XMMWORD PTR [rbp-0x180],xmm0
  arena = arena_make(GB(4));
    3443:	lea    rdx,[rbp-0x270]
    344a:	movabs rax,0x100000000
    3454:	mov    rsi,rax
    3457:	mov    rdi,rdx
    345a:	call   1632 <arena_make>
    345f:	mov    rax,QWORD PTR [rbp-0x270]
    3466:	mov    rdx,QWORD PTR [rbp-0x268]
    346d:	mov    QWORD PTR [rbp-0x190],rax
    3474:	mov    QWORD PTR [rbp-0x188],rdx
    347b:	mov    rax,QWORD PTR [rbp-0x260]
    3482:	mov    rdx,QWORD PTR [rbp-0x258]
    3489:	mov    QWORD PTR [rbp-0x180],rax
    3490:	mov    QWORD PTR [rbp-0x178],rdx

  String source = {0};
    3497:	mov    QWORD PTR [rbp-0x1a0],0x0
    34a2:	mov    QWORD PTR [rbp-0x198],0x0
  printf("%lu", file_size(args[1]));
    34ad:	mov    rax,QWORD PTR [rbp-0x250]
    34b4:	add    rax,0x8
    34b8:	mov    rax,QWORD PTR [rax]
    34bb:	mov    rdi,rax
    34be:	call   1303 <file_size>
    34c3:	mov    rdx,rax
    34c6:	lea    rax,[rip+0x118f]        # 465c <_IO_stdin_used+0x65c>
    34cd:	mov    rsi,rdx
    34d0:	mov    rdi,rax
    34d3:	mov    eax,0x0
    34d8:	call   1070 <printf@plt>
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    34dd:	mov    rax,QWORD PTR [rbp-0x250]
    34e4:	add    rax,0x8
    34e8:	mov    rax,QWORD PTR [rax]
    34eb:	mov    rdi,rax
    34ee:	call   1303 <file_size>
    34f3:	mov    rcx,rax
    34f6:	lea    r12,[rip+0x1163]        # 4660 <_IO_stdin_used+0x660>
    34fd:	mov    r13d,0x4
    3503:	lea    rdi,[rbp-0x170]
    350a:	mov    rdx,r12
    350d:	mov    rax,r13
    3510:	mov    r8,rcx
    3513:	mov    ecx,0x5
    3518:	mov    rsi,rdx
    351b:	mov    rdx,rax
    351e:	call   1f6c <__profile_begin_pass>
    3523:	mov    QWORD PTR [rbp-0x230],0x0
    352e:	jmp    35c9 <main+0x201>
  {
    source = read_file_to_arena(&arena, args[1]);
    3533:	mov    rax,QWORD PTR [rbp-0x250]
    353a:	add    rax,0x8
    353e:	mov    rdx,QWORD PTR [rax]
    3541:	lea    rax,[rbp-0x190]
    3548:	mov    rsi,rdx
    354b:	mov    rdi,rax
    354e:	call   1357 <read_file_to_arena>
    3553:	mov    QWORD PTR [rbp-0x1a0],rax
    355a:	mov    QWORD PTR [rbp-0x198],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    3561:	add    QWORD PTR [rbp-0x230],0x1
    3569:	sub    rsp,0x8
    356d:	sub    rsp,0x38
    3571:	mov    rcx,rsp
    3574:	mov    rax,QWORD PTR [rbp-0x170]
    357b:	mov    rdx,QWORD PTR [rbp-0x168]
    3582:	mov    QWORD PTR [rcx],rax
    3585:	mov    QWORD PTR [rcx+0x8],rdx
    3589:	mov    rax,QWORD PTR [rbp-0x160]
    3590:	mov    rdx,QWORD PTR [rbp-0x158]
    3597:	mov    QWORD PTR [rcx+0x10],rax
    359b:	mov    QWORD PTR [rcx+0x18],rdx
    359f:	mov    rax,QWORD PTR [rbp-0x150]
    35a6:	mov    rdx,QWORD PTR [rbp-0x148]
    35ad:	mov    QWORD PTR [rcx+0x20],rax
    35b1:	mov    QWORD PTR [rcx+0x28],rdx
    35b5:	mov    rax,QWORD PTR [rbp-0x140]
    35bc:	mov    QWORD PTR [rcx+0x30],rax
    35c0:	call   2056 <__profile_end_pass>
    35c5:	add    rsp,0x40
    35c9:	cmp    QWORD PTR [rbp-0x230],0x0
    35d1:	je     3533 <main+0x16b>
  }

  Haversine_Pair *pairs = NULL;
    35d7:	mov    QWORD PTR [rbp-0x228],0x0
  i32 pair_count = 0;
    35e2:	mov    DWORD PTR [rbp-0x238],0x0
  usize max_pairs = 0;
    35ec:	mov    QWORD PTR [rbp-0x220],0x0
  PROFILE_SCOPE("haversine alloc")
    35f7:	lea    r14,[rip+0x1067]        # 4665 <_IO_stdin_used+0x665>
    35fe:	mov    r15d,0xf
    3604:	lea    rdi,[rbp-0x130]
    360b:	mov    rdx,r14
    360e:	mov    rax,r15
    3611:	mov    r8d,0x0
    3617:	mov    ecx,0x6
    361c:	mov    rsi,rdx
    361f:	mov    rdx,rax
    3622:	call   1f6c <__profile_begin_pass>
    3627:	mov    QWORD PTR [rbp-0x218],0x0
    3632:	jmp    36fa <main+0x332>
  {
    usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    3637:	mov    QWORD PTR [rbp-0x1a8],0x18
    max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    3642:	mov    rax,QWORD PTR [rbp-0x198]
    3649:	mov    edx,0x0
    364e:	div    QWORD PTR [rbp-0x1a8]
    3655:	mov    QWORD PTR [rbp-0x220],rax

    pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    365c:	mov    rax,QWORD PTR [rbp-0x220]
    3663:	shl    rax,0x5
    3667:	mov    rcx,rax
    366a:	lea    rax,[rbp-0x190]
    3671:	mov    edx,0x8
    3676:	mov    rsi,rcx
    3679:	mov    rdi,rax
    367c:	call   17d3 <arena_alloc>
    3681:	mov    QWORD PTR [rbp-0x228],rax
    pair_count = 0;
    3688:	mov    DWORD PTR [rbp-0x238],0x0
  PROFILE_SCOPE("haversine alloc")
    3692:	add    QWORD PTR [rbp-0x218],0x1
    369a:	sub    rsp,0x8
    369e:	sub    rsp,0x38
    36a2:	mov    rcx,rsp
    36a5:	mov    rax,QWORD PTR [rbp-0x130]
    36ac:	mov    rdx,QWORD PTR [rbp-0x128]
    36b3:	mov    QWORD PTR [rcx],rax
    36b6:	mov    QWORD PTR [rcx+0x8],rdx
    36ba:	mov    rax,QWORD PTR [rbp-0x120]
    36c1:	mov    rdx,QWORD PTR [rbp-0x118]
    36c8:	mov    QWORD PTR [rcx+0x10],rax
    36cc:	mov    QWORD PTR [rcx+0x18],rdx
    36d0:	mov    rax,QWORD PTR [rbp-0x110]
    36d7:	mov    rdx,QWORD PTR [rbp-0x108]
    36de:	mov    QWORD PTR [rcx+0x20],rax
    36e2:	mov    QWORD PTR [rcx+0x28],rdx
    36e6:	mov    rax,QWORD PTR [rbp-0x100]
    36ed:	mov    QWORD PTR [rcx+0x30],rax
    36f1:	call   2056 <__profile_end_pass>
    36f6:	add    rsp,0x40
    36fa:	cmp    QWORD PTR [rbp-0x218],0x0
    3702:	je     3637 <main+0x26f>
  }

  JSON_Object *root = NULL;
    3708:	mov    QWORD PTR [rbp-0x1d8],0x0
  root = parse_json(&arena, source);
    3713:	mov    rcx,QWORD PTR [rbp-0x1a0]
    371a:	mov    rdx,QWORD PTR [rbp-0x198]
    3721:	lea    rax,[rbp-0x190]
    3728:	mov    rsi,rcx
    372b:	mov    rdi,rax
    372e:	call   2d84 <parse_json>
    3733:	mov    QWORD PTR [rbp-0x1d8],rax

  f64 haversine_sum = 0.0;
    373a:	pxor   xmm0,xmm0
    373e:	movsd  QWORD PTR [rbp-0x1d0],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    3746:	lea    rax,[rip+0xf28]        # 4675 <_IO_stdin_used+0x675>
    374d:	mov    QWORD PTR [rbp-0x280],rax
    3754:	mov    QWORD PTR [rbp-0x278],0x5
    375f:	mov    rax,QWORD PTR [rbp-0x280]
    3766:	mov    rdx,QWORD PTR [rbp-0x278]
    376d:	mov    rcx,rax
    3770:	mov    rax,QWORD PTR [rbp-0x1d8]
    3777:	mov    rsi,rcx
    377a:	mov    rdi,rax
    377d:	call   2ee7 <lookup_json_object>
    3782:	mov    QWORD PTR [rbp-0x1c8],rax
  if (pairs)
    3789:	cmp    QWORD PTR [rbp-0x228],0x0
    3791:	je     3a26 <main+0x65e>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    3797:	mov    rax,QWORD PTR [rbp-0x1c8]
    379e:	mov    rax,QWORD PTR [rax+0x20]
    37a2:	mov    QWORD PTR [rbp-0x210],rax
    37a9:	jmp    3a07 <main+0x63f>
    {
      PROFILE_SCOPE("child convert")
    37ae:	lea    rax,[rip+0xec6]        # 467b <_IO_stdin_used+0x67b>
    37b5:	mov    QWORD PTR [rbp-0x2c0],rax
    37bc:	mov    QWORD PTR [rbp-0x2b8],0xd
    37c7:	lea    rdi,[rbp-0x70]
    37cb:	mov    rbx,QWORD PTR [rbp-0x2c0]
    37d2:	mov    rsi,QWORD PTR [rbp-0x2b8]
    37d9:	mov    rdx,rbx
    37dc:	mov    rax,rsi
    37df:	mov    r8d,0x0
    37e5:	mov    ecx,0x7
    37ea:	mov    rsi,rdx
    37ed:	mov    rdx,rax
    37f0:	call   1f6c <__profile_begin_pass>
    37f5:	mov    QWORD PTR [rbp-0x208],0x0
    3800:	jmp    39e7 <main+0x61f>
      {
        Haversine_Pair pair =
        {
          .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    3805:	lea    rax,[rip+0xe7d]        # 4689 <_IO_stdin_used+0x689>
    380c:	mov    QWORD PTR [rbp-0x2d0],rax
    3813:	mov    QWORD PTR [rbp-0x2c8],0x2
    381e:	mov    rbx,QWORD PTR [rbp-0x2d0]
    3825:	mov    rsi,QWORD PTR [rbp-0x2c8]
    382c:	mov    rax,rbx
    382f:	mov    rdx,rsi
    3832:	mov    rcx,QWORD PTR [rbp-0x210]
    3839:	mov    rsi,rax
    383c:	mov    rdi,rcx
    383f:	call   2ee7 <lookup_json_object>
    3844:	mov    rdi,rax
    3847:	call   300a <json_object_to_f64>
    384c:	movq   rax,xmm0
        Haversine_Pair pair =
    3851:	mov    QWORD PTR [rbp-0xb0],rax
          .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    3858:	lea    rax,[rip+0xe2d]        # 468c <_IO_stdin_used+0x68c>
    385f:	mov    QWORD PTR [rbp-0x2e0],rax
    3866:	mov    QWORD PTR [rbp-0x2d8],0x2
    3871:	mov    rax,QWORD PTR [rbp-0x2e0]
    3878:	mov    rdx,QWORD PTR [rbp-0x2d8]
    387f:	mov    rcx,rax
    3882:	mov    rax,QWORD PTR [rbp-0x210]
    3889:	mov    rsi,rcx
    388c:	mov    rdi,rax
    388f:	call   2ee7 <lookup_json_object>
    3894:	mov    rdi,rax
    3897:	call   300a <json_object_to_f64>
    389c:	movq   rax,xmm0
        Haversine_Pair pair =
    38a1:	mov    QWORD PTR [rbp-0xa8],rax
          .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    38a8:	lea    rax,[rip+0xde0]        # 468f <_IO_stdin_used+0x68f>
    38af:	mov    QWORD PTR [rbp-0x2f0],rax
    38b6:	mov    QWORD PTR [rbp-0x2e8],0x2
    38c1:	mov    rax,QWORD PTR [rbp-0x2f0]
    38c8:	mov    rdx,QWORD PTR [rbp-0x2e8]
    38cf:	mov    rcx,rax
    38d2:	mov    rax,QWORD PTR [rbp-0x210]
    38d9:	mov    rsi,rcx
    38dc:	mov    rdi,rax
    38df:	call   2ee7 <lookup_json_object>
    38e4:	mov    rdi,rax
    38e7:	call   300a <json_object_to_f64>
    38ec:	movq   rax,xmm0
        Haversine_Pair pair =
    38f1:	mov    QWORD PTR [rbp-0xa0],rax
          .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    38f8:	lea    rax,[rip+0xd93]        # 4692 <_IO_stdin_used+0x692>
    38ff:	mov    QWORD PTR [rbp-0x300],rax
    3906:	mov    QWORD PTR [rbp-0x2f8],0x2
    3911:	mov    rax,QWORD PTR [rbp-0x300]
    3918:	mov    rdx,QWORD PTR [rbp-0x2f8]
    391f:	mov    rcx,rax
    3922:	mov    rax,QWORD PTR [rbp-0x210]
    3929:	mov    rsi,rcx
    392c:	mov    rdi,rax
    392f:	call   2ee7 <lookup_json_object>
    3934:	mov    rdi,rax
    3937:	call   300a <json_object_to_f64>
    393c:	movq   rax,xmm0
        Haversine_Pair pair =
    3941:	mov    QWORD PTR [rbp-0x98],rax
        };

        pairs[pair_count] = pair;
    3948:	mov    eax,DWORD PTR [rbp-0x238]
    394e:	cdqe
    3950:	shl    rax,0x5
    3954:	mov    rdx,rax
    3957:	mov    rax,QWORD PTR [rbp-0x228]
    395e:	lea    rcx,[rdx+rax*1]
    3962:	mov    rax,QWORD PTR [rbp-0xb0]
    3969:	mov    rdx,QWORD PTR [rbp-0xa8]
    3970:	mov    QWORD PTR [rcx],rax
    3973:	mov    QWORD PTR [rcx+0x8],rdx
    3977:	mov    rax,QWORD PTR [rbp-0xa0]
    397e:	mov    rdx,QWORD PTR [rbp-0x98]
    3985:	mov    QWORD PTR [rcx+0x10],rax
    3989:	mov    QWORD PTR [rcx+0x18],rdx
        pair_count += 1;
    398d:	add    DWORD PTR [rbp-0x238],0x1
      PROFILE_SCOPE("child convert")
    3994:	add    QWORD PTR [rbp-0x208],0x1
    399c:	sub    rsp,0x8
    39a0:	sub    rsp,0x38
    39a4:	mov    rcx,rsp
    39a7:	mov    rax,QWORD PTR [rbp-0x70]
    39ab:	mov    rdx,QWORD PTR [rbp-0x68]
    39af:	mov    QWORD PTR [rcx],rax
    39b2:	mov    QWORD PTR [rcx+0x8],rdx
    39b6:	mov    rax,QWORD PTR [rbp-0x60]
    39ba:	mov    rdx,QWORD PTR [rbp-0x58]
    39be:	mov    QWORD PTR [rcx+0x10],rax
    39c2:	mov    QWORD PTR [rcx+0x18],rdx
    39c6:	mov    rax,QWORD PTR [rbp-0x50]
    39ca:	mov    rdx,QWORD PTR [rbp-0x48]
    39ce:	mov    QWORD PTR [rcx+0x20],rax
    39d2:	mov    QWORD PTR [rcx+0x28],rdx
    39d6:	mov    rax,QWORD PTR [rbp-0x40]
    39da:	mov    QWORD PTR [rcx+0x30],rax
    39de:	call   2056 <__profile_end_pass>
    39e3:	add    rsp,0x40
    39e7:	cmp    QWORD PTR [rbp-0x208],0x0
    39ef:	je     3805 <main+0x43d>
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    39f5:	mov    rax,QWORD PTR [rbp-0x210]
    39fc:	mov    rax,QWORD PTR [rax+0x28]
    3a00:	mov    QWORD PTR [rbp-0x210],rax
    3a07:	cmp    QWORD PTR [rbp-0x210],0x0
    3a0f:	je     3a26 <main+0x65e>
    3a11:	mov    eax,DWORD PTR [rbp-0x238]
    3a17:	cdqe
    3a19:	cmp    rax,QWORD PTR [rbp-0x220]
    3a20:	jb     37ae <main+0x3e6>
      }
    }
  }

  f64 sum = 0.0;
    3a26:	pxor   xmm0,xmm0
    3a2a:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3a32:	lea    rax,[rip+0xc5c]        # 4695 <_IO_stdin_used+0x695>
    3a39:	mov    QWORD PTR [rbp-0x290],rax
    3a40:	mov    QWORD PTR [rbp-0x288],0x3
    3a4b:	lea    rax,[rbp-0xf0]
    3a52:	mov    rcx,QWORD PTR [rbp-0x290]
    3a59:	mov    rbx,QWORD PTR [rbp-0x288]
    3a60:	mov    rsi,rcx
    3a63:	mov    rdx,rbx
    3a66:	mov    r8d,0x0
    3a6c:	mov    ecx,0x8
    3a71:	mov    rdi,rax
    3a74:	call   1f6c <__profile_begin_pass>
    3a79:	mov    QWORD PTR [rbp-0x1f8],0x0
    3a84:	jmp    3c06 <main+0x83e>
  {
    for (usize i = 0; i < pair_count; i++)
    3a89:	mov    QWORD PTR [rbp-0x1f0],0x0
    3a94:	jmp    3b69 <main+0x7a1>
    {
      f64 earth_radius = 6372.8;
    3a99:	movsd  xmm0,QWORD PTR [rip+0xe6f]        # 4910 <__PRETTY_FUNCTION__.0+0x80>
    3aa1:	movsd  QWORD PTR [rbp-0x1b8],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    3aa9:	mov    rax,QWORD PTR [rbp-0x1f0]
    3ab0:	shl    rax,0x5
    3ab4:	mov    rdx,rax
    3ab7:	mov    rax,QWORD PTR [rbp-0x228]
    3abe:	add    rax,rdx
    3ac1:	movsd  xmm2,QWORD PTR [rax+0x18]
    3ac6:	mov    rax,QWORD PTR [rbp-0x1f0]
    3acd:	shl    rax,0x5
    3ad1:	mov    rdx,rax
    3ad4:	mov    rax,QWORD PTR [rbp-0x228]
    3adb:	add    rax,rdx
    3ade:	movsd  xmm1,QWORD PTR [rax+0x10]
    3ae3:	mov    rax,QWORD PTR [rbp-0x1f0]
    3aea:	shl    rax,0x5
    3aee:	mov    rdx,rax
    3af1:	mov    rax,QWORD PTR [rbp-0x228]
    3af8:	add    rax,rdx
    3afb:	movsd  xmm0,QWORD PTR [rax+0x8]
    3b00:	mov    rax,QWORD PTR [rbp-0x1f0]
    3b07:	shl    rax,0x5
    3b0b:	mov    rdx,rax
    3b0e:	mov    rax,QWORD PTR [rbp-0x228]
    3b15:	add    rax,rdx
    3b18:	mov    rax,QWORD PTR [rax]
    3b1b:	movsd  xmm3,QWORD PTR [rbp-0x1b8]
    3b23:	movapd xmm4,xmm3
    3b27:	movapd xmm3,xmm2
    3b2b:	movapd xmm2,xmm1
    3b2f:	movapd xmm1,xmm0
    3b33:	movq   xmm0,rax
    3b38:	call   31c7 <reference_haversine>
    3b3d:	movq   rax,xmm0
    3b42:	mov    QWORD PTR [rbp-0x1b0],rax
      sum += result;
    3b49:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b51:	addsd  xmm0,QWORD PTR [rbp-0x1b0]
    3b59:	movsd  QWORD PTR [rbp-0x200],xmm0
    for (usize i = 0; i < pair_count; i++)
    3b61:	add    QWORD PTR [rbp-0x1f0],0x1
    3b69:	mov    eax,DWORD PTR [rbp-0x238]
    3b6f:	cdqe
    3b71:	cmp    QWORD PTR [rbp-0x1f0],rax
    3b78:	jb     3a99 <main+0x6d1>
    }
    sum /= pair_count;
    3b7e:	pxor   xmm1,xmm1
    3b82:	cvtsi2sd xmm1,DWORD PTR [rbp-0x238]
    3b8a:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3b92:	divsd  xmm0,xmm1
    3b96:	movsd  QWORD PTR [rbp-0x200],xmm0
  PROFILE_SCOPE("sum")
    3b9e:	add    QWORD PTR [rbp-0x1f8],0x1
    3ba6:	sub    rsp,0x8
    3baa:	sub    rsp,0x38
    3bae:	mov    rax,rsp
    3bb1:	mov    rcx,QWORD PTR [rbp-0xf0]
    3bb8:	mov    rbx,QWORD PTR [rbp-0xe8]
    3bbf:	mov    QWORD PTR [rax],rcx
    3bc2:	mov    QWORD PTR [rax+0x8],rbx
    3bc6:	mov    rcx,QWORD PTR [rbp-0xe0]
    3bcd:	mov    rbx,QWORD PTR [rbp-0xd8]
    3bd4:	mov    QWORD PTR [rax+0x10],rcx
    3bd8:	mov    QWORD PTR [rax+0x18],rbx
    3bdc:	mov    rcx,QWORD PTR [rbp-0xd0]
    3be3:	mov    rbx,QWORD PTR [rbp-0xc8]
    3bea:	mov    QWORD PTR [rax+0x20],rcx
    3bee:	mov    QWORD PTR [rax+0x28],rbx
    3bf2:	mov    rdx,QWORD PTR [rbp-0xc0]
    3bf9:	mov    QWORD PTR [rax+0x30],rdx
    3bfd:	call   2056 <__profile_end_pass>
    3c02:	add    rsp,0x40
    3c06:	cmp    QWORD PTR [rbp-0x1f8],0x0
    3c0e:	je     3a89 <main+0x6c1>
  }

  PROFILE_SCOPE("check")
    3c14:	lea    rax,[rip+0xa7e]        # 4699 <_IO_stdin_used+0x699>
    3c1b:	mov    QWORD PTR [rbp-0x2a0],rax
    3c22:	mov    QWORD PTR [rbp-0x298],0x5
    3c2d:	lea    rax,[rbp-0xb0]
    3c34:	mov    rcx,QWORD PTR [rbp-0x2a0]
    3c3b:	mov    rbx,QWORD PTR [rbp-0x298]
    3c42:	mov    rsi,rcx
    3c45:	mov    rdx,rbx
    3c48:	mov    r8d,0x0
    3c4e:	mov    ecx,0x9
    3c53:	mov    rdi,rax
    3c56:	call   1f6c <__profile_begin_pass>
    3c5b:	mov    QWORD PTR [rbp-0x1e8],0x0
    3c66:	jmp    3e3b <main+0xa73>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3c6b:	mov    rax,QWORD PTR [rbp-0x250]
    3c72:	add    rax,0x10
    3c76:	mov    rdx,QWORD PTR [rax]
    3c79:	lea    rax,[rbp-0x190]
    3c80:	mov    rsi,rdx
    3c83:	mov    rdi,rax
    3c86:	call   1357 <read_file_to_arena>
    3c8b:	mov    QWORD PTR [rbp-0x70],rax
    3c8f:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3c93:	mov    rax,QWORD PTR [rbp-0x68]
    3c97:	cmp    rax,0xb
    3c9b:	jbe    3dae <main+0x9e6>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3ca1:	mov    rax,QWORD PTR [rbp-0x70]
    3ca5:	movsd  xmm0,QWORD PTR [rax]
    3ca9:	movsd  QWORD PTR [rbp-0x1c0],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3cb1:	mov    rax,QWORD PTR [rbp-0x70]
    3cb5:	mov    eax,DWORD PTR [rax+0x8]
    3cb8:	mov    DWORD PTR [rbp-0x234],eax

      if (solution_pairs == pair_count)
    3cbe:	mov    eax,DWORD PTR [rbp-0x234]
    3cc4:	cmp    eax,DWORD PTR [rbp-0x238]
    3cca:	jne    3d72 <main+0x9aa>
      {
        if (epsilon_equal(solution_sum, sum))
    3cd0:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3cd8:	mov    rax,QWORD PTR [rbp-0x1c0]
    3cdf:	movapd xmm1,xmm0
    3ce3:	movq   xmm0,rax
    3ce8:	call   3372 <epsilon_equal>
    3ced:	test   eax,eax
    3cef:	je     3d33 <main+0x96b>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3cf1:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3cf9:	mov    rax,QWORD PTR [rbp-0x1c0]
    3d00:	lea    rdx,[rip+0x999]        # 46a0 <_IO_stdin_used+0x6a0>
    3d07:	lea    rsi,[rip+0x9c5]        # 46d3 <_IO_stdin_used+0x6d3>
    3d0e:	movapd xmm1,xmm0
    3d12:	movq   xmm0,rax
    3d17:	mov    rcx,rdx
    3d1a:	mov    edx,0x65
    3d1f:	mov    edi,0x3
    3d24:	mov    eax,0x2
    3d29:	call   14a1 <log_message>
    3d2e:	jmp    3dd6 <main+0xa0e>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3d33:	movsd  xmm0,QWORD PTR [rbp-0x200]
    3d3b:	mov    rax,QWORD PTR [rbp-0x1c0]
    3d42:	lea    rdx,[rip+0x99f]        # 46e8 <_IO_stdin_used+0x6e8>
    3d49:	lea    rsi,[rip+0x983]        # 46d3 <_IO_stdin_used+0x6d3>
    3d50:	movapd xmm1,xmm0
    3d54:	movq   xmm0,rax
    3d59:	mov    rcx,rdx
    3d5c:	mov    edx,0x69
    3d61:	mov    edi,0x1
    3d66:	mov    eax,0x2
    3d6b:	call   14a1 <log_message>
    3d70:	jmp    3dd6 <main+0xa0e>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3d72:	mov    esi,DWORD PTR [rbp-0x238]
    3d78:	mov    ecx,DWORD PTR [rbp-0x234]
    3d7e:	lea    rdx,[rip+0x99b]        # 4720 <_IO_stdin_used+0x720>
    3d85:	lea    rax,[rip+0x947]        # 46d3 <_IO_stdin_used+0x6d3>
    3d8c:	mov    r9d,esi
    3d8f:	mov    r8d,ecx
    3d92:	mov    rcx,rdx
    3d95:	mov    edx,0x6e
    3d9a:	mov    rsi,rax
    3d9d:	mov    edi,0x1
    3da2:	mov    eax,0x0
    3da7:	call   14a1 <log_message>
    3dac:	jmp    3dd6 <main+0xa0e>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3dae:	lea    rdx,[rip+0x9b3]        # 4768 <_IO_stdin_used+0x768>
    3db5:	lea    rax,[rip+0x917]        # 46d3 <_IO_stdin_used+0x6d3>
    3dbc:	mov    rcx,rdx
    3dbf:	mov    edx,0x73
    3dc4:	mov    rsi,rax
    3dc7:	mov    edi,0x1
    3dcc:	mov    eax,0x0
    3dd1:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3dd6:	add    QWORD PTR [rbp-0x1e8],0x1
    3dde:	sub    rsp,0x8
    3de2:	sub    rsp,0x38
    3de6:	mov    rax,rsp
    3de9:	mov    rcx,QWORD PTR [rbp-0xb0]
    3df0:	mov    rbx,QWORD PTR [rbp-0xa8]
    3df7:	mov    QWORD PTR [rax],rcx
    3dfa:	mov    QWORD PTR [rax+0x8],rbx
    3dfe:	mov    rcx,QWORD PTR [rbp-0xa0]
    3e05:	mov    rbx,QWORD PTR [rbp-0x98]
    3e0c:	mov    QWORD PTR [rax+0x10],rcx
    3e10:	mov    QWORD PTR [rax+0x18],rbx
    3e14:	mov    rcx,QWORD PTR [rbp-0x90]
    3e1b:	mov    rbx,QWORD PTR [rbp-0x88]
    3e22:	mov    QWORD PTR [rax+0x20],rcx
    3e26:	mov    QWORD PTR [rax+0x28],rbx
    3e2a:	mov    rdx,QWORD PTR [rbp-0x80]
    3e2e:	mov    QWORD PTR [rax+0x30],rdx
    3e32:	call   2056 <__profile_end_pass>
    3e37:	add    rsp,0x40
    3e3b:	cmp    QWORD PTR [rbp-0x1e8],0x0
    3e43:	je     3c6b <main+0x8a3>
    }
  }

  PROFILE_SCOPE("free")
    3e49:	lea    rax,[rip+0x953]        # 47a3 <_IO_stdin_used+0x7a3>
    3e50:	mov    QWORD PTR [rbp-0x2b0],rax
    3e57:	mov    QWORD PTR [rbp-0x2a8],0x4
    3e62:	lea    rax,[rbp-0x70]
    3e66:	mov    rcx,QWORD PTR [rbp-0x2b0]
    3e6d:	mov    rbx,QWORD PTR [rbp-0x2a8]
    3e74:	mov    rsi,rcx
    3e77:	mov    rdx,rbx
    3e7a:	mov    r8d,0x0
    3e80:	mov    ecx,0xa
    3e85:	mov    rdi,rax
    3e88:	call   1f6c <__profile_begin_pass>
    3e8d:	mov    QWORD PTR [rbp-0x1e0],0x0
    3e98:	jmp    3efc <main+0xb34>
  {
    arena_free(&arena);
    3e9a:	lea    rax,[rbp-0x190]
    3ea1:	mov    rdi,rax
    3ea4:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3ea9:	add    QWORD PTR [rbp-0x1e0],0x1
    3eb1:	sub    rsp,0x8
    3eb5:	sub    rsp,0x38
    3eb9:	mov    rax,rsp
    3ebc:	mov    rcx,QWORD PTR [rbp-0x70]
    3ec0:	mov    rbx,QWORD PTR [rbp-0x68]
    3ec4:	mov    QWORD PTR [rax],rcx
    3ec7:	mov    QWORD PTR [rax+0x8],rbx
    3ecb:	mov    rcx,QWORD PTR [rbp-0x60]
    3ecf:	mov    rbx,QWORD PTR [rbp-0x58]
    3ed3:	mov    QWORD PTR [rax+0x10],rcx
    3ed7:	mov    QWORD PTR [rax+0x18],rbx
    3edb:	mov    rcx,QWORD PTR [rbp-0x50]
    3edf:	mov    rbx,QWORD PTR [rbp-0x48]
    3ee3:	mov    QWORD PTR [rax+0x20],rcx
    3ee7:	mov    QWORD PTR [rax+0x28],rbx
    3eeb:	mov    rdx,QWORD PTR [rbp-0x40]
    3eef:	mov    QWORD PTR [rax+0x30],rdx
    3ef3:	call   2056 <__profile_end_pass>
    3ef8:	add    rsp,0x40
    3efc:	cmp    QWORD PTR [rbp-0x1e0],0x0
    3f04:	je     3e9a <main+0xad2>
  }

  end_profiling();
    3f06:	call   1b9b <end_profiling>
    3f0b:	mov    eax,0x0
}
    3f10:	mov    rdx,QWORD PTR [rbp-0x38]
    3f14:	sub    rdx,QWORD PTR fs:0x28
    3f1d:	je     3f24 <main+0xb5c>
    3f1f:	call   1060 <__stack_chk_fail@plt>
    3f24:	lea    rsp,[rbp-0x28]
    3f28:	pop    rbx
    3f29:	pop    r12
    3f2b:	pop    r13
    3f2d:	pop    r14
    3f2f:	pop    r15
    3f31:	pop    rbp
    3f32:	ret

Disassembly of section .fini:

0000000000003f34 <_fini>:
    3f34:	endbr64
    3f38:	sub    rsp,0x8
    3f3c:	add    rsp,0x8
    3f40:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x4fc1]        # 5fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x4fca]        # 5ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x4fcc]        # 5ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x4fca]        # 6000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x4fc2]        # 6008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x4fba]        # 6010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x4fb2]        # 6018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x4faa]        # 6020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x4fa2]        # 6028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x4f9a]        # 6030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x4f92]        # 6038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x4f8a]        # 6040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x4f82]        # 6048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x4f7a]        # 6050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x4f72]        # 6058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x4f6a]        # 6060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x4f62]        # 6068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x4f5a]        # 6070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x4f52]        # 6078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x4f4a]        # 6080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x4f42]        # 6088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x4f3a]        # 6090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x4f32]        # 6098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x223f]        # 33ce <main>
    118f:	call   QWORD PTR [rip+0x4e2b]        # 5fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x4fa1]        # 6148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x4f9a]        # 6148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x4e0e]        # 5fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x4f71]        # 6148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x4f6a]        # 6148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x4ddd]        # 5fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x4f6d],0x0        # 6188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x4dba],0x0        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x4e76]        # 60a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x4da8]        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x4f44],0x1        # 6188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x4c6e]        # 6180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x4b89]        # 60c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x4be7]        # 6160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x4b2b]        # 60c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x3097]        # 4790 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x306b]        # 4790 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fae]        # 47a8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2eaf]        # 47b8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2ccd]        # 47d0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x4639]        # 61a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x4620],rbx        # 61a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x50
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x45ee]        # 61a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x40],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x40],0x0
    1bbe:	je     1f6f <end_profiling+0x3d4>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x38],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x40]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x38]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c51]        # 4888 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x38]
    1c44:	mov    rax,QWORD PTR [rbp-0x40]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x50],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x48],0x0
    1c72:	jmp    1f61 <end_profiling+0x3c6>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x48]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x450d]        # 61a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x30],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x30]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1f5c <end_profiling+0x3c1>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x30]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x40]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b77]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x28],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x30]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x30]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x30]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x30]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x28]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>

        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x30]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x30]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x30]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x40]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2a9f]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x20],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x30]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x20]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x50]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x28]
    1e2c:	movsd  QWORD PTR [rbp-0x50],xmm0

        if (zone->bytes_processed)
    1e31:	mov    rax,QWORD PTR [rbp-0x30]
    1e35:	mov    rax,QWORD PTR [rax+0x28]
    1e39:	test   rax,rax
    1e3c:	je     1f5c <end_profiling+0x3c1>
        {
          f64 gigabytes = (f64)zone->bytes_processed / GB(1);
    1e42:	mov    rax,QWORD PTR [rbp-0x30]
    1e46:	mov    rax,QWORD PTR [rax+0x28]
    1e4a:	test   rax,rax
    1e4d:	js     1e5a <end_profiling+0x2bf>
    1e4f:	pxor   xmm0,xmm0
    1e53:	cvtsi2sd xmm0,rax
    1e58:	jmp    1e73 <end_profiling+0x2d8>
    1e5a:	mov    rdx,rax
    1e5d:	shr    rdx,1
    1e60:	and    eax,0x1
    1e63:	or     rdx,rax
    1e66:	pxor   xmm0,xmm0
    1e6a:	cvtsi2sd xmm0,rdx
    1e6f:	addsd  xmm0,xmm0
    1e73:	movsd  xmm1,QWORD PTR [rip+0x2a1d]        # 4898 <__PRETTY_FUNCTION__.0+0x28>
    1e7b:	divsd  xmm0,xmm1
    1e7f:	movsd  QWORD PTR [rbp-0x18],xmm0
          f64 megabytes = (f64)zone->bytes_processed / MB(1);
    1e84:	mov    rax,QWORD PTR [rbp-0x30]
    1e88:	mov    rax,QWORD PTR [rax+0x28]
    1e8c:	test   rax,rax
    1e8f:	js     1e9c <end_profiling+0x301>
    1e91:	pxor   xmm0,xmm0
    1e95:	cvtsi2sd xmm0,rax
    1e9a:	jmp    1eb5 <end_profiling+0x31a>
    1e9c:	mov    rdx,rax
    1e9f:	shr    rdx,1
    1ea2:	and    eax,0x1
    1ea5:	or     rdx,rax
    1ea8:	pxor   xmm0,xmm0
    1eac:	cvtsi2sd xmm0,rdx
    1eb1:	addsd  xmm0,xmm0
    1eb5:	movsd  xmm1,QWORD PTR [rip+0x29e3]        # 48a0 <__PRETTY_FUNCTION__.0+0x30>
    1ebd:	divsd  xmm0,xmm1
    1ec1:	movsd  QWORD PTR [rbp-0x10],xmm0

          f64 gb_per_s = gigabytes / (f64)zone->elapsed_inclusive / (f64)freq;
    1ec6:	mov    rax,QWORD PTR [rbp-0x30]
    1eca:	mov    rax,QWORD PTR [rax+0x18]
    1ece:	test   rax,rax
    1ed1:	js     1ede <end_profiling+0x343>
    1ed3:	pxor   xmm0,xmm0
    1ed7:	cvtsi2sd xmm0,rax
    1edc:	jmp    1ef7 <end_profiling+0x35c>
    1ede:	mov    rdx,rax
    1ee1:	shr    rdx,1
    1ee4:	and    eax,0x1
    1ee7:	or     rdx,rax
    1eea:	pxor   xmm0,xmm0
    1eee:	cvtsi2sd xmm0,rdx
    1ef3:	addsd  xmm0,xmm0
    1ef7:	movsd  xmm1,QWORD PTR [rbp-0x18]
    1efc:	divsd  xmm1,xmm0
    1f00:	mov    rax,QWORD PTR [rbp-0x38]
    1f04:	test   rax,rax
    1f07:	js     1f14 <end_profiling+0x379>
    1f09:	pxor   xmm0,xmm0
    1f0d:	cvtsi2sd xmm0,rax
    1f12:	jmp    1f2d <end_profiling+0x392>
    1f14:	mov    rdx,rax
    1f17:	shr    rdx,1
    1f1a:	and    eax,0x1
    1f1d:	or     rdx,rax
    1f20:	pxor   xmm0,xmm0
    1f24:	cvtsi2sd xmm0,rdx
    1f29:	addsd  xmm0,xmm0
    1f2d:	divsd  xmm1,xmm0
    1f31:	movsd  QWORD PTR [rbp-0x8],xmm1

          printf("  Megabytes Processed: %lu @ %f GB/s\n", megabytes, gb_per_s);
    1f36:	movsd  xmm0,QWORD PTR [rbp-0x8]
    1f3b:	mov    rax,QWORD PTR [rbp-0x10]
    1f3f:	lea    rdx,[rip+0x2402]        # 4348 <_IO_stdin_used+0x348>
    1f46:	movapd xmm1,xmm0
    1f4a:	movq   xmm0,rax
    1f4f:	mov    rdi,rdx
    1f52:	mov    eax,0x2
    1f57:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1f5c:	add    QWORD PTR [rbp-0x48],0x1
    1f61:	cmp    QWORD PTR [rbp-0x48],0xfff
    1f69:	jbe    1c77 <end_profiling+0xdc>
        }
      }
    }
  }
}
    1f6f:	nop
    1f70:	leave
    1f71:	ret

0000000000001f72 <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1f72:	push   rbp
    1f73:	mov    rbp,rsp
    1f76:	push   rbx
    1f77:	sub    rsp,0x78
    1f7b:	mov    QWORD PTR [rbp-0x58],rdi
    1f7f:	mov    rax,rsi
    1f82:	mov    rsi,rdx
    1f85:	mov    rax,rax
    1f88:	mov    edx,0x0
    1f8d:	mov    rdx,rsi
    1f90:	mov    QWORD PTR [rbp-0x70],rax
    1f94:	mov    QWORD PTR [rbp-0x68],rdx
    1f98:	mov    QWORD PTR [rbp-0x60],rcx
    1f9c:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1fa0:	pxor   xmm0,xmm0
    1fa4:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1fa8:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1fac:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1fb0:	movq   QWORD PTR [rbp-0x20],xmm0
    1fb5:	mov    rax,QWORD PTR [rbp-0x70]
    1fb9:	mov    rdx,QWORD PTR [rbp-0x68]
    1fbd:	mov    QWORD PTR [rbp-0x50],rax
    1fc1:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1fc5:	mov    rdx,QWORD PTR [rbp-0x60]
    1fc9:	mov    rax,rdx
    1fcc:	add    rax,rax
    1fcf:	add    rax,rdx
    1fd2:	shl    rax,0x4
    1fd6:	mov    rdx,rax
    1fd9:	lea    rax,[rip+0x41e8]        # 61c8 <g_profiler+0x28>
    1fe0:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1fe4:	mov    QWORD PTR [rbp-0x38],rax
    1fe8:	mov    rax,QWORD PTR [rbp-0x60]
    1fec:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1ff0:	mov    rax,QWORD PTR [rip+0x41b1]        # 61a8 <g_profiler+0x8>
  Profile_Pass pass =
    1ff7:	mov    QWORD PTR [rbp-0x28],rax
    1ffb:	mov    rax,QWORD PTR [rbp-0x78]
    1fff:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    2003:	mov    rax,QWORD PTR [rbp-0x60]
    2007:	mov    QWORD PTR [rip+0x419a],rax        # 61a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    200e:	call   1a48 <read_cpu_timer>
    2013:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    2017:	mov    rax,QWORD PTR [rbp-0x58]
    201b:	mov    rcx,QWORD PTR [rbp-0x50]
    201f:	mov    rbx,QWORD PTR [rbp-0x48]
    2023:	mov    QWORD PTR [rax],rcx
    2026:	mov    QWORD PTR [rax+0x8],rbx
    202a:	mov    rcx,QWORD PTR [rbp-0x40]
    202e:	mov    rbx,QWORD PTR [rbp-0x38]
    2032:	mov    QWORD PTR [rax+0x10],rcx
    2036:	mov    QWORD PTR [rax+0x18],rbx
    203a:	mov    rcx,QWORD PTR [rbp-0x30]
    203e:	mov    rbx,QWORD PTR [rbp-0x28]
    2042:	mov    QWORD PTR [rax+0x20],rcx
    2046:	mov    QWORD PTR [rax+0x28],rbx
    204a:	mov    rdx,QWORD PTR [rbp-0x20]
    204e:	mov    QWORD PTR [rax+0x30],rdx
}
    2052:	mov    rax,QWORD PTR [rbp-0x58]
    2056:	mov    rbx,QWORD PTR [rbp-0x8]
    205a:	leave
    205b:	ret

000000000000205c <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    205c:	push   rbp
    205d:	mov    rbp,rsp
    2060:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    2064:	call   1a48 <read_cpu_timer>
    2069:	mov    rdx,rax
    206c:	mov    rax,QWORD PTR [rbp+0x20]
    2070:	sub    rdx,rax
    2073:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    2077:	mov    rax,QWORD PTR [rbp+0x38]
    207b:	mov    QWORD PTR [rip+0x4126],rax        # 61a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    2082:	mov    rdx,QWORD PTR [rbp+0x30]
    2086:	mov    rax,rdx
    2089:	add    rax,rax
    208c:	add    rax,rdx
    208f:	shl    rax,0x4
    2093:	lea    rdx,[rax+0x10]
    2097:	lea    rax,[rip+0x4102]        # 61a0 <g_profiler>
    209e:	add    rax,rdx
    20a1:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    20a5:	mov    rax,QWORD PTR [rbp-0x10]
    20a9:	mov    rdx,QWORD PTR [rax+0x10]
    20ad:	mov    rax,QWORD PTR [rbp-0x18]
    20b1:	add    rdx,rax
    20b4:	mov    rax,QWORD PTR [rbp-0x10]
    20b8:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    20bc:	mov    rax,QWORD PTR [rbp-0x10]
    20c0:	mov    rax,QWORD PTR [rax+0x20]
    20c4:	lea    rdx,[rax+0x1]
    20c8:	mov    rax,QWORD PTR [rbp-0x10]
    20cc:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    20d0:	mov    rcx,QWORD PTR [rbp-0x10]
    20d4:	mov    rax,QWORD PTR [rbp+0x10]
    20d8:	mov    rdx,QWORD PTR [rbp+0x18]
    20dc:	mov    QWORD PTR [rcx],rax
    20df:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    20e3:	mov    rdx,QWORD PTR [rbp+0x28]
    20e7:	mov    rax,QWORD PTR [rbp-0x18]
    20eb:	add    rdx,rax
    20ee:	mov    rax,QWORD PTR [rbp-0x10]
    20f2:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    20f6:	mov    rax,QWORD PTR [rbp-0x10]
    20fa:	mov    rdx,QWORD PTR [rax+0x28]
    20fe:	mov    rax,QWORD PTR [rbp+0x40]
    2102:	add    rdx,rax
    2105:	mov    rax,QWORD PTR [rbp-0x10]
    2109:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    210d:	mov    rdx,QWORD PTR [rbp+0x38]
    2111:	mov    rax,rdx
    2114:	add    rax,rax
    2117:	add    rax,rdx
    211a:	shl    rax,0x4
    211e:	lea    rdx,[rax+0x10]
    2122:	lea    rax,[rip+0x4077]        # 61a0 <g_profiler>
    2129:	add    rax,rdx
    212c:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    2130:	mov    rax,QWORD PTR [rbp-0x8]
    2134:	mov    rax,QWORD PTR [rax+0x10]
    2138:	sub    rax,QWORD PTR [rbp-0x18]
    213c:	mov    rdx,rax
    213f:	mov    rax,QWORD PTR [rbp-0x8]
    2143:	mov    QWORD PTR [rax+0x10],rdx
}
    2147:	nop
    2148:	leave
    2149:	ret

000000000000214a <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    214a:	push   rbp
    214b:	mov    rbp,rsp
    214e:	sub    rsp,0x10
    2152:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2156:	mov    rax,QWORD PTR [rbp-0x8]
    215a:	mov    rdx,QWORD PTR [rax+0x10]
    215e:	mov    rax,QWORD PTR [rbp-0x8]
    2162:	mov    rax,QWORD PTR [rax+0x8]
    2166:	cmp    rdx,rax
    2169:	jb     2190 <parser_at+0x46>
    216b:	lea    rdx,[rip+0x2676]        # 47e8 <__PRETTY_FUNCTION__.5>
    2172:	lea    rsi,[rip+0x2300]        # 4479 <_IO_stdin_used+0x479>
    2179:	lea    rax,[rip+0x2310]        # 4490 <_IO_stdin_used+0x490>
    2180:	mov    rcx,rdx
    2183:	mov    edx,0x2f
    2188:	mov    rdi,rax
    218b:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    2190:	mov    rax,QWORD PTR [rbp-0x8]
    2194:	mov    rdx,QWORD PTR [rax]
    2197:	mov    rax,QWORD PTR [rbp-0x8]
    219b:	mov    rax,QWORD PTR [rax+0x10]
    219f:	add    rax,rdx
}
    21a2:	leave
    21a3:	ret

00000000000021a4 <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    21a4:	push   rbp
    21a5:	mov    rbp,rsp
    21a8:	sub    rsp,0x10
    21ac:	mov    QWORD PTR [rbp-0x8],rdi
    21b0:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    21b4:	mov    rax,QWORD PTR [rbp-0x8]
    21b8:	mov    rdi,rax
    21bb:	call   214a <parser_at>
    21c0:	mov    rdx,QWORD PTR [rbp-0x10]
    21c4:	add    rax,rdx
}
    21c7:	leave
    21c8:	ret

00000000000021c9 <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    21c9:	push   rbp
    21ca:	mov    rbp,rsp
    21cd:	mov    QWORD PTR [rbp-0x8],rdi
    21d1:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    21d5:	mov    rax,QWORD PTR [rbp-0x8]
    21d9:	mov    rdx,QWORD PTR [rax+0x10]
    21dd:	mov    rax,QWORD PTR [rbp-0x10]
    21e1:	add    rdx,rax
    21e4:	mov    rax,QWORD PTR [rbp-0x8]
    21e8:	mov    QWORD PTR [rax+0x10],rdx
}
    21ec:	nop
    21ed:	pop    rbp
    21ee:	ret

00000000000021ef <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    21ef:	push   rbp
    21f0:	mov    rbp,rsp
    21f3:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    21f7:	mov    rax,QWORD PTR [rbp-0x8]
    21fb:	mov    rdx,QWORD PTR [rax+0x10]
    21ff:	mov    rax,QWORD PTR [rbp-0x8]
    2203:	mov    rax,QWORD PTR [rax+0x8]
    2207:	cmp    rdx,rax
    220a:	setb   al
}
    220d:	pop    rbp
    220e:	ret

000000000000220f <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    220f:	push   rbp
    2210:	mov    rbp,rsp
    2213:	push   r12
    2215:	push   rbx
    2216:	sub    rsp,0x20
    221a:	mov    QWORD PTR [rbp-0x18],rdi
    221e:	mov    rax,rsi
    2221:	mov    rcx,rdx
    2224:	mov    rax,rax
    2227:	mov    edx,0x0
    222c:	mov    rdx,rcx
    222f:	mov    QWORD PTR [rbp-0x30],rax
    2233:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    2237:	mov    rax,QWORD PTR [rbp-0x28]
    223b:	mov    r12,rax
    223e:	mov    rbx,QWORD PTR [rbp-0x30]
    2242:	mov    rax,QWORD PTR [rbp-0x18]
    2246:	mov    rdi,rax
    2249:	call   214a <parser_at>
    224e:	mov    rdx,r12
    2251:	mov    rsi,rbx
    2254:	mov    rdi,rax
    2257:	call   10d0 <memcmp@plt>
    225c:	test   eax,eax
    225e:	sete   al
}
    2261:	add    rsp,0x20
    2265:	pop    rbx
    2266:	pop    r12
    2268:	pop    rbp
    2269:	ret

000000000000226a <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    226a:	push   rbp
    226b:	mov    rbp,rsp
    226e:	mov    eax,edi
    2270:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    2273:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    2277:	movzx  eax,BYTE PTR [rbp-0x14]
    227b:	cmp    eax,0x2e
    227e:	jg     2287 <is_numeric+0x1d>
    2280:	cmp    eax,0x2d
    2283:	jge    228f <is_numeric+0x25>
    2285:	jmp    2294 <is_numeric+0x2a>
    2287:	sub    eax,0x30
    228a:	cmp    eax,0x9
    228d:	ja     2294 <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    228f:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    2293:	nop
  }


  return result;
    2294:	movzx  eax,BYTE PTR [rbp-0x1]
}
    2298:	pop    rbp
    2299:	ret

000000000000229a <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    229a:	push   rbp
    229b:	mov    rbp,rsp
    229e:	sub    rsp,0x50
    22a2:	mov    QWORD PTR [rbp-0x48],rdi
    22a6:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    22aa:	pxor   xmm0,xmm0
    22ae:	movaps XMMWORD PTR [rbp-0x20],xmm0
    22b2:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    22b7:	jmp    22ca <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    22b9:	mov    rax,QWORD PTR [rbp-0x50]
    22bd:	mov    esi,0x1
    22c2:	mov    rdi,rax
    22c5:	call   21c9 <parser_advance>
  while (parser_incomplete(parser)  &&
    22ca:	mov    rax,QWORD PTR [rbp-0x50]
    22ce:	mov    rdi,rax
    22d1:	call   21ef <parser_incomplete>
    22d6:	test   al,al
    22d8:	je     2326 <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    22da:	mov    rax,QWORD PTR [rbp-0x50]
    22de:	mov    rdi,rax
    22e1:	call   214a <parser_at>
    22e6:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    22e9:	cmp    al,0x20
    22eb:	je     22b9 <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    22ed:	mov    rax,QWORD PTR [rbp-0x50]
    22f1:	mov    rdi,rax
    22f4:	call   214a <parser_at>
    22f9:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    22fc:	cmp    al,0xa
    22fe:	je     22b9 <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    2300:	mov    rax,QWORD PTR [rbp-0x50]
    2304:	mov    rdi,rax
    2307:	call   214a <parser_at>
    230c:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    230f:	cmp    al,0xd
    2311:	je     22b9 <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    2313:	mov    rax,QWORD PTR [rbp-0x50]
    2317:	mov    rdi,rax
    231a:	call   214a <parser_at>
    231f:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    2322:	cmp    al,0x9
    2324:	je     22b9 <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    2326:	mov    rax,QWORD PTR [rbp-0x50]
    232a:	mov    rdi,rax
    232d:	call   21ef <parser_incomplete>
    2332:	test   al,al
    2334:	je     2761 <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    233a:	mov    rax,QWORD PTR [rbp-0x50]
    233e:	mov    rdi,rax
    2341:	call   214a <parser_at>
    2346:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    234a:	mov    rax,QWORD PTR [rbp-0x50]
    234e:	mov    rdi,rax
    2351:	call   214a <parser_at>
    2356:	movzx  eax,BYTE PTR [rax]
    2359:	movzx  eax,al
    235c:	cmp    eax,0x7d
    235f:	je     244c <get_json_token+0x1b2>
    2365:	cmp    eax,0x7d
    2368:	jg     2772 <get_json_token+0x4d8>
    236e:	cmp    eax,0x7b
    2371:	je     2427 <get_json_token+0x18d>
    2377:	cmp    eax,0x7b
    237a:	jg     2772 <get_json_token+0x4d8>
    2380:	cmp    eax,0x74
    2383:	je     25cf <get_json_token+0x335>
    2389:	cmp    eax,0x74
    238c:	jg     2772 <get_json_token+0x4d8>
    2392:	cmp    eax,0x6e
    2395:	je     26df <get_json_token+0x445>
    239b:	cmp    eax,0x6e
    239e:	jg     2772 <get_json_token+0x4d8>
    23a4:	cmp    eax,0x66
    23a7:	je     2657 <get_json_token+0x3bd>
    23ad:	cmp    eax,0x66
    23b0:	jg     2772 <get_json_token+0x4d8>
    23b6:	cmp    eax,0x5d
    23b9:	je     2496 <get_json_token+0x1fc>
    23bf:	cmp    eax,0x5d
    23c2:	jg     2772 <get_json_token+0x4d8>
    23c8:	cmp    eax,0x5b
    23cb:	je     2471 <get_json_token+0x1d7>
    23d1:	cmp    eax,0x5b
    23d4:	jg     2772 <get_json_token+0x4d8>
    23da:	cmp    eax,0x3a
    23dd:	je     24e0 <get_json_token+0x246>
    23e3:	cmp    eax,0x3a
    23e6:	jg     2772 <get_json_token+0x4d8>
    23ec:	cmp    eax,0x39
    23ef:	jg     2772 <get_json_token+0x4d8>
    23f5:	cmp    eax,0x30
    23f8:	jge    257e <get_json_token+0x2e4>
    23fe:	cmp    eax,0x2e
    2401:	jg     2772 <get_json_token+0x4d8>
    2407:	cmp    eax,0x2d
    240a:	jge    257e <get_json_token+0x2e4>
    2410:	cmp    eax,0x22
    2413:	je     2505 <get_json_token+0x26b>
    2419:	cmp    eax,0x2c
    241c:	je     24bb <get_json_token+0x221>
    2422:	jmp    2772 <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    2427:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    242e:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2436:	mov    rax,QWORD PTR [rbp-0x50]
    243a:	mov    esi,0x1
    243f:	mov    rdi,rax
    2442:	call   21c9 <parser_advance>
      }
      break;
    2447:	jmp    2772 <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    244c:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    2453:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    245b:	mov    rax,QWORD PTR [rbp-0x50]
    245f:	mov    esi,0x1
    2464:	mov    rdi,rax
    2467:	call   21c9 <parser_advance>
      }
      break;
    246c:	jmp    2772 <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2471:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    2478:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2480:	mov    rax,QWORD PTR [rbp-0x50]
    2484:	mov    esi,0x1
    2489:	mov    rdi,rax
    248c:	call   21c9 <parser_advance>
      }
      break;
    2491:	jmp    2772 <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    2496:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    249d:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24a5:	mov    rax,QWORD PTR [rbp-0x50]
    24a9:	mov    esi,0x1
    24ae:	mov    rdi,rax
    24b1:	call   21c9 <parser_advance>
      }
      break;
    24b6:	jmp    2772 <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    24bb:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    24c2:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24ca:	mov    rax,QWORD PTR [rbp-0x50]
    24ce:	mov    esi,0x1
    24d3:	mov    rdi,rax
    24d6:	call   21c9 <parser_advance>
      }
      break;
    24db:	jmp    2772 <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    24e0:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    24e7:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24ef:	mov    rax,QWORD PTR [rbp-0x50]
    24f3:	mov    esi,0x1
    24f8:	mov    rdi,rax
    24fb:	call   21c9 <parser_advance>
      }
      break;
    2500:	jmp    2772 <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    2505:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    250c:	mov    rax,QWORD PTR [rbp-0x50]
    2510:	mov    esi,0x1
    2515:	mov    rdi,rax
    2518:	call   21c9 <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    251d:	mov    rax,QWORD PTR [rbp-0x50]
    2521:	mov    rdi,rax
    2524:	call   214a <parser_at>
    2529:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    252d:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    2535:	jmp    254d <get_json_token+0x2b3>
        {
          string_count += 1;
    2537:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    253c:	mov    rax,QWORD PTR [rbp-0x50]
    2540:	mov    esi,0x1
    2545:	mov    rdi,rax
    2548:	call   21c9 <parser_advance>
        while (*parser_at(parser) != '"')
    254d:	mov    rax,QWORD PTR [rbp-0x50]
    2551:	mov    rdi,rax
    2554:	call   214a <parser_at>
    2559:	movzx  eax,BYTE PTR [rax]
    255c:	cmp    al,0x22
    255e:	jne    2537 <get_json_token+0x29d>
        }
        token.value.count = string_count;
    2560:	mov    rax,QWORD PTR [rbp-0x40]
    2564:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    2568:	mov    rax,QWORD PTR [rbp-0x50]
    256c:	mov    esi,0x1
    2571:	mov    rdi,rax
    2574:	call   21c9 <parser_advance>
      }
      break;
    2579:	jmp    2772 <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    257e:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    2585:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    258d:	jmp    25a5 <get_json_token+0x30b>
        {
          digit_count += 1;
    258f:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    2594:	mov    rax,QWORD PTR [rbp-0x50]
    2598:	mov    esi,0x1
    259d:	mov    rdi,rax
    25a0:	call   21c9 <parser_advance>
        while (is_numeric(*parser_at(parser)))
    25a5:	mov    rax,QWORD PTR [rbp-0x50]
    25a9:	mov    rdi,rax
    25ac:	call   214a <parser_at>
    25b1:	movzx  eax,BYTE PTR [rax]
    25b4:	movzx  eax,al
    25b7:	mov    edi,eax
    25b9:	call   226a <is_numeric>
    25be:	test   al,al
    25c0:	jne    258f <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    25c2:	mov    rax,QWORD PTR [rbp-0x38]
    25c6:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    25ca:	jmp    2772 <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    25cf:	lea    rax,[rip+0x1f06]        # 44dc <_IO_stdin_used+0x4dc>
    25d6:	mov    QWORD PTR [rbp-0x30],rax
    25da:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25e2:	mov    rcx,QWORD PTR [rbp-0x30]
    25e6:	mov    rdx,QWORD PTR [rbp-0x28]
    25ea:	mov    rax,QWORD PTR [rbp-0x50]
    25ee:	mov    rsi,rcx
    25f1:	mov    rdi,rax
    25f4:	call   220f <parser_token_is_literal>
    25f9:	test   al,al
    25fb:	je     261f <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    25fd:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    2604:	mov    rax,QWORD PTR [rbp-0x28]
    2608:	mov    rdx,rax
    260b:	mov    rax,QWORD PTR [rbp-0x50]
    260f:	mov    rsi,rdx
    2612:	mov    rdi,rax
    2615:	call   21c9 <parser_advance>
    261a:	jmp    2772 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    261f:	mov    rax,QWORD PTR [rbp-0x50]
    2623:	mov    rcx,QWORD PTR [rax+0x10]
    2627:	lea    rdx,[rip+0x1eba]        # 44e8 <_IO_stdin_used+0x4e8>
    262e:	lea    rax,[rip+0x1e44]        # 4479 <_IO_stdin_used+0x479>
    2635:	mov    r8,rcx
    2638:	mov    rcx,rdx
    263b:	mov    edx,0xdf
    2640:	mov    rsi,rax
    2643:	mov    edi,0x1
    2648:	mov    eax,0x0
    264d:	call   14a1 <log_message>
        }
      }
      break;
    2652:	jmp    2772 <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    2657:	lea    rax,[rip+0x1eb7]        # 4515 <_IO_stdin_used+0x515>
    265e:	mov    QWORD PTR [rbp-0x30],rax
    2662:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    266a:	mov    rcx,QWORD PTR [rbp-0x30]
    266e:	mov    rdx,QWORD PTR [rbp-0x28]
    2672:	mov    rax,QWORD PTR [rbp-0x50]
    2676:	mov    rsi,rcx
    2679:	mov    rdi,rax
    267c:	call   220f <parser_token_is_literal>
    2681:	test   al,al
    2683:	je     26a7 <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    2685:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    268c:	mov    rax,QWORD PTR [rbp-0x28]
    2690:	mov    rdx,rax
    2693:	mov    rax,QWORD PTR [rbp-0x50]
    2697:	mov    rsi,rdx
    269a:	mov    rdi,rax
    269d:	call   21c9 <parser_advance>
    26a2:	jmp    2772 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    26a7:	mov    rax,QWORD PTR [rbp-0x50]
    26ab:	mov    rcx,QWORD PTR [rax+0x10]
    26af:	lea    rdx,[rip+0x1e32]        # 44e8 <_IO_stdin_used+0x4e8>
    26b6:	lea    rax,[rip+0x1dbc]        # 4479 <_IO_stdin_used+0x479>
    26bd:	mov    r8,rcx
    26c0:	mov    rcx,rdx
    26c3:	mov    edx,0xee
    26c8:	mov    rsi,rax
    26cb:	mov    edi,0x1
    26d0:	mov    eax,0x0
    26d5:	call   14a1 <log_message>
        }
      }
      break;
    26da:	jmp    2772 <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    26df:	lea    rax,[rip+0x1e35]        # 451b <_IO_stdin_used+0x51b>
    26e6:	mov    QWORD PTR [rbp-0x30],rax
    26ea:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    26f2:	mov    rcx,QWORD PTR [rbp-0x30]
    26f6:	mov    rdx,QWORD PTR [rbp-0x28]
    26fa:	mov    rax,QWORD PTR [rbp-0x50]
    26fe:	mov    rsi,rcx
    2701:	mov    rdi,rax
    2704:	call   220f <parser_token_is_literal>
    2709:	test   al,al
    270b:	je     272c <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    270d:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    2714:	mov    rax,QWORD PTR [rbp-0x28]
    2718:	mov    rdx,rax
    271b:	mov    rax,QWORD PTR [rbp-0x50]
    271f:	mov    rsi,rdx
    2722:	mov    rdi,rax
    2725:	call   21c9 <parser_advance>
    272a:	jmp    2772 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    272c:	mov    rax,QWORD PTR [rbp-0x50]
    2730:	mov    rcx,QWORD PTR [rax+0x10]
    2734:	lea    rdx,[rip+0x1dad]        # 44e8 <_IO_stdin_used+0x4e8>
    273b:	lea    rax,[rip+0x1d37]        # 4479 <_IO_stdin_used+0x479>
    2742:	mov    r8,rcx
    2745:	mov    rcx,rdx
    2748:	mov    edx,0xfd
    274d:	mov    rsi,rax
    2750:	mov    edi,0x1
    2755:	mov    eax,0x0
    275a:	call   14a1 <log_message>
        }
      }
      break;
    275f:	jmp    2772 <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    2761:	mov    rax,QWORD PTR [rbp-0x50]
    2765:	mov    esi,0x1
    276a:	mov    rdi,rax
    276d:	call   21c9 <parser_advance>
  }

  return token;
    2772:	mov    rcx,QWORD PTR [rbp-0x48]
    2776:	mov    rax,QWORD PTR [rbp-0x20]
    277a:	mov    rdx,QWORD PTR [rbp-0x18]
    277e:	mov    QWORD PTR [rcx],rax
    2781:	mov    QWORD PTR [rcx+0x8],rdx
    2785:	mov    rax,QWORD PTR [rbp-0x10]
    2789:	mov    QWORD PTR [rcx+0x10],rax
}
    278d:	mov    rax,QWORD PTR [rbp-0x48]
    2791:	leave
    2792:	ret

0000000000002793 <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    2793:	push   rbp
    2794:	mov    rbp,rsp
    2797:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    279a:	cmp    DWORD PTR [rbp-0x14],0x7
    279e:	je     27b8 <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    27a0:	cmp    DWORD PTR [rbp-0x14],0x9
    27a4:	je     27b8 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    27a6:	cmp    DWORD PTR [rbp-0x14],0xa
    27aa:	je     27b8 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    27ac:	cmp    DWORD PTR [rbp-0x14],0xb
    27b0:	je     27b8 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    27b2:	cmp    DWORD PTR [rbp-0x14],0x8
    27b6:	jne    27bf <json_token_type_is_value_type+0x2c>
    27b8:	mov    eax,0x1
    27bd:	jmp    27c4 <json_token_type_is_value_type+0x31>
    27bf:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    27c4:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    27c7:	mov    eax,DWORD PTR [rbp-0x4]
}
    27ca:	pop    rbp
    27cb:	ret

00000000000027cc <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    27cc:	push   rbp
    27cd:	mov    rbp,rsp
    27d0:	push   rbx
    27d1:	sub    rsp,0x88
    27d8:	mov    QWORD PTR [rbp-0x78],rdi
    27dc:	mov    QWORD PTR [rbp-0x80],rsi
    27e0:	mov    QWORD PTR [rbp-0x90],rdx
    27e7:	mov    QWORD PTR [rbp-0x88],rcx
    27ee:	mov    rax,QWORD PTR fs:0x28
    27f7:	mov    QWORD PTR [rbp-0x18],rax
    27fb:	xor    eax,eax
  profile_begin_func();
    27fd:	lea    r8,[rip+0x1ffc]        # 4800 <__func__.4>
    2804:	mov    r9d,0x11
    280a:	lea    rax,[rbp-0x50]
    280e:	mov    rsi,r8
    2811:	mov    rdx,r9
    2814:	mov    r8d,0x0
    281a:	mov    ecx,0x1
    281f:	mov    rdi,rax
    2822:	call   1f72 <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    2827:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    282f:	mov    eax,DWORD PTR [rbp+0x10]
    2832:	cmp    eax,0x1
    2835:	jne    2861 <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    2837:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    283e:	mov    edx,DWORD PTR [rbp-0x64]
    2841:	mov    rsi,QWORD PTR [rbp-0x80]
    2845:	mov    rax,QWORD PTR [rbp-0x78]
    2849:	mov    ecx,edx
    284b:	mov    edx,0x2
    2850:	mov    rdi,rax
    2853:	call   29b3 <parse_json_children>
    2858:	mov    QWORD PTR [rbp-0x60],rax
    285c:	jmp    28eb <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2861:	mov    eax,DWORD PTR [rbp+0x10]
    2864:	cmp    eax,0x3
    2867:	jne    2890 <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    2869:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2870:	mov    edx,DWORD PTR [rbp-0x68]
    2873:	mov    rsi,QWORD PTR [rbp-0x80]
    2877:	mov    rax,QWORD PTR [rbp-0x78]
    287b:	mov    ecx,edx
    287d:	mov    edx,0x4
    2882:	mov    rdi,rax
    2885:	call   29b3 <parse_json_children>
    288a:	mov    QWORD PTR [rbp-0x60],rax
    288e:	jmp    28eb <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    2890:	mov    eax,DWORD PTR [rbp+0x10]
    2893:	mov    edi,eax
    2895:	call   2793 <json_token_type_is_value_type>
    289a:	test   eax,eax
    289c:	jne    28eb <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    289e:	mov    eax,DWORD PTR [rbp+0x10]
    28a1:	mov    eax,eax
    28a3:	lea    rdx,[rax*8+0x0]
    28ab:	lea    rax,[rip+0x382e]        # 60e0 <JSON_Token_Type_strings>
    28b2:	mov    rcx,QWORD PTR [rdx+rax*1]
    28b6:	lea    rdx,[rip+0x1c63]        # 4520 <_IO_stdin_used+0x520>
    28bd:	lea    rax,[rip+0x1bb5]        # 4479 <_IO_stdin_used+0x479>
    28c4:	push   QWORD PTR [rbp+0x20]
    28c7:	push   QWORD PTR [rbp+0x18]
    28ca:	mov    r8,rcx
    28cd:	mov    rcx,rdx
    28d0:	mov    edx,0x134
    28d5:	mov    rsi,rax
    28d8:	mov    edi,0x1
    28dd:	mov    eax,0x0
    28e2:	call   14a1 <log_message>
    28e7:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    28eb:	mov    rax,QWORD PTR [rbp-0x78]
    28ef:	mov    edx,0x8
    28f4:	mov    esi,0x30
    28f9:	mov    rdi,rax
    28fc:	call   17d3 <arena_alloc>
    2901:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    2905:	mov    rcx,QWORD PTR [rbp-0x58]
    2909:	mov    rax,QWORD PTR [rbp-0x90]
    2910:	mov    rdx,QWORD PTR [rbp-0x88]
    2917:	mov    QWORD PTR [rcx],rax
    291a:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    291e:	mov    rax,QWORD PTR [rbp-0x58]
    2922:	mov    rdx,QWORD PTR [rbp-0x60]
    2926:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    292a:	mov    rax,QWORD PTR [rbp-0x58]
    292e:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    2936:	mov    rcx,QWORD PTR [rbp-0x58]
    293a:	mov    rax,QWORD PTR [rbp+0x18]
    293e:	mov    rdx,QWORD PTR [rbp+0x20]
    2942:	mov    QWORD PTR [rcx+0x10],rax
    2946:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    294a:	sub    rsp,0x8
    294e:	sub    rsp,0x38
    2952:	mov    rax,rsp
    2955:	mov    rcx,QWORD PTR [rbp-0x50]
    2959:	mov    rbx,QWORD PTR [rbp-0x48]
    295d:	mov    QWORD PTR [rax],rcx
    2960:	mov    QWORD PTR [rax+0x8],rbx
    2964:	mov    rcx,QWORD PTR [rbp-0x40]
    2968:	mov    rbx,QWORD PTR [rbp-0x38]
    296c:	mov    QWORD PTR [rax+0x10],rcx
    2970:	mov    QWORD PTR [rax+0x18],rbx
    2974:	mov    rcx,QWORD PTR [rbp-0x30]
    2978:	mov    rbx,QWORD PTR [rbp-0x28]
    297c:	mov    QWORD PTR [rax+0x20],rcx
    2980:	mov    QWORD PTR [rax+0x28],rbx
    2984:	mov    rdx,QWORD PTR [rbp-0x20]
    2988:	mov    QWORD PTR [rax+0x30],rdx
    298c:	call   205c <__profile_end_pass>
    2991:	add    rsp,0x40

  return result;
    2995:	mov    rax,QWORD PTR [rbp-0x58]
}
    2999:	mov    rdx,QWORD PTR [rbp-0x18]
    299d:	sub    rdx,QWORD PTR fs:0x28
    29a6:	je     29ad <parse_json_object+0x1e1>
    29a8:	call   1060 <__stack_chk_fail@plt>
    29ad:	mov    rbx,QWORD PTR [rbp-0x8]
    29b1:	leave
    29b2:	ret

00000000000029b3 <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    29b3:	push   rbp
    29b4:	mov    rbp,rsp
    29b7:	push   rbx
    29b8:	sub    rsp,0x108
    29bf:	mov    QWORD PTR [rbp-0xd8],rdi
    29c6:	mov    QWORD PTR [rbp-0xe0],rsi
    29cd:	mov    DWORD PTR [rbp-0xe4],edx
    29d3:	mov    DWORD PTR [rbp-0xe8],ecx
    29d9:	mov    rax,QWORD PTR fs:0x28
    29e2:	mov    QWORD PTR [rbp-0x18],rax
    29e6:	xor    eax,eax
  profile_begin_func();
    29e8:	lea    r8,[rip+0x1e31]        # 4820 <__func__.3>
    29ef:	mov    r9d,0x13
    29f5:	lea    rax,[rbp-0x50]
    29f9:	mov    rsi,r8
    29fc:	mov    rdx,r9
    29ff:	mov    r8d,0x0
    2a05:	mov    ecx,0x2
    2a0a:	mov    rdi,rax
    2a0d:	call   1f72 <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2a12:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    2a1d:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2a28:	jmp    2d01 <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2a2d:	pxor   xmm0,xmm0
    2a31:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2a38:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2a40:	pxor   xmm0,xmm0
    2a44:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2a4b:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2a50:	cmp    DWORD PTR [rbp-0xe8],0x0
    2a57:	je     2b64 <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2a5d:	lea    rax,[rbp-0xb0]
    2a64:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a6b:	mov    rsi,rdx
    2a6e:	mov    rdi,rax
    2a71:	call   229a <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2a76:	mov    eax,DWORD PTR [rbp-0xb0]
    2a7c:	cmp    eax,0x7
    2a7f:	jne    2b00 <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2a81:	lea    rax,[rbp-0x70]
    2a85:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a8c:	mov    rsi,rdx
    2a8f:	mov    rdi,rax
    2a92:	call   229a <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2a97:	mov    eax,DWORD PTR [rbp-0x70]
    2a9a:	cmp    eax,0x6
    2a9d:	jne    2abd <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2a9f:	lea    rax,[rbp-0x90]
    2aa6:	mov    rdx,QWORD PTR [rbp-0xe0]
    2aad:	mov    rsi,rdx
    2ab0:	mov    rdi,rax
    2ab3:	call   229a <get_json_token>
    2ab8:	jmp    2ba4 <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2abd:	mov    rcx,QWORD PTR [rbp-0xa8]
    2ac4:	mov    rax,QWORD PTR [rbp-0xa0]
    2acb:	mov    esi,eax
    2acd:	lea    rdx,[rip+0x1a9c]        # 4570 <_IO_stdin_used+0x570>
    2ad4:	lea    rax,[rip+0x199e]        # 4479 <_IO_stdin_used+0x479>
    2adb:	mov    r9,rcx
    2ade:	mov    r8d,esi
    2ae1:	mov    rcx,rdx
    2ae4:	mov    edx,0x15f
    2ae9:	mov    rsi,rax
    2aec:	mov    edi,0x1
    2af1:	mov    eax,0x0
    2af6:	call   14a1 <log_message>
    2afb:	jmp    2ba4 <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2b00:	mov    rcx,QWORD PTR [rbp-0xa8]
    2b07:	mov    rax,QWORD PTR [rbp-0xa0]
    2b0e:	mov    edi,eax
    2b10:	mov    eax,DWORD PTR [rbp-0xb0]
    2b16:	mov    eax,eax
    2b18:	lea    rdx,[rax*8+0x0]
    2b20:	lea    rax,[rip+0x35b9]        # 60e0 <JSON_Token_Type_strings>
    2b27:	mov    rsi,QWORD PTR [rdx+rax*1]
    2b2b:	lea    rdx,[rip+0x1a5e]        # 4590 <_IO_stdin_used+0x590>
    2b32:	lea    rax,[rip+0x1940]        # 4479 <_IO_stdin_used+0x479>
    2b39:	sub    rsp,0x8
    2b3d:	push   rcx
    2b3e:	mov    r9d,edi
    2b41:	mov    r8,rsi
    2b44:	mov    rcx,rdx
    2b47:	mov    edx,0x164
    2b4c:	mov    rsi,rax
    2b4f:	mov    edi,0x1
    2b54:	mov    eax,0x0
    2b59:	call   14a1 <log_message>
    2b5e:	add    rsp,0x10
    2b62:	jmp    2ba4 <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2b64:	lea    rax,[rbp-0x110]
    2b6b:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b72:	mov    rsi,rdx
    2b75:	mov    rdi,rax
    2b78:	call   229a <get_json_token>
    2b7d:	mov    rax,QWORD PTR [rbp-0x110]
    2b84:	mov    rdx,QWORD PTR [rbp-0x108]
    2b8b:	mov    QWORD PTR [rbp-0x90],rax
    2b92:	mov    QWORD PTR [rbp-0x88],rdx
    2b99:	mov    rax,QWORD PTR [rbp-0x100]
    2ba0:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2ba4:	mov    eax,DWORD PTR [rbp-0x90]
    2baa:	cmp    DWORD PTR [rbp-0xe4],eax
    2bb0:	je     2d1a <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2bb6:	mov    rax,QWORD PTR [rbp-0xa8]
    2bbd:	mov    rdx,QWORD PTR [rbp-0xa0]
    2bc4:	mov    r8,QWORD PTR [rbp-0xe0]
    2bcb:	mov    rdi,QWORD PTR [rbp-0xd8]
    2bd2:	sub    rsp,0x8
    2bd6:	sub    rsp,0x18
    2bda:	mov    rsi,rsp
    2bdd:	mov    rcx,QWORD PTR [rbp-0x90]
    2be4:	mov    rbx,QWORD PTR [rbp-0x88]
    2beb:	mov    QWORD PTR [rsi],rcx
    2bee:	mov    QWORD PTR [rsi+0x8],rbx
    2bf2:	mov    rcx,QWORD PTR [rbp-0x80]
    2bf6:	mov    QWORD PTR [rsi+0x10],rcx
    2bfa:	mov    rcx,rdx
    2bfd:	mov    rdx,rax
    2c00:	mov    rsi,r8
    2c03:	call   27cc <parse_json_object>
    2c08:	add    rsp,0x20
    2c0c:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2c13:	cmp    QWORD PTR [rbp-0xb8],0x0
    2c1b:	je     2c65 <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2c1d:	cmp    QWORD PTR [rbp-0xc8],0x0
    2c25:	jne    2c45 <parse_json_children+0x292>
      {
        first_child        = object;
    2c27:	mov    rax,QWORD PTR [rbp-0xb8]
    2c2e:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2c35:	mov    rax,QWORD PTR [rbp-0xb8]
    2c3c:	mov    QWORD PTR [rbp-0xc0],rax
    2c43:	jmp    2c65 <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2c45:	mov    rax,QWORD PTR [rbp-0xc0]
    2c4c:	mov    rdx,QWORD PTR [rbp-0xb8]
    2c53:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2c57:	mov    rax,QWORD PTR [rbp-0xb8]
    2c5e:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2c65:	lea    rax,[rbp-0x70]
    2c69:	mov    rdx,QWORD PTR [rbp-0xe0]
    2c70:	mov    rsi,rdx
    2c73:	mov    rdi,rax
    2c76:	call   229a <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2c7b:	mov    eax,DWORD PTR [rbp-0x70]
    2c7e:	cmp    DWORD PTR [rbp-0xe4],eax
    2c84:	je     2d1d <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2c8a:	mov    eax,DWORD PTR [rbp-0x70]
    2c8d:	cmp    eax,0x5
    2c90:	je     2d01 <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2c92:	mov    r8,QWORD PTR [rbp-0x68]
    2c96:	mov    rax,QWORD PTR [rbp-0x60]
    2c9a:	mov    r9d,eax
    2c9d:	mov    eax,DWORD PTR [rbp-0x70]
    2ca0:	mov    eax,eax
    2ca2:	lea    rdx,[rax*8+0x0]
    2caa:	lea    rax,[rip+0x342f]        # 60e0 <JSON_Token_Type_strings>
    2cb1:	mov    r10,QWORD PTR [rdx+rax*1]
    2cb5:	lea    rdi,[rip+0x18fc]        # 45b8 <_IO_stdin_used+0x5b8>
    2cbc:	lea    rsi,[rip+0x17b6]        # 4479 <_IO_stdin_used+0x479>
    2cc3:	sub    rsp,0x18
    2cc7:	mov    rcx,rsp
    2cca:	mov    rax,QWORD PTR [rbp-0x70]
    2cce:	mov    rdx,QWORD PTR [rbp-0x68]
    2cd2:	mov    QWORD PTR [rcx],rax
    2cd5:	mov    QWORD PTR [rcx+0x8],rdx
    2cd9:	mov    rax,QWORD PTR [rbp-0x60]
    2cdd:	mov    QWORD PTR [rcx+0x10],rax
    2ce1:	push   r8
    2ce3:	mov    r8,r10
    2ce6:	mov    rcx,rdi
    2ce9:	mov    edx,0x18b
    2cee:	mov    edi,0x1
    2cf3:	mov    eax,0x0
    2cf8:	call   14a1 <log_message>
    2cfd:	add    rsp,0x20
  while (parser_incomplete(parser))
    2d01:	mov    rax,QWORD PTR [rbp-0xe0]
    2d08:	mov    rdi,rax
    2d0b:	call   21ef <parser_incomplete>
    2d10:	test   al,al
    2d12:	jne    2a2d <parse_json_children+0x7a>
    2d18:	jmp    2d1e <parse_json_children+0x36b>
      break;
    2d1a:	nop
    2d1b:	jmp    2d1e <parse_json_children+0x36b>
      break;
    2d1d:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2d1e:	sub    rsp,0x8
    2d22:	sub    rsp,0x38
    2d26:	mov    rax,rsp
    2d29:	mov    rcx,QWORD PTR [rbp-0x50]
    2d2d:	mov    rbx,QWORD PTR [rbp-0x48]
    2d31:	mov    QWORD PTR [rax],rcx
    2d34:	mov    QWORD PTR [rax+0x8],rbx
    2d38:	mov    rcx,QWORD PTR [rbp-0x40]
    2d3c:	mov    rbx,QWORD PTR [rbp-0x38]
    2d40:	mov    QWORD PTR [rax+0x10],rcx
    2d44:	mov    QWORD PTR [rax+0x18],rbx
    2d48:	mov    rcx,QWORD PTR [rbp-0x30]
    2d4c:	mov    rbx,QWORD PTR [rbp-0x28]
    2d50:	mov    QWORD PTR [rax+0x20],rcx
    2d54:	mov    QWORD PTR [rax+0x28],rbx
    2d58:	mov    rdx,QWORD PTR [rbp-0x20]
    2d5c:	mov    QWORD PTR [rax+0x30],rdx
    2d60:	call   205c <__profile_end_pass>
    2d65:	add    rsp,0x40

  return first_child;
    2d69:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2d70:	mov    rdx,QWORD PTR [rbp-0x18]
    2d74:	sub    rdx,QWORD PTR fs:0x28
    2d7d:	je     2d84 <parse_json_children+0x3d1>
    2d7f:	call   1060 <__stack_chk_fail@plt>
    2d84:	mov    rbx,QWORD PTR [rbp-0x8]
    2d88:	leave
    2d89:	ret

0000000000002d8a <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2d8a:	push   rbp
    2d8b:	mov    rbp,rsp
    2d8e:	push   rbx
    2d8f:	sub    rsp,0xb8
    2d96:	mov    QWORD PTR [rbp-0xa8],rdi
    2d9d:	mov    rax,rsi
    2da0:	mov    rsi,rdx
    2da3:	mov    rax,rax
    2da6:	mov    edx,0x0
    2dab:	mov    rdx,rsi
    2dae:	mov    QWORD PTR [rbp-0xc0],rax
    2db5:	mov    QWORD PTR [rbp-0xb8],rdx
    2dbc:	mov    rax,QWORD PTR fs:0x28
    2dc5:	mov    QWORD PTR [rbp-0x18],rax
    2dc9:	xor    eax,eax
  profile_begin_func();
    2dcb:	lea    rcx,[rip+0x1a66]        # 4838 <__func__.2>
    2dd2:	mov    ebx,0xa
    2dd7:	lea    rax,[rbp-0x50]
    2ddb:	mov    rsi,rcx
    2dde:	mov    rdx,rbx
    2de1:	mov    r8d,0x0
    2de7:	mov    ecx,0x3
    2dec:	mov    rdi,rax
    2def:	call   1f72 <__profile_begin_pass>

  JSON_Parser parser =
    2df4:	mov    rax,QWORD PTR [rbp-0xc0]
    2dfb:	mov    rdx,QWORD PTR [rbp-0xb8]
    2e02:	mov    QWORD PTR [rbp-0x90],rax
    2e09:	mov    QWORD PTR [rbp-0x88],rdx
    2e10:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2e18:	lea    rax,[rbp-0x70]
    2e1c:	lea    rdx,[rbp-0x90]
    2e23:	mov    rsi,rdx
    2e26:	mov    rdi,rax
    2e29:	call   229a <get_json_token>
    2e2e:	mov    ecx,0x0
    2e33:	mov    ebx,0x0
    2e38:	lea    r8,[rbp-0x90]
    2e3f:	mov    rdi,QWORD PTR [rbp-0xa8]
    2e46:	sub    rsp,0x8
    2e4a:	sub    rsp,0x18
    2e4e:	mov    rsi,rsp
    2e51:	mov    rax,QWORD PTR [rbp-0x70]
    2e55:	mov    rdx,QWORD PTR [rbp-0x68]
    2e59:	mov    QWORD PTR [rsi],rax
    2e5c:	mov    QWORD PTR [rsi+0x8],rdx
    2e60:	mov    rax,QWORD PTR [rbp-0x60]
    2e64:	mov    QWORD PTR [rsi+0x10],rax
    2e68:	mov    rdx,rcx
    2e6b:	mov    rcx,rbx
    2e6e:	mov    rsi,r8
    2e71:	call   27cc <parse_json_object>
    2e76:	add    rsp,0x20
    2e7a:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2e81:	sub    rsp,0x8
    2e85:	sub    rsp,0x38
    2e89:	mov    rax,rsp
    2e8c:	mov    rcx,QWORD PTR [rbp-0x50]
    2e90:	mov    rbx,QWORD PTR [rbp-0x48]
    2e94:	mov    QWORD PTR [rax],rcx
    2e97:	mov    QWORD PTR [rax+0x8],rbx
    2e9b:	mov    rcx,QWORD PTR [rbp-0x40]
    2e9f:	mov    rbx,QWORD PTR [rbp-0x38]
    2ea3:	mov    QWORD PTR [rax+0x10],rcx
    2ea7:	mov    QWORD PTR [rax+0x18],rbx
    2eab:	mov    rcx,QWORD PTR [rbp-0x30]
    2eaf:	mov    rbx,QWORD PTR [rbp-0x28]
    2eb3:	mov    QWORD PTR [rax+0x20],rcx
    2eb7:	mov    QWORD PTR [rax+0x28],rbx
    2ebb:	mov    rdx,QWORD PTR [rbp-0x20]
    2ebf:	mov    QWORD PTR [rax+0x30],rdx
    2ec3:	call   205c <__profile_end_pass>
    2ec8:	add    rsp,0x40

  return outer;
    2ecc:	mov    rax,QWORD PTR [rbp-0x98]
}
    2ed3:	mov    rdx,QWORD PTR [rbp-0x18]
    2ed7:	sub    rdx,QWORD PTR fs:0x28
    2ee0:	je     2ee7 <parse_json+0x15d>
    2ee2:	call   1060 <__stack_chk_fail@plt>
    2ee7:	mov    rbx,QWORD PTR [rbp-0x8]
    2eeb:	leave
    2eec:	ret

0000000000002eed <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2eed:	push   rbp
    2eee:	mov    rbp,rsp
    2ef1:	push   rbx
    2ef2:	sub    rsp,0x78
    2ef6:	mov    QWORD PTR [rbp-0x68],rdi
    2efa:	mov    rax,rsi
    2efd:	mov    rsi,rdx
    2f00:	mov    rax,rax
    2f03:	mov    edx,0x0
    2f08:	mov    rdx,rsi
    2f0b:	mov    QWORD PTR [rbp-0x80],rax
    2f0f:	mov    QWORD PTR [rbp-0x78],rdx
    2f13:	mov    rax,QWORD PTR fs:0x28
    2f1c:	mov    QWORD PTR [rbp-0x18],rax
    2f20:	xor    eax,eax
  profile_begin_func();
    2f22:	lea    rcx,[rip+0x1927]        # 4850 <__func__.1>
    2f29:	mov    ebx,0x12
    2f2e:	lea    rax,[rbp-0x50]
    2f32:	mov    rsi,rcx
    2f35:	mov    rdx,rbx
    2f38:	mov    r8d,0x0
    2f3e:	mov    ecx,0x4
    2f43:	mov    rdi,rax
    2f46:	call   1f72 <__profile_begin_pass>

  JSON_Object *result = NULL;
    2f4b:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2f53:	cmp    QWORD PTR [rbp-0x68],0x0
    2f58:	je     2fa7 <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f5a:	mov    rax,QWORD PTR [rbp-0x68]
    2f5e:	mov    rax,QWORD PTR [rax+0x20]
    2f62:	mov    QWORD PTR [rbp-0x58],rax
    2f66:	jmp    2fa0 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2f68:	mov    rax,QWORD PTR [rbp-0x58]
    2f6c:	mov    rdx,QWORD PTR [rax+0x8]
    2f70:	mov    rax,QWORD PTR [rax]
    2f73:	mov    rdi,QWORD PTR [rbp-0x80]
    2f77:	mov    rsi,QWORD PTR [rbp-0x78]
    2f7b:	mov    rcx,rdx
    2f7e:	mov    rdx,rax
    2f81:	call   143f <strings_equal>
    2f86:	test   al,al
    2f88:	je     2f94 <lookup_json_object+0xa7>
      {
        result = cursor;
    2f8a:	mov    rax,QWORD PTR [rbp-0x58]
    2f8e:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2f92:	jmp    2fa7 <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f94:	mov    rax,QWORD PTR [rbp-0x58]
    2f98:	mov    rax,QWORD PTR [rax+0x28]
    2f9c:	mov    QWORD PTR [rbp-0x58],rax
    2fa0:	cmp    QWORD PTR [rbp-0x58],0x0
    2fa5:	jne    2f68 <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2fa7:	sub    rsp,0x8
    2fab:	sub    rsp,0x38
    2faf:	mov    rax,rsp
    2fb2:	mov    rcx,QWORD PTR [rbp-0x50]
    2fb6:	mov    rbx,QWORD PTR [rbp-0x48]
    2fba:	mov    QWORD PTR [rax],rcx
    2fbd:	mov    QWORD PTR [rax+0x8],rbx
    2fc1:	mov    rcx,QWORD PTR [rbp-0x40]
    2fc5:	mov    rbx,QWORD PTR [rbp-0x38]
    2fc9:	mov    QWORD PTR [rax+0x10],rcx
    2fcd:	mov    QWORD PTR [rax+0x18],rbx
    2fd1:	mov    rcx,QWORD PTR [rbp-0x30]
    2fd5:	mov    rbx,QWORD PTR [rbp-0x28]
    2fd9:	mov    QWORD PTR [rax+0x20],rcx
    2fdd:	mov    QWORD PTR [rax+0x28],rbx
    2fe1:	mov    rdx,QWORD PTR [rbp-0x20]
    2fe5:	mov    QWORD PTR [rax+0x30],rdx
    2fe9:	call   205c <__profile_end_pass>
    2fee:	add    rsp,0x40

  return result;
    2ff2:	mov    rax,QWORD PTR [rbp-0x60]
}
    2ff6:	mov    rdx,QWORD PTR [rbp-0x18]
    2ffa:	sub    rdx,QWORD PTR fs:0x28
    3003:	je     300a <lookup_json_object+0x11d>
    3005:	call   1060 <__stack_chk_fail@plt>
    300a:	mov    rbx,QWORD PTR [rbp-0x8]
    300e:	leave
    300f:	ret

0000000000003010 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    3010:	push   rbp
    3011:	mov    rbp,rsp
    3014:	sub    rsp,0x50
    3018:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    301c:	cmp    QWORD PTR [rbp-0x48],0x0
    3021:	jne    3048 <json_object_to_f64+0x38>
    3023:	lea    rdx,[rip+0x1846]        # 4870 <__PRETTY_FUNCTION__.0>
    302a:	lea    rsi,[rip+0x1448]        # 4479 <_IO_stdin_used+0x479>
    3031:	lea    rax,[rip+0x15c0]        # 45f8 <_IO_stdin_used+0x5f8>
    3038:	mov    rcx,rdx
    303b:	mov    edx,0x1c2
    3040:	mov    rdi,rax
    3043:	call   1090 <__assert_fail@plt>

  String val = object->value;
    3048:	mov    rax,QWORD PTR [rbp-0x48]
    304c:	mov    rdx,QWORD PTR [rax+0x18]
    3050:	mov    rax,QWORD PTR [rax+0x10]
    3054:	mov    QWORD PTR [rbp-0x10],rax
    3058:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    305c:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    3064:	movsd  xmm0,QWORD PTR [rip+0x183c]        # 48a8 <__PRETTY_FUNCTION__.0+0x38>
    306c:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    3071:	mov    rax,QWORD PTR [rbp-0x8]
    3075:	cmp    QWORD PTR [rbp-0x30],rax
    3079:	jae    309f <json_object_to_f64+0x8f>
    307b:	mov    rdx,QWORD PTR [rbp-0x10]
    307f:	mov    rax,QWORD PTR [rbp-0x30]
    3083:	add    rax,rdx
    3086:	movzx  eax,BYTE PTR [rax]
    3089:	cmp    al,0x2d
    308b:	jne    309f <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    308d:	movsd  xmm0,QWORD PTR [rip+0x181b]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    3095:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    309a:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    309f:	pxor   xmm0,xmm0
    30a3:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    30a8:	jmp    30ef <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    30aa:	mov    rdx,QWORD PTR [rbp-0x10]
    30ae:	mov    rax,QWORD PTR [rbp-0x30]
    30b2:	add    rax,rdx
    30b5:	movzx  eax,BYTE PTR [rax]
    30b8:	sub    eax,0x30
    30bb:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    30be:	cmp    BYTE PTR [rbp-0x32],0x9
    30c2:	ja     30fb <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    30c4:	movsd  xmm1,QWORD PTR [rbp-0x20]
    30c9:	movsd  xmm0,QWORD PTR [rip+0x17e7]        # 48b8 <__PRETTY_FUNCTION__.0+0x48>
    30d1:	mulsd  xmm1,xmm0
    30d5:	movzx  eax,BYTE PTR [rbp-0x32]
    30d9:	pxor   xmm0,xmm0
    30dd:	cvtsi2sd xmm0,eax
    30e1:	addsd  xmm0,xmm1
    30e5:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    30ea:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    30ef:	mov    rax,QWORD PTR [rbp-0x8]
    30f3:	cmp    QWORD PTR [rbp-0x30],rax
    30f7:	jb     30aa <json_object_to_f64+0x9a>
    30f9:	jmp    30fc <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    30fb:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    30fc:	mov    rax,QWORD PTR [rbp-0x8]
    3100:	cmp    QWORD PTR [rbp-0x30],rax
    3104:	jae    3191 <json_object_to_f64+0x181>
    310a:	mov    rdx,QWORD PTR [rbp-0x10]
    310e:	mov    rax,QWORD PTR [rbp-0x30]
    3112:	add    rax,rdx
    3115:	movzx  eax,BYTE PTR [rax]
    3118:	cmp    al,0x2e
    311a:	jne    3191 <json_object_to_f64+0x181>
  {
    at += 1;
    311c:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    3121:	movsd  xmm0,QWORD PTR [rip+0x1797]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    3129:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    312e:	jmp    3184 <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3130:	mov    rdx,QWORD PTR [rbp-0x10]
    3134:	mov    rax,QWORD PTR [rbp-0x30]
    3138:	add    rax,rdx
    313b:	movzx  eax,BYTE PTR [rax]
    313e:	sub    eax,0x30
    3141:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    3144:	cmp    BYTE PTR [rbp-0x31],0x9
    3148:	ja     3190 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    314a:	movzx  eax,BYTE PTR [rbp-0x31]
    314e:	pxor   xmm0,xmm0
    3152:	cvtsi2sd xmm0,eax
    3156:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    315b:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3160:	addsd  xmm0,xmm1
    3164:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    3169:	movsd  xmm1,QWORD PTR [rbp-0x18]
    316e:	movsd  xmm0,QWORD PTR [rip+0x174a]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    3176:	mulsd  xmm0,xmm1
    317a:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    317f:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    3184:	mov    rax,QWORD PTR [rbp-0x8]
    3188:	cmp    QWORD PTR [rbp-0x30],rax
    318c:	jb     3130 <json_object_to_f64+0x120>
    318e:	jmp    3191 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    3190:	nop
      }
    }
  }

  return sign * result;
    3191:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3196:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    319b:	leave
    319c:	ret

000000000000319d <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    319d:	push   rbp
    319e:	mov    rbp,rsp
    31a1:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    31a6:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31ab:	movsd  xmm1,QWORD PTR [rip+0x1715]        # 48c8 <__PRETTY_FUNCTION__.0+0x58>
    31b3:	divsd  xmm0,xmm1
}
    31b7:	pop    rbp
    31b8:	ret

00000000000031b9 <square>:

static
f64 square(f64 x)
{
    31b9:	push   rbp
    31ba:	mov    rbp,rsp
    31bd:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    31c2:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31c7:	mulsd  xmm0,xmm0
}
    31cb:	pop    rbp
    31cc:	ret

00000000000031cd <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    31cd:	push   rbp
    31ce:	mov    rbp,rsp
    31d1:	sub    rsp,0x90
    31d8:	movsd  QWORD PTR [rbp-0x58],xmm0
    31dd:	movsd  QWORD PTR [rbp-0x60],xmm1
    31e2:	movsd  QWORD PTR [rbp-0x68],xmm2
    31e7:	movsd  QWORD PTR [rbp-0x70],xmm3
    31ec:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    31f1:	movsd  xmm0,QWORD PTR [rbp-0x60]
    31f6:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    31fb:	movsd  xmm0,QWORD PTR [rbp-0x70]
    3200:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    3205:	movsd  xmm0,QWORD PTR [rbp-0x58]
    320a:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    320f:	movsd  xmm0,QWORD PTR [rbp-0x68]
    3214:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    3219:	movsd  xmm0,QWORD PTR [rbp-0x40]
    321e:	subsd  xmm0,QWORD PTR [rbp-0x48]
    3223:	movq   rax,xmm0
    3228:	movq   xmm0,rax
    322d:	call   319d <to_radians>
    3232:	movq   rax,xmm0
    3237:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    323b:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3240:	subsd  xmm0,QWORD PTR [rbp-0x38]
    3245:	movq   rax,xmm0
    324a:	movq   xmm0,rax
    324f:	call   319d <to_radians>
    3254:	movq   rax,xmm0
    3259:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    325d:	mov    rax,QWORD PTR [rbp-0x48]
    3261:	movq   xmm0,rax
    3266:	call   319d <to_radians>
    326b:	movq   rax,xmm0
    3270:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    3274:	mov    rax,QWORD PTR [rbp-0x40]
    3278:	movq   xmm0,rax
    327d:	call   319d <to_radians>
    3282:	movq   rax,xmm0
    3287:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    328b:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3290:	movsd  xmm1,QWORD PTR [rip+0x1638]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    3298:	divsd  xmm0,xmm1
    329c:	movq   rax,xmm0
    32a1:	movq   xmm0,rax
    32a6:	call   1130 <sin@plt>
    32ab:	movq   rax,xmm0
    32b0:	movq   xmm0,rax
    32b5:	call   31b9 <square>
    32ba:	movsd  QWORD PTR [rbp-0x80],xmm0
    32bf:	mov    rax,QWORD PTR [rbp-0x48]
    32c3:	movq   xmm0,rax
    32c8:	call   10b0 <cos@plt>
    32cd:	movsd  QWORD PTR [rbp-0x88],xmm0
    32d5:	mov    rax,QWORD PTR [rbp-0x40]
    32d9:	movq   xmm0,rax
    32de:	call   10b0 <cos@plt>
    32e3:	movapd xmm5,xmm0
    32e7:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    32ef:	movsd  QWORD PTR [rbp-0x88],xmm5
    32f7:	movsd  xmm0,QWORD PTR [rbp-0x20]
    32fc:	movsd  xmm1,QWORD PTR [rip+0x15cc]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    3304:	movapd xmm6,xmm0
    3308:	divsd  xmm6,xmm1
    330c:	movq   rax,xmm6
    3311:	movq   xmm0,rax
    3316:	call   1130 <sin@plt>
    331b:	movq   rax,xmm0
    3320:	movq   xmm0,rax
    3325:	call   31b9 <square>
    332a:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    3332:	addsd  xmm0,QWORD PTR [rbp-0x80]
    3337:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    333c:	mov    rax,QWORD PTR [rbp-0x18]
    3340:	movq   xmm0,rax
    3345:	call   1160 <sqrt@plt>
    334a:	movq   rax,xmm0
    334f:	movq   xmm0,rax
    3354:	call   1140 <asin@plt>
    3359:	addsd  xmm0,xmm0
    335d:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    3362:	movsd  xmm0,QWORD PTR [rbp-0x78]
    3367:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    336c:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3371:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    3376:	leave
    3377:	ret

0000000000003378 <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    3378:	push   rbp
    3379:	mov    rbp,rsp
    337c:	movsd  QWORD PTR [rbp-0x18],xmm0
    3381:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    3386:	movsd  xmm0,QWORD PTR [rip+0x154a]        # 48d8 <__PRETTY_FUNCTION__.0+0x68>
    338e:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    3393:	movsd  xmm0,QWORD PTR [rbp-0x18]
    3398:	movq   xmm1,QWORD PTR [rip+0x1540]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    33a0:	andpd  xmm0,xmm1
    33a4:	movsd  xmm1,QWORD PTR [rbp-0x20]
    33a9:	movq   xmm2,QWORD PTR [rip+0x152f]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    33b1:	andpd  xmm2,xmm1
    33b5:	movapd xmm1,xmm0
    33b9:	subsd  xmm1,xmm2
    33bd:	movsd  xmm0,QWORD PTR [rbp-0x8]
    33c2:	comisd xmm0,xmm1
    33c6:	setae  al
    33c9:	movzx  eax,al
}
    33cc:	pop    rbp
    33cd:	ret

00000000000033ce <main>:

int main(int args_count, char **args)
{
    33ce:	push   rbp
    33cf:	mov    rbp,rsp
    33d2:	push   r15
    33d4:	push   r14
    33d6:	push   r13
    33d8:	push   r12
    33da:	push   rbx
    33db:	sub    rsp,0x268
    33e2:	mov    DWORD PTR [rbp-0x1f4],edi
    33e8:	mov    QWORD PTR [rbp-0x200],rsi
    33ef:	mov    rax,QWORD PTR fs:0x28
    33f8:	mov    QWORD PTR [rbp-0x38],rax
    33fc:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    33fe:	cmp    DWORD PTR [rbp-0x1f4],0x3
    3405:	je     3432 <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    3407:	mov    rax,QWORD PTR [rbp-0x200]
    340e:	mov    rax,QWORD PTR [rax]
    3411:	lea    rdx,[rip+0x1218]        # 4630 <_IO_stdin_used+0x630>
    3418:	mov    rsi,rax
    341b:	mov    rdi,rdx
    341e:	mov    eax,0x0
    3423:	call   1070 <printf@plt>
    return 1;
    3428:	mov    eax,0x1
    342d:	jmp    3d68 <main+0x99a>
  }

  begin_profiling();
    3432:	call   1b3d <begin_profiling>

  Arena arena = {0};
    3437:	pxor   xmm0,xmm0
    343b:	movaps XMMWORD PTR [rbp-0x150],xmm0
    3442:	movaps XMMWORD PTR [rbp-0x140],xmm0
  arena = arena_make(GB(4));
    3449:	lea    rdx,[rbp-0x220]
    3450:	movabs rax,0x100000000
    345a:	mov    rsi,rax
    345d:	mov    rdi,rdx
    3460:	call   1632 <arena_make>
    3465:	mov    rax,QWORD PTR [rbp-0x220]
    346c:	mov    rdx,QWORD PTR [rbp-0x218]
    3473:	mov    QWORD PTR [rbp-0x150],rax
    347a:	mov    QWORD PTR [rbp-0x148],rdx
    3481:	mov    rax,QWORD PTR [rbp-0x210]
    3488:	mov    rdx,QWORD PTR [rbp-0x208]
    348f:	mov    QWORD PTR [rbp-0x140],rax
    3496:	mov    QWORD PTR [rbp-0x138],rdx

  String source = {0};
    349d:	mov    QWORD PTR [rbp-0x160],0x0
    34a8:	mov    QWORD PTR [rbp-0x158],0x0
  printf("%lu", file_size(args[1]));
    34b3:	mov    rax,QWORD PTR [rbp-0x200]
    34ba:	add    rax,0x8
    34be:	mov    rax,QWORD PTR [rax]
    34c1:	mov    rdi,rax
    34c4:	call   1303 <file_size>
    34c9:	mov    rdx,rax
    34cc:	lea    rax,[rip+0x1189]        # 465c <_IO_stdin_used+0x65c>
    34d3:	mov    rsi,rdx
    34d6:	mov    rdi,rax
    34d9:	mov    eax,0x0
    34de:	call   1070 <printf@plt>
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    34e3:	mov    rax,QWORD PTR [rbp-0x200]
    34ea:	add    rax,0x8
    34ee:	mov    rax,QWORD PTR [rax]
    34f1:	mov    rdi,rax
    34f4:	call   1303 <file_size>
    34f9:	mov    rcx,rax
    34fc:	lea    r12,[rip+0x115d]        # 4660 <_IO_stdin_used+0x660>
    3503:	mov    r13d,0x4
    3509:	lea    rdi,[rbp-0x130]
    3510:	mov    rdx,r12
    3513:	mov    rax,r13
    3516:	mov    r8,rcx
    3519:	mov    ecx,0x5
    351e:	mov    rsi,rdx
    3521:	mov    rdx,rax
    3524:	call   1f72 <__profile_begin_pass>
    3529:	mov    QWORD PTR [rbp-0x1e0],0x0
    3534:	jmp    35cf <main+0x201>
  {
    source = read_file_to_arena(&arena, args[1]);
    3539:	mov    rax,QWORD PTR [rbp-0x200]
    3540:	add    rax,0x8
    3544:	mov    rdx,QWORD PTR [rax]
    3547:	lea    rax,[rbp-0x150]
    354e:	mov    rsi,rdx
    3551:	mov    rdi,rax
    3554:	call   1357 <read_file_to_arena>
    3559:	mov    QWORD PTR [rbp-0x160],rax
    3560:	mov    QWORD PTR [rbp-0x158],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    3567:	add    QWORD PTR [rbp-0x1e0],0x1
    356f:	sub    rsp,0x8
    3573:	sub    rsp,0x38
    3577:	mov    rcx,rsp
    357a:	mov    rax,QWORD PTR [rbp-0x130]
    3581:	mov    rdx,QWORD PTR [rbp-0x128]
    3588:	mov    QWORD PTR [rcx],rax
    358b:	mov    QWORD PTR [rcx+0x8],rdx
    358f:	mov    rax,QWORD PTR [rbp-0x120]
    3596:	mov    rdx,QWORD PTR [rbp-0x118]
    359d:	mov    QWORD PTR [rcx+0x10],rax
    35a1:	mov    QWORD PTR [rcx+0x18],rdx
    35a5:	mov    rax,QWORD PTR [rbp-0x110]
    35ac:	mov    rdx,QWORD PTR [rbp-0x108]
    35b3:	mov    QWORD PTR [rcx+0x20],rax
    35b7:	mov    QWORD PTR [rcx+0x28],rdx
    35bb:	mov    rax,QWORD PTR [rbp-0x100]
    35c2:	mov    QWORD PTR [rcx+0x30],rax
    35c6:	call   205c <__profile_end_pass>
    35cb:	add    rsp,0x40
    35cf:	cmp    QWORD PTR [rbp-0x1e0],0x0
    35d7:	je     3539 <main+0x16b>
  }

  usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    35dd:	mov    QWORD PTR [rbp-0x1a8],0x18
  usize max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    35e8:	mov    rax,QWORD PTR [rbp-0x158]
    35ef:	mov    edx,0x0
    35f4:	div    QWORD PTR [rbp-0x1a8]
    35fb:	mov    QWORD PTR [rbp-0x1a0],rax
  Haversine_Pair * pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    3602:	mov    rax,QWORD PTR [rbp-0x1a0]
    3609:	shl    rax,0x5
    360d:	mov    rcx,rax
    3610:	lea    rax,[rbp-0x150]
    3617:	mov    edx,0x8
    361c:	mov    rsi,rcx
    361f:	mov    rdi,rax
    3622:	call   17d3 <arena_alloc>
    3627:	mov    QWORD PTR [rbp-0x198],rax
  i32 pair_count = 0;
    362e:	mov    DWORD PTR [rbp-0x1e8],0x0

  JSON_Object *root = NULL;
    3638:	mov    QWORD PTR [rbp-0x190],0x0
  root = parse_json(&arena, source);
    3643:	mov    rcx,QWORD PTR [rbp-0x160]
    364a:	mov    rdx,QWORD PTR [rbp-0x158]
    3651:	lea    rax,[rbp-0x150]
    3658:	mov    rsi,rcx
    365b:	mov    rdi,rax
    365e:	call   2d8a <parse_json>
    3663:	mov    QWORD PTR [rbp-0x190],rax

  f64 haversine_sum = 0.0;
    366a:	pxor   xmm0,xmm0
    366e:	movsd  QWORD PTR [rbp-0x188],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    3676:	lea    r14,[rip+0xfe8]        # 4665 <_IO_stdin_used+0x665>
    367d:	mov    r15d,0x5
    3683:	mov    rcx,r14
    3686:	mov    rdx,r15
    3689:	mov    rax,QWORD PTR [rbp-0x190]
    3690:	mov    rsi,rcx
    3693:	mov    rdi,rax
    3696:	call   2eed <lookup_json_object>
    369b:	mov    QWORD PTR [rbp-0x180],rax
  if (pairs)
    36a2:	cmp    QWORD PTR [rbp-0x198],0x0
    36aa:	je     386f <main+0x4a1>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    36b0:	mov    rax,QWORD PTR [rbp-0x180]
    36b7:	mov    rax,QWORD PTR [rax+0x20]
    36bb:	mov    QWORD PTR [rbp-0x1d8],rax
    36c2:	jmp    3850 <main+0x482>
    {
      Haversine_Pair pair =
      {
        .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    36c7:	lea    rax,[rip+0xf9d]        # 466b <_IO_stdin_used+0x66b>
    36ce:	mov    QWORD PTR [rbp-0x260],rax
    36d5:	mov    QWORD PTR [rbp-0x258],0x2
    36e0:	mov    rbx,QWORD PTR [rbp-0x260]
    36e7:	mov    rsi,QWORD PTR [rbp-0x258]
    36ee:	mov    rax,rbx
    36f1:	mov    rdx,rsi
    36f4:	mov    rcx,QWORD PTR [rbp-0x1d8]
    36fb:	mov    rsi,rax
    36fe:	mov    rdi,rcx
    3701:	call   2eed <lookup_json_object>
    3706:	mov    rdi,rax
    3709:	call   3010 <json_object_to_f64>
    370e:	movq   rax,xmm0
      Haversine_Pair pair =
    3713:	mov    QWORD PTR [rbp-0x70],rax
        .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    3717:	lea    rax,[rip+0xf50]        # 466e <_IO_stdin_used+0x66e>
    371e:	mov    QWORD PTR [rbp-0x270],rax
    3725:	mov    QWORD PTR [rbp-0x268],0x2
    3730:	mov    rax,QWORD PTR [rbp-0x270]
    3737:	mov    rdx,QWORD PTR [rbp-0x268]
    373e:	mov    rcx,rax
    3741:	mov    rax,QWORD PTR [rbp-0x1d8]
    3748:	mov    rsi,rcx
    374b:	mov    rdi,rax
    374e:	call   2eed <lookup_json_object>
    3753:	mov    rdi,rax
    3756:	call   3010 <json_object_to_f64>
    375b:	movq   rax,xmm0
      Haversine_Pair pair =
    3760:	mov    QWORD PTR [rbp-0x68],rax
        .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    3764:	lea    rax,[rip+0xf06]        # 4671 <_IO_stdin_used+0x671>
    376b:	mov    QWORD PTR [rbp-0x280],rax
    3772:	mov    QWORD PTR [rbp-0x278],0x2
    377d:	mov    rax,QWORD PTR [rbp-0x280]
    3784:	mov    rdx,QWORD PTR [rbp-0x278]
    378b:	mov    rcx,rax
    378e:	mov    rax,QWORD PTR [rbp-0x1d8]
    3795:	mov    rsi,rcx
    3798:	mov    rdi,rax
    379b:	call   2eed <lookup_json_object>
    37a0:	mov    rdi,rax
    37a3:	call   3010 <json_object_to_f64>
    37a8:	movq   rax,xmm0
      Haversine_Pair pair =
    37ad:	mov    QWORD PTR [rbp-0x60],rax
        .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    37b1:	lea    rax,[rip+0xebc]        # 4674 <_IO_stdin_used+0x674>
    37b8:	mov    QWORD PTR [rbp-0x290],rax
    37bf:	mov    QWORD PTR [rbp-0x288],0x2
    37ca:	mov    rax,QWORD PTR [rbp-0x290]
    37d1:	mov    rdx,QWORD PTR [rbp-0x288]
    37d8:	mov    rcx,rax
    37db:	mov    rax,QWORD PTR [rbp-0x1d8]
    37e2:	mov    rsi,rcx
    37e5:	mov    rdi,rax
    37e8:	call   2eed <lookup_json_object>
    37ed:	mov    rdi,rax
    37f0:	call   3010 <json_object_to_f64>
    37f5:	movq   rax,xmm0
      Haversine_Pair pair =
    37fa:	mov    QWORD PTR [rbp-0x58],rax
      };

      pairs[pair_count] = pair;
    37fe:	mov    eax,DWORD PTR [rbp-0x1e8]
    3804:	cdqe
    3806:	shl    rax,0x5
    380a:	mov    rdx,rax
    380d:	mov    rax,QWORD PTR [rbp-0x198]
    3814:	lea    rcx,[rdx+rax*1]
    3818:	mov    rax,QWORD PTR [rbp-0x70]
    381c:	mov    rdx,QWORD PTR [rbp-0x68]
    3820:	mov    QWORD PTR [rcx],rax
    3823:	mov    QWORD PTR [rcx+0x8],rdx
    3827:	mov    rax,QWORD PTR [rbp-0x60]
    382b:	mov    rdx,QWORD PTR [rbp-0x58]
    382f:	mov    QWORD PTR [rcx+0x10],rax
    3833:	mov    QWORD PTR [rcx+0x18],rdx
      pair_count += 1;
    3837:	add    DWORD PTR [rbp-0x1e8],0x1
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    383e:	mov    rax,QWORD PTR [rbp-0x1d8]
    3845:	mov    rax,QWORD PTR [rax+0x28]
    3849:	mov    QWORD PTR [rbp-0x1d8],rax
    3850:	cmp    QWORD PTR [rbp-0x1d8],0x0
    3858:	je     386f <main+0x4a1>
    385a:	mov    eax,DWORD PTR [rbp-0x1e8]
    3860:	cdqe
    3862:	cmp    rax,QWORD PTR [rbp-0x1a0]
    3869:	jb     36c7 <main+0x2f9>
    }
  }

  f64 sum = 0.0;
    386f:	pxor   xmm0,xmm0
    3873:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    387b:	mov    eax,DWORD PTR [rbp-0x1e8]
    3881:	cdqe
    3883:	shl    rax,0x5
    3887:	mov    rdx,rax
    388a:	lea    rax,[rip+0xde6]        # 4677 <_IO_stdin_used+0x677>
    3891:	mov    QWORD PTR [rbp-0x230],rax
    3898:	mov    QWORD PTR [rbp-0x228],0x3
    38a3:	lea    rax,[rbp-0xf0]
    38aa:	mov    rcx,QWORD PTR [rbp-0x230]
    38b1:	mov    rbx,QWORD PTR [rbp-0x228]
    38b8:	mov    rsi,rcx
    38bb:	mov    rdi,rbx
    38be:	mov    r8,rdx
    38c1:	mov    ecx,0x6
    38c6:	mov    rdx,rdi
    38c9:	mov    rdi,rax
    38cc:	call   1f72 <__profile_begin_pass>
    38d1:	mov    QWORD PTR [rbp-0x1c8],0x0
    38dc:	jmp    3a5e <main+0x690>
  {
    for (usize i = 0; i < pair_count; i++)
    38e1:	mov    QWORD PTR [rbp-0x1c0],0x0
    38ec:	jmp    39c1 <main+0x5f3>
    {
      f64 earth_radius = 6372.8;
    38f1:	movsd  xmm0,QWORD PTR [rip+0xff7]        # 48f0 <__PRETTY_FUNCTION__.0+0x80>
    38f9:	movsd  QWORD PTR [rbp-0x170],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    3901:	mov    rax,QWORD PTR [rbp-0x1c0]
    3908:	shl    rax,0x5
    390c:	mov    rdx,rax
    390f:	mov    rax,QWORD PTR [rbp-0x198]
    3916:	add    rax,rdx
    3919:	movsd  xmm2,QWORD PTR [rax+0x18]
    391e:	mov    rax,QWORD PTR [rbp-0x1c0]
    3925:	shl    rax,0x5
    3929:	mov    rdx,rax
    392c:	mov    rax,QWORD PTR [rbp-0x198]
    3933:	add    rax,rdx
    3936:	movsd  xmm1,QWORD PTR [rax+0x10]
    393b:	mov    rax,QWORD PTR [rbp-0x1c0]
    3942:	shl    rax,0x5
    3946:	mov    rdx,rax
    3949:	mov    rax,QWORD PTR [rbp-0x198]
    3950:	add    rax,rdx
    3953:	movsd  xmm0,QWORD PTR [rax+0x8]
    3958:	mov    rax,QWORD PTR [rbp-0x1c0]
    395f:	shl    rax,0x5
    3963:	mov    rdx,rax
    3966:	mov    rax,QWORD PTR [rbp-0x198]
    396d:	add    rax,rdx
    3970:	mov    rax,QWORD PTR [rax]
    3973:	movsd  xmm3,QWORD PTR [rbp-0x170]
    397b:	movapd xmm4,xmm3
    397f:	movapd xmm3,xmm2
    3983:	movapd xmm2,xmm1
    3987:	movapd xmm1,xmm0
    398b:	movq   xmm0,rax
    3990:	call   31cd <reference_haversine>
    3995:	movq   rax,xmm0
    399a:	mov    QWORD PTR [rbp-0x168],rax
      sum += result;
    39a1:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    39a9:	addsd  xmm0,QWORD PTR [rbp-0x168]
    39b1:	movsd  QWORD PTR [rbp-0x1d0],xmm0
    for (usize i = 0; i < pair_count; i++)
    39b9:	add    QWORD PTR [rbp-0x1c0],0x1
    39c1:	mov    eax,DWORD PTR [rbp-0x1e8]
    39c7:	cdqe
    39c9:	cmp    QWORD PTR [rbp-0x1c0],rax
    39d0:	jb     38f1 <main+0x523>
    }
    sum /= pair_count;
    39d6:	pxor   xmm1,xmm1
    39da:	cvtsi2sd xmm1,DWORD PTR [rbp-0x1e8]
    39e2:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    39ea:	divsd  xmm0,xmm1
    39ee:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    39f6:	add    QWORD PTR [rbp-0x1c8],0x1
    39fe:	sub    rsp,0x8
    3a02:	sub    rsp,0x38
    3a06:	mov    rax,rsp
    3a09:	mov    rcx,QWORD PTR [rbp-0xf0]
    3a10:	mov    rbx,QWORD PTR [rbp-0xe8]
    3a17:	mov    QWORD PTR [rax],rcx
    3a1a:	mov    QWORD PTR [rax+0x8],rbx
    3a1e:	mov    rcx,QWORD PTR [rbp-0xe0]
    3a25:	mov    rbx,QWORD PTR [rbp-0xd8]
    3a2c:	mov    QWORD PTR [rax+0x10],rcx
    3a30:	mov    QWORD PTR [rax+0x18],rbx
    3a34:	mov    rcx,QWORD PTR [rbp-0xd0]
    3a3b:	mov    rbx,QWORD PTR [rbp-0xc8]
    3a42:	mov    QWORD PTR [rax+0x20],rcx
    3a46:	mov    QWORD PTR [rax+0x28],rbx
    3a4a:	mov    rdx,QWORD PTR [rbp-0xc0]
    3a51:	mov    QWORD PTR [rax+0x30],rdx
    3a55:	call   205c <__profile_end_pass>
    3a5a:	add    rsp,0x40
    3a5e:	cmp    QWORD PTR [rbp-0x1c8],0x0
    3a66:	je     38e1 <main+0x513>
  }

  PROFILE_SCOPE("check")
    3a6c:	lea    rax,[rip+0xc08]        # 467b <_IO_stdin_used+0x67b>
    3a73:	mov    QWORD PTR [rbp-0x240],rax
    3a7a:	mov    QWORD PTR [rbp-0x238],0x5
    3a85:	lea    rax,[rbp-0xb0]
    3a8c:	mov    rcx,QWORD PTR [rbp-0x240]
    3a93:	mov    rbx,QWORD PTR [rbp-0x238]
    3a9a:	mov    rsi,rcx
    3a9d:	mov    rdx,rbx
    3aa0:	mov    r8d,0x0
    3aa6:	mov    ecx,0x7
    3aab:	mov    rdi,rax
    3aae:	call   1f72 <__profile_begin_pass>
    3ab3:	mov    QWORD PTR [rbp-0x1b8],0x0
    3abe:	jmp    3c93 <main+0x8c5>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3ac3:	mov    rax,QWORD PTR [rbp-0x200]
    3aca:	add    rax,0x10
    3ace:	mov    rdx,QWORD PTR [rax]
    3ad1:	lea    rax,[rbp-0x150]
    3ad8:	mov    rsi,rdx
    3adb:	mov    rdi,rax
    3ade:	call   1357 <read_file_to_arena>
    3ae3:	mov    QWORD PTR [rbp-0x70],rax
    3ae7:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3aeb:	mov    rax,QWORD PTR [rbp-0x68]
    3aef:	cmp    rax,0xb
    3af3:	jbe    3c06 <main+0x838>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3af9:	mov    rax,QWORD PTR [rbp-0x70]
    3afd:	movsd  xmm0,QWORD PTR [rax]
    3b01:	movsd  QWORD PTR [rbp-0x178],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3b09:	mov    rax,QWORD PTR [rbp-0x70]
    3b0d:	mov    eax,DWORD PTR [rax+0x8]
    3b10:	mov    DWORD PTR [rbp-0x1e4],eax

      if (solution_pairs == pair_count)
    3b16:	mov    eax,DWORD PTR [rbp-0x1e4]
    3b1c:	cmp    eax,DWORD PTR [rbp-0x1e8]
    3b22:	jne    3bca <main+0x7fc>
      {
        if (epsilon_equal(solution_sum, sum))
    3b28:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3b30:	mov    rax,QWORD PTR [rbp-0x178]
    3b37:	movapd xmm1,xmm0
    3b3b:	movq   xmm0,rax
    3b40:	call   3378 <epsilon_equal>
    3b45:	test   eax,eax
    3b47:	je     3b8b <main+0x7bd>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3b49:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3b51:	mov    rax,QWORD PTR [rbp-0x178]
    3b58:	lea    rdx,[rip+0xb29]        # 4688 <_IO_stdin_used+0x688>
    3b5f:	lea    rsi,[rip+0xb55]        # 46bb <_IO_stdin_used+0x6bb>
    3b66:	movapd xmm1,xmm0
    3b6a:	movq   xmm0,rax
    3b6f:	mov    rcx,rdx
    3b72:	mov    edx,0x5b
    3b77:	mov    edi,0x3
    3b7c:	mov    eax,0x2
    3b81:	call   14a1 <log_message>
    3b86:	jmp    3c2e <main+0x860>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3b8b:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3b93:	mov    rax,QWORD PTR [rbp-0x178]
    3b9a:	lea    rdx,[rip+0xb2f]        # 46d0 <_IO_stdin_used+0x6d0>
    3ba1:	lea    rsi,[rip+0xb13]        # 46bb <_IO_stdin_used+0x6bb>
    3ba8:	movapd xmm1,xmm0
    3bac:	movq   xmm0,rax
    3bb1:	mov    rcx,rdx
    3bb4:	mov    edx,0x5f
    3bb9:	mov    edi,0x1
    3bbe:	mov    eax,0x2
    3bc3:	call   14a1 <log_message>
    3bc8:	jmp    3c2e <main+0x860>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3bca:	mov    esi,DWORD PTR [rbp-0x1e8]
    3bd0:	mov    ecx,DWORD PTR [rbp-0x1e4]
    3bd6:	lea    rdx,[rip+0xb2b]        # 4708 <_IO_stdin_used+0x708>
    3bdd:	lea    rax,[rip+0xad7]        # 46bb <_IO_stdin_used+0x6bb>
    3be4:	mov    r9d,esi
    3be7:	mov    r8d,ecx
    3bea:	mov    rcx,rdx
    3bed:	mov    edx,0x64
    3bf2:	mov    rsi,rax
    3bf5:	mov    edi,0x1
    3bfa:	mov    eax,0x0
    3bff:	call   14a1 <log_message>
    3c04:	jmp    3c2e <main+0x860>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3c06:	lea    rdx,[rip+0xb43]        # 4750 <_IO_stdin_used+0x750>
    3c0d:	lea    rax,[rip+0xaa7]        # 46bb <_IO_stdin_used+0x6bb>
    3c14:	mov    rcx,rdx
    3c17:	mov    edx,0x69
    3c1c:	mov    rsi,rax
    3c1f:	mov    edi,0x1
    3c24:	mov    eax,0x0
    3c29:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3c2e:	add    QWORD PTR [rbp-0x1b8],0x1
    3c36:	sub    rsp,0x8
    3c3a:	sub    rsp,0x38
    3c3e:	mov    rax,rsp
    3c41:	mov    rcx,QWORD PTR [rbp-0xb0]
    3c48:	mov    rbx,QWORD PTR [rbp-0xa8]
    3c4f:	mov    QWORD PTR [rax],rcx
    3c52:	mov    QWORD PTR [rax+0x8],rbx
    3c56:	mov    rcx,QWORD PTR [rbp-0xa0]
    3c5d:	mov    rbx,QWORD PTR [rbp-0x98]
    3c64:	mov    QWORD PTR [rax+0x10],rcx
    3c68:	mov    QWORD PTR [rax+0x18],rbx
    3c6c:	mov    rcx,QWORD PTR [rbp-0x90]
    3c73:	mov    rbx,QWORD PTR [rbp-0x88]
    3c7a:	mov    QWORD PTR [rax+0x20],rcx
    3c7e:	mov    QWORD PTR [rax+0x28],rbx
    3c82:	mov    rdx,QWORD PTR [rbp-0x80]
    3c86:	mov    QWORD PTR [rax+0x30],rdx
    3c8a:	call   205c <__profile_end_pass>
    3c8f:	add    rsp,0x40
    3c93:	cmp    QWORD PTR [rbp-0x1b8],0x0
    3c9b:	je     3ac3 <main+0x6f5>
    }
  }

  PROFILE_SCOPE("free")
    3ca1:	lea    rax,[rip+0xae3]        # 478b <_IO_stdin_used+0x78b>
    3ca8:	mov    QWORD PTR [rbp-0x250],rax
    3caf:	mov    QWORD PTR [rbp-0x248],0x4
    3cba:	lea    rax,[rbp-0x70]
    3cbe:	mov    rcx,QWORD PTR [rbp-0x250]
    3cc5:	mov    rbx,QWORD PTR [rbp-0x248]
    3ccc:	mov    rsi,rcx
    3ccf:	mov    rdx,rbx
    3cd2:	mov    r8d,0x0
    3cd8:	mov    ecx,0x8
    3cdd:	mov    rdi,rax
    3ce0:	call   1f72 <__profile_begin_pass>
    3ce5:	mov    QWORD PTR [rbp-0x1b0],0x0
    3cf0:	jmp    3d54 <main+0x986>
  {
    arena_free(&arena);
    3cf2:	lea    rax,[rbp-0x150]
    3cf9:	mov    rdi,rax
    3cfc:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3d01:	add    QWORD PTR [rbp-0x1b0],0x1
    3d09:	sub    rsp,0x8
    3d0d:	sub    rsp,0x38
    3d11:	mov    rax,rsp
    3d14:	mov    rcx,QWORD PTR [rbp-0x70]
    3d18:	mov    rbx,QWORD PTR [rbp-0x68]
    3d1c:	mov    QWORD PTR [rax],rcx
    3d1f:	mov    QWORD PTR [rax+0x8],rbx
    3d23:	mov    rcx,QWORD PTR [rbp-0x60]
    3d27:	mov    rbx,QWORD PTR [rbp-0x58]
    3d2b:	mov    QWORD PTR [rax+0x10],rcx
    3d2f:	mov    QWORD PTR [rax+0x18],rbx
    3d33:	mov    rcx,QWORD PTR [rbp-0x50]
    3d37:	mov    rbx,QWORD PTR [rbp-0x48]
    3d3b:	mov    QWORD PTR [rax+0x20],rcx
    3d3f:	mov    QWORD PTR [rax+0x28],rbx
    3d43:	mov    rdx,QWORD PTR [rbp-0x40]
    3d47:	mov    QWORD PTR [rax+0x30],rdx
    3d4b:	call   205c <__profile_end_pass>
    3d50:	add    rsp,0x40
    3d54:	cmp    QWORD PTR [rbp-0x1b0],0x0
    3d5c:	je     3cf2 <main+0x924>
  }

  end_profiling();
    3d5e:	call   1b9b <end_profiling>
    3d63:	mov    eax,0x0
}
    3d68:	mov    rdx,QWORD PTR [rbp-0x38]
    3d6c:	sub    rdx,QWORD PTR fs:0x28
    3d75:	je     3d7c <main+0x9ae>
    3d77:	call   1060 <__stack_chk_fail@plt>
    3d7c:	lea    rsp,[rbp-0x28]
    3d80:	pop    rbx
    3d81:	pop    r12
    3d83:	pop    r13
    3d85:	pop    r14
    3d87:	pop    r15
    3d89:	pop    rbp
    3d8a:	ret

Disassembly of section .fini:

0000000000003d8c <_fini>:
    3d8c:	endbr64
    3d90:	sub    rsp,0x8
    3d94:	add    rsp,0x8
    3d98:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x4fc1]        # 5fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x4fca]        # 5ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x4fcc]        # 5ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x4fca]        # 6000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x4fc2]        # 6008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x4fba]        # 6010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x4fb2]        # 6018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x4faa]        # 6020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x4fa2]        # 6028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x4f9a]        # 6030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x4f92]        # 6038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x4f8a]        # 6040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x4f82]        # 6048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x4f7a]        # 6050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x4f72]        # 6058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x4f6a]        # 6060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x4f62]        # 6068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x4f5a]        # 6070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x4f52]        # 6078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x4f4a]        # 6080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x4f42]        # 6088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x4f3a]        # 6090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x4f32]        # 6098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x223f]        # 33ce <main>
    118f:	call   QWORD PTR [rip+0x4e2b]        # 5fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x4fa1]        # 6148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x4f9a]        # 6148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x4e0e]        # 5fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x4f71]        # 6148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x4f6a]        # 6148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x4ddd]        # 5fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x4f6d],0x0        # 6188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x4dba],0x0        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x4e76]        # 60a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x4da8]        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x4f44],0x1        # 6188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x4c6e]        # 6180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x4b89]        # 60c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x4be7]        # 6160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x4b2b]        # 60c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x3097]        # 4790 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x306b]        # 4790 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fae]        # 47a8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2eaf]        # 47b8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2ccd]        # 47d0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x4639]        # 61a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x4620],rbx        # 61a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x50
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x45ee]        # 61a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x40],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x40],0x0
    1bbe:	je     1f6f <end_profiling+0x3d4>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x38],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x40]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x38]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c51]        # 4888 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x38]
    1c44:	mov    rax,QWORD PTR [rbp-0x40]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x50],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x48],0x0
    1c72:	jmp    1f61 <end_profiling+0x3c6>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x48]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x450d]        # 61a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x30],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x30]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1f5c <end_profiling+0x3c1>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x30]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x40]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b77]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x28],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x30]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x30]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x30]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x30]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x28]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>

        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x30]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x30]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x30]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x40]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2a9f]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x20],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x30]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x20]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x50]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x28]
    1e2c:	movsd  QWORD PTR [rbp-0x50],xmm0

        if (zone->bytes_processed)
    1e31:	mov    rax,QWORD PTR [rbp-0x30]
    1e35:	mov    rax,QWORD PTR [rax+0x28]
    1e39:	test   rax,rax
    1e3c:	je     1f5c <end_profiling+0x3c1>
        {
          f64 gigabytes = (f64)zone->bytes_processed / GB(1);
    1e42:	mov    rax,QWORD PTR [rbp-0x30]
    1e46:	mov    rax,QWORD PTR [rax+0x28]
    1e4a:	test   rax,rax
    1e4d:	js     1e5a <end_profiling+0x2bf>
    1e4f:	pxor   xmm0,xmm0
    1e53:	cvtsi2sd xmm0,rax
    1e58:	jmp    1e73 <end_profiling+0x2d8>
    1e5a:	mov    rdx,rax
    1e5d:	shr    rdx,1
    1e60:	and    eax,0x1
    1e63:	or     rdx,rax
    1e66:	pxor   xmm0,xmm0
    1e6a:	cvtsi2sd xmm0,rdx
    1e6f:	addsd  xmm0,xmm0
    1e73:	movsd  xmm1,QWORD PTR [rip+0x2a1d]        # 4898 <__PRETTY_FUNCTION__.0+0x28>
    1e7b:	divsd  xmm0,xmm1
    1e7f:	movsd  QWORD PTR [rbp-0x18],xmm0
          f64 megabytes = (f64)zone->bytes_processed / MB(1);
    1e84:	mov    rax,QWORD PTR [rbp-0x30]
    1e88:	mov    rax,QWORD PTR [rax+0x28]
    1e8c:	test   rax,rax
    1e8f:	js     1e9c <end_profiling+0x301>
    1e91:	pxor   xmm0,xmm0
    1e95:	cvtsi2sd xmm0,rax
    1e9a:	jmp    1eb5 <end_profiling+0x31a>
    1e9c:	mov    rdx,rax
    1e9f:	shr    rdx,1
    1ea2:	and    eax,0x1
    1ea5:	or     rdx,rax
    1ea8:	pxor   xmm0,xmm0
    1eac:	cvtsi2sd xmm0,rdx
    1eb1:	addsd  xmm0,xmm0
    1eb5:	movsd  xmm1,QWORD PTR [rip+0x29e3]        # 48a0 <__PRETTY_FUNCTION__.0+0x30>
    1ebd:	divsd  xmm0,xmm1
    1ec1:	movsd  QWORD PTR [rbp-0x10],xmm0

          f64 gb_per_s = gigabytes / (f64)zone->elapsed_inclusive / (f64)freq;
    1ec6:	mov    rax,QWORD PTR [rbp-0x30]
    1eca:	mov    rax,QWORD PTR [rax+0x18]
    1ece:	test   rax,rax
    1ed1:	js     1ede <end_profiling+0x343>
    1ed3:	pxor   xmm0,xmm0
    1ed7:	cvtsi2sd xmm0,rax
    1edc:	jmp    1ef7 <end_profiling+0x35c>
    1ede:	mov    rdx,rax
    1ee1:	shr    rdx,1
    1ee4:	and    eax,0x1
    1ee7:	or     rdx,rax
    1eea:	pxor   xmm0,xmm0
    1eee:	cvtsi2sd xmm0,rdx
    1ef3:	addsd  xmm0,xmm0
    1ef7:	movsd  xmm1,QWORD PTR [rbp-0x18]
    1efc:	divsd  xmm1,xmm0
    1f00:	mov    rax,QWORD PTR [rbp-0x38]
    1f04:	test   rax,rax
    1f07:	js     1f14 <end_profiling+0x379>
    1f09:	pxor   xmm0,xmm0
    1f0d:	cvtsi2sd xmm0,rax
    1f12:	jmp    1f2d <end_profiling+0x392>
    1f14:	mov    rdx,rax
    1f17:	shr    rdx,1
    1f1a:	and    eax,0x1
    1f1d:	or     rdx,rax
    1f20:	pxor   xmm0,xmm0
    1f24:	cvtsi2sd xmm0,rdx
    1f29:	addsd  xmm0,xmm0
    1f2d:	divsd  xmm1,xmm0
    1f31:	movsd  QWORD PTR [rbp-0x8],xmm1

          printf("  Megabytes Processed: %f @ %f GB/s\n", megabytes, gb_per_s);
    1f36:	movsd  xmm0,QWORD PTR [rbp-0x8]
    1f3b:	mov    rax,QWORD PTR [rbp-0x10]
    1f3f:	lea    rdx,[rip+0x2402]        # 4348 <_IO_stdin_used+0x348>
    1f46:	movapd xmm1,xmm0
    1f4a:	movq   xmm0,rax
    1f4f:	mov    rdi,rdx
    1f52:	mov    eax,0x2
    1f57:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1f5c:	add    QWORD PTR [rbp-0x48],0x1
    1f61:	cmp    QWORD PTR [rbp-0x48],0xfff
    1f69:	jbe    1c77 <end_profiling+0xdc>
        }
      }
    }
  }
}
    1f6f:	nop
    1f70:	leave
    1f71:	ret

0000000000001f72 <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1f72:	push   rbp
    1f73:	mov    rbp,rsp
    1f76:	push   rbx
    1f77:	sub    rsp,0x78
    1f7b:	mov    QWORD PTR [rbp-0x58],rdi
    1f7f:	mov    rax,rsi
    1f82:	mov    rsi,rdx
    1f85:	mov    rax,rax
    1f88:	mov    edx,0x0
    1f8d:	mov    rdx,rsi
    1f90:	mov    QWORD PTR [rbp-0x70],rax
    1f94:	mov    QWORD PTR [rbp-0x68],rdx
    1f98:	mov    QWORD PTR [rbp-0x60],rcx
    1f9c:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1fa0:	pxor   xmm0,xmm0
    1fa4:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1fa8:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1fac:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1fb0:	movq   QWORD PTR [rbp-0x20],xmm0
    1fb5:	mov    rax,QWORD PTR [rbp-0x70]
    1fb9:	mov    rdx,QWORD PTR [rbp-0x68]
    1fbd:	mov    QWORD PTR [rbp-0x50],rax
    1fc1:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1fc5:	mov    rdx,QWORD PTR [rbp-0x60]
    1fc9:	mov    rax,rdx
    1fcc:	add    rax,rax
    1fcf:	add    rax,rdx
    1fd2:	shl    rax,0x4
    1fd6:	mov    rdx,rax
    1fd9:	lea    rax,[rip+0x41e8]        # 61c8 <g_profiler+0x28>
    1fe0:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1fe4:	mov    QWORD PTR [rbp-0x38],rax
    1fe8:	mov    rax,QWORD PTR [rbp-0x60]
    1fec:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1ff0:	mov    rax,QWORD PTR [rip+0x41b1]        # 61a8 <g_profiler+0x8>
  Profile_Pass pass =
    1ff7:	mov    QWORD PTR [rbp-0x28],rax
    1ffb:	mov    rax,QWORD PTR [rbp-0x78]
    1fff:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    2003:	mov    rax,QWORD PTR [rbp-0x60]
    2007:	mov    QWORD PTR [rip+0x419a],rax        # 61a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    200e:	call   1a48 <read_cpu_timer>
    2013:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    2017:	mov    rax,QWORD PTR [rbp-0x58]
    201b:	mov    rcx,QWORD PTR [rbp-0x50]
    201f:	mov    rbx,QWORD PTR [rbp-0x48]
    2023:	mov    QWORD PTR [rax],rcx
    2026:	mov    QWORD PTR [rax+0x8],rbx
    202a:	mov    rcx,QWORD PTR [rbp-0x40]
    202e:	mov    rbx,QWORD PTR [rbp-0x38]
    2032:	mov    QWORD PTR [rax+0x10],rcx
    2036:	mov    QWORD PTR [rax+0x18],rbx
    203a:	mov    rcx,QWORD PTR [rbp-0x30]
    203e:	mov    rbx,QWORD PTR [rbp-0x28]
    2042:	mov    QWORD PTR [rax+0x20],rcx
    2046:	mov    QWORD PTR [rax+0x28],rbx
    204a:	mov    rdx,QWORD PTR [rbp-0x20]
    204e:	mov    QWORD PTR [rax+0x30],rdx
}
    2052:	mov    rax,QWORD PTR [rbp-0x58]
    2056:	mov    rbx,QWORD PTR [rbp-0x8]
    205a:	leave
    205b:	ret

000000000000205c <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    205c:	push   rbp
    205d:	mov    rbp,rsp
    2060:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    2064:	call   1a48 <read_cpu_timer>
    2069:	mov    rdx,rax
    206c:	mov    rax,QWORD PTR [rbp+0x20]
    2070:	sub    rdx,rax
    2073:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    2077:	mov    rax,QWORD PTR [rbp+0x38]
    207b:	mov    QWORD PTR [rip+0x4126],rax        # 61a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    2082:	mov    rdx,QWORD PTR [rbp+0x30]
    2086:	mov    rax,rdx
    2089:	add    rax,rax
    208c:	add    rax,rdx
    208f:	shl    rax,0x4
    2093:	lea    rdx,[rax+0x10]
    2097:	lea    rax,[rip+0x4102]        # 61a0 <g_profiler>
    209e:	add    rax,rdx
    20a1:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    20a5:	mov    rax,QWORD PTR [rbp-0x10]
    20a9:	mov    rdx,QWORD PTR [rax+0x10]
    20ad:	mov    rax,QWORD PTR [rbp-0x18]
    20b1:	add    rdx,rax
    20b4:	mov    rax,QWORD PTR [rbp-0x10]
    20b8:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    20bc:	mov    rax,QWORD PTR [rbp-0x10]
    20c0:	mov    rax,QWORD PTR [rax+0x20]
    20c4:	lea    rdx,[rax+0x1]
    20c8:	mov    rax,QWORD PTR [rbp-0x10]
    20cc:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    20d0:	mov    rcx,QWORD PTR [rbp-0x10]
    20d4:	mov    rax,QWORD PTR [rbp+0x10]
    20d8:	mov    rdx,QWORD PTR [rbp+0x18]
    20dc:	mov    QWORD PTR [rcx],rax
    20df:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    20e3:	mov    rdx,QWORD PTR [rbp+0x28]
    20e7:	mov    rax,QWORD PTR [rbp-0x18]
    20eb:	add    rdx,rax
    20ee:	mov    rax,QWORD PTR [rbp-0x10]
    20f2:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    20f6:	mov    rax,QWORD PTR [rbp-0x10]
    20fa:	mov    rdx,QWORD PTR [rax+0x28]
    20fe:	mov    rax,QWORD PTR [rbp+0x40]
    2102:	add    rdx,rax
    2105:	mov    rax,QWORD PTR [rbp-0x10]
    2109:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    210d:	mov    rdx,QWORD PTR [rbp+0x38]
    2111:	mov    rax,rdx
    2114:	add    rax,rax
    2117:	add    rax,rdx
    211a:	shl    rax,0x4
    211e:	lea    rdx,[rax+0x10]
    2122:	lea    rax,[rip+0x4077]        # 61a0 <g_profiler>
    2129:	add    rax,rdx
    212c:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    2130:	mov    rax,QWORD PTR [rbp-0x8]
    2134:	mov    rax,QWORD PTR [rax+0x10]
    2138:	sub    rax,QWORD PTR [rbp-0x18]
    213c:	mov    rdx,rax
    213f:	mov    rax,QWORD PTR [rbp-0x8]
    2143:	mov    QWORD PTR [rax+0x10],rdx
}
    2147:	nop
    2148:	leave
    2149:	ret

000000000000214a <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    214a:	push   rbp
    214b:	mov    rbp,rsp
    214e:	sub    rsp,0x10
    2152:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2156:	mov    rax,QWORD PTR [rbp-0x8]
    215a:	mov    rdx,QWORD PTR [rax+0x10]
    215e:	mov    rax,QWORD PTR [rbp-0x8]
    2162:	mov    rax,QWORD PTR [rax+0x8]
    2166:	cmp    rdx,rax
    2169:	jb     2190 <parser_at+0x46>
    216b:	lea    rdx,[rip+0x2676]        # 47e8 <__PRETTY_FUNCTION__.5>
    2172:	lea    rsi,[rip+0x22ff]        # 4478 <_IO_stdin_used+0x478>
    2179:	lea    rax,[rip+0x2310]        # 4490 <_IO_stdin_used+0x490>
    2180:	mov    rcx,rdx
    2183:	mov    edx,0x2f
    2188:	mov    rdi,rax
    218b:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    2190:	mov    rax,QWORD PTR [rbp-0x8]
    2194:	mov    rdx,QWORD PTR [rax]
    2197:	mov    rax,QWORD PTR [rbp-0x8]
    219b:	mov    rax,QWORD PTR [rax+0x10]
    219f:	add    rax,rdx
}
    21a2:	leave
    21a3:	ret

00000000000021a4 <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    21a4:	push   rbp
    21a5:	mov    rbp,rsp
    21a8:	sub    rsp,0x10
    21ac:	mov    QWORD PTR [rbp-0x8],rdi
    21b0:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    21b4:	mov    rax,QWORD PTR [rbp-0x8]
    21b8:	mov    rdi,rax
    21bb:	call   214a <parser_at>
    21c0:	mov    rdx,QWORD PTR [rbp-0x10]
    21c4:	add    rax,rdx
}
    21c7:	leave
    21c8:	ret

00000000000021c9 <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    21c9:	push   rbp
    21ca:	mov    rbp,rsp
    21cd:	mov    QWORD PTR [rbp-0x8],rdi
    21d1:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    21d5:	mov    rax,QWORD PTR [rbp-0x8]
    21d9:	mov    rdx,QWORD PTR [rax+0x10]
    21dd:	mov    rax,QWORD PTR [rbp-0x10]
    21e1:	add    rdx,rax
    21e4:	mov    rax,QWORD PTR [rbp-0x8]
    21e8:	mov    QWORD PTR [rax+0x10],rdx
}
    21ec:	nop
    21ed:	pop    rbp
    21ee:	ret

00000000000021ef <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    21ef:	push   rbp
    21f0:	mov    rbp,rsp
    21f3:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    21f7:	mov    rax,QWORD PTR [rbp-0x8]
    21fb:	mov    rdx,QWORD PTR [rax+0x10]
    21ff:	mov    rax,QWORD PTR [rbp-0x8]
    2203:	mov    rax,QWORD PTR [rax+0x8]
    2207:	cmp    rdx,rax
    220a:	setb   al
}
    220d:	pop    rbp
    220e:	ret

000000000000220f <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    220f:	push   rbp
    2210:	mov    rbp,rsp
    2213:	push   r12
    2215:	push   rbx
    2216:	sub    rsp,0x20
    221a:	mov    QWORD PTR [rbp-0x18],rdi
    221e:	mov    rax,rsi
    2221:	mov    rcx,rdx
    2224:	mov    rax,rax
    2227:	mov    edx,0x0
    222c:	mov    rdx,rcx
    222f:	mov    QWORD PTR [rbp-0x30],rax
    2233:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    2237:	mov    rax,QWORD PTR [rbp-0x28]
    223b:	mov    r12,rax
    223e:	mov    rbx,QWORD PTR [rbp-0x30]
    2242:	mov    rax,QWORD PTR [rbp-0x18]
    2246:	mov    rdi,rax
    2249:	call   214a <parser_at>
    224e:	mov    rdx,r12
    2251:	mov    rsi,rbx
    2254:	mov    rdi,rax
    2257:	call   10d0 <memcmp@plt>
    225c:	test   eax,eax
    225e:	sete   al
}
    2261:	add    rsp,0x20
    2265:	pop    rbx
    2266:	pop    r12
    2268:	pop    rbp
    2269:	ret

000000000000226a <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    226a:	push   rbp
    226b:	mov    rbp,rsp
    226e:	mov    eax,edi
    2270:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    2273:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    2277:	movzx  eax,BYTE PTR [rbp-0x14]
    227b:	cmp    eax,0x2e
    227e:	jg     2287 <is_numeric+0x1d>
    2280:	cmp    eax,0x2d
    2283:	jge    228f <is_numeric+0x25>
    2285:	jmp    2294 <is_numeric+0x2a>
    2287:	sub    eax,0x30
    228a:	cmp    eax,0x9
    228d:	ja     2294 <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    228f:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    2293:	nop
  }


  return result;
    2294:	movzx  eax,BYTE PTR [rbp-0x1]
}
    2298:	pop    rbp
    2299:	ret

000000000000229a <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    229a:	push   rbp
    229b:	mov    rbp,rsp
    229e:	sub    rsp,0x50
    22a2:	mov    QWORD PTR [rbp-0x48],rdi
    22a6:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    22aa:	pxor   xmm0,xmm0
    22ae:	movaps XMMWORD PTR [rbp-0x20],xmm0
    22b2:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    22b7:	jmp    22ca <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    22b9:	mov    rax,QWORD PTR [rbp-0x50]
    22bd:	mov    esi,0x1
    22c2:	mov    rdi,rax
    22c5:	call   21c9 <parser_advance>
  while (parser_incomplete(parser)  &&
    22ca:	mov    rax,QWORD PTR [rbp-0x50]
    22ce:	mov    rdi,rax
    22d1:	call   21ef <parser_incomplete>
    22d6:	test   al,al
    22d8:	je     2326 <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    22da:	mov    rax,QWORD PTR [rbp-0x50]
    22de:	mov    rdi,rax
    22e1:	call   214a <parser_at>
    22e6:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    22e9:	cmp    al,0x20
    22eb:	je     22b9 <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    22ed:	mov    rax,QWORD PTR [rbp-0x50]
    22f1:	mov    rdi,rax
    22f4:	call   214a <parser_at>
    22f9:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    22fc:	cmp    al,0xa
    22fe:	je     22b9 <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    2300:	mov    rax,QWORD PTR [rbp-0x50]
    2304:	mov    rdi,rax
    2307:	call   214a <parser_at>
    230c:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    230f:	cmp    al,0xd
    2311:	je     22b9 <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    2313:	mov    rax,QWORD PTR [rbp-0x50]
    2317:	mov    rdi,rax
    231a:	call   214a <parser_at>
    231f:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    2322:	cmp    al,0x9
    2324:	je     22b9 <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    2326:	mov    rax,QWORD PTR [rbp-0x50]
    232a:	mov    rdi,rax
    232d:	call   21ef <parser_incomplete>
    2332:	test   al,al
    2334:	je     2761 <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    233a:	mov    rax,QWORD PTR [rbp-0x50]
    233e:	mov    rdi,rax
    2341:	call   214a <parser_at>
    2346:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    234a:	mov    rax,QWORD PTR [rbp-0x50]
    234e:	mov    rdi,rax
    2351:	call   214a <parser_at>
    2356:	movzx  eax,BYTE PTR [rax]
    2359:	movzx  eax,al
    235c:	cmp    eax,0x7d
    235f:	je     244c <get_json_token+0x1b2>
    2365:	cmp    eax,0x7d
    2368:	jg     2772 <get_json_token+0x4d8>
    236e:	cmp    eax,0x7b
    2371:	je     2427 <get_json_token+0x18d>
    2377:	cmp    eax,0x7b
    237a:	jg     2772 <get_json_token+0x4d8>
    2380:	cmp    eax,0x74
    2383:	je     25cf <get_json_token+0x335>
    2389:	cmp    eax,0x74
    238c:	jg     2772 <get_json_token+0x4d8>
    2392:	cmp    eax,0x6e
    2395:	je     26df <get_json_token+0x445>
    239b:	cmp    eax,0x6e
    239e:	jg     2772 <get_json_token+0x4d8>
    23a4:	cmp    eax,0x66
    23a7:	je     2657 <get_json_token+0x3bd>
    23ad:	cmp    eax,0x66
    23b0:	jg     2772 <get_json_token+0x4d8>
    23b6:	cmp    eax,0x5d
    23b9:	je     2496 <get_json_token+0x1fc>
    23bf:	cmp    eax,0x5d
    23c2:	jg     2772 <get_json_token+0x4d8>
    23c8:	cmp    eax,0x5b
    23cb:	je     2471 <get_json_token+0x1d7>
    23d1:	cmp    eax,0x5b
    23d4:	jg     2772 <get_json_token+0x4d8>
    23da:	cmp    eax,0x3a
    23dd:	je     24e0 <get_json_token+0x246>
    23e3:	cmp    eax,0x3a
    23e6:	jg     2772 <get_json_token+0x4d8>
    23ec:	cmp    eax,0x39
    23ef:	jg     2772 <get_json_token+0x4d8>
    23f5:	cmp    eax,0x30
    23f8:	jge    257e <get_json_token+0x2e4>
    23fe:	cmp    eax,0x2e
    2401:	jg     2772 <get_json_token+0x4d8>
    2407:	cmp    eax,0x2d
    240a:	jge    257e <get_json_token+0x2e4>
    2410:	cmp    eax,0x22
    2413:	je     2505 <get_json_token+0x26b>
    2419:	cmp    eax,0x2c
    241c:	je     24bb <get_json_token+0x221>
    2422:	jmp    2772 <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    2427:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    242e:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2436:	mov    rax,QWORD PTR [rbp-0x50]
    243a:	mov    esi,0x1
    243f:	mov    rdi,rax
    2442:	call   21c9 <parser_advance>
      }
      break;
    2447:	jmp    2772 <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    244c:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    2453:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    245b:	mov    rax,QWORD PTR [rbp-0x50]
    245f:	mov    esi,0x1
    2464:	mov    rdi,rax
    2467:	call   21c9 <parser_advance>
      }
      break;
    246c:	jmp    2772 <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2471:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    2478:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2480:	mov    rax,QWORD PTR [rbp-0x50]
    2484:	mov    esi,0x1
    2489:	mov    rdi,rax
    248c:	call   21c9 <parser_advance>
      }
      break;
    2491:	jmp    2772 <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    2496:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    249d:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24a5:	mov    rax,QWORD PTR [rbp-0x50]
    24a9:	mov    esi,0x1
    24ae:	mov    rdi,rax
    24b1:	call   21c9 <parser_advance>
      }
      break;
    24b6:	jmp    2772 <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    24bb:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    24c2:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24ca:	mov    rax,QWORD PTR [rbp-0x50]
    24ce:	mov    esi,0x1
    24d3:	mov    rdi,rax
    24d6:	call   21c9 <parser_advance>
      }
      break;
    24db:	jmp    2772 <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    24e0:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    24e7:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24ef:	mov    rax,QWORD PTR [rbp-0x50]
    24f3:	mov    esi,0x1
    24f8:	mov    rdi,rax
    24fb:	call   21c9 <parser_advance>
      }
      break;
    2500:	jmp    2772 <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    2505:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    250c:	mov    rax,QWORD PTR [rbp-0x50]
    2510:	mov    esi,0x1
    2515:	mov    rdi,rax
    2518:	call   21c9 <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    251d:	mov    rax,QWORD PTR [rbp-0x50]
    2521:	mov    rdi,rax
    2524:	call   214a <parser_at>
    2529:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    252d:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    2535:	jmp    254d <get_json_token+0x2b3>
        {
          string_count += 1;
    2537:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    253c:	mov    rax,QWORD PTR [rbp-0x50]
    2540:	mov    esi,0x1
    2545:	mov    rdi,rax
    2548:	call   21c9 <parser_advance>
        while (*parser_at(parser) != '"')
    254d:	mov    rax,QWORD PTR [rbp-0x50]
    2551:	mov    rdi,rax
    2554:	call   214a <parser_at>
    2559:	movzx  eax,BYTE PTR [rax]
    255c:	cmp    al,0x22
    255e:	jne    2537 <get_json_token+0x29d>
        }
        token.value.count = string_count;
    2560:	mov    rax,QWORD PTR [rbp-0x40]
    2564:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    2568:	mov    rax,QWORD PTR [rbp-0x50]
    256c:	mov    esi,0x1
    2571:	mov    rdi,rax
    2574:	call   21c9 <parser_advance>
      }
      break;
    2579:	jmp    2772 <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    257e:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    2585:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    258d:	jmp    25a5 <get_json_token+0x30b>
        {
          digit_count += 1;
    258f:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    2594:	mov    rax,QWORD PTR [rbp-0x50]
    2598:	mov    esi,0x1
    259d:	mov    rdi,rax
    25a0:	call   21c9 <parser_advance>
        while (is_numeric(*parser_at(parser)))
    25a5:	mov    rax,QWORD PTR [rbp-0x50]
    25a9:	mov    rdi,rax
    25ac:	call   214a <parser_at>
    25b1:	movzx  eax,BYTE PTR [rax]
    25b4:	movzx  eax,al
    25b7:	mov    edi,eax
    25b9:	call   226a <is_numeric>
    25be:	test   al,al
    25c0:	jne    258f <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    25c2:	mov    rax,QWORD PTR [rbp-0x38]
    25c6:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    25ca:	jmp    2772 <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    25cf:	lea    rax,[rip+0x1f06]        # 44dc <_IO_stdin_used+0x4dc>
    25d6:	mov    QWORD PTR [rbp-0x30],rax
    25da:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25e2:	mov    rcx,QWORD PTR [rbp-0x30]
    25e6:	mov    rdx,QWORD PTR [rbp-0x28]
    25ea:	mov    rax,QWORD PTR [rbp-0x50]
    25ee:	mov    rsi,rcx
    25f1:	mov    rdi,rax
    25f4:	call   220f <parser_token_is_literal>
    25f9:	test   al,al
    25fb:	je     261f <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    25fd:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    2604:	mov    rax,QWORD PTR [rbp-0x28]
    2608:	mov    rdx,rax
    260b:	mov    rax,QWORD PTR [rbp-0x50]
    260f:	mov    rsi,rdx
    2612:	mov    rdi,rax
    2615:	call   21c9 <parser_advance>
    261a:	jmp    2772 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    261f:	mov    rax,QWORD PTR [rbp-0x50]
    2623:	mov    rcx,QWORD PTR [rax+0x10]
    2627:	lea    rdx,[rip+0x1eba]        # 44e8 <_IO_stdin_used+0x4e8>
    262e:	lea    rax,[rip+0x1e43]        # 4478 <_IO_stdin_used+0x478>
    2635:	mov    r8,rcx
    2638:	mov    rcx,rdx
    263b:	mov    edx,0xdf
    2640:	mov    rsi,rax
    2643:	mov    edi,0x1
    2648:	mov    eax,0x0
    264d:	call   14a1 <log_message>
        }
      }
      break;
    2652:	jmp    2772 <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    2657:	lea    rax,[rip+0x1eb7]        # 4515 <_IO_stdin_used+0x515>
    265e:	mov    QWORD PTR [rbp-0x30],rax
    2662:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    266a:	mov    rcx,QWORD PTR [rbp-0x30]
    266e:	mov    rdx,QWORD PTR [rbp-0x28]
    2672:	mov    rax,QWORD PTR [rbp-0x50]
    2676:	mov    rsi,rcx
    2679:	mov    rdi,rax
    267c:	call   220f <parser_token_is_literal>
    2681:	test   al,al
    2683:	je     26a7 <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    2685:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    268c:	mov    rax,QWORD PTR [rbp-0x28]
    2690:	mov    rdx,rax
    2693:	mov    rax,QWORD PTR [rbp-0x50]
    2697:	mov    rsi,rdx
    269a:	mov    rdi,rax
    269d:	call   21c9 <parser_advance>
    26a2:	jmp    2772 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    26a7:	mov    rax,QWORD PTR [rbp-0x50]
    26ab:	mov    rcx,QWORD PTR [rax+0x10]
    26af:	lea    rdx,[rip+0x1e32]        # 44e8 <_IO_stdin_used+0x4e8>
    26b6:	lea    rax,[rip+0x1dbb]        # 4478 <_IO_stdin_used+0x478>
    26bd:	mov    r8,rcx
    26c0:	mov    rcx,rdx
    26c3:	mov    edx,0xee
    26c8:	mov    rsi,rax
    26cb:	mov    edi,0x1
    26d0:	mov    eax,0x0
    26d5:	call   14a1 <log_message>
        }
      }
      break;
    26da:	jmp    2772 <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    26df:	lea    rax,[rip+0x1e35]        # 451b <_IO_stdin_used+0x51b>
    26e6:	mov    QWORD PTR [rbp-0x30],rax
    26ea:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    26f2:	mov    rcx,QWORD PTR [rbp-0x30]
    26f6:	mov    rdx,QWORD PTR [rbp-0x28]
    26fa:	mov    rax,QWORD PTR [rbp-0x50]
    26fe:	mov    rsi,rcx
    2701:	mov    rdi,rax
    2704:	call   220f <parser_token_is_literal>
    2709:	test   al,al
    270b:	je     272c <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    270d:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    2714:	mov    rax,QWORD PTR [rbp-0x28]
    2718:	mov    rdx,rax
    271b:	mov    rax,QWORD PTR [rbp-0x50]
    271f:	mov    rsi,rdx
    2722:	mov    rdi,rax
    2725:	call   21c9 <parser_advance>
    272a:	jmp    2772 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    272c:	mov    rax,QWORD PTR [rbp-0x50]
    2730:	mov    rcx,QWORD PTR [rax+0x10]
    2734:	lea    rdx,[rip+0x1dad]        # 44e8 <_IO_stdin_used+0x4e8>
    273b:	lea    rax,[rip+0x1d36]        # 4478 <_IO_stdin_used+0x478>
    2742:	mov    r8,rcx
    2745:	mov    rcx,rdx
    2748:	mov    edx,0xfd
    274d:	mov    rsi,rax
    2750:	mov    edi,0x1
    2755:	mov    eax,0x0
    275a:	call   14a1 <log_message>
        }
      }
      break;
    275f:	jmp    2772 <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    2761:	mov    rax,QWORD PTR [rbp-0x50]
    2765:	mov    esi,0x1
    276a:	mov    rdi,rax
    276d:	call   21c9 <parser_advance>
  }

  return token;
    2772:	mov    rcx,QWORD PTR [rbp-0x48]
    2776:	mov    rax,QWORD PTR [rbp-0x20]
    277a:	mov    rdx,QWORD PTR [rbp-0x18]
    277e:	mov    QWORD PTR [rcx],rax
    2781:	mov    QWORD PTR [rcx+0x8],rdx
    2785:	mov    rax,QWORD PTR [rbp-0x10]
    2789:	mov    QWORD PTR [rcx+0x10],rax
}
    278d:	mov    rax,QWORD PTR [rbp-0x48]
    2791:	leave
    2792:	ret

0000000000002793 <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    2793:	push   rbp
    2794:	mov    rbp,rsp
    2797:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    279a:	cmp    DWORD PTR [rbp-0x14],0x7
    279e:	je     27b8 <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    27a0:	cmp    DWORD PTR [rbp-0x14],0x9
    27a4:	je     27b8 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    27a6:	cmp    DWORD PTR [rbp-0x14],0xa
    27aa:	je     27b8 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    27ac:	cmp    DWORD PTR [rbp-0x14],0xb
    27b0:	je     27b8 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    27b2:	cmp    DWORD PTR [rbp-0x14],0x8
    27b6:	jne    27bf <json_token_type_is_value_type+0x2c>
    27b8:	mov    eax,0x1
    27bd:	jmp    27c4 <json_token_type_is_value_type+0x31>
    27bf:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    27c4:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    27c7:	mov    eax,DWORD PTR [rbp-0x4]
}
    27ca:	pop    rbp
    27cb:	ret

00000000000027cc <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    27cc:	push   rbp
    27cd:	mov    rbp,rsp
    27d0:	push   rbx
    27d1:	sub    rsp,0x88
    27d8:	mov    QWORD PTR [rbp-0x78],rdi
    27dc:	mov    QWORD PTR [rbp-0x80],rsi
    27e0:	mov    QWORD PTR [rbp-0x90],rdx
    27e7:	mov    QWORD PTR [rbp-0x88],rcx
    27ee:	mov    rax,QWORD PTR fs:0x28
    27f7:	mov    QWORD PTR [rbp-0x18],rax
    27fb:	xor    eax,eax
  profile_begin_func();
    27fd:	lea    r8,[rip+0x1ffc]        # 4800 <__func__.4>
    2804:	mov    r9d,0x11
    280a:	lea    rax,[rbp-0x50]
    280e:	mov    rsi,r8
    2811:	mov    rdx,r9
    2814:	mov    r8d,0x0
    281a:	mov    ecx,0x1
    281f:	mov    rdi,rax
    2822:	call   1f72 <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    2827:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    282f:	mov    eax,DWORD PTR [rbp+0x10]
    2832:	cmp    eax,0x1
    2835:	jne    2861 <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    2837:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    283e:	mov    edx,DWORD PTR [rbp-0x64]
    2841:	mov    rsi,QWORD PTR [rbp-0x80]
    2845:	mov    rax,QWORD PTR [rbp-0x78]
    2849:	mov    ecx,edx
    284b:	mov    edx,0x2
    2850:	mov    rdi,rax
    2853:	call   29b3 <parse_json_children>
    2858:	mov    QWORD PTR [rbp-0x60],rax
    285c:	jmp    28eb <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2861:	mov    eax,DWORD PTR [rbp+0x10]
    2864:	cmp    eax,0x3
    2867:	jne    2890 <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    2869:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2870:	mov    edx,DWORD PTR [rbp-0x68]
    2873:	mov    rsi,QWORD PTR [rbp-0x80]
    2877:	mov    rax,QWORD PTR [rbp-0x78]
    287b:	mov    ecx,edx
    287d:	mov    edx,0x4
    2882:	mov    rdi,rax
    2885:	call   29b3 <parse_json_children>
    288a:	mov    QWORD PTR [rbp-0x60],rax
    288e:	jmp    28eb <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    2890:	mov    eax,DWORD PTR [rbp+0x10]
    2893:	mov    edi,eax
    2895:	call   2793 <json_token_type_is_value_type>
    289a:	test   eax,eax
    289c:	jne    28eb <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    289e:	mov    eax,DWORD PTR [rbp+0x10]
    28a1:	mov    eax,eax
    28a3:	lea    rdx,[rax*8+0x0]
    28ab:	lea    rax,[rip+0x382e]        # 60e0 <JSON_Token_Type_strings>
    28b2:	mov    rcx,QWORD PTR [rdx+rax*1]
    28b6:	lea    rdx,[rip+0x1c63]        # 4520 <_IO_stdin_used+0x520>
    28bd:	lea    rax,[rip+0x1bb4]        # 4478 <_IO_stdin_used+0x478>
    28c4:	push   QWORD PTR [rbp+0x20]
    28c7:	push   QWORD PTR [rbp+0x18]
    28ca:	mov    r8,rcx
    28cd:	mov    rcx,rdx
    28d0:	mov    edx,0x134
    28d5:	mov    rsi,rax
    28d8:	mov    edi,0x1
    28dd:	mov    eax,0x0
    28e2:	call   14a1 <log_message>
    28e7:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    28eb:	mov    rax,QWORD PTR [rbp-0x78]
    28ef:	mov    edx,0x8
    28f4:	mov    esi,0x30
    28f9:	mov    rdi,rax
    28fc:	call   17d3 <arena_alloc>
    2901:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    2905:	mov    rcx,QWORD PTR [rbp-0x58]
    2909:	mov    rax,QWORD PTR [rbp-0x90]
    2910:	mov    rdx,QWORD PTR [rbp-0x88]
    2917:	mov    QWORD PTR [rcx],rax
    291a:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    291e:	mov    rax,QWORD PTR [rbp-0x58]
    2922:	mov    rdx,QWORD PTR [rbp-0x60]
    2926:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    292a:	mov    rax,QWORD PTR [rbp-0x58]
    292e:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    2936:	mov    rcx,QWORD PTR [rbp-0x58]
    293a:	mov    rax,QWORD PTR [rbp+0x18]
    293e:	mov    rdx,QWORD PTR [rbp+0x20]
    2942:	mov    QWORD PTR [rcx+0x10],rax
    2946:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    294a:	sub    rsp,0x8
    294e:	sub    rsp,0x38
    2952:	mov    rax,rsp
    2955:	mov    rcx,QWORD PTR [rbp-0x50]
    2959:	mov    rbx,QWORD PTR [rbp-0x48]
    295d:	mov    QWORD PTR [rax],rcx
    2960:	mov    QWORD PTR [rax+0x8],rbx
    2964:	mov    rcx,QWORD PTR [rbp-0x40]
    2968:	mov    rbx,QWORD PTR [rbp-0x38]
    296c:	mov    QWORD PTR [rax+0x10],rcx
    2970:	mov    QWORD PTR [rax+0x18],rbx
    2974:	mov    rcx,QWORD PTR [rbp-0x30]
    2978:	mov    rbx,QWORD PTR [rbp-0x28]
    297c:	mov    QWORD PTR [rax+0x20],rcx
    2980:	mov    QWORD PTR [rax+0x28],rbx
    2984:	mov    rdx,QWORD PTR [rbp-0x20]
    2988:	mov    QWORD PTR [rax+0x30],rdx
    298c:	call   205c <__profile_end_pass>
    2991:	add    rsp,0x40

  return result;
    2995:	mov    rax,QWORD PTR [rbp-0x58]
}
    2999:	mov    rdx,QWORD PTR [rbp-0x18]
    299d:	sub    rdx,QWORD PTR fs:0x28
    29a6:	je     29ad <parse_json_object+0x1e1>
    29a8:	call   1060 <__stack_chk_fail@plt>
    29ad:	mov    rbx,QWORD PTR [rbp-0x8]
    29b1:	leave
    29b2:	ret

00000000000029b3 <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    29b3:	push   rbp
    29b4:	mov    rbp,rsp
    29b7:	push   rbx
    29b8:	sub    rsp,0x108
    29bf:	mov    QWORD PTR [rbp-0xd8],rdi
    29c6:	mov    QWORD PTR [rbp-0xe0],rsi
    29cd:	mov    DWORD PTR [rbp-0xe4],edx
    29d3:	mov    DWORD PTR [rbp-0xe8],ecx
    29d9:	mov    rax,QWORD PTR fs:0x28
    29e2:	mov    QWORD PTR [rbp-0x18],rax
    29e6:	xor    eax,eax
  profile_begin_func();
    29e8:	lea    r8,[rip+0x1e31]        # 4820 <__func__.3>
    29ef:	mov    r9d,0x13
    29f5:	lea    rax,[rbp-0x50]
    29f9:	mov    rsi,r8
    29fc:	mov    rdx,r9
    29ff:	mov    r8d,0x0
    2a05:	mov    ecx,0x2
    2a0a:	mov    rdi,rax
    2a0d:	call   1f72 <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2a12:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    2a1d:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2a28:	jmp    2d01 <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2a2d:	pxor   xmm0,xmm0
    2a31:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2a38:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2a40:	pxor   xmm0,xmm0
    2a44:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2a4b:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2a50:	cmp    DWORD PTR [rbp-0xe8],0x0
    2a57:	je     2b64 <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2a5d:	lea    rax,[rbp-0xb0]
    2a64:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a6b:	mov    rsi,rdx
    2a6e:	mov    rdi,rax
    2a71:	call   229a <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2a76:	mov    eax,DWORD PTR [rbp-0xb0]
    2a7c:	cmp    eax,0x7
    2a7f:	jne    2b00 <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2a81:	lea    rax,[rbp-0x70]
    2a85:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a8c:	mov    rsi,rdx
    2a8f:	mov    rdi,rax
    2a92:	call   229a <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2a97:	mov    eax,DWORD PTR [rbp-0x70]
    2a9a:	cmp    eax,0x6
    2a9d:	jne    2abd <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2a9f:	lea    rax,[rbp-0x90]
    2aa6:	mov    rdx,QWORD PTR [rbp-0xe0]
    2aad:	mov    rsi,rdx
    2ab0:	mov    rdi,rax
    2ab3:	call   229a <get_json_token>
    2ab8:	jmp    2ba4 <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2abd:	mov    rcx,QWORD PTR [rbp-0xa8]
    2ac4:	mov    rax,QWORD PTR [rbp-0xa0]
    2acb:	mov    esi,eax
    2acd:	lea    rdx,[rip+0x1a9c]        # 4570 <_IO_stdin_used+0x570>
    2ad4:	lea    rax,[rip+0x199d]        # 4478 <_IO_stdin_used+0x478>
    2adb:	mov    r9,rcx
    2ade:	mov    r8d,esi
    2ae1:	mov    rcx,rdx
    2ae4:	mov    edx,0x15f
    2ae9:	mov    rsi,rax
    2aec:	mov    edi,0x1
    2af1:	mov    eax,0x0
    2af6:	call   14a1 <log_message>
    2afb:	jmp    2ba4 <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2b00:	mov    rcx,QWORD PTR [rbp-0xa8]
    2b07:	mov    rax,QWORD PTR [rbp-0xa0]
    2b0e:	mov    edi,eax
    2b10:	mov    eax,DWORD PTR [rbp-0xb0]
    2b16:	mov    eax,eax
    2b18:	lea    rdx,[rax*8+0x0]
    2b20:	lea    rax,[rip+0x35b9]        # 60e0 <JSON_Token_Type_strings>
    2b27:	mov    rsi,QWORD PTR [rdx+rax*1]
    2b2b:	lea    rdx,[rip+0x1a5e]        # 4590 <_IO_stdin_used+0x590>
    2b32:	lea    rax,[rip+0x193f]        # 4478 <_IO_stdin_used+0x478>
    2b39:	sub    rsp,0x8
    2b3d:	push   rcx
    2b3e:	mov    r9d,edi
    2b41:	mov    r8,rsi
    2b44:	mov    rcx,rdx
    2b47:	mov    edx,0x164
    2b4c:	mov    rsi,rax
    2b4f:	mov    edi,0x1
    2b54:	mov    eax,0x0
    2b59:	call   14a1 <log_message>
    2b5e:	add    rsp,0x10
    2b62:	jmp    2ba4 <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2b64:	lea    rax,[rbp-0x110]
    2b6b:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b72:	mov    rsi,rdx
    2b75:	mov    rdi,rax
    2b78:	call   229a <get_json_token>
    2b7d:	mov    rax,QWORD PTR [rbp-0x110]
    2b84:	mov    rdx,QWORD PTR [rbp-0x108]
    2b8b:	mov    QWORD PTR [rbp-0x90],rax
    2b92:	mov    QWORD PTR [rbp-0x88],rdx
    2b99:	mov    rax,QWORD PTR [rbp-0x100]
    2ba0:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2ba4:	mov    eax,DWORD PTR [rbp-0x90]
    2baa:	cmp    DWORD PTR [rbp-0xe4],eax
    2bb0:	je     2d1a <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2bb6:	mov    rax,QWORD PTR [rbp-0xa8]
    2bbd:	mov    rdx,QWORD PTR [rbp-0xa0]
    2bc4:	mov    r8,QWORD PTR [rbp-0xe0]
    2bcb:	mov    rdi,QWORD PTR [rbp-0xd8]
    2bd2:	sub    rsp,0x8
    2bd6:	sub    rsp,0x18
    2bda:	mov    rsi,rsp
    2bdd:	mov    rcx,QWORD PTR [rbp-0x90]
    2be4:	mov    rbx,QWORD PTR [rbp-0x88]
    2beb:	mov    QWORD PTR [rsi],rcx
    2bee:	mov    QWORD PTR [rsi+0x8],rbx
    2bf2:	mov    rcx,QWORD PTR [rbp-0x80]
    2bf6:	mov    QWORD PTR [rsi+0x10],rcx
    2bfa:	mov    rcx,rdx
    2bfd:	mov    rdx,rax
    2c00:	mov    rsi,r8
    2c03:	call   27cc <parse_json_object>
    2c08:	add    rsp,0x20
    2c0c:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2c13:	cmp    QWORD PTR [rbp-0xb8],0x0
    2c1b:	je     2c65 <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2c1d:	cmp    QWORD PTR [rbp-0xc8],0x0
    2c25:	jne    2c45 <parse_json_children+0x292>
      {
        first_child        = object;
    2c27:	mov    rax,QWORD PTR [rbp-0xb8]
    2c2e:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2c35:	mov    rax,QWORD PTR [rbp-0xb8]
    2c3c:	mov    QWORD PTR [rbp-0xc0],rax
    2c43:	jmp    2c65 <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2c45:	mov    rax,QWORD PTR [rbp-0xc0]
    2c4c:	mov    rdx,QWORD PTR [rbp-0xb8]
    2c53:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2c57:	mov    rax,QWORD PTR [rbp-0xb8]
    2c5e:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2c65:	lea    rax,[rbp-0x70]
    2c69:	mov    rdx,QWORD PTR [rbp-0xe0]
    2c70:	mov    rsi,rdx
    2c73:	mov    rdi,rax
    2c76:	call   229a <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2c7b:	mov    eax,DWORD PTR [rbp-0x70]
    2c7e:	cmp    DWORD PTR [rbp-0xe4],eax
    2c84:	je     2d1d <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2c8a:	mov    eax,DWORD PTR [rbp-0x70]
    2c8d:	cmp    eax,0x5
    2c90:	je     2d01 <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2c92:	mov    r8,QWORD PTR [rbp-0x68]
    2c96:	mov    rax,QWORD PTR [rbp-0x60]
    2c9a:	mov    r9d,eax
    2c9d:	mov    eax,DWORD PTR [rbp-0x70]
    2ca0:	mov    eax,eax
    2ca2:	lea    rdx,[rax*8+0x0]
    2caa:	lea    rax,[rip+0x342f]        # 60e0 <JSON_Token_Type_strings>
    2cb1:	mov    r10,QWORD PTR [rdx+rax*1]
    2cb5:	lea    rdi,[rip+0x18fc]        # 45b8 <_IO_stdin_used+0x5b8>
    2cbc:	lea    rsi,[rip+0x17b5]        # 4478 <_IO_stdin_used+0x478>
    2cc3:	sub    rsp,0x18
    2cc7:	mov    rcx,rsp
    2cca:	mov    rax,QWORD PTR [rbp-0x70]
    2cce:	mov    rdx,QWORD PTR [rbp-0x68]
    2cd2:	mov    QWORD PTR [rcx],rax
    2cd5:	mov    QWORD PTR [rcx+0x8],rdx
    2cd9:	mov    rax,QWORD PTR [rbp-0x60]
    2cdd:	mov    QWORD PTR [rcx+0x10],rax
    2ce1:	push   r8
    2ce3:	mov    r8,r10
    2ce6:	mov    rcx,rdi
    2ce9:	mov    edx,0x18b
    2cee:	mov    edi,0x1
    2cf3:	mov    eax,0x0
    2cf8:	call   14a1 <log_message>
    2cfd:	add    rsp,0x20
  while (parser_incomplete(parser))
    2d01:	mov    rax,QWORD PTR [rbp-0xe0]
    2d08:	mov    rdi,rax
    2d0b:	call   21ef <parser_incomplete>
    2d10:	test   al,al
    2d12:	jne    2a2d <parse_json_children+0x7a>
    2d18:	jmp    2d1e <parse_json_children+0x36b>
      break;
    2d1a:	nop
    2d1b:	jmp    2d1e <parse_json_children+0x36b>
      break;
    2d1d:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2d1e:	sub    rsp,0x8
    2d22:	sub    rsp,0x38
    2d26:	mov    rax,rsp
    2d29:	mov    rcx,QWORD PTR [rbp-0x50]
    2d2d:	mov    rbx,QWORD PTR [rbp-0x48]
    2d31:	mov    QWORD PTR [rax],rcx
    2d34:	mov    QWORD PTR [rax+0x8],rbx
    2d38:	mov    rcx,QWORD PTR [rbp-0x40]
    2d3c:	mov    rbx,QWORD PTR [rbp-0x38]
    2d40:	mov    QWORD PTR [rax+0x10],rcx
    2d44:	mov    QWORD PTR [rax+0x18],rbx
    2d48:	mov    rcx,QWORD PTR [rbp-0x30]
    2d4c:	mov    rbx,QWORD PTR [rbp-0x28]
    2d50:	mov    QWORD PTR [rax+0x20],rcx
    2d54:	mov    QWORD PTR [rax+0x28],rbx
    2d58:	mov    rdx,QWORD PTR [rbp-0x20]
    2d5c:	mov    QWORD PTR [rax+0x30],rdx
    2d60:	call   205c <__profile_end_pass>
    2d65:	add    rsp,0x40

  return first_child;
    2d69:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2d70:	mov    rdx,QWORD PTR [rbp-0x18]
    2d74:	sub    rdx,QWORD PTR fs:0x28
    2d7d:	je     2d84 <parse_json_children+0x3d1>
    2d7f:	call   1060 <__stack_chk_fail@plt>
    2d84:	mov    rbx,QWORD PTR [rbp-0x8]
    2d88:	leave
    2d89:	ret

0000000000002d8a <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2d8a:	push   rbp
    2d8b:	mov    rbp,rsp
    2d8e:	push   rbx
    2d8f:	sub    rsp,0xb8
    2d96:	mov    QWORD PTR [rbp-0xa8],rdi
    2d9d:	mov    rax,rsi
    2da0:	mov    rsi,rdx
    2da3:	mov    rax,rax
    2da6:	mov    edx,0x0
    2dab:	mov    rdx,rsi
    2dae:	mov    QWORD PTR [rbp-0xc0],rax
    2db5:	mov    QWORD PTR [rbp-0xb8],rdx
    2dbc:	mov    rax,QWORD PTR fs:0x28
    2dc5:	mov    QWORD PTR [rbp-0x18],rax
    2dc9:	xor    eax,eax
  profile_begin_func();
    2dcb:	lea    rcx,[rip+0x1a66]        # 4838 <__func__.2>
    2dd2:	mov    ebx,0xa
    2dd7:	lea    rax,[rbp-0x50]
    2ddb:	mov    rsi,rcx
    2dde:	mov    rdx,rbx
    2de1:	mov    r8d,0x0
    2de7:	mov    ecx,0x3
    2dec:	mov    rdi,rax
    2def:	call   1f72 <__profile_begin_pass>

  JSON_Parser parser =
    2df4:	mov    rax,QWORD PTR [rbp-0xc0]
    2dfb:	mov    rdx,QWORD PTR [rbp-0xb8]
    2e02:	mov    QWORD PTR [rbp-0x90],rax
    2e09:	mov    QWORD PTR [rbp-0x88],rdx
    2e10:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2e18:	lea    rax,[rbp-0x70]
    2e1c:	lea    rdx,[rbp-0x90]
    2e23:	mov    rsi,rdx
    2e26:	mov    rdi,rax
    2e29:	call   229a <get_json_token>
    2e2e:	mov    ecx,0x0
    2e33:	mov    ebx,0x0
    2e38:	lea    r8,[rbp-0x90]
    2e3f:	mov    rdi,QWORD PTR [rbp-0xa8]
    2e46:	sub    rsp,0x8
    2e4a:	sub    rsp,0x18
    2e4e:	mov    rsi,rsp
    2e51:	mov    rax,QWORD PTR [rbp-0x70]
    2e55:	mov    rdx,QWORD PTR [rbp-0x68]
    2e59:	mov    QWORD PTR [rsi],rax
    2e5c:	mov    QWORD PTR [rsi+0x8],rdx
    2e60:	mov    rax,QWORD PTR [rbp-0x60]
    2e64:	mov    QWORD PTR [rsi+0x10],rax
    2e68:	mov    rdx,rcx
    2e6b:	mov    rcx,rbx
    2e6e:	mov    rsi,r8
    2e71:	call   27cc <parse_json_object>
    2e76:	add    rsp,0x20
    2e7a:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2e81:	sub    rsp,0x8
    2e85:	sub    rsp,0x38
    2e89:	mov    rax,rsp
    2e8c:	mov    rcx,QWORD PTR [rbp-0x50]
    2e90:	mov    rbx,QWORD PTR [rbp-0x48]
    2e94:	mov    QWORD PTR [rax],rcx
    2e97:	mov    QWORD PTR [rax+0x8],rbx
    2e9b:	mov    rcx,QWORD PTR [rbp-0x40]
    2e9f:	mov    rbx,QWORD PTR [rbp-0x38]
    2ea3:	mov    QWORD PTR [rax+0x10],rcx
    2ea7:	mov    QWORD PTR [rax+0x18],rbx
    2eab:	mov    rcx,QWORD PTR [rbp-0x30]
    2eaf:	mov    rbx,QWORD PTR [rbp-0x28]
    2eb3:	mov    QWORD PTR [rax+0x20],rcx
    2eb7:	mov    QWORD PTR [rax+0x28],rbx
    2ebb:	mov    rdx,QWORD PTR [rbp-0x20]
    2ebf:	mov    QWORD PTR [rax+0x30],rdx
    2ec3:	call   205c <__profile_end_pass>
    2ec8:	add    rsp,0x40

  return outer;
    2ecc:	mov    rax,QWORD PTR [rbp-0x98]
}
    2ed3:	mov    rdx,QWORD PTR [rbp-0x18]
    2ed7:	sub    rdx,QWORD PTR fs:0x28
    2ee0:	je     2ee7 <parse_json+0x15d>
    2ee2:	call   1060 <__stack_chk_fail@plt>
    2ee7:	mov    rbx,QWORD PTR [rbp-0x8]
    2eeb:	leave
    2eec:	ret

0000000000002eed <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2eed:	push   rbp
    2eee:	mov    rbp,rsp
    2ef1:	push   rbx
    2ef2:	sub    rsp,0x78
    2ef6:	mov    QWORD PTR [rbp-0x68],rdi
    2efa:	mov    rax,rsi
    2efd:	mov    rsi,rdx
    2f00:	mov    rax,rax
    2f03:	mov    edx,0x0
    2f08:	mov    rdx,rsi
    2f0b:	mov    QWORD PTR [rbp-0x80],rax
    2f0f:	mov    QWORD PTR [rbp-0x78],rdx
    2f13:	mov    rax,QWORD PTR fs:0x28
    2f1c:	mov    QWORD PTR [rbp-0x18],rax
    2f20:	xor    eax,eax
  profile_begin_func();
    2f22:	lea    rcx,[rip+0x1927]        # 4850 <__func__.1>
    2f29:	mov    ebx,0x12
    2f2e:	lea    rax,[rbp-0x50]
    2f32:	mov    rsi,rcx
    2f35:	mov    rdx,rbx
    2f38:	mov    r8d,0x0
    2f3e:	mov    ecx,0x4
    2f43:	mov    rdi,rax
    2f46:	call   1f72 <__profile_begin_pass>

  JSON_Object *result = NULL;
    2f4b:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2f53:	cmp    QWORD PTR [rbp-0x68],0x0
    2f58:	je     2fa7 <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f5a:	mov    rax,QWORD PTR [rbp-0x68]
    2f5e:	mov    rax,QWORD PTR [rax+0x20]
    2f62:	mov    QWORD PTR [rbp-0x58],rax
    2f66:	jmp    2fa0 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2f68:	mov    rax,QWORD PTR [rbp-0x58]
    2f6c:	mov    rdx,QWORD PTR [rax+0x8]
    2f70:	mov    rax,QWORD PTR [rax]
    2f73:	mov    rdi,QWORD PTR [rbp-0x80]
    2f77:	mov    rsi,QWORD PTR [rbp-0x78]
    2f7b:	mov    rcx,rdx
    2f7e:	mov    rdx,rax
    2f81:	call   143f <strings_equal>
    2f86:	test   al,al
    2f88:	je     2f94 <lookup_json_object+0xa7>
      {
        result = cursor;
    2f8a:	mov    rax,QWORD PTR [rbp-0x58]
    2f8e:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2f92:	jmp    2fa7 <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f94:	mov    rax,QWORD PTR [rbp-0x58]
    2f98:	mov    rax,QWORD PTR [rax+0x28]
    2f9c:	mov    QWORD PTR [rbp-0x58],rax
    2fa0:	cmp    QWORD PTR [rbp-0x58],0x0
    2fa5:	jne    2f68 <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2fa7:	sub    rsp,0x8
    2fab:	sub    rsp,0x38
    2faf:	mov    rax,rsp
    2fb2:	mov    rcx,QWORD PTR [rbp-0x50]
    2fb6:	mov    rbx,QWORD PTR [rbp-0x48]
    2fba:	mov    QWORD PTR [rax],rcx
    2fbd:	mov    QWORD PTR [rax+0x8],rbx
    2fc1:	mov    rcx,QWORD PTR [rbp-0x40]
    2fc5:	mov    rbx,QWORD PTR [rbp-0x38]
    2fc9:	mov    QWORD PTR [rax+0x10],rcx
    2fcd:	mov    QWORD PTR [rax+0x18],rbx
    2fd1:	mov    rcx,QWORD PTR [rbp-0x30]
    2fd5:	mov    rbx,QWORD PTR [rbp-0x28]
    2fd9:	mov    QWORD PTR [rax+0x20],rcx
    2fdd:	mov    QWORD PTR [rax+0x28],rbx
    2fe1:	mov    rdx,QWORD PTR [rbp-0x20]
    2fe5:	mov    QWORD PTR [rax+0x30],rdx
    2fe9:	call   205c <__profile_end_pass>
    2fee:	add    rsp,0x40

  return result;
    2ff2:	mov    rax,QWORD PTR [rbp-0x60]
}
    2ff6:	mov    rdx,QWORD PTR [rbp-0x18]
    2ffa:	sub    rdx,QWORD PTR fs:0x28
    3003:	je     300a <lookup_json_object+0x11d>
    3005:	call   1060 <__stack_chk_fail@plt>
    300a:	mov    rbx,QWORD PTR [rbp-0x8]
    300e:	leave
    300f:	ret

0000000000003010 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    3010:	push   rbp
    3011:	mov    rbp,rsp
    3014:	sub    rsp,0x50
    3018:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    301c:	cmp    QWORD PTR [rbp-0x48],0x0
    3021:	jne    3048 <json_object_to_f64+0x38>
    3023:	lea    rdx,[rip+0x1846]        # 4870 <__PRETTY_FUNCTION__.0>
    302a:	lea    rsi,[rip+0x1447]        # 4478 <_IO_stdin_used+0x478>
    3031:	lea    rax,[rip+0x15c0]        # 45f8 <_IO_stdin_used+0x5f8>
    3038:	mov    rcx,rdx
    303b:	mov    edx,0x1c2
    3040:	mov    rdi,rax
    3043:	call   1090 <__assert_fail@plt>

  String val = object->value;
    3048:	mov    rax,QWORD PTR [rbp-0x48]
    304c:	mov    rdx,QWORD PTR [rax+0x18]
    3050:	mov    rax,QWORD PTR [rax+0x10]
    3054:	mov    QWORD PTR [rbp-0x10],rax
    3058:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    305c:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    3064:	movsd  xmm0,QWORD PTR [rip+0x183c]        # 48a8 <__PRETTY_FUNCTION__.0+0x38>
    306c:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    3071:	mov    rax,QWORD PTR [rbp-0x8]
    3075:	cmp    QWORD PTR [rbp-0x30],rax
    3079:	jae    309f <json_object_to_f64+0x8f>
    307b:	mov    rdx,QWORD PTR [rbp-0x10]
    307f:	mov    rax,QWORD PTR [rbp-0x30]
    3083:	add    rax,rdx
    3086:	movzx  eax,BYTE PTR [rax]
    3089:	cmp    al,0x2d
    308b:	jne    309f <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    308d:	movsd  xmm0,QWORD PTR [rip+0x181b]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    3095:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    309a:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    309f:	pxor   xmm0,xmm0
    30a3:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    30a8:	jmp    30ef <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    30aa:	mov    rdx,QWORD PTR [rbp-0x10]
    30ae:	mov    rax,QWORD PTR [rbp-0x30]
    30b2:	add    rax,rdx
    30b5:	movzx  eax,BYTE PTR [rax]
    30b8:	sub    eax,0x30
    30bb:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    30be:	cmp    BYTE PTR [rbp-0x32],0x9
    30c2:	ja     30fb <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    30c4:	movsd  xmm1,QWORD PTR [rbp-0x20]
    30c9:	movsd  xmm0,QWORD PTR [rip+0x17e7]        # 48b8 <__PRETTY_FUNCTION__.0+0x48>
    30d1:	mulsd  xmm1,xmm0
    30d5:	movzx  eax,BYTE PTR [rbp-0x32]
    30d9:	pxor   xmm0,xmm0
    30dd:	cvtsi2sd xmm0,eax
    30e1:	addsd  xmm0,xmm1
    30e5:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    30ea:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    30ef:	mov    rax,QWORD PTR [rbp-0x8]
    30f3:	cmp    QWORD PTR [rbp-0x30],rax
    30f7:	jb     30aa <json_object_to_f64+0x9a>
    30f9:	jmp    30fc <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    30fb:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    30fc:	mov    rax,QWORD PTR [rbp-0x8]
    3100:	cmp    QWORD PTR [rbp-0x30],rax
    3104:	jae    3191 <json_object_to_f64+0x181>
    310a:	mov    rdx,QWORD PTR [rbp-0x10]
    310e:	mov    rax,QWORD PTR [rbp-0x30]
    3112:	add    rax,rdx
    3115:	movzx  eax,BYTE PTR [rax]
    3118:	cmp    al,0x2e
    311a:	jne    3191 <json_object_to_f64+0x181>
  {
    at += 1;
    311c:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    3121:	movsd  xmm0,QWORD PTR [rip+0x1797]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    3129:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    312e:	jmp    3184 <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3130:	mov    rdx,QWORD PTR [rbp-0x10]
    3134:	mov    rax,QWORD PTR [rbp-0x30]
    3138:	add    rax,rdx
    313b:	movzx  eax,BYTE PTR [rax]
    313e:	sub    eax,0x30
    3141:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    3144:	cmp    BYTE PTR [rbp-0x31],0x9
    3148:	ja     3190 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    314a:	movzx  eax,BYTE PTR [rbp-0x31]
    314e:	pxor   xmm0,xmm0
    3152:	cvtsi2sd xmm0,eax
    3156:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    315b:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3160:	addsd  xmm0,xmm1
    3164:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    3169:	movsd  xmm1,QWORD PTR [rbp-0x18]
    316e:	movsd  xmm0,QWORD PTR [rip+0x174a]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    3176:	mulsd  xmm0,xmm1
    317a:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    317f:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    3184:	mov    rax,QWORD PTR [rbp-0x8]
    3188:	cmp    QWORD PTR [rbp-0x30],rax
    318c:	jb     3130 <json_object_to_f64+0x120>
    318e:	jmp    3191 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    3190:	nop
      }
    }
  }

  return sign * result;
    3191:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3196:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    319b:	leave
    319c:	ret

000000000000319d <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    319d:	push   rbp
    319e:	mov    rbp,rsp
    31a1:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    31a6:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31ab:	movsd  xmm1,QWORD PTR [rip+0x1715]        # 48c8 <__PRETTY_FUNCTION__.0+0x58>
    31b3:	divsd  xmm0,xmm1
}
    31b7:	pop    rbp
    31b8:	ret

00000000000031b9 <square>:

static
f64 square(f64 x)
{
    31b9:	push   rbp
    31ba:	mov    rbp,rsp
    31bd:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    31c2:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31c7:	mulsd  xmm0,xmm0
}
    31cb:	pop    rbp
    31cc:	ret

00000000000031cd <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    31cd:	push   rbp
    31ce:	mov    rbp,rsp
    31d1:	sub    rsp,0x90
    31d8:	movsd  QWORD PTR [rbp-0x58],xmm0
    31dd:	movsd  QWORD PTR [rbp-0x60],xmm1
    31e2:	movsd  QWORD PTR [rbp-0x68],xmm2
    31e7:	movsd  QWORD PTR [rbp-0x70],xmm3
    31ec:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    31f1:	movsd  xmm0,QWORD PTR [rbp-0x60]
    31f6:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    31fb:	movsd  xmm0,QWORD PTR [rbp-0x70]
    3200:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    3205:	movsd  xmm0,QWORD PTR [rbp-0x58]
    320a:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    320f:	movsd  xmm0,QWORD PTR [rbp-0x68]
    3214:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    3219:	movsd  xmm0,QWORD PTR [rbp-0x40]
    321e:	subsd  xmm0,QWORD PTR [rbp-0x48]
    3223:	movq   rax,xmm0
    3228:	movq   xmm0,rax
    322d:	call   319d <to_radians>
    3232:	movq   rax,xmm0
    3237:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    323b:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3240:	subsd  xmm0,QWORD PTR [rbp-0x38]
    3245:	movq   rax,xmm0
    324a:	movq   xmm0,rax
    324f:	call   319d <to_radians>
    3254:	movq   rax,xmm0
    3259:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    325d:	mov    rax,QWORD PTR [rbp-0x48]
    3261:	movq   xmm0,rax
    3266:	call   319d <to_radians>
    326b:	movq   rax,xmm0
    3270:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    3274:	mov    rax,QWORD PTR [rbp-0x40]
    3278:	movq   xmm0,rax
    327d:	call   319d <to_radians>
    3282:	movq   rax,xmm0
    3287:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    328b:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3290:	movsd  xmm1,QWORD PTR [rip+0x1638]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    3298:	divsd  xmm0,xmm1
    329c:	movq   rax,xmm0
    32a1:	movq   xmm0,rax
    32a6:	call   1130 <sin@plt>
    32ab:	movq   rax,xmm0
    32b0:	movq   xmm0,rax
    32b5:	call   31b9 <square>
    32ba:	movsd  QWORD PTR [rbp-0x80],xmm0
    32bf:	mov    rax,QWORD PTR [rbp-0x48]
    32c3:	movq   xmm0,rax
    32c8:	call   10b0 <cos@plt>
    32cd:	movsd  QWORD PTR [rbp-0x88],xmm0
    32d5:	mov    rax,QWORD PTR [rbp-0x40]
    32d9:	movq   xmm0,rax
    32de:	call   10b0 <cos@plt>
    32e3:	movapd xmm5,xmm0
    32e7:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    32ef:	movsd  QWORD PTR [rbp-0x88],xmm5
    32f7:	movsd  xmm0,QWORD PTR [rbp-0x20]
    32fc:	movsd  xmm1,QWORD PTR [rip+0x15cc]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    3304:	movapd xmm6,xmm0
    3308:	divsd  xmm6,xmm1
    330c:	movq   rax,xmm6
    3311:	movq   xmm0,rax
    3316:	call   1130 <sin@plt>
    331b:	movq   rax,xmm0
    3320:	movq   xmm0,rax
    3325:	call   31b9 <square>
    332a:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    3332:	addsd  xmm0,QWORD PTR [rbp-0x80]
    3337:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    333c:	mov    rax,QWORD PTR [rbp-0x18]
    3340:	movq   xmm0,rax
    3345:	call   1160 <sqrt@plt>
    334a:	movq   rax,xmm0
    334f:	movq   xmm0,rax
    3354:	call   1140 <asin@plt>
    3359:	addsd  xmm0,xmm0
    335d:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    3362:	movsd  xmm0,QWORD PTR [rbp-0x78]
    3367:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    336c:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3371:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    3376:	leave
    3377:	ret

0000000000003378 <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    3378:	push   rbp
    3379:	mov    rbp,rsp
    337c:	movsd  QWORD PTR [rbp-0x18],xmm0
    3381:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    3386:	movsd  xmm0,QWORD PTR [rip+0x154a]        # 48d8 <__PRETTY_FUNCTION__.0+0x68>
    338e:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    3393:	movsd  xmm0,QWORD PTR [rbp-0x18]
    3398:	movq   xmm1,QWORD PTR [rip+0x1540]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    33a0:	andpd  xmm0,xmm1
    33a4:	movsd  xmm1,QWORD PTR [rbp-0x20]
    33a9:	movq   xmm2,QWORD PTR [rip+0x152f]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    33b1:	andpd  xmm2,xmm1
    33b5:	movapd xmm1,xmm0
    33b9:	subsd  xmm1,xmm2
    33bd:	movsd  xmm0,QWORD PTR [rbp-0x8]
    33c2:	comisd xmm0,xmm1
    33c6:	setae  al
    33c9:	movzx  eax,al
}
    33cc:	pop    rbp
    33cd:	ret

00000000000033ce <main>:

int main(int args_count, char **args)
{
    33ce:	push   rbp
    33cf:	mov    rbp,rsp
    33d2:	push   r15
    33d4:	push   r14
    33d6:	push   r13
    33d8:	push   r12
    33da:	push   rbx
    33db:	sub    rsp,0x268
    33e2:	mov    DWORD PTR [rbp-0x1f4],edi
    33e8:	mov    QWORD PTR [rbp-0x200],rsi
    33ef:	mov    rax,QWORD PTR fs:0x28
    33f8:	mov    QWORD PTR [rbp-0x38],rax
    33fc:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    33fe:	cmp    DWORD PTR [rbp-0x1f4],0x3
    3405:	je     3432 <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    3407:	mov    rax,QWORD PTR [rbp-0x200]
    340e:	mov    rax,QWORD PTR [rax]
    3411:	lea    rdx,[rip+0x1218]        # 4630 <_IO_stdin_used+0x630>
    3418:	mov    rsi,rax
    341b:	mov    rdi,rdx
    341e:	mov    eax,0x0
    3423:	call   1070 <printf@plt>
    return 1;
    3428:	mov    eax,0x1
    342d:	jmp    3d68 <main+0x99a>
  }

  begin_profiling();
    3432:	call   1b3d <begin_profiling>

  Arena arena = {0};
    3437:	pxor   xmm0,xmm0
    343b:	movaps XMMWORD PTR [rbp-0x150],xmm0
    3442:	movaps XMMWORD PTR [rbp-0x140],xmm0
  arena = arena_make(GB(4));
    3449:	lea    rdx,[rbp-0x220]
    3450:	movabs rax,0x100000000
    345a:	mov    rsi,rax
    345d:	mov    rdi,rdx
    3460:	call   1632 <arena_make>
    3465:	mov    rax,QWORD PTR [rbp-0x220]
    346c:	mov    rdx,QWORD PTR [rbp-0x218]
    3473:	mov    QWORD PTR [rbp-0x150],rax
    347a:	mov    QWORD PTR [rbp-0x148],rdx
    3481:	mov    rax,QWORD PTR [rbp-0x210]
    3488:	mov    rdx,QWORD PTR [rbp-0x208]
    348f:	mov    QWORD PTR [rbp-0x140],rax
    3496:	mov    QWORD PTR [rbp-0x138],rdx

  String source = {0};
    349d:	mov    QWORD PTR [rbp-0x160],0x0
    34a8:	mov    QWORD PTR [rbp-0x158],0x0
  printf("%lu", file_size(args[1]));
    34b3:	mov    rax,QWORD PTR [rbp-0x200]
    34ba:	add    rax,0x8
    34be:	mov    rax,QWORD PTR [rax]
    34c1:	mov    rdi,rax
    34c4:	call   1303 <file_size>
    34c9:	mov    rdx,rax
    34cc:	lea    rax,[rip+0x1189]        # 465c <_IO_stdin_used+0x65c>
    34d3:	mov    rsi,rdx
    34d6:	mov    rdi,rax
    34d9:	mov    eax,0x0
    34de:	call   1070 <printf@plt>
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    34e3:	mov    rax,QWORD PTR [rbp-0x200]
    34ea:	add    rax,0x8
    34ee:	mov    rax,QWORD PTR [rax]
    34f1:	mov    rdi,rax
    34f4:	call   1303 <file_size>
    34f9:	mov    rcx,rax
    34fc:	lea    r12,[rip+0x115d]        # 4660 <_IO_stdin_used+0x660>
    3503:	mov    r13d,0x4
    3509:	lea    rdi,[rbp-0x130]
    3510:	mov    rdx,r12
    3513:	mov    rax,r13
    3516:	mov    r8,rcx
    3519:	mov    ecx,0x5
    351e:	mov    rsi,rdx
    3521:	mov    rdx,rax
    3524:	call   1f72 <__profile_begin_pass>
    3529:	mov    QWORD PTR [rbp-0x1e0],0x0
    3534:	jmp    35cf <main+0x201>
  {
    source = read_file_to_arena(&arena, args[1]);
    3539:	mov    rax,QWORD PTR [rbp-0x200]
    3540:	add    rax,0x8
    3544:	mov    rdx,QWORD PTR [rax]
    3547:	lea    rax,[rbp-0x150]
    354e:	mov    rsi,rdx
    3551:	mov    rdi,rax
    3554:	call   1357 <read_file_to_arena>
    3559:	mov    QWORD PTR [rbp-0x160],rax
    3560:	mov    QWORD PTR [rbp-0x158],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    3567:	add    QWORD PTR [rbp-0x1e0],0x1
    356f:	sub    rsp,0x8
    3573:	sub    rsp,0x38
    3577:	mov    rcx,rsp
    357a:	mov    rax,QWORD PTR [rbp-0x130]
    3581:	mov    rdx,QWORD PTR [rbp-0x128]
    3588:	mov    QWORD PTR [rcx],rax
    358b:	mov    QWORD PTR [rcx+0x8],rdx
    358f:	mov    rax,QWORD PTR [rbp-0x120]
    3596:	mov    rdx,QWORD PTR [rbp-0x118]
    359d:	mov    QWORD PTR [rcx+0x10],rax
    35a1:	mov    QWORD PTR [rcx+0x18],rdx
    35a5:	mov    rax,QWORD PTR [rbp-0x110]
    35ac:	mov    rdx,QWORD PTR [rbp-0x108]
    35b3:	mov    QWORD PTR [rcx+0x20],rax
    35b7:	mov    QWORD PTR [rcx+0x28],rdx
    35bb:	mov    rax,QWORD PTR [rbp-0x100]
    35c2:	mov    QWORD PTR [rcx+0x30],rax
    35c6:	call   205c <__profile_end_pass>
    35cb:	add    rsp,0x40
    35cf:	cmp    QWORD PTR [rbp-0x1e0],0x0
    35d7:	je     3539 <main+0x16b>
  }

  usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    35dd:	mov    QWORD PTR [rbp-0x1a8],0x18
  usize max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    35e8:	mov    rax,QWORD PTR [rbp-0x158]
    35ef:	mov    edx,0x0
    35f4:	div    QWORD PTR [rbp-0x1a8]
    35fb:	mov    QWORD PTR [rbp-0x1a0],rax
  Haversine_Pair * pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    3602:	mov    rax,QWORD PTR [rbp-0x1a0]
    3609:	shl    rax,0x5
    360d:	mov    rcx,rax
    3610:	lea    rax,[rbp-0x150]
    3617:	mov    edx,0x8
    361c:	mov    rsi,rcx
    361f:	mov    rdi,rax
    3622:	call   17d3 <arena_alloc>
    3627:	mov    QWORD PTR [rbp-0x198],rax
  i32 pair_count = 0;
    362e:	mov    DWORD PTR [rbp-0x1e8],0x0

  JSON_Object *root = NULL;
    3638:	mov    QWORD PTR [rbp-0x190],0x0
  root = parse_json(&arena, source);
    3643:	mov    rcx,QWORD PTR [rbp-0x160]
    364a:	mov    rdx,QWORD PTR [rbp-0x158]
    3651:	lea    rax,[rbp-0x150]
    3658:	mov    rsi,rcx
    365b:	mov    rdi,rax
    365e:	call   2d8a <parse_json>
    3663:	mov    QWORD PTR [rbp-0x190],rax

  f64 haversine_sum = 0.0;
    366a:	pxor   xmm0,xmm0
    366e:	movsd  QWORD PTR [rbp-0x188],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    3676:	lea    r14,[rip+0xfe8]        # 4665 <_IO_stdin_used+0x665>
    367d:	mov    r15d,0x5
    3683:	mov    rcx,r14
    3686:	mov    rdx,r15
    3689:	mov    rax,QWORD PTR [rbp-0x190]
    3690:	mov    rsi,rcx
    3693:	mov    rdi,rax
    3696:	call   2eed <lookup_json_object>
    369b:	mov    QWORD PTR [rbp-0x180],rax
  if (pairs)
    36a2:	cmp    QWORD PTR [rbp-0x198],0x0
    36aa:	je     386f <main+0x4a1>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    36b0:	mov    rax,QWORD PTR [rbp-0x180]
    36b7:	mov    rax,QWORD PTR [rax+0x20]
    36bb:	mov    QWORD PTR [rbp-0x1d8],rax
    36c2:	jmp    3850 <main+0x482>
    {
      Haversine_Pair pair =
      {
        .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    36c7:	lea    rax,[rip+0xf9d]        # 466b <_IO_stdin_used+0x66b>
    36ce:	mov    QWORD PTR [rbp-0x260],rax
    36d5:	mov    QWORD PTR [rbp-0x258],0x2
    36e0:	mov    rbx,QWORD PTR [rbp-0x260]
    36e7:	mov    rsi,QWORD PTR [rbp-0x258]
    36ee:	mov    rax,rbx
    36f1:	mov    rdx,rsi
    36f4:	mov    rcx,QWORD PTR [rbp-0x1d8]
    36fb:	mov    rsi,rax
    36fe:	mov    rdi,rcx
    3701:	call   2eed <lookup_json_object>
    3706:	mov    rdi,rax
    3709:	call   3010 <json_object_to_f64>
    370e:	movq   rax,xmm0
      Haversine_Pair pair =
    3713:	mov    QWORD PTR [rbp-0x70],rax
        .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    3717:	lea    rax,[rip+0xf50]        # 466e <_IO_stdin_used+0x66e>
    371e:	mov    QWORD PTR [rbp-0x270],rax
    3725:	mov    QWORD PTR [rbp-0x268],0x2
    3730:	mov    rax,QWORD PTR [rbp-0x270]
    3737:	mov    rdx,QWORD PTR [rbp-0x268]
    373e:	mov    rcx,rax
    3741:	mov    rax,QWORD PTR [rbp-0x1d8]
    3748:	mov    rsi,rcx
    374b:	mov    rdi,rax
    374e:	call   2eed <lookup_json_object>
    3753:	mov    rdi,rax
    3756:	call   3010 <json_object_to_f64>
    375b:	movq   rax,xmm0
      Haversine_Pair pair =
    3760:	mov    QWORD PTR [rbp-0x68],rax
        .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    3764:	lea    rax,[rip+0xf06]        # 4671 <_IO_stdin_used+0x671>
    376b:	mov    QWORD PTR [rbp-0x280],rax
    3772:	mov    QWORD PTR [rbp-0x278],0x2
    377d:	mov    rax,QWORD PTR [rbp-0x280]
    3784:	mov    rdx,QWORD PTR [rbp-0x278]
    378b:	mov    rcx,rax
    378e:	mov    rax,QWORD PTR [rbp-0x1d8]
    3795:	mov    rsi,rcx
    3798:	mov    rdi,rax
    379b:	call   2eed <lookup_json_object>
    37a0:	mov    rdi,rax
    37a3:	call   3010 <json_object_to_f64>
    37a8:	movq   rax,xmm0
      Haversine_Pair pair =
    37ad:	mov    QWORD PTR [rbp-0x60],rax
        .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    37b1:	lea    rax,[rip+0xebc]        # 4674 <_IO_stdin_used+0x674>
    37b8:	mov    QWORD PTR [rbp-0x290],rax
    37bf:	mov    QWORD PTR [rbp-0x288],0x2
    37ca:	mov    rax,QWORD PTR [rbp-0x290]
    37d1:	mov    rdx,QWORD PTR [rbp-0x288]
    37d8:	mov    rcx,rax
    37db:	mov    rax,QWORD PTR [rbp-0x1d8]
    37e2:	mov    rsi,rcx
    37e5:	mov    rdi,rax
    37e8:	call   2eed <lookup_json_object>
    37ed:	mov    rdi,rax
    37f0:	call   3010 <json_object_to_f64>
    37f5:	movq   rax,xmm0
      Haversine_Pair pair =
    37fa:	mov    QWORD PTR [rbp-0x58],rax
      };

      pairs[pair_count] = pair;
    37fe:	mov    eax,DWORD PTR [rbp-0x1e8]
    3804:	cdqe
    3806:	shl    rax,0x5
    380a:	mov    rdx,rax
    380d:	mov    rax,QWORD PTR [rbp-0x198]
    3814:	lea    rcx,[rdx+rax*1]
    3818:	mov    rax,QWORD PTR [rbp-0x70]
    381c:	mov    rdx,QWORD PTR [rbp-0x68]
    3820:	mov    QWORD PTR [rcx],rax
    3823:	mov    QWORD PTR [rcx+0x8],rdx
    3827:	mov    rax,QWORD PTR [rbp-0x60]
    382b:	mov    rdx,QWORD PTR [rbp-0x58]
    382f:	mov    QWORD PTR [rcx+0x10],rax
    3833:	mov    QWORD PTR [rcx+0x18],rdx
      pair_count += 1;
    3837:	add    DWORD PTR [rbp-0x1e8],0x1
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    383e:	mov    rax,QWORD PTR [rbp-0x1d8]
    3845:	mov    rax,QWORD PTR [rax+0x28]
    3849:	mov    QWORD PTR [rbp-0x1d8],rax
    3850:	cmp    QWORD PTR [rbp-0x1d8],0x0
    3858:	je     386f <main+0x4a1>
    385a:	mov    eax,DWORD PTR [rbp-0x1e8]
    3860:	cdqe
    3862:	cmp    rax,QWORD PTR [rbp-0x1a0]
    3869:	jb     36c7 <main+0x2f9>
    }
  }

  f64 sum = 0.0;
    386f:	pxor   xmm0,xmm0
    3873:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    387b:	mov    eax,DWORD PTR [rbp-0x1e8]
    3881:	cdqe
    3883:	shl    rax,0x5
    3887:	mov    rdx,rax
    388a:	lea    rax,[rip+0xde6]        # 4677 <_IO_stdin_used+0x677>
    3891:	mov    QWORD PTR [rbp-0x230],rax
    3898:	mov    QWORD PTR [rbp-0x228],0x3
    38a3:	lea    rax,[rbp-0xf0]
    38aa:	mov    rcx,QWORD PTR [rbp-0x230]
    38b1:	mov    rbx,QWORD PTR [rbp-0x228]
    38b8:	mov    rsi,rcx
    38bb:	mov    rdi,rbx
    38be:	mov    r8,rdx
    38c1:	mov    ecx,0x6
    38c6:	mov    rdx,rdi
    38c9:	mov    rdi,rax
    38cc:	call   1f72 <__profile_begin_pass>
    38d1:	mov    QWORD PTR [rbp-0x1c8],0x0
    38dc:	jmp    3a5e <main+0x690>
  {
    for (usize i = 0; i < pair_count; i++)
    38e1:	mov    QWORD PTR [rbp-0x1c0],0x0
    38ec:	jmp    39c1 <main+0x5f3>
    {
      f64 earth_radius = 6372.8;
    38f1:	movsd  xmm0,QWORD PTR [rip+0xff7]        # 48f0 <__PRETTY_FUNCTION__.0+0x80>
    38f9:	movsd  QWORD PTR [rbp-0x170],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    3901:	mov    rax,QWORD PTR [rbp-0x1c0]
    3908:	shl    rax,0x5
    390c:	mov    rdx,rax
    390f:	mov    rax,QWORD PTR [rbp-0x198]
    3916:	add    rax,rdx
    3919:	movsd  xmm2,QWORD PTR [rax+0x18]
    391e:	mov    rax,QWORD PTR [rbp-0x1c0]
    3925:	shl    rax,0x5
    3929:	mov    rdx,rax
    392c:	mov    rax,QWORD PTR [rbp-0x198]
    3933:	add    rax,rdx
    3936:	movsd  xmm1,QWORD PTR [rax+0x10]
    393b:	mov    rax,QWORD PTR [rbp-0x1c0]
    3942:	shl    rax,0x5
    3946:	mov    rdx,rax
    3949:	mov    rax,QWORD PTR [rbp-0x198]
    3950:	add    rax,rdx
    3953:	movsd  xmm0,QWORD PTR [rax+0x8]
    3958:	mov    rax,QWORD PTR [rbp-0x1c0]
    395f:	shl    rax,0x5
    3963:	mov    rdx,rax
    3966:	mov    rax,QWORD PTR [rbp-0x198]
    396d:	add    rax,rdx
    3970:	mov    rax,QWORD PTR [rax]
    3973:	movsd  xmm3,QWORD PTR [rbp-0x170]
    397b:	movapd xmm4,xmm3
    397f:	movapd xmm3,xmm2
    3983:	movapd xmm2,xmm1
    3987:	movapd xmm1,xmm0
    398b:	movq   xmm0,rax
    3990:	call   31cd <reference_haversine>
    3995:	movq   rax,xmm0
    399a:	mov    QWORD PTR [rbp-0x168],rax
      sum += result;
    39a1:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    39a9:	addsd  xmm0,QWORD PTR [rbp-0x168]
    39b1:	movsd  QWORD PTR [rbp-0x1d0],xmm0
    for (usize i = 0; i < pair_count; i++)
    39b9:	add    QWORD PTR [rbp-0x1c0],0x1
    39c1:	mov    eax,DWORD PTR [rbp-0x1e8]
    39c7:	cdqe
    39c9:	cmp    QWORD PTR [rbp-0x1c0],rax
    39d0:	jb     38f1 <main+0x523>
    }
    sum /= pair_count;
    39d6:	pxor   xmm1,xmm1
    39da:	cvtsi2sd xmm1,DWORD PTR [rbp-0x1e8]
    39e2:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    39ea:	divsd  xmm0,xmm1
    39ee:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    39f6:	add    QWORD PTR [rbp-0x1c8],0x1
    39fe:	sub    rsp,0x8
    3a02:	sub    rsp,0x38
    3a06:	mov    rax,rsp
    3a09:	mov    rcx,QWORD PTR [rbp-0xf0]
    3a10:	mov    rbx,QWORD PTR [rbp-0xe8]
    3a17:	mov    QWORD PTR [rax],rcx
    3a1a:	mov    QWORD PTR [rax+0x8],rbx
    3a1e:	mov    rcx,QWORD PTR [rbp-0xe0]
    3a25:	mov    rbx,QWORD PTR [rbp-0xd8]
    3a2c:	mov    QWORD PTR [rax+0x10],rcx
    3a30:	mov    QWORD PTR [rax+0x18],rbx
    3a34:	mov    rcx,QWORD PTR [rbp-0xd0]
    3a3b:	mov    rbx,QWORD PTR [rbp-0xc8]
    3a42:	mov    QWORD PTR [rax+0x20],rcx
    3a46:	mov    QWORD PTR [rax+0x28],rbx
    3a4a:	mov    rdx,QWORD PTR [rbp-0xc0]
    3a51:	mov    QWORD PTR [rax+0x30],rdx
    3a55:	call   205c <__profile_end_pass>
    3a5a:	add    rsp,0x40
    3a5e:	cmp    QWORD PTR [rbp-0x1c8],0x0
    3a66:	je     38e1 <main+0x513>
  }

  PROFILE_SCOPE("check")
    3a6c:	lea    rax,[rip+0xc08]        # 467b <_IO_stdin_used+0x67b>
    3a73:	mov    QWORD PTR [rbp-0x240],rax
    3a7a:	mov    QWORD PTR [rbp-0x238],0x5
    3a85:	lea    rax,[rbp-0xb0]
    3a8c:	mov    rcx,QWORD PTR [rbp-0x240]
    3a93:	mov    rbx,QWORD PTR [rbp-0x238]
    3a9a:	mov    rsi,rcx
    3a9d:	mov    rdx,rbx
    3aa0:	mov    r8d,0x0
    3aa6:	mov    ecx,0x7
    3aab:	mov    rdi,rax
    3aae:	call   1f72 <__profile_begin_pass>
    3ab3:	mov    QWORD PTR [rbp-0x1b8],0x0
    3abe:	jmp    3c93 <main+0x8c5>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3ac3:	mov    rax,QWORD PTR [rbp-0x200]
    3aca:	add    rax,0x10
    3ace:	mov    rdx,QWORD PTR [rax]
    3ad1:	lea    rax,[rbp-0x150]
    3ad8:	mov    rsi,rdx
    3adb:	mov    rdi,rax
    3ade:	call   1357 <read_file_to_arena>
    3ae3:	mov    QWORD PTR [rbp-0x70],rax
    3ae7:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3aeb:	mov    rax,QWORD PTR [rbp-0x68]
    3aef:	cmp    rax,0xb
    3af3:	jbe    3c06 <main+0x838>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3af9:	mov    rax,QWORD PTR [rbp-0x70]
    3afd:	movsd  xmm0,QWORD PTR [rax]
    3b01:	movsd  QWORD PTR [rbp-0x178],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3b09:	mov    rax,QWORD PTR [rbp-0x70]
    3b0d:	mov    eax,DWORD PTR [rax+0x8]
    3b10:	mov    DWORD PTR [rbp-0x1e4],eax

      if (solution_pairs == pair_count)
    3b16:	mov    eax,DWORD PTR [rbp-0x1e4]
    3b1c:	cmp    eax,DWORD PTR [rbp-0x1e8]
    3b22:	jne    3bca <main+0x7fc>
      {
        if (epsilon_equal(solution_sum, sum))
    3b28:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3b30:	mov    rax,QWORD PTR [rbp-0x178]
    3b37:	movapd xmm1,xmm0
    3b3b:	movq   xmm0,rax
    3b40:	call   3378 <epsilon_equal>
    3b45:	test   eax,eax
    3b47:	je     3b8b <main+0x7bd>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3b49:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3b51:	mov    rax,QWORD PTR [rbp-0x178]
    3b58:	lea    rdx,[rip+0xb29]        # 4688 <_IO_stdin_used+0x688>
    3b5f:	lea    rsi,[rip+0xb55]        # 46bb <_IO_stdin_used+0x6bb>
    3b66:	movapd xmm1,xmm0
    3b6a:	movq   xmm0,rax
    3b6f:	mov    rcx,rdx
    3b72:	mov    edx,0x5b
    3b77:	mov    edi,0x3
    3b7c:	mov    eax,0x2
    3b81:	call   14a1 <log_message>
    3b86:	jmp    3c2e <main+0x860>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3b8b:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3b93:	mov    rax,QWORD PTR [rbp-0x178]
    3b9a:	lea    rdx,[rip+0xb2f]        # 46d0 <_IO_stdin_used+0x6d0>
    3ba1:	lea    rsi,[rip+0xb13]        # 46bb <_IO_stdin_used+0x6bb>
    3ba8:	movapd xmm1,xmm0
    3bac:	movq   xmm0,rax
    3bb1:	mov    rcx,rdx
    3bb4:	mov    edx,0x5f
    3bb9:	mov    edi,0x1
    3bbe:	mov    eax,0x2
    3bc3:	call   14a1 <log_message>
    3bc8:	jmp    3c2e <main+0x860>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3bca:	mov    esi,DWORD PTR [rbp-0x1e8]
    3bd0:	mov    ecx,DWORD PTR [rbp-0x1e4]
    3bd6:	lea    rdx,[rip+0xb2b]        # 4708 <_IO_stdin_used+0x708>
    3bdd:	lea    rax,[rip+0xad7]        # 46bb <_IO_stdin_used+0x6bb>
    3be4:	mov    r9d,esi
    3be7:	mov    r8d,ecx
    3bea:	mov    rcx,rdx
    3bed:	mov    edx,0x64
    3bf2:	mov    rsi,rax
    3bf5:	mov    edi,0x1
    3bfa:	mov    eax,0x0
    3bff:	call   14a1 <log_message>
    3c04:	jmp    3c2e <main+0x860>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3c06:	lea    rdx,[rip+0xb43]        # 4750 <_IO_stdin_used+0x750>
    3c0d:	lea    rax,[rip+0xaa7]        # 46bb <_IO_stdin_used+0x6bb>
    3c14:	mov    rcx,rdx
    3c17:	mov    edx,0x69
    3c1c:	mov    rsi,rax
    3c1f:	mov    edi,0x1
    3c24:	mov    eax,0x0
    3c29:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3c2e:	add    QWORD PTR [rbp-0x1b8],0x1
    3c36:	sub    rsp,0x8
    3c3a:	sub    rsp,0x38
    3c3e:	mov    rax,rsp
    3c41:	mov    rcx,QWORD PTR [rbp-0xb0]
    3c48:	mov    rbx,QWORD PTR [rbp-0xa8]
    3c4f:	mov    QWORD PTR [rax],rcx
    3c52:	mov    QWORD PTR [rax+0x8],rbx
    3c56:	mov    rcx,QWORD PTR [rbp-0xa0]
    3c5d:	mov    rbx,QWORD PTR [rbp-0x98]
    3c64:	mov    QWORD PTR [rax+0x10],rcx
    3c68:	mov    QWORD PTR [rax+0x18],rbx
    3c6c:	mov    rcx,QWORD PTR [rbp-0x90]
    3c73:	mov    rbx,QWORD PTR [rbp-0x88]
    3c7a:	mov    QWORD PTR [rax+0x20],rcx
    3c7e:	mov    QWORD PTR [rax+0x28],rbx
    3c82:	mov    rdx,QWORD PTR [rbp-0x80]
    3c86:	mov    QWORD PTR [rax+0x30],rdx
    3c8a:	call   205c <__profile_end_pass>
    3c8f:	add    rsp,0x40
    3c93:	cmp    QWORD PTR [rbp-0x1b8],0x0
    3c9b:	je     3ac3 <main+0x6f5>
    }
  }

  PROFILE_SCOPE("free")
    3ca1:	lea    rax,[rip+0xae3]        # 478b <_IO_stdin_used+0x78b>
    3ca8:	mov    QWORD PTR [rbp-0x250],rax
    3caf:	mov    QWORD PTR [rbp-0x248],0x4
    3cba:	lea    rax,[rbp-0x70]
    3cbe:	mov    rcx,QWORD PTR [rbp-0x250]
    3cc5:	mov    rbx,QWORD PTR [rbp-0x248]
    3ccc:	mov    rsi,rcx
    3ccf:	mov    rdx,rbx
    3cd2:	mov    r8d,0x0
    3cd8:	mov    ecx,0x8
    3cdd:	mov    rdi,rax
    3ce0:	call   1f72 <__profile_begin_pass>
    3ce5:	mov    QWORD PTR [rbp-0x1b0],0x0
    3cf0:	jmp    3d54 <main+0x986>
  {
    arena_free(&arena);
    3cf2:	lea    rax,[rbp-0x150]
    3cf9:	mov    rdi,rax
    3cfc:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3d01:	add    QWORD PTR [rbp-0x1b0],0x1
    3d09:	sub    rsp,0x8
    3d0d:	sub    rsp,0x38
    3d11:	mov    rax,rsp
    3d14:	mov    rcx,QWORD PTR [rbp-0x70]
    3d18:	mov    rbx,QWORD PTR [rbp-0x68]
    3d1c:	mov    QWORD PTR [rax],rcx
    3d1f:	mov    QWORD PTR [rax+0x8],rbx
    3d23:	mov    rcx,QWORD PTR [rbp-0x60]
    3d27:	mov    rbx,QWORD PTR [rbp-0x58]
    3d2b:	mov    QWORD PTR [rax+0x10],rcx
    3d2f:	mov    QWORD PTR [rax+0x18],rbx
    3d33:	mov    rcx,QWORD PTR [rbp-0x50]
    3d37:	mov    rbx,QWORD PTR [rbp-0x48]
    3d3b:	mov    QWORD PTR [rax+0x20],rcx
    3d3f:	mov    QWORD PTR [rax+0x28],rbx
    3d43:	mov    rdx,QWORD PTR [rbp-0x40]
    3d47:	mov    QWORD PTR [rax+0x30],rdx
    3d4b:	call   205c <__profile_end_pass>
    3d50:	add    rsp,0x40
    3d54:	cmp    QWORD PTR [rbp-0x1b0],0x0
    3d5c:	je     3cf2 <main+0x924>
  }

  end_profiling();
    3d5e:	call   1b9b <end_profiling>
    3d63:	mov    eax,0x0
}
    3d68:	mov    rdx,QWORD PTR [rbp-0x38]
    3d6c:	sub    rdx,QWORD PTR fs:0x28
    3d75:	je     3d7c <main+0x9ae>
    3d77:	call   1060 <__stack_chk_fail@plt>
    3d7c:	lea    rsp,[rbp-0x28]
    3d80:	pop    rbx
    3d81:	pop    r12
    3d83:	pop    r13
    3d85:	pop    r14
    3d87:	pop    r15
    3d89:	pop    rbp
    3d8a:	ret

Disassembly of section .fini:

0000000000003d8c <_fini>:
    3d8c:	endbr64
    3d90:	sub    rsp,0x8
    3d94:	add    rsp,0x8
    3d98:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x4fc1]        # 5fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x4fca]        # 5ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x4fcc]        # 5ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x4fca]        # 6000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x4fc2]        # 6008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x4fba]        # 6010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x4fb2]        # 6018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x4faa]        # 6020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x4fa2]        # 6028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x4f9a]        # 6030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x4f92]        # 6038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x4f8a]        # 6040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x4f82]        # 6048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x4f7a]        # 6050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x4f72]        # 6058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x4f6a]        # 6060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x4f62]        # 6068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x4f5a]        # 6070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x4f52]        # 6078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x4f4a]        # 6080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x4f42]        # 6088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x4f3a]        # 6090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x4f32]        # 6098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2229]        # 33b8 <main>
    118f:	call   QWORD PTR [rip+0x4e2b]        # 5fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x4fa1]        # 6148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x4f9a]        # 6148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x4e0e]        # 5fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x4f71]        # 6148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x4f6a]        # 6148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x4ddd]        # 5fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x4f6d],0x0        # 6188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x4dba],0x0        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x4e76]        # 60a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x4da8]        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x4f44],0x1        # 6188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x4c6e]        # 6180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x4b89]        # 60c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x4be7]        # 6160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x4b2b]        # 60c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x3097]        # 4790 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x306b]        # 4790 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fae]        # 47a8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2eaf]        # 47b8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2ccd]        # 47d0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x4639]        # 61a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x4620],rbx        # 61a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x50
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x45ee]        # 61a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x38],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x38],0x0
    1bbe:	je     1f59 <end_profiling+0x3be>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x30],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x38]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x30]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c51]        # 4888 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x30]
    1c44:	mov    rax,QWORD PTR [rbp-0x38]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x48],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x40],0x0
    1c72:	jmp    1f4b <end_profiling+0x3b0>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x40]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x450d]        # 61a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x28],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x28]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1f46 <end_profiling+0x3ab>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x28]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x38]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b77]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x20],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x28]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x28]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x28]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x28]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x20]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>

        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x28]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x28]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x28]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x38]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2a9f]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x18],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x28]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x18]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x48]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x20]
    1e2c:	movsd  QWORD PTR [rbp-0x48],xmm0

        if (zone->bytes_processed)
    1e31:	mov    rax,QWORD PTR [rbp-0x28]
    1e35:	mov    rax,QWORD PTR [rax+0x28]
    1e39:	test   rax,rax
    1e3c:	je     1f46 <end_profiling+0x3ab>
        {
          f64 megabytes = (f64)zone->bytes_processed / MB(1);
    1e42:	mov    rax,QWORD PTR [rbp-0x28]
    1e46:	mov    rax,QWORD PTR [rax+0x28]
    1e4a:	test   rax,rax
    1e4d:	js     1e5a <end_profiling+0x2bf>
    1e4f:	pxor   xmm0,xmm0
    1e53:	cvtsi2sd xmm0,rax
    1e58:	jmp    1e73 <end_profiling+0x2d8>
    1e5a:	mov    rdx,rax
    1e5d:	shr    rdx,1
    1e60:	and    eax,0x1
    1e63:	or     rdx,rax
    1e66:	pxor   xmm0,xmm0
    1e6a:	cvtsi2sd xmm0,rdx
    1e6f:	addsd  xmm0,xmm0
    1e73:	movsd  xmm1,QWORD PTR [rip+0x2a1d]        # 4898 <__PRETTY_FUNCTION__.0+0x28>
    1e7b:	divsd  xmm0,xmm1
    1e7f:	movsd  QWORD PTR [rbp-0x10],xmm0

          f64 gb_per_s = (f64)zone->bytes_processed / ((f64)zone->elapsed_inclusive / (f64)freq);
    1e84:	mov    rax,QWORD PTR [rbp-0x28]
    1e88:	mov    rax,QWORD PTR [rax+0x28]
    1e8c:	test   rax,rax
    1e8f:	js     1e9c <end_profiling+0x301>
    1e91:	pxor   xmm0,xmm0
    1e95:	cvtsi2sd xmm0,rax
    1e9a:	jmp    1eb5 <end_profiling+0x31a>
    1e9c:	mov    rdx,rax
    1e9f:	shr    rdx,1
    1ea2:	and    eax,0x1
    1ea5:	or     rdx,rax
    1ea8:	pxor   xmm0,xmm0
    1eac:	cvtsi2sd xmm0,rdx
    1eb1:	addsd  xmm0,xmm0
    1eb5:	mov    rax,QWORD PTR [rbp-0x28]
    1eb9:	mov    rax,QWORD PTR [rax+0x18]
    1ebd:	test   rax,rax
    1ec0:	js     1ecd <end_profiling+0x332>
    1ec2:	pxor   xmm1,xmm1
    1ec6:	cvtsi2sd xmm1,rax
    1ecb:	jmp    1ee6 <end_profiling+0x34b>
    1ecd:	mov    rdx,rax
    1ed0:	shr    rdx,1
    1ed3:	and    eax,0x1
    1ed6:	or     rdx,rax
    1ed9:	pxor   xmm1,xmm1
    1edd:	cvtsi2sd xmm1,rdx
    1ee2:	addsd  xmm1,xmm1
    1ee6:	mov    rax,QWORD PTR [rbp-0x30]
    1eea:	test   rax,rax
    1eed:	js     1efa <end_profiling+0x35f>
    1eef:	pxor   xmm2,xmm2
    1ef3:	cvtsi2sd xmm2,rax
    1ef8:	jmp    1f13 <end_profiling+0x378>
    1efa:	mov    rdx,rax
    1efd:	shr    rdx,1
    1f00:	and    eax,0x1
    1f03:	or     rdx,rax
    1f06:	pxor   xmm2,xmm2
    1f0a:	cvtsi2sd xmm2,rdx
    1f0f:	addsd  xmm2,xmm2
    1f13:	divsd  xmm1,xmm2
    1f17:	divsd  xmm0,xmm1
    1f1b:	movsd  QWORD PTR [rbp-0x8],xmm0

          printf("  Megabytes Processed: %f @ %f GB/s\n", megabytes, gb_per_s);
    1f20:	movsd  xmm0,QWORD PTR [rbp-0x8]
    1f25:	mov    rax,QWORD PTR [rbp-0x10]
    1f29:	lea    rdx,[rip+0x2418]        # 4348 <_IO_stdin_used+0x348>
    1f30:	movapd xmm1,xmm0
    1f34:	movq   xmm0,rax
    1f39:	mov    rdi,rdx
    1f3c:	mov    eax,0x2
    1f41:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1f46:	add    QWORD PTR [rbp-0x40],0x1
    1f4b:	cmp    QWORD PTR [rbp-0x40],0xfff
    1f53:	jbe    1c77 <end_profiling+0xdc>
        }
      }
    }
  }
}
    1f59:	nop
    1f5a:	leave
    1f5b:	ret

0000000000001f5c <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1f5c:	push   rbp
    1f5d:	mov    rbp,rsp
    1f60:	push   rbx
    1f61:	sub    rsp,0x78
    1f65:	mov    QWORD PTR [rbp-0x58],rdi
    1f69:	mov    rax,rsi
    1f6c:	mov    rsi,rdx
    1f6f:	mov    rax,rax
    1f72:	mov    edx,0x0
    1f77:	mov    rdx,rsi
    1f7a:	mov    QWORD PTR [rbp-0x70],rax
    1f7e:	mov    QWORD PTR [rbp-0x68],rdx
    1f82:	mov    QWORD PTR [rbp-0x60],rcx
    1f86:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1f8a:	pxor   xmm0,xmm0
    1f8e:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1f92:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1f96:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1f9a:	movq   QWORD PTR [rbp-0x20],xmm0
    1f9f:	mov    rax,QWORD PTR [rbp-0x70]
    1fa3:	mov    rdx,QWORD PTR [rbp-0x68]
    1fa7:	mov    QWORD PTR [rbp-0x50],rax
    1fab:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1faf:	mov    rdx,QWORD PTR [rbp-0x60]
    1fb3:	mov    rax,rdx
    1fb6:	add    rax,rax
    1fb9:	add    rax,rdx
    1fbc:	shl    rax,0x4
    1fc0:	mov    rdx,rax
    1fc3:	lea    rax,[rip+0x41fe]        # 61c8 <g_profiler+0x28>
    1fca:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1fce:	mov    QWORD PTR [rbp-0x38],rax
    1fd2:	mov    rax,QWORD PTR [rbp-0x60]
    1fd6:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1fda:	mov    rax,QWORD PTR [rip+0x41c7]        # 61a8 <g_profiler+0x8>
  Profile_Pass pass =
    1fe1:	mov    QWORD PTR [rbp-0x28],rax
    1fe5:	mov    rax,QWORD PTR [rbp-0x78]
    1fe9:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    1fed:	mov    rax,QWORD PTR [rbp-0x60]
    1ff1:	mov    QWORD PTR [rip+0x41b0],rax        # 61a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    1ff8:	call   1a48 <read_cpu_timer>
    1ffd:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    2001:	mov    rax,QWORD PTR [rbp-0x58]
    2005:	mov    rcx,QWORD PTR [rbp-0x50]
    2009:	mov    rbx,QWORD PTR [rbp-0x48]
    200d:	mov    QWORD PTR [rax],rcx
    2010:	mov    QWORD PTR [rax+0x8],rbx
    2014:	mov    rcx,QWORD PTR [rbp-0x40]
    2018:	mov    rbx,QWORD PTR [rbp-0x38]
    201c:	mov    QWORD PTR [rax+0x10],rcx
    2020:	mov    QWORD PTR [rax+0x18],rbx
    2024:	mov    rcx,QWORD PTR [rbp-0x30]
    2028:	mov    rbx,QWORD PTR [rbp-0x28]
    202c:	mov    QWORD PTR [rax+0x20],rcx
    2030:	mov    QWORD PTR [rax+0x28],rbx
    2034:	mov    rdx,QWORD PTR [rbp-0x20]
    2038:	mov    QWORD PTR [rax+0x30],rdx
}
    203c:	mov    rax,QWORD PTR [rbp-0x58]
    2040:	mov    rbx,QWORD PTR [rbp-0x8]
    2044:	leave
    2045:	ret

0000000000002046 <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    2046:	push   rbp
    2047:	mov    rbp,rsp
    204a:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    204e:	call   1a48 <read_cpu_timer>
    2053:	mov    rdx,rax
    2056:	mov    rax,QWORD PTR [rbp+0x20]
    205a:	sub    rdx,rax
    205d:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    2061:	mov    rax,QWORD PTR [rbp+0x38]
    2065:	mov    QWORD PTR [rip+0x413c],rax        # 61a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    206c:	mov    rdx,QWORD PTR [rbp+0x30]
    2070:	mov    rax,rdx
    2073:	add    rax,rax
    2076:	add    rax,rdx
    2079:	shl    rax,0x4
    207d:	lea    rdx,[rax+0x10]
    2081:	lea    rax,[rip+0x4118]        # 61a0 <g_profiler>
    2088:	add    rax,rdx
    208b:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    208f:	mov    rax,QWORD PTR [rbp-0x10]
    2093:	mov    rdx,QWORD PTR [rax+0x10]
    2097:	mov    rax,QWORD PTR [rbp-0x18]
    209b:	add    rdx,rax
    209e:	mov    rax,QWORD PTR [rbp-0x10]
    20a2:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    20a6:	mov    rax,QWORD PTR [rbp-0x10]
    20aa:	mov    rax,QWORD PTR [rax+0x20]
    20ae:	lea    rdx,[rax+0x1]
    20b2:	mov    rax,QWORD PTR [rbp-0x10]
    20b6:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    20ba:	mov    rcx,QWORD PTR [rbp-0x10]
    20be:	mov    rax,QWORD PTR [rbp+0x10]
    20c2:	mov    rdx,QWORD PTR [rbp+0x18]
    20c6:	mov    QWORD PTR [rcx],rax
    20c9:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    20cd:	mov    rdx,QWORD PTR [rbp+0x28]
    20d1:	mov    rax,QWORD PTR [rbp-0x18]
    20d5:	add    rdx,rax
    20d8:	mov    rax,QWORD PTR [rbp-0x10]
    20dc:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    20e0:	mov    rax,QWORD PTR [rbp-0x10]
    20e4:	mov    rdx,QWORD PTR [rax+0x28]
    20e8:	mov    rax,QWORD PTR [rbp+0x40]
    20ec:	add    rdx,rax
    20ef:	mov    rax,QWORD PTR [rbp-0x10]
    20f3:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    20f7:	mov    rdx,QWORD PTR [rbp+0x38]
    20fb:	mov    rax,rdx
    20fe:	add    rax,rax
    2101:	add    rax,rdx
    2104:	shl    rax,0x4
    2108:	lea    rdx,[rax+0x10]
    210c:	lea    rax,[rip+0x408d]        # 61a0 <g_profiler>
    2113:	add    rax,rdx
    2116:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    211a:	mov    rax,QWORD PTR [rbp-0x8]
    211e:	mov    rax,QWORD PTR [rax+0x10]
    2122:	sub    rax,QWORD PTR [rbp-0x18]
    2126:	mov    rdx,rax
    2129:	mov    rax,QWORD PTR [rbp-0x8]
    212d:	mov    QWORD PTR [rax+0x10],rdx
}
    2131:	nop
    2132:	leave
    2133:	ret

0000000000002134 <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    2134:	push   rbp
    2135:	mov    rbp,rsp
    2138:	sub    rsp,0x10
    213c:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    2140:	mov    rax,QWORD PTR [rbp-0x8]
    2144:	mov    rdx,QWORD PTR [rax+0x10]
    2148:	mov    rax,QWORD PTR [rbp-0x8]
    214c:	mov    rax,QWORD PTR [rax+0x8]
    2150:	cmp    rdx,rax
    2153:	jb     217a <parser_at+0x46>
    2155:	lea    rdx,[rip+0x268c]        # 47e8 <__PRETTY_FUNCTION__.5>
    215c:	lea    rsi,[rip+0x2315]        # 4478 <_IO_stdin_used+0x478>
    2163:	lea    rax,[rip+0x2326]        # 4490 <_IO_stdin_used+0x490>
    216a:	mov    rcx,rdx
    216d:	mov    edx,0x2f
    2172:	mov    rdi,rax
    2175:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    217a:	mov    rax,QWORD PTR [rbp-0x8]
    217e:	mov    rdx,QWORD PTR [rax]
    2181:	mov    rax,QWORD PTR [rbp-0x8]
    2185:	mov    rax,QWORD PTR [rax+0x10]
    2189:	add    rax,rdx
}
    218c:	leave
    218d:	ret

000000000000218e <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    218e:	push   rbp
    218f:	mov    rbp,rsp
    2192:	sub    rsp,0x10
    2196:	mov    QWORD PTR [rbp-0x8],rdi
    219a:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    219e:	mov    rax,QWORD PTR [rbp-0x8]
    21a2:	mov    rdi,rax
    21a5:	call   2134 <parser_at>
    21aa:	mov    rdx,QWORD PTR [rbp-0x10]
    21ae:	add    rax,rdx
}
    21b1:	leave
    21b2:	ret

00000000000021b3 <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    21b3:	push   rbp
    21b4:	mov    rbp,rsp
    21b7:	mov    QWORD PTR [rbp-0x8],rdi
    21bb:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    21bf:	mov    rax,QWORD PTR [rbp-0x8]
    21c3:	mov    rdx,QWORD PTR [rax+0x10]
    21c7:	mov    rax,QWORD PTR [rbp-0x10]
    21cb:	add    rdx,rax
    21ce:	mov    rax,QWORD PTR [rbp-0x8]
    21d2:	mov    QWORD PTR [rax+0x10],rdx
}
    21d6:	nop
    21d7:	pop    rbp
    21d8:	ret

00000000000021d9 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    21d9:	push   rbp
    21da:	mov    rbp,rsp
    21dd:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    21e1:	mov    rax,QWORD PTR [rbp-0x8]
    21e5:	mov    rdx,QWORD PTR [rax+0x10]
    21e9:	mov    rax,QWORD PTR [rbp-0x8]
    21ed:	mov    rax,QWORD PTR [rax+0x8]
    21f1:	cmp    rdx,rax
    21f4:	setb   al
}
    21f7:	pop    rbp
    21f8:	ret

00000000000021f9 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    21f9:	push   rbp
    21fa:	mov    rbp,rsp
    21fd:	push   r12
    21ff:	push   rbx
    2200:	sub    rsp,0x20
    2204:	mov    QWORD PTR [rbp-0x18],rdi
    2208:	mov    rax,rsi
    220b:	mov    rcx,rdx
    220e:	mov    rax,rax
    2211:	mov    edx,0x0
    2216:	mov    rdx,rcx
    2219:	mov    QWORD PTR [rbp-0x30],rax
    221d:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    2221:	mov    rax,QWORD PTR [rbp-0x28]
    2225:	mov    r12,rax
    2228:	mov    rbx,QWORD PTR [rbp-0x30]
    222c:	mov    rax,QWORD PTR [rbp-0x18]
    2230:	mov    rdi,rax
    2233:	call   2134 <parser_at>
    2238:	mov    rdx,r12
    223b:	mov    rsi,rbx
    223e:	mov    rdi,rax
    2241:	call   10d0 <memcmp@plt>
    2246:	test   eax,eax
    2248:	sete   al
}
    224b:	add    rsp,0x20
    224f:	pop    rbx
    2250:	pop    r12
    2252:	pop    rbp
    2253:	ret

0000000000002254 <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    2254:	push   rbp
    2255:	mov    rbp,rsp
    2258:	mov    eax,edi
    225a:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    225d:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    2261:	movzx  eax,BYTE PTR [rbp-0x14]
    2265:	cmp    eax,0x2e
    2268:	jg     2271 <is_numeric+0x1d>
    226a:	cmp    eax,0x2d
    226d:	jge    2279 <is_numeric+0x25>
    226f:	jmp    227e <is_numeric+0x2a>
    2271:	sub    eax,0x30
    2274:	cmp    eax,0x9
    2277:	ja     227e <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2279:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    227d:	nop
  }


  return result;
    227e:	movzx  eax,BYTE PTR [rbp-0x1]
}
    2282:	pop    rbp
    2283:	ret

0000000000002284 <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    2284:	push   rbp
    2285:	mov    rbp,rsp
    2288:	sub    rsp,0x50
    228c:	mov    QWORD PTR [rbp-0x48],rdi
    2290:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    2294:	pxor   xmm0,xmm0
    2298:	movaps XMMWORD PTR [rbp-0x20],xmm0
    229c:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    22a1:	jmp    22b4 <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    22a3:	mov    rax,QWORD PTR [rbp-0x50]
    22a7:	mov    esi,0x1
    22ac:	mov    rdi,rax
    22af:	call   21b3 <parser_advance>
  while (parser_incomplete(parser)  &&
    22b4:	mov    rax,QWORD PTR [rbp-0x50]
    22b8:	mov    rdi,rax
    22bb:	call   21d9 <parser_incomplete>
    22c0:	test   al,al
    22c2:	je     2310 <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    22c4:	mov    rax,QWORD PTR [rbp-0x50]
    22c8:	mov    rdi,rax
    22cb:	call   2134 <parser_at>
    22d0:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    22d3:	cmp    al,0x20
    22d5:	je     22a3 <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    22d7:	mov    rax,QWORD PTR [rbp-0x50]
    22db:	mov    rdi,rax
    22de:	call   2134 <parser_at>
    22e3:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    22e6:	cmp    al,0xa
    22e8:	je     22a3 <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    22ea:	mov    rax,QWORD PTR [rbp-0x50]
    22ee:	mov    rdi,rax
    22f1:	call   2134 <parser_at>
    22f6:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    22f9:	cmp    al,0xd
    22fb:	je     22a3 <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    22fd:	mov    rax,QWORD PTR [rbp-0x50]
    2301:	mov    rdi,rax
    2304:	call   2134 <parser_at>
    2309:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    230c:	cmp    al,0x9
    230e:	je     22a3 <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    2310:	mov    rax,QWORD PTR [rbp-0x50]
    2314:	mov    rdi,rax
    2317:	call   21d9 <parser_incomplete>
    231c:	test   al,al
    231e:	je     274b <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    2324:	mov    rax,QWORD PTR [rbp-0x50]
    2328:	mov    rdi,rax
    232b:	call   2134 <parser_at>
    2330:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    2334:	mov    rax,QWORD PTR [rbp-0x50]
    2338:	mov    rdi,rax
    233b:	call   2134 <parser_at>
    2340:	movzx  eax,BYTE PTR [rax]
    2343:	movzx  eax,al
    2346:	cmp    eax,0x7d
    2349:	je     2436 <get_json_token+0x1b2>
    234f:	cmp    eax,0x7d
    2352:	jg     275c <get_json_token+0x4d8>
    2358:	cmp    eax,0x7b
    235b:	je     2411 <get_json_token+0x18d>
    2361:	cmp    eax,0x7b
    2364:	jg     275c <get_json_token+0x4d8>
    236a:	cmp    eax,0x74
    236d:	je     25b9 <get_json_token+0x335>
    2373:	cmp    eax,0x74
    2376:	jg     275c <get_json_token+0x4d8>
    237c:	cmp    eax,0x6e
    237f:	je     26c9 <get_json_token+0x445>
    2385:	cmp    eax,0x6e
    2388:	jg     275c <get_json_token+0x4d8>
    238e:	cmp    eax,0x66
    2391:	je     2641 <get_json_token+0x3bd>
    2397:	cmp    eax,0x66
    239a:	jg     275c <get_json_token+0x4d8>
    23a0:	cmp    eax,0x5d
    23a3:	je     2480 <get_json_token+0x1fc>
    23a9:	cmp    eax,0x5d
    23ac:	jg     275c <get_json_token+0x4d8>
    23b2:	cmp    eax,0x5b
    23b5:	je     245b <get_json_token+0x1d7>
    23bb:	cmp    eax,0x5b
    23be:	jg     275c <get_json_token+0x4d8>
    23c4:	cmp    eax,0x3a
    23c7:	je     24ca <get_json_token+0x246>
    23cd:	cmp    eax,0x3a
    23d0:	jg     275c <get_json_token+0x4d8>
    23d6:	cmp    eax,0x39
    23d9:	jg     275c <get_json_token+0x4d8>
    23df:	cmp    eax,0x30
    23e2:	jge    2568 <get_json_token+0x2e4>
    23e8:	cmp    eax,0x2e
    23eb:	jg     275c <get_json_token+0x4d8>
    23f1:	cmp    eax,0x2d
    23f4:	jge    2568 <get_json_token+0x2e4>
    23fa:	cmp    eax,0x22
    23fd:	je     24ef <get_json_token+0x26b>
    2403:	cmp    eax,0x2c
    2406:	je     24a5 <get_json_token+0x221>
    240c:	jmp    275c <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    2411:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    2418:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2420:	mov    rax,QWORD PTR [rbp-0x50]
    2424:	mov    esi,0x1
    2429:	mov    rdi,rax
    242c:	call   21b3 <parser_advance>
      }
      break;
    2431:	jmp    275c <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2436:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    243d:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2445:	mov    rax,QWORD PTR [rbp-0x50]
    2449:	mov    esi,0x1
    244e:	mov    rdi,rax
    2451:	call   21b3 <parser_advance>
      }
      break;
    2456:	jmp    275c <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    245b:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    2462:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    246a:	mov    rax,QWORD PTR [rbp-0x50]
    246e:	mov    esi,0x1
    2473:	mov    rdi,rax
    2476:	call   21b3 <parser_advance>
      }
      break;
    247b:	jmp    275c <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    2480:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    2487:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    248f:	mov    rax,QWORD PTR [rbp-0x50]
    2493:	mov    esi,0x1
    2498:	mov    rdi,rax
    249b:	call   21b3 <parser_advance>
      }
      break;
    24a0:	jmp    275c <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    24a5:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    24ac:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24b4:	mov    rax,QWORD PTR [rbp-0x50]
    24b8:	mov    esi,0x1
    24bd:	mov    rdi,rax
    24c0:	call   21b3 <parser_advance>
      }
      break;
    24c5:	jmp    275c <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    24ca:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    24d1:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24d9:	mov    rax,QWORD PTR [rbp-0x50]
    24dd:	mov    esi,0x1
    24e2:	mov    rdi,rax
    24e5:	call   21b3 <parser_advance>
      }
      break;
    24ea:	jmp    275c <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    24ef:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    24f6:	mov    rax,QWORD PTR [rbp-0x50]
    24fa:	mov    esi,0x1
    24ff:	mov    rdi,rax
    2502:	call   21b3 <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    2507:	mov    rax,QWORD PTR [rbp-0x50]
    250b:	mov    rdi,rax
    250e:	call   2134 <parser_at>
    2513:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    2517:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    251f:	jmp    2537 <get_json_token+0x2b3>
        {
          string_count += 1;
    2521:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    2526:	mov    rax,QWORD PTR [rbp-0x50]
    252a:	mov    esi,0x1
    252f:	mov    rdi,rax
    2532:	call   21b3 <parser_advance>
        while (*parser_at(parser) != '"')
    2537:	mov    rax,QWORD PTR [rbp-0x50]
    253b:	mov    rdi,rax
    253e:	call   2134 <parser_at>
    2543:	movzx  eax,BYTE PTR [rax]
    2546:	cmp    al,0x22
    2548:	jne    2521 <get_json_token+0x29d>
        }
        token.value.count = string_count;
    254a:	mov    rax,QWORD PTR [rbp-0x40]
    254e:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    2552:	mov    rax,QWORD PTR [rbp-0x50]
    2556:	mov    esi,0x1
    255b:	mov    rdi,rax
    255e:	call   21b3 <parser_advance>
      }
      break;
    2563:	jmp    275c <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2568:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    256f:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2577:	jmp    258f <get_json_token+0x30b>
        {
          digit_count += 1;
    2579:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    257e:	mov    rax,QWORD PTR [rbp-0x50]
    2582:	mov    esi,0x1
    2587:	mov    rdi,rax
    258a:	call   21b3 <parser_advance>
        while (is_numeric(*parser_at(parser)))
    258f:	mov    rax,QWORD PTR [rbp-0x50]
    2593:	mov    rdi,rax
    2596:	call   2134 <parser_at>
    259b:	movzx  eax,BYTE PTR [rax]
    259e:	movzx  eax,al
    25a1:	mov    edi,eax
    25a3:	call   2254 <is_numeric>
    25a8:	test   al,al
    25aa:	jne    2579 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    25ac:	mov    rax,QWORD PTR [rbp-0x38]
    25b0:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    25b4:	jmp    275c <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    25b9:	lea    rax,[rip+0x1f1c]        # 44dc <_IO_stdin_used+0x4dc>
    25c0:	mov    QWORD PTR [rbp-0x30],rax
    25c4:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25cc:	mov    rcx,QWORD PTR [rbp-0x30]
    25d0:	mov    rdx,QWORD PTR [rbp-0x28]
    25d4:	mov    rax,QWORD PTR [rbp-0x50]
    25d8:	mov    rsi,rcx
    25db:	mov    rdi,rax
    25de:	call   21f9 <parser_token_is_literal>
    25e3:	test   al,al
    25e5:	je     2609 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    25e7:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    25ee:	mov    rax,QWORD PTR [rbp-0x28]
    25f2:	mov    rdx,rax
    25f5:	mov    rax,QWORD PTR [rbp-0x50]
    25f9:	mov    rsi,rdx
    25fc:	mov    rdi,rax
    25ff:	call   21b3 <parser_advance>
    2604:	jmp    275c <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2609:	mov    rax,QWORD PTR [rbp-0x50]
    260d:	mov    rcx,QWORD PTR [rax+0x10]
    2611:	lea    rdx,[rip+0x1ed0]        # 44e8 <_IO_stdin_used+0x4e8>
    2618:	lea    rax,[rip+0x1e59]        # 4478 <_IO_stdin_used+0x478>
    261f:	mov    r8,rcx
    2622:	mov    rcx,rdx
    2625:	mov    edx,0xdf
    262a:	mov    rsi,rax
    262d:	mov    edi,0x1
    2632:	mov    eax,0x0
    2637:	call   14a1 <log_message>
        }
      }
      break;
    263c:	jmp    275c <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    2641:	lea    rax,[rip+0x1ecd]        # 4515 <_IO_stdin_used+0x515>
    2648:	mov    QWORD PTR [rbp-0x30],rax
    264c:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    2654:	mov    rcx,QWORD PTR [rbp-0x30]
    2658:	mov    rdx,QWORD PTR [rbp-0x28]
    265c:	mov    rax,QWORD PTR [rbp-0x50]
    2660:	mov    rsi,rcx
    2663:	mov    rdi,rax
    2666:	call   21f9 <parser_token_is_literal>
    266b:	test   al,al
    266d:	je     2691 <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    266f:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    2676:	mov    rax,QWORD PTR [rbp-0x28]
    267a:	mov    rdx,rax
    267d:	mov    rax,QWORD PTR [rbp-0x50]
    2681:	mov    rsi,rdx
    2684:	mov    rdi,rax
    2687:	call   21b3 <parser_advance>
    268c:	jmp    275c <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2691:	mov    rax,QWORD PTR [rbp-0x50]
    2695:	mov    rcx,QWORD PTR [rax+0x10]
    2699:	lea    rdx,[rip+0x1e48]        # 44e8 <_IO_stdin_used+0x4e8>
    26a0:	lea    rax,[rip+0x1dd1]        # 4478 <_IO_stdin_used+0x478>
    26a7:	mov    r8,rcx
    26aa:	mov    rcx,rdx
    26ad:	mov    edx,0xee
    26b2:	mov    rsi,rax
    26b5:	mov    edi,0x1
    26ba:	mov    eax,0x0
    26bf:	call   14a1 <log_message>
        }
      }
      break;
    26c4:	jmp    275c <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    26c9:	lea    rax,[rip+0x1e4b]        # 451b <_IO_stdin_used+0x51b>
    26d0:	mov    QWORD PTR [rbp-0x30],rax
    26d4:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    26dc:	mov    rcx,QWORD PTR [rbp-0x30]
    26e0:	mov    rdx,QWORD PTR [rbp-0x28]
    26e4:	mov    rax,QWORD PTR [rbp-0x50]
    26e8:	mov    rsi,rcx
    26eb:	mov    rdi,rax
    26ee:	call   21f9 <parser_token_is_literal>
    26f3:	test   al,al
    26f5:	je     2716 <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    26f7:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    26fe:	mov    rax,QWORD PTR [rbp-0x28]
    2702:	mov    rdx,rax
    2705:	mov    rax,QWORD PTR [rbp-0x50]
    2709:	mov    rsi,rdx
    270c:	mov    rdi,rax
    270f:	call   21b3 <parser_advance>
    2714:	jmp    275c <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2716:	mov    rax,QWORD PTR [rbp-0x50]
    271a:	mov    rcx,QWORD PTR [rax+0x10]
    271e:	lea    rdx,[rip+0x1dc3]        # 44e8 <_IO_stdin_used+0x4e8>
    2725:	lea    rax,[rip+0x1d4c]        # 4478 <_IO_stdin_used+0x478>
    272c:	mov    r8,rcx
    272f:	mov    rcx,rdx
    2732:	mov    edx,0xfd
    2737:	mov    rsi,rax
    273a:	mov    edi,0x1
    273f:	mov    eax,0x0
    2744:	call   14a1 <log_message>
        }
      }
      break;
    2749:	jmp    275c <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    274b:	mov    rax,QWORD PTR [rbp-0x50]
    274f:	mov    esi,0x1
    2754:	mov    rdi,rax
    2757:	call   21b3 <parser_advance>
  }

  return token;
    275c:	mov    rcx,QWORD PTR [rbp-0x48]
    2760:	mov    rax,QWORD PTR [rbp-0x20]
    2764:	mov    rdx,QWORD PTR [rbp-0x18]
    2768:	mov    QWORD PTR [rcx],rax
    276b:	mov    QWORD PTR [rcx+0x8],rdx
    276f:	mov    rax,QWORD PTR [rbp-0x10]
    2773:	mov    QWORD PTR [rcx+0x10],rax
}
    2777:	mov    rax,QWORD PTR [rbp-0x48]
    277b:	leave
    277c:	ret

000000000000277d <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    277d:	push   rbp
    277e:	mov    rbp,rsp
    2781:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    2784:	cmp    DWORD PTR [rbp-0x14],0x7
    2788:	je     27a2 <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    278a:	cmp    DWORD PTR [rbp-0x14],0x9
    278e:	je     27a2 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    2790:	cmp    DWORD PTR [rbp-0x14],0xa
    2794:	je     27a2 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    2796:	cmp    DWORD PTR [rbp-0x14],0xb
    279a:	je     27a2 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    279c:	cmp    DWORD PTR [rbp-0x14],0x8
    27a0:	jne    27a9 <json_token_type_is_value_type+0x2c>
    27a2:	mov    eax,0x1
    27a7:	jmp    27ae <json_token_type_is_value_type+0x31>
    27a9:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    27ae:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    27b1:	mov    eax,DWORD PTR [rbp-0x4]
}
    27b4:	pop    rbp
    27b5:	ret

00000000000027b6 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    27b6:	push   rbp
    27b7:	mov    rbp,rsp
    27ba:	push   rbx
    27bb:	sub    rsp,0x88
    27c2:	mov    QWORD PTR [rbp-0x78],rdi
    27c6:	mov    QWORD PTR [rbp-0x80],rsi
    27ca:	mov    QWORD PTR [rbp-0x90],rdx
    27d1:	mov    QWORD PTR [rbp-0x88],rcx
    27d8:	mov    rax,QWORD PTR fs:0x28
    27e1:	mov    QWORD PTR [rbp-0x18],rax
    27e5:	xor    eax,eax
  profile_begin_func();
    27e7:	lea    r8,[rip+0x2012]        # 4800 <__func__.4>
    27ee:	mov    r9d,0x11
    27f4:	lea    rax,[rbp-0x50]
    27f8:	mov    rsi,r8
    27fb:	mov    rdx,r9
    27fe:	mov    r8d,0x0
    2804:	mov    ecx,0x1
    2809:	mov    rdi,rax
    280c:	call   1f5c <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    2811:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2819:	mov    eax,DWORD PTR [rbp+0x10]
    281c:	cmp    eax,0x1
    281f:	jne    284b <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    2821:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    2828:	mov    edx,DWORD PTR [rbp-0x64]
    282b:	mov    rsi,QWORD PTR [rbp-0x80]
    282f:	mov    rax,QWORD PTR [rbp-0x78]
    2833:	mov    ecx,edx
    2835:	mov    edx,0x2
    283a:	mov    rdi,rax
    283d:	call   299d <parse_json_children>
    2842:	mov    QWORD PTR [rbp-0x60],rax
    2846:	jmp    28d5 <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    284b:	mov    eax,DWORD PTR [rbp+0x10]
    284e:	cmp    eax,0x3
    2851:	jne    287a <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    2853:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    285a:	mov    edx,DWORD PTR [rbp-0x68]
    285d:	mov    rsi,QWORD PTR [rbp-0x80]
    2861:	mov    rax,QWORD PTR [rbp-0x78]
    2865:	mov    ecx,edx
    2867:	mov    edx,0x4
    286c:	mov    rdi,rax
    286f:	call   299d <parse_json_children>
    2874:	mov    QWORD PTR [rbp-0x60],rax
    2878:	jmp    28d5 <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    287a:	mov    eax,DWORD PTR [rbp+0x10]
    287d:	mov    edi,eax
    287f:	call   277d <json_token_type_is_value_type>
    2884:	test   eax,eax
    2886:	jne    28d5 <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2888:	mov    eax,DWORD PTR [rbp+0x10]
    288b:	mov    eax,eax
    288d:	lea    rdx,[rax*8+0x0]
    2895:	lea    rax,[rip+0x3844]        # 60e0 <JSON_Token_Type_strings>
    289c:	mov    rcx,QWORD PTR [rdx+rax*1]
    28a0:	lea    rdx,[rip+0x1c79]        # 4520 <_IO_stdin_used+0x520>
    28a7:	lea    rax,[rip+0x1bca]        # 4478 <_IO_stdin_used+0x478>
    28ae:	push   QWORD PTR [rbp+0x20]
    28b1:	push   QWORD PTR [rbp+0x18]
    28b4:	mov    r8,rcx
    28b7:	mov    rcx,rdx
    28ba:	mov    edx,0x134
    28bf:	mov    rsi,rax
    28c2:	mov    edi,0x1
    28c7:	mov    eax,0x0
    28cc:	call   14a1 <log_message>
    28d1:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    28d5:	mov    rax,QWORD PTR [rbp-0x78]
    28d9:	mov    edx,0x8
    28de:	mov    esi,0x30
    28e3:	mov    rdi,rax
    28e6:	call   17d3 <arena_alloc>
    28eb:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    28ef:	mov    rcx,QWORD PTR [rbp-0x58]
    28f3:	mov    rax,QWORD PTR [rbp-0x90]
    28fa:	mov    rdx,QWORD PTR [rbp-0x88]
    2901:	mov    QWORD PTR [rcx],rax
    2904:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    2908:	mov    rax,QWORD PTR [rbp-0x58]
    290c:	mov    rdx,QWORD PTR [rbp-0x60]
    2910:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    2914:	mov    rax,QWORD PTR [rbp-0x58]
    2918:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    2920:	mov    rcx,QWORD PTR [rbp-0x58]
    2924:	mov    rax,QWORD PTR [rbp+0x18]
    2928:	mov    rdx,QWORD PTR [rbp+0x20]
    292c:	mov    QWORD PTR [rcx+0x10],rax
    2930:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    2934:	sub    rsp,0x8
    2938:	sub    rsp,0x38
    293c:	mov    rax,rsp
    293f:	mov    rcx,QWORD PTR [rbp-0x50]
    2943:	mov    rbx,QWORD PTR [rbp-0x48]
    2947:	mov    QWORD PTR [rax],rcx
    294a:	mov    QWORD PTR [rax+0x8],rbx
    294e:	mov    rcx,QWORD PTR [rbp-0x40]
    2952:	mov    rbx,QWORD PTR [rbp-0x38]
    2956:	mov    QWORD PTR [rax+0x10],rcx
    295a:	mov    QWORD PTR [rax+0x18],rbx
    295e:	mov    rcx,QWORD PTR [rbp-0x30]
    2962:	mov    rbx,QWORD PTR [rbp-0x28]
    2966:	mov    QWORD PTR [rax+0x20],rcx
    296a:	mov    QWORD PTR [rax+0x28],rbx
    296e:	mov    rdx,QWORD PTR [rbp-0x20]
    2972:	mov    QWORD PTR [rax+0x30],rdx
    2976:	call   2046 <__profile_end_pass>
    297b:	add    rsp,0x40

  return result;
    297f:	mov    rax,QWORD PTR [rbp-0x58]
}
    2983:	mov    rdx,QWORD PTR [rbp-0x18]
    2987:	sub    rdx,QWORD PTR fs:0x28
    2990:	je     2997 <parse_json_object+0x1e1>
    2992:	call   1060 <__stack_chk_fail@plt>
    2997:	mov    rbx,QWORD PTR [rbp-0x8]
    299b:	leave
    299c:	ret

000000000000299d <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    299d:	push   rbp
    299e:	mov    rbp,rsp
    29a1:	push   rbx
    29a2:	sub    rsp,0x108
    29a9:	mov    QWORD PTR [rbp-0xd8],rdi
    29b0:	mov    QWORD PTR [rbp-0xe0],rsi
    29b7:	mov    DWORD PTR [rbp-0xe4],edx
    29bd:	mov    DWORD PTR [rbp-0xe8],ecx
    29c3:	mov    rax,QWORD PTR fs:0x28
    29cc:	mov    QWORD PTR [rbp-0x18],rax
    29d0:	xor    eax,eax
  profile_begin_func();
    29d2:	lea    r8,[rip+0x1e47]        # 4820 <__func__.3>
    29d9:	mov    r9d,0x13
    29df:	lea    rax,[rbp-0x50]
    29e3:	mov    rsi,r8
    29e6:	mov    rdx,r9
    29e9:	mov    r8d,0x0
    29ef:	mov    ecx,0x2
    29f4:	mov    rdi,rax
    29f7:	call   1f5c <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    29fc:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    2a07:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2a12:	jmp    2ceb <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2a17:	pxor   xmm0,xmm0
    2a1b:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2a22:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2a2a:	pxor   xmm0,xmm0
    2a2e:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2a35:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2a3a:	cmp    DWORD PTR [rbp-0xe8],0x0
    2a41:	je     2b4e <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2a47:	lea    rax,[rbp-0xb0]
    2a4e:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a55:	mov    rsi,rdx
    2a58:	mov    rdi,rax
    2a5b:	call   2284 <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2a60:	mov    eax,DWORD PTR [rbp-0xb0]
    2a66:	cmp    eax,0x7
    2a69:	jne    2aea <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2a6b:	lea    rax,[rbp-0x70]
    2a6f:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a76:	mov    rsi,rdx
    2a79:	mov    rdi,rax
    2a7c:	call   2284 <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2a81:	mov    eax,DWORD PTR [rbp-0x70]
    2a84:	cmp    eax,0x6
    2a87:	jne    2aa7 <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2a89:	lea    rax,[rbp-0x90]
    2a90:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a97:	mov    rsi,rdx
    2a9a:	mov    rdi,rax
    2a9d:	call   2284 <get_json_token>
    2aa2:	jmp    2b8e <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2aa7:	mov    rcx,QWORD PTR [rbp-0xa8]
    2aae:	mov    rax,QWORD PTR [rbp-0xa0]
    2ab5:	mov    esi,eax
    2ab7:	lea    rdx,[rip+0x1ab2]        # 4570 <_IO_stdin_used+0x570>
    2abe:	lea    rax,[rip+0x19b3]        # 4478 <_IO_stdin_used+0x478>
    2ac5:	mov    r9,rcx
    2ac8:	mov    r8d,esi
    2acb:	mov    rcx,rdx
    2ace:	mov    edx,0x15f
    2ad3:	mov    rsi,rax
    2ad6:	mov    edi,0x1
    2adb:	mov    eax,0x0
    2ae0:	call   14a1 <log_message>
    2ae5:	jmp    2b8e <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2aea:	mov    rcx,QWORD PTR [rbp-0xa8]
    2af1:	mov    rax,QWORD PTR [rbp-0xa0]
    2af8:	mov    edi,eax
    2afa:	mov    eax,DWORD PTR [rbp-0xb0]
    2b00:	mov    eax,eax
    2b02:	lea    rdx,[rax*8+0x0]
    2b0a:	lea    rax,[rip+0x35cf]        # 60e0 <JSON_Token_Type_strings>
    2b11:	mov    rsi,QWORD PTR [rdx+rax*1]
    2b15:	lea    rdx,[rip+0x1a74]        # 4590 <_IO_stdin_used+0x590>
    2b1c:	lea    rax,[rip+0x1955]        # 4478 <_IO_stdin_used+0x478>
    2b23:	sub    rsp,0x8
    2b27:	push   rcx
    2b28:	mov    r9d,edi
    2b2b:	mov    r8,rsi
    2b2e:	mov    rcx,rdx
    2b31:	mov    edx,0x164
    2b36:	mov    rsi,rax
    2b39:	mov    edi,0x1
    2b3e:	mov    eax,0x0
    2b43:	call   14a1 <log_message>
    2b48:	add    rsp,0x10
    2b4c:	jmp    2b8e <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2b4e:	lea    rax,[rbp-0x110]
    2b55:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b5c:	mov    rsi,rdx
    2b5f:	mov    rdi,rax
    2b62:	call   2284 <get_json_token>
    2b67:	mov    rax,QWORD PTR [rbp-0x110]
    2b6e:	mov    rdx,QWORD PTR [rbp-0x108]
    2b75:	mov    QWORD PTR [rbp-0x90],rax
    2b7c:	mov    QWORD PTR [rbp-0x88],rdx
    2b83:	mov    rax,QWORD PTR [rbp-0x100]
    2b8a:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2b8e:	mov    eax,DWORD PTR [rbp-0x90]
    2b94:	cmp    DWORD PTR [rbp-0xe4],eax
    2b9a:	je     2d04 <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2ba0:	mov    rax,QWORD PTR [rbp-0xa8]
    2ba7:	mov    rdx,QWORD PTR [rbp-0xa0]
    2bae:	mov    r8,QWORD PTR [rbp-0xe0]
    2bb5:	mov    rdi,QWORD PTR [rbp-0xd8]
    2bbc:	sub    rsp,0x8
    2bc0:	sub    rsp,0x18
    2bc4:	mov    rsi,rsp
    2bc7:	mov    rcx,QWORD PTR [rbp-0x90]
    2bce:	mov    rbx,QWORD PTR [rbp-0x88]
    2bd5:	mov    QWORD PTR [rsi],rcx
    2bd8:	mov    QWORD PTR [rsi+0x8],rbx
    2bdc:	mov    rcx,QWORD PTR [rbp-0x80]
    2be0:	mov    QWORD PTR [rsi+0x10],rcx
    2be4:	mov    rcx,rdx
    2be7:	mov    rdx,rax
    2bea:	mov    rsi,r8
    2bed:	call   27b6 <parse_json_object>
    2bf2:	add    rsp,0x20
    2bf6:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2bfd:	cmp    QWORD PTR [rbp-0xb8],0x0
    2c05:	je     2c4f <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2c07:	cmp    QWORD PTR [rbp-0xc8],0x0
    2c0f:	jne    2c2f <parse_json_children+0x292>
      {
        first_child        = object;
    2c11:	mov    rax,QWORD PTR [rbp-0xb8]
    2c18:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2c1f:	mov    rax,QWORD PTR [rbp-0xb8]
    2c26:	mov    QWORD PTR [rbp-0xc0],rax
    2c2d:	jmp    2c4f <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2c2f:	mov    rax,QWORD PTR [rbp-0xc0]
    2c36:	mov    rdx,QWORD PTR [rbp-0xb8]
    2c3d:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2c41:	mov    rax,QWORD PTR [rbp-0xb8]
    2c48:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2c4f:	lea    rax,[rbp-0x70]
    2c53:	mov    rdx,QWORD PTR [rbp-0xe0]
    2c5a:	mov    rsi,rdx
    2c5d:	mov    rdi,rax
    2c60:	call   2284 <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2c65:	mov    eax,DWORD PTR [rbp-0x70]
    2c68:	cmp    DWORD PTR [rbp-0xe4],eax
    2c6e:	je     2d07 <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2c74:	mov    eax,DWORD PTR [rbp-0x70]
    2c77:	cmp    eax,0x5
    2c7a:	je     2ceb <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2c7c:	mov    r8,QWORD PTR [rbp-0x68]
    2c80:	mov    rax,QWORD PTR [rbp-0x60]
    2c84:	mov    r9d,eax
    2c87:	mov    eax,DWORD PTR [rbp-0x70]
    2c8a:	mov    eax,eax
    2c8c:	lea    rdx,[rax*8+0x0]
    2c94:	lea    rax,[rip+0x3445]        # 60e0 <JSON_Token_Type_strings>
    2c9b:	mov    r10,QWORD PTR [rdx+rax*1]
    2c9f:	lea    rdi,[rip+0x1912]        # 45b8 <_IO_stdin_used+0x5b8>
    2ca6:	lea    rsi,[rip+0x17cb]        # 4478 <_IO_stdin_used+0x478>
    2cad:	sub    rsp,0x18
    2cb1:	mov    rcx,rsp
    2cb4:	mov    rax,QWORD PTR [rbp-0x70]
    2cb8:	mov    rdx,QWORD PTR [rbp-0x68]
    2cbc:	mov    QWORD PTR [rcx],rax
    2cbf:	mov    QWORD PTR [rcx+0x8],rdx
    2cc3:	mov    rax,QWORD PTR [rbp-0x60]
    2cc7:	mov    QWORD PTR [rcx+0x10],rax
    2ccb:	push   r8
    2ccd:	mov    r8,r10
    2cd0:	mov    rcx,rdi
    2cd3:	mov    edx,0x18b
    2cd8:	mov    edi,0x1
    2cdd:	mov    eax,0x0
    2ce2:	call   14a1 <log_message>
    2ce7:	add    rsp,0x20
  while (parser_incomplete(parser))
    2ceb:	mov    rax,QWORD PTR [rbp-0xe0]
    2cf2:	mov    rdi,rax
    2cf5:	call   21d9 <parser_incomplete>
    2cfa:	test   al,al
    2cfc:	jne    2a17 <parse_json_children+0x7a>
    2d02:	jmp    2d08 <parse_json_children+0x36b>
      break;
    2d04:	nop
    2d05:	jmp    2d08 <parse_json_children+0x36b>
      break;
    2d07:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2d08:	sub    rsp,0x8
    2d0c:	sub    rsp,0x38
    2d10:	mov    rax,rsp
    2d13:	mov    rcx,QWORD PTR [rbp-0x50]
    2d17:	mov    rbx,QWORD PTR [rbp-0x48]
    2d1b:	mov    QWORD PTR [rax],rcx
    2d1e:	mov    QWORD PTR [rax+0x8],rbx
    2d22:	mov    rcx,QWORD PTR [rbp-0x40]
    2d26:	mov    rbx,QWORD PTR [rbp-0x38]
    2d2a:	mov    QWORD PTR [rax+0x10],rcx
    2d2e:	mov    QWORD PTR [rax+0x18],rbx
    2d32:	mov    rcx,QWORD PTR [rbp-0x30]
    2d36:	mov    rbx,QWORD PTR [rbp-0x28]
    2d3a:	mov    QWORD PTR [rax+0x20],rcx
    2d3e:	mov    QWORD PTR [rax+0x28],rbx
    2d42:	mov    rdx,QWORD PTR [rbp-0x20]
    2d46:	mov    QWORD PTR [rax+0x30],rdx
    2d4a:	call   2046 <__profile_end_pass>
    2d4f:	add    rsp,0x40

  return first_child;
    2d53:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2d5a:	mov    rdx,QWORD PTR [rbp-0x18]
    2d5e:	sub    rdx,QWORD PTR fs:0x28
    2d67:	je     2d6e <parse_json_children+0x3d1>
    2d69:	call   1060 <__stack_chk_fail@plt>
    2d6e:	mov    rbx,QWORD PTR [rbp-0x8]
    2d72:	leave
    2d73:	ret

0000000000002d74 <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2d74:	push   rbp
    2d75:	mov    rbp,rsp
    2d78:	push   rbx
    2d79:	sub    rsp,0xb8
    2d80:	mov    QWORD PTR [rbp-0xa8],rdi
    2d87:	mov    rax,rsi
    2d8a:	mov    rsi,rdx
    2d8d:	mov    rax,rax
    2d90:	mov    edx,0x0
    2d95:	mov    rdx,rsi
    2d98:	mov    QWORD PTR [rbp-0xc0],rax
    2d9f:	mov    QWORD PTR [rbp-0xb8],rdx
    2da6:	mov    rax,QWORD PTR fs:0x28
    2daf:	mov    QWORD PTR [rbp-0x18],rax
    2db3:	xor    eax,eax
  profile_begin_func();
    2db5:	lea    rcx,[rip+0x1a7c]        # 4838 <__func__.2>
    2dbc:	mov    ebx,0xa
    2dc1:	lea    rax,[rbp-0x50]
    2dc5:	mov    rsi,rcx
    2dc8:	mov    rdx,rbx
    2dcb:	mov    r8d,0x0
    2dd1:	mov    ecx,0x3
    2dd6:	mov    rdi,rax
    2dd9:	call   1f5c <__profile_begin_pass>

  JSON_Parser parser =
    2dde:	mov    rax,QWORD PTR [rbp-0xc0]
    2de5:	mov    rdx,QWORD PTR [rbp-0xb8]
    2dec:	mov    QWORD PTR [rbp-0x90],rax
    2df3:	mov    QWORD PTR [rbp-0x88],rdx
    2dfa:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2e02:	lea    rax,[rbp-0x70]
    2e06:	lea    rdx,[rbp-0x90]
    2e0d:	mov    rsi,rdx
    2e10:	mov    rdi,rax
    2e13:	call   2284 <get_json_token>
    2e18:	mov    ecx,0x0
    2e1d:	mov    ebx,0x0
    2e22:	lea    r8,[rbp-0x90]
    2e29:	mov    rdi,QWORD PTR [rbp-0xa8]
    2e30:	sub    rsp,0x8
    2e34:	sub    rsp,0x18
    2e38:	mov    rsi,rsp
    2e3b:	mov    rax,QWORD PTR [rbp-0x70]
    2e3f:	mov    rdx,QWORD PTR [rbp-0x68]
    2e43:	mov    QWORD PTR [rsi],rax
    2e46:	mov    QWORD PTR [rsi+0x8],rdx
    2e4a:	mov    rax,QWORD PTR [rbp-0x60]
    2e4e:	mov    QWORD PTR [rsi+0x10],rax
    2e52:	mov    rdx,rcx
    2e55:	mov    rcx,rbx
    2e58:	mov    rsi,r8
    2e5b:	call   27b6 <parse_json_object>
    2e60:	add    rsp,0x20
    2e64:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2e6b:	sub    rsp,0x8
    2e6f:	sub    rsp,0x38
    2e73:	mov    rax,rsp
    2e76:	mov    rcx,QWORD PTR [rbp-0x50]
    2e7a:	mov    rbx,QWORD PTR [rbp-0x48]
    2e7e:	mov    QWORD PTR [rax],rcx
    2e81:	mov    QWORD PTR [rax+0x8],rbx
    2e85:	mov    rcx,QWORD PTR [rbp-0x40]
    2e89:	mov    rbx,QWORD PTR [rbp-0x38]
    2e8d:	mov    QWORD PTR [rax+0x10],rcx
    2e91:	mov    QWORD PTR [rax+0x18],rbx
    2e95:	mov    rcx,QWORD PTR [rbp-0x30]
    2e99:	mov    rbx,QWORD PTR [rbp-0x28]
    2e9d:	mov    QWORD PTR [rax+0x20],rcx
    2ea1:	mov    QWORD PTR [rax+0x28],rbx
    2ea5:	mov    rdx,QWORD PTR [rbp-0x20]
    2ea9:	mov    QWORD PTR [rax+0x30],rdx
    2ead:	call   2046 <__profile_end_pass>
    2eb2:	add    rsp,0x40

  return outer;
    2eb6:	mov    rax,QWORD PTR [rbp-0x98]
}
    2ebd:	mov    rdx,QWORD PTR [rbp-0x18]
    2ec1:	sub    rdx,QWORD PTR fs:0x28
    2eca:	je     2ed1 <parse_json+0x15d>
    2ecc:	call   1060 <__stack_chk_fail@plt>
    2ed1:	mov    rbx,QWORD PTR [rbp-0x8]
    2ed5:	leave
    2ed6:	ret

0000000000002ed7 <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2ed7:	push   rbp
    2ed8:	mov    rbp,rsp
    2edb:	push   rbx
    2edc:	sub    rsp,0x78
    2ee0:	mov    QWORD PTR [rbp-0x68],rdi
    2ee4:	mov    rax,rsi
    2ee7:	mov    rsi,rdx
    2eea:	mov    rax,rax
    2eed:	mov    edx,0x0
    2ef2:	mov    rdx,rsi
    2ef5:	mov    QWORD PTR [rbp-0x80],rax
    2ef9:	mov    QWORD PTR [rbp-0x78],rdx
    2efd:	mov    rax,QWORD PTR fs:0x28
    2f06:	mov    QWORD PTR [rbp-0x18],rax
    2f0a:	xor    eax,eax
  profile_begin_func();
    2f0c:	lea    rcx,[rip+0x193d]        # 4850 <__func__.1>
    2f13:	mov    ebx,0x12
    2f18:	lea    rax,[rbp-0x50]
    2f1c:	mov    rsi,rcx
    2f1f:	mov    rdx,rbx
    2f22:	mov    r8d,0x0
    2f28:	mov    ecx,0x4
    2f2d:	mov    rdi,rax
    2f30:	call   1f5c <__profile_begin_pass>

  JSON_Object *result = NULL;
    2f35:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2f3d:	cmp    QWORD PTR [rbp-0x68],0x0
    2f42:	je     2f91 <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f44:	mov    rax,QWORD PTR [rbp-0x68]
    2f48:	mov    rax,QWORD PTR [rax+0x20]
    2f4c:	mov    QWORD PTR [rbp-0x58],rax
    2f50:	jmp    2f8a <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2f52:	mov    rax,QWORD PTR [rbp-0x58]
    2f56:	mov    rdx,QWORD PTR [rax+0x8]
    2f5a:	mov    rax,QWORD PTR [rax]
    2f5d:	mov    rdi,QWORD PTR [rbp-0x80]
    2f61:	mov    rsi,QWORD PTR [rbp-0x78]
    2f65:	mov    rcx,rdx
    2f68:	mov    rdx,rax
    2f6b:	call   143f <strings_equal>
    2f70:	test   al,al
    2f72:	je     2f7e <lookup_json_object+0xa7>
      {
        result = cursor;
    2f74:	mov    rax,QWORD PTR [rbp-0x58]
    2f78:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2f7c:	jmp    2f91 <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f7e:	mov    rax,QWORD PTR [rbp-0x58]
    2f82:	mov    rax,QWORD PTR [rax+0x28]
    2f86:	mov    QWORD PTR [rbp-0x58],rax
    2f8a:	cmp    QWORD PTR [rbp-0x58],0x0
    2f8f:	jne    2f52 <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2f91:	sub    rsp,0x8
    2f95:	sub    rsp,0x38
    2f99:	mov    rax,rsp
    2f9c:	mov    rcx,QWORD PTR [rbp-0x50]
    2fa0:	mov    rbx,QWORD PTR [rbp-0x48]
    2fa4:	mov    QWORD PTR [rax],rcx
    2fa7:	mov    QWORD PTR [rax+0x8],rbx
    2fab:	mov    rcx,QWORD PTR [rbp-0x40]
    2faf:	mov    rbx,QWORD PTR [rbp-0x38]
    2fb3:	mov    QWORD PTR [rax+0x10],rcx
    2fb7:	mov    QWORD PTR [rax+0x18],rbx
    2fbb:	mov    rcx,QWORD PTR [rbp-0x30]
    2fbf:	mov    rbx,QWORD PTR [rbp-0x28]
    2fc3:	mov    QWORD PTR [rax+0x20],rcx
    2fc7:	mov    QWORD PTR [rax+0x28],rbx
    2fcb:	mov    rdx,QWORD PTR [rbp-0x20]
    2fcf:	mov    QWORD PTR [rax+0x30],rdx
    2fd3:	call   2046 <__profile_end_pass>
    2fd8:	add    rsp,0x40

  return result;
    2fdc:	mov    rax,QWORD PTR [rbp-0x60]
}
    2fe0:	mov    rdx,QWORD PTR [rbp-0x18]
    2fe4:	sub    rdx,QWORD PTR fs:0x28
    2fed:	je     2ff4 <lookup_json_object+0x11d>
    2fef:	call   1060 <__stack_chk_fail@plt>
    2ff4:	mov    rbx,QWORD PTR [rbp-0x8]
    2ff8:	leave
    2ff9:	ret

0000000000002ffa <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    2ffa:	push   rbp
    2ffb:	mov    rbp,rsp
    2ffe:	sub    rsp,0x50
    3002:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    3006:	cmp    QWORD PTR [rbp-0x48],0x0
    300b:	jne    3032 <json_object_to_f64+0x38>
    300d:	lea    rdx,[rip+0x185c]        # 4870 <__PRETTY_FUNCTION__.0>
    3014:	lea    rsi,[rip+0x145d]        # 4478 <_IO_stdin_used+0x478>
    301b:	lea    rax,[rip+0x15d6]        # 45f8 <_IO_stdin_used+0x5f8>
    3022:	mov    rcx,rdx
    3025:	mov    edx,0x1c2
    302a:	mov    rdi,rax
    302d:	call   1090 <__assert_fail@plt>

  String val = object->value;
    3032:	mov    rax,QWORD PTR [rbp-0x48]
    3036:	mov    rdx,QWORD PTR [rax+0x18]
    303a:	mov    rax,QWORD PTR [rax+0x10]
    303e:	mov    QWORD PTR [rbp-0x10],rax
    3042:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    3046:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    304e:	movsd  xmm0,QWORD PTR [rip+0x184a]        # 48a0 <__PRETTY_FUNCTION__.0+0x30>
    3056:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    305b:	mov    rax,QWORD PTR [rbp-0x8]
    305f:	cmp    QWORD PTR [rbp-0x30],rax
    3063:	jae    3089 <json_object_to_f64+0x8f>
    3065:	mov    rdx,QWORD PTR [rbp-0x10]
    3069:	mov    rax,QWORD PTR [rbp-0x30]
    306d:	add    rax,rdx
    3070:	movzx  eax,BYTE PTR [rax]
    3073:	cmp    al,0x2d
    3075:	jne    3089 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    3077:	movsd  xmm0,QWORD PTR [rip+0x1829]        # 48a8 <__PRETTY_FUNCTION__.0+0x38>
    307f:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    3084:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    3089:	pxor   xmm0,xmm0
    308d:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    3092:	jmp    30d9 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    3094:	mov    rdx,QWORD PTR [rbp-0x10]
    3098:	mov    rax,QWORD PTR [rbp-0x30]
    309c:	add    rax,rdx
    309f:	movzx  eax,BYTE PTR [rax]
    30a2:	sub    eax,0x30
    30a5:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    30a8:	cmp    BYTE PTR [rbp-0x32],0x9
    30ac:	ja     30e5 <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    30ae:	movsd  xmm1,QWORD PTR [rbp-0x20]
    30b3:	movsd  xmm0,QWORD PTR [rip+0x17f5]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    30bb:	mulsd  xmm1,xmm0
    30bf:	movzx  eax,BYTE PTR [rbp-0x32]
    30c3:	pxor   xmm0,xmm0
    30c7:	cvtsi2sd xmm0,eax
    30cb:	addsd  xmm0,xmm1
    30cf:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    30d4:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    30d9:	mov    rax,QWORD PTR [rbp-0x8]
    30dd:	cmp    QWORD PTR [rbp-0x30],rax
    30e1:	jb     3094 <json_object_to_f64+0x9a>
    30e3:	jmp    30e6 <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    30e5:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    30e6:	mov    rax,QWORD PTR [rbp-0x8]
    30ea:	cmp    QWORD PTR [rbp-0x30],rax
    30ee:	jae    317b <json_object_to_f64+0x181>
    30f4:	mov    rdx,QWORD PTR [rbp-0x10]
    30f8:	mov    rax,QWORD PTR [rbp-0x30]
    30fc:	add    rax,rdx
    30ff:	movzx  eax,BYTE PTR [rax]
    3102:	cmp    al,0x2e
    3104:	jne    317b <json_object_to_f64+0x181>
  {
    at += 1;
    3106:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    310b:	movsd  xmm0,QWORD PTR [rip+0x17a5]        # 48b8 <__PRETTY_FUNCTION__.0+0x48>
    3113:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    3118:	jmp    316e <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    311a:	mov    rdx,QWORD PTR [rbp-0x10]
    311e:	mov    rax,QWORD PTR [rbp-0x30]
    3122:	add    rax,rdx
    3125:	movzx  eax,BYTE PTR [rax]
    3128:	sub    eax,0x30
    312b:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    312e:	cmp    BYTE PTR [rbp-0x31],0x9
    3132:	ja     317a <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    3134:	movzx  eax,BYTE PTR [rbp-0x31]
    3138:	pxor   xmm0,xmm0
    313c:	cvtsi2sd xmm0,eax
    3140:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    3145:	movsd  xmm1,QWORD PTR [rbp-0x20]
    314a:	addsd  xmm0,xmm1
    314e:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    3153:	movsd  xmm1,QWORD PTR [rbp-0x18]
    3158:	movsd  xmm0,QWORD PTR [rip+0x1758]        # 48b8 <__PRETTY_FUNCTION__.0+0x48>
    3160:	mulsd  xmm0,xmm1
    3164:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3169:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    316e:	mov    rax,QWORD PTR [rbp-0x8]
    3172:	cmp    QWORD PTR [rbp-0x30],rax
    3176:	jb     311a <json_object_to_f64+0x120>
    3178:	jmp    317b <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    317a:	nop
      }
    }
  }

  return sign * result;
    317b:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3180:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    3185:	leave
    3186:	ret

0000000000003187 <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    3187:	push   rbp
    3188:	mov    rbp,rsp
    318b:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    3190:	movsd  xmm0,QWORD PTR [rbp-0x8]
    3195:	movsd  xmm1,QWORD PTR [rip+0x1723]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    319d:	divsd  xmm0,xmm1
}
    31a1:	pop    rbp
    31a2:	ret

00000000000031a3 <square>:

static
f64 square(f64 x)
{
    31a3:	push   rbp
    31a4:	mov    rbp,rsp
    31a7:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    31ac:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31b1:	mulsd  xmm0,xmm0
}
    31b5:	pop    rbp
    31b6:	ret

00000000000031b7 <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    31b7:	push   rbp
    31b8:	mov    rbp,rsp
    31bb:	sub    rsp,0x90
    31c2:	movsd  QWORD PTR [rbp-0x58],xmm0
    31c7:	movsd  QWORD PTR [rbp-0x60],xmm1
    31cc:	movsd  QWORD PTR [rbp-0x68],xmm2
    31d1:	movsd  QWORD PTR [rbp-0x70],xmm3
    31d6:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    31db:	movsd  xmm0,QWORD PTR [rbp-0x60]
    31e0:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    31e5:	movsd  xmm0,QWORD PTR [rbp-0x70]
    31ea:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    31ef:	movsd  xmm0,QWORD PTR [rbp-0x58]
    31f4:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    31f9:	movsd  xmm0,QWORD PTR [rbp-0x68]
    31fe:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    3203:	movsd  xmm0,QWORD PTR [rbp-0x40]
    3208:	subsd  xmm0,QWORD PTR [rbp-0x48]
    320d:	movq   rax,xmm0
    3212:	movq   xmm0,rax
    3217:	call   3187 <to_radians>
    321c:	movq   rax,xmm0
    3221:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    3225:	movsd  xmm0,QWORD PTR [rbp-0x30]
    322a:	subsd  xmm0,QWORD PTR [rbp-0x38]
    322f:	movq   rax,xmm0
    3234:	movq   xmm0,rax
    3239:	call   3187 <to_radians>
    323e:	movq   rax,xmm0
    3243:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    3247:	mov    rax,QWORD PTR [rbp-0x48]
    324b:	movq   xmm0,rax
    3250:	call   3187 <to_radians>
    3255:	movq   rax,xmm0
    325a:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    325e:	mov    rax,QWORD PTR [rbp-0x40]
    3262:	movq   xmm0,rax
    3267:	call   3187 <to_radians>
    326c:	movq   rax,xmm0
    3271:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    3275:	movsd  xmm0,QWORD PTR [rbp-0x28]
    327a:	movsd  xmm1,QWORD PTR [rip+0x1646]        # 48c8 <__PRETTY_FUNCTION__.0+0x58>
    3282:	divsd  xmm0,xmm1
    3286:	movq   rax,xmm0
    328b:	movq   xmm0,rax
    3290:	call   1130 <sin@plt>
    3295:	movq   rax,xmm0
    329a:	movq   xmm0,rax
    329f:	call   31a3 <square>
    32a4:	movsd  QWORD PTR [rbp-0x80],xmm0
    32a9:	mov    rax,QWORD PTR [rbp-0x48]
    32ad:	movq   xmm0,rax
    32b2:	call   10b0 <cos@plt>
    32b7:	movsd  QWORD PTR [rbp-0x88],xmm0
    32bf:	mov    rax,QWORD PTR [rbp-0x40]
    32c3:	movq   xmm0,rax
    32c8:	call   10b0 <cos@plt>
    32cd:	movapd xmm5,xmm0
    32d1:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    32d9:	movsd  QWORD PTR [rbp-0x88],xmm5
    32e1:	movsd  xmm0,QWORD PTR [rbp-0x20]
    32e6:	movsd  xmm1,QWORD PTR [rip+0x15da]        # 48c8 <__PRETTY_FUNCTION__.0+0x58>
    32ee:	movapd xmm6,xmm0
    32f2:	divsd  xmm6,xmm1
    32f6:	movq   rax,xmm6
    32fb:	movq   xmm0,rax
    3300:	call   1130 <sin@plt>
    3305:	movq   rax,xmm0
    330a:	movq   xmm0,rax
    330f:	call   31a3 <square>
    3314:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    331c:	addsd  xmm0,QWORD PTR [rbp-0x80]
    3321:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    3326:	mov    rax,QWORD PTR [rbp-0x18]
    332a:	movq   xmm0,rax
    332f:	call   1160 <sqrt@plt>
    3334:	movq   rax,xmm0
    3339:	movq   xmm0,rax
    333e:	call   1140 <asin@plt>
    3343:	addsd  xmm0,xmm0
    3347:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    334c:	movsd  xmm0,QWORD PTR [rbp-0x78]
    3351:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    3356:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    335b:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    3360:	leave
    3361:	ret

0000000000003362 <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    3362:	push   rbp
    3363:	mov    rbp,rsp
    3366:	movsd  QWORD PTR [rbp-0x18],xmm0
    336b:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    3370:	movsd  xmm0,QWORD PTR [rip+0x1558]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    3378:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    337d:	movsd  xmm0,QWORD PTR [rbp-0x18]
    3382:	movq   xmm1,QWORD PTR [rip+0x1556]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    338a:	andpd  xmm0,xmm1
    338e:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3393:	movq   xmm2,QWORD PTR [rip+0x1545]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    339b:	andpd  xmm2,xmm1
    339f:	movapd xmm1,xmm0
    33a3:	subsd  xmm1,xmm2
    33a7:	movsd  xmm0,QWORD PTR [rbp-0x8]
    33ac:	comisd xmm0,xmm1
    33b0:	setae  al
    33b3:	movzx  eax,al
}
    33b6:	pop    rbp
    33b7:	ret

00000000000033b8 <main>:

int main(int args_count, char **args)
{
    33b8:	push   rbp
    33b9:	mov    rbp,rsp
    33bc:	push   r15
    33be:	push   r14
    33c0:	push   r13
    33c2:	push   r12
    33c4:	push   rbx
    33c5:	sub    rsp,0x268
    33cc:	mov    DWORD PTR [rbp-0x1f4],edi
    33d2:	mov    QWORD PTR [rbp-0x200],rsi
    33d9:	mov    rax,QWORD PTR fs:0x28
    33e2:	mov    QWORD PTR [rbp-0x38],rax
    33e6:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    33e8:	cmp    DWORD PTR [rbp-0x1f4],0x3
    33ef:	je     341c <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    33f1:	mov    rax,QWORD PTR [rbp-0x200]
    33f8:	mov    rax,QWORD PTR [rax]
    33fb:	lea    rdx,[rip+0x122e]        # 4630 <_IO_stdin_used+0x630>
    3402:	mov    rsi,rax
    3405:	mov    rdi,rdx
    3408:	mov    eax,0x0
    340d:	call   1070 <printf@plt>
    return 1;
    3412:	mov    eax,0x1
    3417:	jmp    3d52 <main+0x99a>
  }

  begin_profiling();
    341c:	call   1b3d <begin_profiling>

  Arena arena = {0};
    3421:	pxor   xmm0,xmm0
    3425:	movaps XMMWORD PTR [rbp-0x150],xmm0
    342c:	movaps XMMWORD PTR [rbp-0x140],xmm0
  arena = arena_make(GB(4));
    3433:	lea    rdx,[rbp-0x220]
    343a:	movabs rax,0x100000000
    3444:	mov    rsi,rax
    3447:	mov    rdi,rdx
    344a:	call   1632 <arena_make>
    344f:	mov    rax,QWORD PTR [rbp-0x220]
    3456:	mov    rdx,QWORD PTR [rbp-0x218]
    345d:	mov    QWORD PTR [rbp-0x150],rax
    3464:	mov    QWORD PTR [rbp-0x148],rdx
    346b:	mov    rax,QWORD PTR [rbp-0x210]
    3472:	mov    rdx,QWORD PTR [rbp-0x208]
    3479:	mov    QWORD PTR [rbp-0x140],rax
    3480:	mov    QWORD PTR [rbp-0x138],rdx

  String source = {0};
    3487:	mov    QWORD PTR [rbp-0x160],0x0
    3492:	mov    QWORD PTR [rbp-0x158],0x0
  printf("%lu", file_size(args[1]));
    349d:	mov    rax,QWORD PTR [rbp-0x200]
    34a4:	add    rax,0x8
    34a8:	mov    rax,QWORD PTR [rax]
    34ab:	mov    rdi,rax
    34ae:	call   1303 <file_size>
    34b3:	mov    rdx,rax
    34b6:	lea    rax,[rip+0x119f]        # 465c <_IO_stdin_used+0x65c>
    34bd:	mov    rsi,rdx
    34c0:	mov    rdi,rax
    34c3:	mov    eax,0x0
    34c8:	call   1070 <printf@plt>
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    34cd:	mov    rax,QWORD PTR [rbp-0x200]
    34d4:	add    rax,0x8
    34d8:	mov    rax,QWORD PTR [rax]
    34db:	mov    rdi,rax
    34de:	call   1303 <file_size>
    34e3:	mov    rcx,rax
    34e6:	lea    r12,[rip+0x1173]        # 4660 <_IO_stdin_used+0x660>
    34ed:	mov    r13d,0x4
    34f3:	lea    rdi,[rbp-0x130]
    34fa:	mov    rdx,r12
    34fd:	mov    rax,r13
    3500:	mov    r8,rcx
    3503:	mov    ecx,0x5
    3508:	mov    rsi,rdx
    350b:	mov    rdx,rax
    350e:	call   1f5c <__profile_begin_pass>
    3513:	mov    QWORD PTR [rbp-0x1e0],0x0
    351e:	jmp    35b9 <main+0x201>
  {
    source = read_file_to_arena(&arena, args[1]);
    3523:	mov    rax,QWORD PTR [rbp-0x200]
    352a:	add    rax,0x8
    352e:	mov    rdx,QWORD PTR [rax]
    3531:	lea    rax,[rbp-0x150]
    3538:	mov    rsi,rdx
    353b:	mov    rdi,rax
    353e:	call   1357 <read_file_to_arena>
    3543:	mov    QWORD PTR [rbp-0x160],rax
    354a:	mov    QWORD PTR [rbp-0x158],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    3551:	add    QWORD PTR [rbp-0x1e0],0x1
    3559:	sub    rsp,0x8
    355d:	sub    rsp,0x38
    3561:	mov    rcx,rsp
    3564:	mov    rax,QWORD PTR [rbp-0x130]
    356b:	mov    rdx,QWORD PTR [rbp-0x128]
    3572:	mov    QWORD PTR [rcx],rax
    3575:	mov    QWORD PTR [rcx+0x8],rdx
    3579:	mov    rax,QWORD PTR [rbp-0x120]
    3580:	mov    rdx,QWORD PTR [rbp-0x118]
    3587:	mov    QWORD PTR [rcx+0x10],rax
    358b:	mov    QWORD PTR [rcx+0x18],rdx
    358f:	mov    rax,QWORD PTR [rbp-0x110]
    3596:	mov    rdx,QWORD PTR [rbp-0x108]
    359d:	mov    QWORD PTR [rcx+0x20],rax
    35a1:	mov    QWORD PTR [rcx+0x28],rdx
    35a5:	mov    rax,QWORD PTR [rbp-0x100]
    35ac:	mov    QWORD PTR [rcx+0x30],rax
    35b0:	call   2046 <__profile_end_pass>
    35b5:	add    rsp,0x40
    35b9:	cmp    QWORD PTR [rbp-0x1e0],0x0
    35c1:	je     3523 <main+0x16b>
  }

  usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    35c7:	mov    QWORD PTR [rbp-0x1a8],0x18
  usize max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    35d2:	mov    rax,QWORD PTR [rbp-0x158]
    35d9:	mov    edx,0x0
    35de:	div    QWORD PTR [rbp-0x1a8]
    35e5:	mov    QWORD PTR [rbp-0x1a0],rax
  Haversine_Pair * pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    35ec:	mov    rax,QWORD PTR [rbp-0x1a0]
    35f3:	shl    rax,0x5
    35f7:	mov    rcx,rax
    35fa:	lea    rax,[rbp-0x150]
    3601:	mov    edx,0x8
    3606:	mov    rsi,rcx
    3609:	mov    rdi,rax
    360c:	call   17d3 <arena_alloc>
    3611:	mov    QWORD PTR [rbp-0x198],rax
  i32 pair_count = 0;
    3618:	mov    DWORD PTR [rbp-0x1e8],0x0

  JSON_Object *root = NULL;
    3622:	mov    QWORD PTR [rbp-0x190],0x0
  root = parse_json(&arena, source);
    362d:	mov    rcx,QWORD PTR [rbp-0x160]
    3634:	mov    rdx,QWORD PTR [rbp-0x158]
    363b:	lea    rax,[rbp-0x150]
    3642:	mov    rsi,rcx
    3645:	mov    rdi,rax
    3648:	call   2d74 <parse_json>
    364d:	mov    QWORD PTR [rbp-0x190],rax

  f64 haversine_sum = 0.0;
    3654:	pxor   xmm0,xmm0
    3658:	movsd  QWORD PTR [rbp-0x188],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    3660:	lea    r14,[rip+0xffe]        # 4665 <_IO_stdin_used+0x665>
    3667:	mov    r15d,0x5
    366d:	mov    rcx,r14
    3670:	mov    rdx,r15
    3673:	mov    rax,QWORD PTR [rbp-0x190]
    367a:	mov    rsi,rcx
    367d:	mov    rdi,rax
    3680:	call   2ed7 <lookup_json_object>
    3685:	mov    QWORD PTR [rbp-0x180],rax
  if (pairs)
    368c:	cmp    QWORD PTR [rbp-0x198],0x0
    3694:	je     3859 <main+0x4a1>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    369a:	mov    rax,QWORD PTR [rbp-0x180]
    36a1:	mov    rax,QWORD PTR [rax+0x20]
    36a5:	mov    QWORD PTR [rbp-0x1d8],rax
    36ac:	jmp    383a <main+0x482>
    {
      Haversine_Pair pair =
      {
        .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    36b1:	lea    rax,[rip+0xfb3]        # 466b <_IO_stdin_used+0x66b>
    36b8:	mov    QWORD PTR [rbp-0x260],rax
    36bf:	mov    QWORD PTR [rbp-0x258],0x2
    36ca:	mov    rbx,QWORD PTR [rbp-0x260]
    36d1:	mov    rsi,QWORD PTR [rbp-0x258]
    36d8:	mov    rax,rbx
    36db:	mov    rdx,rsi
    36de:	mov    rcx,QWORD PTR [rbp-0x1d8]
    36e5:	mov    rsi,rax
    36e8:	mov    rdi,rcx
    36eb:	call   2ed7 <lookup_json_object>
    36f0:	mov    rdi,rax
    36f3:	call   2ffa <json_object_to_f64>
    36f8:	movq   rax,xmm0
      Haversine_Pair pair =
    36fd:	mov    QWORD PTR [rbp-0x70],rax
        .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    3701:	lea    rax,[rip+0xf66]        # 466e <_IO_stdin_used+0x66e>
    3708:	mov    QWORD PTR [rbp-0x270],rax
    370f:	mov    QWORD PTR [rbp-0x268],0x2
    371a:	mov    rax,QWORD PTR [rbp-0x270]
    3721:	mov    rdx,QWORD PTR [rbp-0x268]
    3728:	mov    rcx,rax
    372b:	mov    rax,QWORD PTR [rbp-0x1d8]
    3732:	mov    rsi,rcx
    3735:	mov    rdi,rax
    3738:	call   2ed7 <lookup_json_object>
    373d:	mov    rdi,rax
    3740:	call   2ffa <json_object_to_f64>
    3745:	movq   rax,xmm0
      Haversine_Pair pair =
    374a:	mov    QWORD PTR [rbp-0x68],rax
        .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    374e:	lea    rax,[rip+0xf1c]        # 4671 <_IO_stdin_used+0x671>
    3755:	mov    QWORD PTR [rbp-0x280],rax
    375c:	mov    QWORD PTR [rbp-0x278],0x2
    3767:	mov    rax,QWORD PTR [rbp-0x280]
    376e:	mov    rdx,QWORD PTR [rbp-0x278]
    3775:	mov    rcx,rax
    3778:	mov    rax,QWORD PTR [rbp-0x1d8]
    377f:	mov    rsi,rcx
    3782:	mov    rdi,rax
    3785:	call   2ed7 <lookup_json_object>
    378a:	mov    rdi,rax
    378d:	call   2ffa <json_object_to_f64>
    3792:	movq   rax,xmm0
      Haversine_Pair pair =
    3797:	mov    QWORD PTR [rbp-0x60],rax
        .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    379b:	lea    rax,[rip+0xed2]        # 4674 <_IO_stdin_used+0x674>
    37a2:	mov    QWORD PTR [rbp-0x290],rax
    37a9:	mov    QWORD PTR [rbp-0x288],0x2
    37b4:	mov    rax,QWORD PTR [rbp-0x290]
    37bb:	mov    rdx,QWORD PTR [rbp-0x288]
    37c2:	mov    rcx,rax
    37c5:	mov    rax,QWORD PTR [rbp-0x1d8]
    37cc:	mov    rsi,rcx
    37cf:	mov    rdi,rax
    37d2:	call   2ed7 <lookup_json_object>
    37d7:	mov    rdi,rax
    37da:	call   2ffa <json_object_to_f64>
    37df:	movq   rax,xmm0
      Haversine_Pair pair =
    37e4:	mov    QWORD PTR [rbp-0x58],rax
      };

      pairs[pair_count] = pair;
    37e8:	mov    eax,DWORD PTR [rbp-0x1e8]
    37ee:	cdqe
    37f0:	shl    rax,0x5
    37f4:	mov    rdx,rax
    37f7:	mov    rax,QWORD PTR [rbp-0x198]
    37fe:	lea    rcx,[rdx+rax*1]
    3802:	mov    rax,QWORD PTR [rbp-0x70]
    3806:	mov    rdx,QWORD PTR [rbp-0x68]
    380a:	mov    QWORD PTR [rcx],rax
    380d:	mov    QWORD PTR [rcx+0x8],rdx
    3811:	mov    rax,QWORD PTR [rbp-0x60]
    3815:	mov    rdx,QWORD PTR [rbp-0x58]
    3819:	mov    QWORD PTR [rcx+0x10],rax
    381d:	mov    QWORD PTR [rcx+0x18],rdx
      pair_count += 1;
    3821:	add    DWORD PTR [rbp-0x1e8],0x1
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    3828:	mov    rax,QWORD PTR [rbp-0x1d8]
    382f:	mov    rax,QWORD PTR [rax+0x28]
    3833:	mov    QWORD PTR [rbp-0x1d8],rax
    383a:	cmp    QWORD PTR [rbp-0x1d8],0x0
    3842:	je     3859 <main+0x4a1>
    3844:	mov    eax,DWORD PTR [rbp-0x1e8]
    384a:	cdqe
    384c:	cmp    rax,QWORD PTR [rbp-0x1a0]
    3853:	jb     36b1 <main+0x2f9>
    }
  }

  f64 sum = 0.0;
    3859:	pxor   xmm0,xmm0
    385d:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    3865:	mov    eax,DWORD PTR [rbp-0x1e8]
    386b:	cdqe
    386d:	shl    rax,0x5
    3871:	mov    rdx,rax
    3874:	lea    rax,[rip+0xdfc]        # 4677 <_IO_stdin_used+0x677>
    387b:	mov    QWORD PTR [rbp-0x230],rax
    3882:	mov    QWORD PTR [rbp-0x228],0x3
    388d:	lea    rax,[rbp-0xf0]
    3894:	mov    rcx,QWORD PTR [rbp-0x230]
    389b:	mov    rbx,QWORD PTR [rbp-0x228]
    38a2:	mov    rsi,rcx
    38a5:	mov    rdi,rbx
    38a8:	mov    r8,rdx
    38ab:	mov    ecx,0x6
    38b0:	mov    rdx,rdi
    38b3:	mov    rdi,rax
    38b6:	call   1f5c <__profile_begin_pass>
    38bb:	mov    QWORD PTR [rbp-0x1c8],0x0
    38c6:	jmp    3a48 <main+0x690>
  {
    for (usize i = 0; i < pair_count; i++)
    38cb:	mov    QWORD PTR [rbp-0x1c0],0x0
    38d6:	jmp    39ab <main+0x5f3>
    {
      f64 earth_radius = 6372.8;
    38db:	movsd  xmm0,QWORD PTR [rip+0x100d]        # 48f0 <__PRETTY_FUNCTION__.0+0x80>
    38e3:	movsd  QWORD PTR [rbp-0x170],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    38eb:	mov    rax,QWORD PTR [rbp-0x1c0]
    38f2:	shl    rax,0x5
    38f6:	mov    rdx,rax
    38f9:	mov    rax,QWORD PTR [rbp-0x198]
    3900:	add    rax,rdx
    3903:	movsd  xmm2,QWORD PTR [rax+0x18]
    3908:	mov    rax,QWORD PTR [rbp-0x1c0]
    390f:	shl    rax,0x5
    3913:	mov    rdx,rax
    3916:	mov    rax,QWORD PTR [rbp-0x198]
    391d:	add    rax,rdx
    3920:	movsd  xmm1,QWORD PTR [rax+0x10]
    3925:	mov    rax,QWORD PTR [rbp-0x1c0]
    392c:	shl    rax,0x5
    3930:	mov    rdx,rax
    3933:	mov    rax,QWORD PTR [rbp-0x198]
    393a:	add    rax,rdx
    393d:	movsd  xmm0,QWORD PTR [rax+0x8]
    3942:	mov    rax,QWORD PTR [rbp-0x1c0]
    3949:	shl    rax,0x5
    394d:	mov    rdx,rax
    3950:	mov    rax,QWORD PTR [rbp-0x198]
    3957:	add    rax,rdx
    395a:	mov    rax,QWORD PTR [rax]
    395d:	movsd  xmm3,QWORD PTR [rbp-0x170]
    3965:	movapd xmm4,xmm3
    3969:	movapd xmm3,xmm2
    396d:	movapd xmm2,xmm1
    3971:	movapd xmm1,xmm0
    3975:	movq   xmm0,rax
    397a:	call   31b7 <reference_haversine>
    397f:	movq   rax,xmm0
    3984:	mov    QWORD PTR [rbp-0x168],rax
      sum += result;
    398b:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3993:	addsd  xmm0,QWORD PTR [rbp-0x168]
    399b:	movsd  QWORD PTR [rbp-0x1d0],xmm0
    for (usize i = 0; i < pair_count; i++)
    39a3:	add    QWORD PTR [rbp-0x1c0],0x1
    39ab:	mov    eax,DWORD PTR [rbp-0x1e8]
    39b1:	cdqe
    39b3:	cmp    QWORD PTR [rbp-0x1c0],rax
    39ba:	jb     38db <main+0x523>
    }
    sum /= pair_count;
    39c0:	pxor   xmm1,xmm1
    39c4:	cvtsi2sd xmm1,DWORD PTR [rbp-0x1e8]
    39cc:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    39d4:	divsd  xmm0,xmm1
    39d8:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    39e0:	add    QWORD PTR [rbp-0x1c8],0x1
    39e8:	sub    rsp,0x8
    39ec:	sub    rsp,0x38
    39f0:	mov    rax,rsp
    39f3:	mov    rcx,QWORD PTR [rbp-0xf0]
    39fa:	mov    rbx,QWORD PTR [rbp-0xe8]
    3a01:	mov    QWORD PTR [rax],rcx
    3a04:	mov    QWORD PTR [rax+0x8],rbx
    3a08:	mov    rcx,QWORD PTR [rbp-0xe0]
    3a0f:	mov    rbx,QWORD PTR [rbp-0xd8]
    3a16:	mov    QWORD PTR [rax+0x10],rcx
    3a1a:	mov    QWORD PTR [rax+0x18],rbx
    3a1e:	mov    rcx,QWORD PTR [rbp-0xd0]
    3a25:	mov    rbx,QWORD PTR [rbp-0xc8]
    3a2c:	mov    QWORD PTR [rax+0x20],rcx
    3a30:	mov    QWORD PTR [rax+0x28],rbx
    3a34:	mov    rdx,QWORD PTR [rbp-0xc0]
    3a3b:	mov    QWORD PTR [rax+0x30],rdx
    3a3f:	call   2046 <__profile_end_pass>
    3a44:	add    rsp,0x40
    3a48:	cmp    QWORD PTR [rbp-0x1c8],0x0
    3a50:	je     38cb <main+0x513>
  }

  PROFILE_SCOPE("check")
    3a56:	lea    rax,[rip+0xc1e]        # 467b <_IO_stdin_used+0x67b>
    3a5d:	mov    QWORD PTR [rbp-0x240],rax
    3a64:	mov    QWORD PTR [rbp-0x238],0x5
    3a6f:	lea    rax,[rbp-0xb0]
    3a76:	mov    rcx,QWORD PTR [rbp-0x240]
    3a7d:	mov    rbx,QWORD PTR [rbp-0x238]
    3a84:	mov    rsi,rcx
    3a87:	mov    rdx,rbx
    3a8a:	mov    r8d,0x0
    3a90:	mov    ecx,0x7
    3a95:	mov    rdi,rax
    3a98:	call   1f5c <__profile_begin_pass>
    3a9d:	mov    QWORD PTR [rbp-0x1b8],0x0
    3aa8:	jmp    3c7d <main+0x8c5>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3aad:	mov    rax,QWORD PTR [rbp-0x200]
    3ab4:	add    rax,0x10
    3ab8:	mov    rdx,QWORD PTR [rax]
    3abb:	lea    rax,[rbp-0x150]
    3ac2:	mov    rsi,rdx
    3ac5:	mov    rdi,rax
    3ac8:	call   1357 <read_file_to_arena>
    3acd:	mov    QWORD PTR [rbp-0x70],rax
    3ad1:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3ad5:	mov    rax,QWORD PTR [rbp-0x68]
    3ad9:	cmp    rax,0xb
    3add:	jbe    3bf0 <main+0x838>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3ae3:	mov    rax,QWORD PTR [rbp-0x70]
    3ae7:	movsd  xmm0,QWORD PTR [rax]
    3aeb:	movsd  QWORD PTR [rbp-0x178],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3af3:	mov    rax,QWORD PTR [rbp-0x70]
    3af7:	mov    eax,DWORD PTR [rax+0x8]
    3afa:	mov    DWORD PTR [rbp-0x1e4],eax

      if (solution_pairs == pair_count)
    3b00:	mov    eax,DWORD PTR [rbp-0x1e4]
    3b06:	cmp    eax,DWORD PTR [rbp-0x1e8]
    3b0c:	jne    3bb4 <main+0x7fc>
      {
        if (epsilon_equal(solution_sum, sum))
    3b12:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3b1a:	mov    rax,QWORD PTR [rbp-0x178]
    3b21:	movapd xmm1,xmm0
    3b25:	movq   xmm0,rax
    3b2a:	call   3362 <epsilon_equal>
    3b2f:	test   eax,eax
    3b31:	je     3b75 <main+0x7bd>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3b33:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3b3b:	mov    rax,QWORD PTR [rbp-0x178]
    3b42:	lea    rdx,[rip+0xb3f]        # 4688 <_IO_stdin_used+0x688>
    3b49:	lea    rsi,[rip+0xb6b]        # 46bb <_IO_stdin_used+0x6bb>
    3b50:	movapd xmm1,xmm0
    3b54:	movq   xmm0,rax
    3b59:	mov    rcx,rdx
    3b5c:	mov    edx,0x5b
    3b61:	mov    edi,0x3
    3b66:	mov    eax,0x2
    3b6b:	call   14a1 <log_message>
    3b70:	jmp    3c18 <main+0x860>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3b75:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3b7d:	mov    rax,QWORD PTR [rbp-0x178]
    3b84:	lea    rdx,[rip+0xb45]        # 46d0 <_IO_stdin_used+0x6d0>
    3b8b:	lea    rsi,[rip+0xb29]        # 46bb <_IO_stdin_used+0x6bb>
    3b92:	movapd xmm1,xmm0
    3b96:	movq   xmm0,rax
    3b9b:	mov    rcx,rdx
    3b9e:	mov    edx,0x5f
    3ba3:	mov    edi,0x1
    3ba8:	mov    eax,0x2
    3bad:	call   14a1 <log_message>
    3bb2:	jmp    3c18 <main+0x860>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3bb4:	mov    esi,DWORD PTR [rbp-0x1e8]
    3bba:	mov    ecx,DWORD PTR [rbp-0x1e4]
    3bc0:	lea    rdx,[rip+0xb41]        # 4708 <_IO_stdin_used+0x708>
    3bc7:	lea    rax,[rip+0xaed]        # 46bb <_IO_stdin_used+0x6bb>
    3bce:	mov    r9d,esi
    3bd1:	mov    r8d,ecx
    3bd4:	mov    rcx,rdx
    3bd7:	mov    edx,0x64
    3bdc:	mov    rsi,rax
    3bdf:	mov    edi,0x1
    3be4:	mov    eax,0x0
    3be9:	call   14a1 <log_message>
    3bee:	jmp    3c18 <main+0x860>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3bf0:	lea    rdx,[rip+0xb59]        # 4750 <_IO_stdin_used+0x750>
    3bf7:	lea    rax,[rip+0xabd]        # 46bb <_IO_stdin_used+0x6bb>
    3bfe:	mov    rcx,rdx
    3c01:	mov    edx,0x69
    3c06:	mov    rsi,rax
    3c09:	mov    edi,0x1
    3c0e:	mov    eax,0x0
    3c13:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3c18:	add    QWORD PTR [rbp-0x1b8],0x1
    3c20:	sub    rsp,0x8
    3c24:	sub    rsp,0x38
    3c28:	mov    rax,rsp
    3c2b:	mov    rcx,QWORD PTR [rbp-0xb0]
    3c32:	mov    rbx,QWORD PTR [rbp-0xa8]
    3c39:	mov    QWORD PTR [rax],rcx
    3c3c:	mov    QWORD PTR [rax+0x8],rbx
    3c40:	mov    rcx,QWORD PTR [rbp-0xa0]
    3c47:	mov    rbx,QWORD PTR [rbp-0x98]
    3c4e:	mov    QWORD PTR [rax+0x10],rcx
    3c52:	mov    QWORD PTR [rax+0x18],rbx
    3c56:	mov    rcx,QWORD PTR [rbp-0x90]
    3c5d:	mov    rbx,QWORD PTR [rbp-0x88]
    3c64:	mov    QWORD PTR [rax+0x20],rcx
    3c68:	mov    QWORD PTR [rax+0x28],rbx
    3c6c:	mov    rdx,QWORD PTR [rbp-0x80]
    3c70:	mov    QWORD PTR [rax+0x30],rdx
    3c74:	call   2046 <__profile_end_pass>
    3c79:	add    rsp,0x40
    3c7d:	cmp    QWORD PTR [rbp-0x1b8],0x0
    3c85:	je     3aad <main+0x6f5>
    }
  }

  PROFILE_SCOPE("free")
    3c8b:	lea    rax,[rip+0xaf9]        # 478b <_IO_stdin_used+0x78b>
    3c92:	mov    QWORD PTR [rbp-0x250],rax
    3c99:	mov    QWORD PTR [rbp-0x248],0x4
    3ca4:	lea    rax,[rbp-0x70]
    3ca8:	mov    rcx,QWORD PTR [rbp-0x250]
    3caf:	mov    rbx,QWORD PTR [rbp-0x248]
    3cb6:	mov    rsi,rcx
    3cb9:	mov    rdx,rbx
    3cbc:	mov    r8d,0x0
    3cc2:	mov    ecx,0x8
    3cc7:	mov    rdi,rax
    3cca:	call   1f5c <__profile_begin_pass>
    3ccf:	mov    QWORD PTR [rbp-0x1b0],0x0
    3cda:	jmp    3d3e <main+0x986>
  {
    arena_free(&arena);
    3cdc:	lea    rax,[rbp-0x150]
    3ce3:	mov    rdi,rax
    3ce6:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3ceb:	add    QWORD PTR [rbp-0x1b0],0x1
    3cf3:	sub    rsp,0x8
    3cf7:	sub    rsp,0x38
    3cfb:	mov    rax,rsp
    3cfe:	mov    rcx,QWORD PTR [rbp-0x70]
    3d02:	mov    rbx,QWORD PTR [rbp-0x68]
    3d06:	mov    QWORD PTR [rax],rcx
    3d09:	mov    QWORD PTR [rax+0x8],rbx
    3d0d:	mov    rcx,QWORD PTR [rbp-0x60]
    3d11:	mov    rbx,QWORD PTR [rbp-0x58]
    3d15:	mov    QWORD PTR [rax+0x10],rcx
    3d19:	mov    QWORD PTR [rax+0x18],rbx
    3d1d:	mov    rcx,QWORD PTR [rbp-0x50]
    3d21:	mov    rbx,QWORD PTR [rbp-0x48]
    3d25:	mov    QWORD PTR [rax+0x20],rcx
    3d29:	mov    QWORD PTR [rax+0x28],rbx
    3d2d:	mov    rdx,QWORD PTR [rbp-0x40]
    3d31:	mov    QWORD PTR [rax+0x30],rdx
    3d35:	call   2046 <__profile_end_pass>
    3d3a:	add    rsp,0x40
    3d3e:	cmp    QWORD PTR [rbp-0x1b0],0x0
    3d46:	je     3cdc <main+0x924>
  }

  end_profiling();
    3d48:	call   1b9b <end_profiling>
    3d4d:	mov    eax,0x0
}
    3d52:	mov    rdx,QWORD PTR [rbp-0x38]
    3d56:	sub    rdx,QWORD PTR fs:0x28
    3d5f:	je     3d66 <main+0x9ae>
    3d61:	call   1060 <__stack_chk_fail@plt>
    3d66:	lea    rsp,[rbp-0x28]
    3d6a:	pop    rbx
    3d6b:	pop    r12
    3d6d:	pop    r13
    3d6f:	pop    r14
    3d71:	pop    r15
    3d73:	pop    rbp
    3d74:	ret

Disassembly of section .fini:

0000000000003d78 <_fini>:
    3d78:	endbr64
    3d7c:	sub    rsp,0x8
    3d80:	add    rsp,0x8
    3d84:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x4fc1]        # 5fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x4fca]        # 5ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x4fcc]        # 5ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x4fca]        # 6000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x4fc2]        # 6008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x4fba]        # 6010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x4fb2]        # 6018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x4faa]        # 6020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x4fa2]        # 6028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x4f9a]        # 6030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x4f92]        # 6038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x4f8a]        # 6040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x4f82]        # 6048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x4f7a]        # 6050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x4f72]        # 6058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x4f6a]        # 6060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x4f62]        # 6068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x4f5a]        # 6070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x4f52]        # 6078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x4f4a]        # 6080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x4f42]        # 6088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x4f3a]        # 6090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x4f32]        # 6098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2235]        # 33c4 <main>
    118f:	call   QWORD PTR [rip+0x4e2b]        # 5fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x4fa1]        # 6148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x4f9a]        # 6148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x4e0e]        # 5fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x4f71]        # 6148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x4f6a]        # 6148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x4ddd]        # 5fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x4f6d],0x0        # 6188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x4dba],0x0        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x4e76]        # 60a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x4da8]        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x4f44],0x1        # 6188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x4c6e]        # 6180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x4b89]        # 60c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x4be7]        # 6160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x4b2b]        # 60c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x3097]        # 4790 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x306b]        # 4790 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fae]        # 47a8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2eaf]        # 47b8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2ccd]        # 47d0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x4639]        # 61a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x4620],rbx        # 61a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x50
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x45ee]        # 61a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x38],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x38],0x0
    1bbe:	je     1f65 <end_profiling+0x3ca>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x30],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x38]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x30]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c51]        # 4888 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x30]
    1c44:	mov    rax,QWORD PTR [rbp-0x38]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x48],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x40],0x0
    1c72:	jmp    1f57 <end_profiling+0x3bc>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x40]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x450d]        # 61a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x28],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x28]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1f52 <end_profiling+0x3b7>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x28]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x38]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b77]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x20],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x28]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x28]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x28]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x28]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x20]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>

        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x28]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x28]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x28]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x38]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2a9f]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x18],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x28]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x18]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x48]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x20]
    1e2c:	movsd  QWORD PTR [rbp-0x48],xmm0

        if (zone->bytes_processed)
    1e31:	mov    rax,QWORD PTR [rbp-0x28]
    1e35:	mov    rax,QWORD PTR [rax+0x28]
    1e39:	test   rax,rax
    1e3c:	je     1f52 <end_profiling+0x3b7>
        {
          f64 megabytes = (f64)zone->bytes_processed / MB(1);
    1e42:	mov    rax,QWORD PTR [rbp-0x28]
    1e46:	mov    rax,QWORD PTR [rax+0x28]
    1e4a:	test   rax,rax
    1e4d:	js     1e5a <end_profiling+0x2bf>
    1e4f:	pxor   xmm0,xmm0
    1e53:	cvtsi2sd xmm0,rax
    1e58:	jmp    1e73 <end_profiling+0x2d8>
    1e5a:	mov    rdx,rax
    1e5d:	shr    rdx,1
    1e60:	and    eax,0x1
    1e63:	or     rdx,rax
    1e66:	pxor   xmm0,xmm0
    1e6a:	cvtsi2sd xmm0,rdx
    1e6f:	addsd  xmm0,xmm0
    1e73:	movsd  xmm1,QWORD PTR [rip+0x2a1d]        # 4898 <__PRETTY_FUNCTION__.0+0x28>
    1e7b:	divsd  xmm0,xmm1
    1e7f:	movsd  QWORD PTR [rbp-0x10],xmm0

          f64 gb_per_s = (f64)zone->bytes_processed / ((f64)zone->elapsed_inclusive / (f64)freq) / (f64)GB(1.0);
    1e84:	mov    rax,QWORD PTR [rbp-0x28]
    1e88:	mov    rax,QWORD PTR [rax+0x28]
    1e8c:	test   rax,rax
    1e8f:	js     1e9c <end_profiling+0x301>
    1e91:	pxor   xmm0,xmm0
    1e95:	cvtsi2sd xmm0,rax
    1e9a:	jmp    1eb5 <end_profiling+0x31a>
    1e9c:	mov    rdx,rax
    1e9f:	shr    rdx,1
    1ea2:	and    eax,0x1
    1ea5:	or     rdx,rax
    1ea8:	pxor   xmm0,xmm0
    1eac:	cvtsi2sd xmm0,rdx
    1eb1:	addsd  xmm0,xmm0
    1eb5:	mov    rax,QWORD PTR [rbp-0x28]
    1eb9:	mov    rax,QWORD PTR [rax+0x18]
    1ebd:	test   rax,rax
    1ec0:	js     1ecd <end_profiling+0x332>
    1ec2:	pxor   xmm1,xmm1
    1ec6:	cvtsi2sd xmm1,rax
    1ecb:	jmp    1ee6 <end_profiling+0x34b>
    1ecd:	mov    rdx,rax
    1ed0:	shr    rdx,1
    1ed3:	and    eax,0x1
    1ed6:	or     rdx,rax
    1ed9:	pxor   xmm1,xmm1
    1edd:	cvtsi2sd xmm1,rdx
    1ee2:	addsd  xmm1,xmm1
    1ee6:	mov    rax,QWORD PTR [rbp-0x30]
    1eea:	test   rax,rax
    1eed:	js     1efa <end_profiling+0x35f>
    1eef:	pxor   xmm2,xmm2
    1ef3:	cvtsi2sd xmm2,rax
    1ef8:	jmp    1f13 <end_profiling+0x378>
    1efa:	mov    rdx,rax
    1efd:	shr    rdx,1
    1f00:	and    eax,0x1
    1f03:	or     rdx,rax
    1f06:	pxor   xmm2,xmm2
    1f0a:	cvtsi2sd xmm2,rdx
    1f0f:	addsd  xmm2,xmm2
    1f13:	divsd  xmm1,xmm2
    1f17:	divsd  xmm0,xmm1
    1f1b:	movsd  xmm1,QWORD PTR [rip+0x297d]        # 48a0 <__PRETTY_FUNCTION__.0+0x30>
    1f23:	divsd  xmm0,xmm1
    1f27:	movsd  QWORD PTR [rbp-0x8],xmm0

          printf("  Megabytes Processed: %f @ %f GB/s\n", megabytes, gb_per_s);
    1f2c:	movsd  xmm0,QWORD PTR [rbp-0x8]
    1f31:	mov    rax,QWORD PTR [rbp-0x10]
    1f35:	lea    rdx,[rip+0x240c]        # 4348 <_IO_stdin_used+0x348>
    1f3c:	movapd xmm1,xmm0
    1f40:	movq   xmm0,rax
    1f45:	mov    rdi,rdx
    1f48:	mov    eax,0x2
    1f4d:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1f52:	add    QWORD PTR [rbp-0x40],0x1
    1f57:	cmp    QWORD PTR [rbp-0x40],0xfff
    1f5f:	jbe    1c77 <end_profiling+0xdc>
        }
      }
    }
  }
}
    1f65:	nop
    1f66:	leave
    1f67:	ret

0000000000001f68 <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1f68:	push   rbp
    1f69:	mov    rbp,rsp
    1f6c:	push   rbx
    1f6d:	sub    rsp,0x78
    1f71:	mov    QWORD PTR [rbp-0x58],rdi
    1f75:	mov    rax,rsi
    1f78:	mov    rsi,rdx
    1f7b:	mov    rax,rax
    1f7e:	mov    edx,0x0
    1f83:	mov    rdx,rsi
    1f86:	mov    QWORD PTR [rbp-0x70],rax
    1f8a:	mov    QWORD PTR [rbp-0x68],rdx
    1f8e:	mov    QWORD PTR [rbp-0x60],rcx
    1f92:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1f96:	pxor   xmm0,xmm0
    1f9a:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1f9e:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1fa2:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1fa6:	movq   QWORD PTR [rbp-0x20],xmm0
    1fab:	mov    rax,QWORD PTR [rbp-0x70]
    1faf:	mov    rdx,QWORD PTR [rbp-0x68]
    1fb3:	mov    QWORD PTR [rbp-0x50],rax
    1fb7:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1fbb:	mov    rdx,QWORD PTR [rbp-0x60]
    1fbf:	mov    rax,rdx
    1fc2:	add    rax,rax
    1fc5:	add    rax,rdx
    1fc8:	shl    rax,0x4
    1fcc:	mov    rdx,rax
    1fcf:	lea    rax,[rip+0x41f2]        # 61c8 <g_profiler+0x28>
    1fd6:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1fda:	mov    QWORD PTR [rbp-0x38],rax
    1fde:	mov    rax,QWORD PTR [rbp-0x60]
    1fe2:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1fe6:	mov    rax,QWORD PTR [rip+0x41bb]        # 61a8 <g_profiler+0x8>
  Profile_Pass pass =
    1fed:	mov    QWORD PTR [rbp-0x28],rax
    1ff1:	mov    rax,QWORD PTR [rbp-0x78]
    1ff5:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    1ff9:	mov    rax,QWORD PTR [rbp-0x60]
    1ffd:	mov    QWORD PTR [rip+0x41a4],rax        # 61a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    2004:	call   1a48 <read_cpu_timer>
    2009:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    200d:	mov    rax,QWORD PTR [rbp-0x58]
    2011:	mov    rcx,QWORD PTR [rbp-0x50]
    2015:	mov    rbx,QWORD PTR [rbp-0x48]
    2019:	mov    QWORD PTR [rax],rcx
    201c:	mov    QWORD PTR [rax+0x8],rbx
    2020:	mov    rcx,QWORD PTR [rbp-0x40]
    2024:	mov    rbx,QWORD PTR [rbp-0x38]
    2028:	mov    QWORD PTR [rax+0x10],rcx
    202c:	mov    QWORD PTR [rax+0x18],rbx
    2030:	mov    rcx,QWORD PTR [rbp-0x30]
    2034:	mov    rbx,QWORD PTR [rbp-0x28]
    2038:	mov    QWORD PTR [rax+0x20],rcx
    203c:	mov    QWORD PTR [rax+0x28],rbx
    2040:	mov    rdx,QWORD PTR [rbp-0x20]
    2044:	mov    QWORD PTR [rax+0x30],rdx
}
    2048:	mov    rax,QWORD PTR [rbp-0x58]
    204c:	mov    rbx,QWORD PTR [rbp-0x8]
    2050:	leave
    2051:	ret

0000000000002052 <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    2052:	push   rbp
    2053:	mov    rbp,rsp
    2056:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    205a:	call   1a48 <read_cpu_timer>
    205f:	mov    rdx,rax
    2062:	mov    rax,QWORD PTR [rbp+0x20]
    2066:	sub    rdx,rax
    2069:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    206d:	mov    rax,QWORD PTR [rbp+0x38]
    2071:	mov    QWORD PTR [rip+0x4130],rax        # 61a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    2078:	mov    rdx,QWORD PTR [rbp+0x30]
    207c:	mov    rax,rdx
    207f:	add    rax,rax
    2082:	add    rax,rdx
    2085:	shl    rax,0x4
    2089:	lea    rdx,[rax+0x10]
    208d:	lea    rax,[rip+0x410c]        # 61a0 <g_profiler>
    2094:	add    rax,rdx
    2097:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    209b:	mov    rax,QWORD PTR [rbp-0x10]
    209f:	mov    rdx,QWORD PTR [rax+0x10]
    20a3:	mov    rax,QWORD PTR [rbp-0x18]
    20a7:	add    rdx,rax
    20aa:	mov    rax,QWORD PTR [rbp-0x10]
    20ae:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    20b2:	mov    rax,QWORD PTR [rbp-0x10]
    20b6:	mov    rax,QWORD PTR [rax+0x20]
    20ba:	lea    rdx,[rax+0x1]
    20be:	mov    rax,QWORD PTR [rbp-0x10]
    20c2:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    20c6:	mov    rcx,QWORD PTR [rbp-0x10]
    20ca:	mov    rax,QWORD PTR [rbp+0x10]
    20ce:	mov    rdx,QWORD PTR [rbp+0x18]
    20d2:	mov    QWORD PTR [rcx],rax
    20d5:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    20d9:	mov    rdx,QWORD PTR [rbp+0x28]
    20dd:	mov    rax,QWORD PTR [rbp-0x18]
    20e1:	add    rdx,rax
    20e4:	mov    rax,QWORD PTR [rbp-0x10]
    20e8:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    20ec:	mov    rax,QWORD PTR [rbp-0x10]
    20f0:	mov    rdx,QWORD PTR [rax+0x28]
    20f4:	mov    rax,QWORD PTR [rbp+0x40]
    20f8:	add    rdx,rax
    20fb:	mov    rax,QWORD PTR [rbp-0x10]
    20ff:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    2103:	mov    rdx,QWORD PTR [rbp+0x38]
    2107:	mov    rax,rdx
    210a:	add    rax,rax
    210d:	add    rax,rdx
    2110:	shl    rax,0x4
    2114:	lea    rdx,[rax+0x10]
    2118:	lea    rax,[rip+0x4081]        # 61a0 <g_profiler>
    211f:	add    rax,rdx
    2122:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    2126:	mov    rax,QWORD PTR [rbp-0x8]
    212a:	mov    rax,QWORD PTR [rax+0x10]
    212e:	sub    rax,QWORD PTR [rbp-0x18]
    2132:	mov    rdx,rax
    2135:	mov    rax,QWORD PTR [rbp-0x8]
    2139:	mov    QWORD PTR [rax+0x10],rdx
}
    213d:	nop
    213e:	leave
    213f:	ret

0000000000002140 <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    2140:	push   rbp
    2141:	mov    rbp,rsp
    2144:	sub    rsp,0x10
    2148:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    214c:	mov    rax,QWORD PTR [rbp-0x8]
    2150:	mov    rdx,QWORD PTR [rax+0x10]
    2154:	mov    rax,QWORD PTR [rbp-0x8]
    2158:	mov    rax,QWORD PTR [rax+0x8]
    215c:	cmp    rdx,rax
    215f:	jb     2186 <parser_at+0x46>
    2161:	lea    rdx,[rip+0x2680]        # 47e8 <__PRETTY_FUNCTION__.5>
    2168:	lea    rsi,[rip+0x2309]        # 4478 <_IO_stdin_used+0x478>
    216f:	lea    rax,[rip+0x231a]        # 4490 <_IO_stdin_used+0x490>
    2176:	mov    rcx,rdx
    2179:	mov    edx,0x2f
    217e:	mov    rdi,rax
    2181:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    2186:	mov    rax,QWORD PTR [rbp-0x8]
    218a:	mov    rdx,QWORD PTR [rax]
    218d:	mov    rax,QWORD PTR [rbp-0x8]
    2191:	mov    rax,QWORD PTR [rax+0x10]
    2195:	add    rax,rdx
}
    2198:	leave
    2199:	ret

000000000000219a <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    219a:	push   rbp
    219b:	mov    rbp,rsp
    219e:	sub    rsp,0x10
    21a2:	mov    QWORD PTR [rbp-0x8],rdi
    21a6:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    21aa:	mov    rax,QWORD PTR [rbp-0x8]
    21ae:	mov    rdi,rax
    21b1:	call   2140 <parser_at>
    21b6:	mov    rdx,QWORD PTR [rbp-0x10]
    21ba:	add    rax,rdx
}
    21bd:	leave
    21be:	ret

00000000000021bf <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    21bf:	push   rbp
    21c0:	mov    rbp,rsp
    21c3:	mov    QWORD PTR [rbp-0x8],rdi
    21c7:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    21cb:	mov    rax,QWORD PTR [rbp-0x8]
    21cf:	mov    rdx,QWORD PTR [rax+0x10]
    21d3:	mov    rax,QWORD PTR [rbp-0x10]
    21d7:	add    rdx,rax
    21da:	mov    rax,QWORD PTR [rbp-0x8]
    21de:	mov    QWORD PTR [rax+0x10],rdx
}
    21e2:	nop
    21e3:	pop    rbp
    21e4:	ret

00000000000021e5 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    21e5:	push   rbp
    21e6:	mov    rbp,rsp
    21e9:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    21ed:	mov    rax,QWORD PTR [rbp-0x8]
    21f1:	mov    rdx,QWORD PTR [rax+0x10]
    21f5:	mov    rax,QWORD PTR [rbp-0x8]
    21f9:	mov    rax,QWORD PTR [rax+0x8]
    21fd:	cmp    rdx,rax
    2200:	setb   al
}
    2203:	pop    rbp
    2204:	ret

0000000000002205 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    2205:	push   rbp
    2206:	mov    rbp,rsp
    2209:	push   r12
    220b:	push   rbx
    220c:	sub    rsp,0x20
    2210:	mov    QWORD PTR [rbp-0x18],rdi
    2214:	mov    rax,rsi
    2217:	mov    rcx,rdx
    221a:	mov    rax,rax
    221d:	mov    edx,0x0
    2222:	mov    rdx,rcx
    2225:	mov    QWORD PTR [rbp-0x30],rax
    2229:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    222d:	mov    rax,QWORD PTR [rbp-0x28]
    2231:	mov    r12,rax
    2234:	mov    rbx,QWORD PTR [rbp-0x30]
    2238:	mov    rax,QWORD PTR [rbp-0x18]
    223c:	mov    rdi,rax
    223f:	call   2140 <parser_at>
    2244:	mov    rdx,r12
    2247:	mov    rsi,rbx
    224a:	mov    rdi,rax
    224d:	call   10d0 <memcmp@plt>
    2252:	test   eax,eax
    2254:	sete   al
}
    2257:	add    rsp,0x20
    225b:	pop    rbx
    225c:	pop    r12
    225e:	pop    rbp
    225f:	ret

0000000000002260 <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    2260:	push   rbp
    2261:	mov    rbp,rsp
    2264:	mov    eax,edi
    2266:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    2269:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    226d:	movzx  eax,BYTE PTR [rbp-0x14]
    2271:	cmp    eax,0x2e
    2274:	jg     227d <is_numeric+0x1d>
    2276:	cmp    eax,0x2d
    2279:	jge    2285 <is_numeric+0x25>
    227b:	jmp    228a <is_numeric+0x2a>
    227d:	sub    eax,0x30
    2280:	cmp    eax,0x9
    2283:	ja     228a <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2285:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    2289:	nop
  }


  return result;
    228a:	movzx  eax,BYTE PTR [rbp-0x1]
}
    228e:	pop    rbp
    228f:	ret

0000000000002290 <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    2290:	push   rbp
    2291:	mov    rbp,rsp
    2294:	sub    rsp,0x50
    2298:	mov    QWORD PTR [rbp-0x48],rdi
    229c:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    22a0:	pxor   xmm0,xmm0
    22a4:	movaps XMMWORD PTR [rbp-0x20],xmm0
    22a8:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    22ad:	jmp    22c0 <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    22af:	mov    rax,QWORD PTR [rbp-0x50]
    22b3:	mov    esi,0x1
    22b8:	mov    rdi,rax
    22bb:	call   21bf <parser_advance>
  while (parser_incomplete(parser)  &&
    22c0:	mov    rax,QWORD PTR [rbp-0x50]
    22c4:	mov    rdi,rax
    22c7:	call   21e5 <parser_incomplete>
    22cc:	test   al,al
    22ce:	je     231c <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    22d0:	mov    rax,QWORD PTR [rbp-0x50]
    22d4:	mov    rdi,rax
    22d7:	call   2140 <parser_at>
    22dc:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    22df:	cmp    al,0x20
    22e1:	je     22af <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    22e3:	mov    rax,QWORD PTR [rbp-0x50]
    22e7:	mov    rdi,rax
    22ea:	call   2140 <parser_at>
    22ef:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    22f2:	cmp    al,0xa
    22f4:	je     22af <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    22f6:	mov    rax,QWORD PTR [rbp-0x50]
    22fa:	mov    rdi,rax
    22fd:	call   2140 <parser_at>
    2302:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    2305:	cmp    al,0xd
    2307:	je     22af <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    2309:	mov    rax,QWORD PTR [rbp-0x50]
    230d:	mov    rdi,rax
    2310:	call   2140 <parser_at>
    2315:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    2318:	cmp    al,0x9
    231a:	je     22af <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    231c:	mov    rax,QWORD PTR [rbp-0x50]
    2320:	mov    rdi,rax
    2323:	call   21e5 <parser_incomplete>
    2328:	test   al,al
    232a:	je     2757 <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    2330:	mov    rax,QWORD PTR [rbp-0x50]
    2334:	mov    rdi,rax
    2337:	call   2140 <parser_at>
    233c:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    2340:	mov    rax,QWORD PTR [rbp-0x50]
    2344:	mov    rdi,rax
    2347:	call   2140 <parser_at>
    234c:	movzx  eax,BYTE PTR [rax]
    234f:	movzx  eax,al
    2352:	cmp    eax,0x7d
    2355:	je     2442 <get_json_token+0x1b2>
    235b:	cmp    eax,0x7d
    235e:	jg     2768 <get_json_token+0x4d8>
    2364:	cmp    eax,0x7b
    2367:	je     241d <get_json_token+0x18d>
    236d:	cmp    eax,0x7b
    2370:	jg     2768 <get_json_token+0x4d8>
    2376:	cmp    eax,0x74
    2379:	je     25c5 <get_json_token+0x335>
    237f:	cmp    eax,0x74
    2382:	jg     2768 <get_json_token+0x4d8>
    2388:	cmp    eax,0x6e
    238b:	je     26d5 <get_json_token+0x445>
    2391:	cmp    eax,0x6e
    2394:	jg     2768 <get_json_token+0x4d8>
    239a:	cmp    eax,0x66
    239d:	je     264d <get_json_token+0x3bd>
    23a3:	cmp    eax,0x66
    23a6:	jg     2768 <get_json_token+0x4d8>
    23ac:	cmp    eax,0x5d
    23af:	je     248c <get_json_token+0x1fc>
    23b5:	cmp    eax,0x5d
    23b8:	jg     2768 <get_json_token+0x4d8>
    23be:	cmp    eax,0x5b
    23c1:	je     2467 <get_json_token+0x1d7>
    23c7:	cmp    eax,0x5b
    23ca:	jg     2768 <get_json_token+0x4d8>
    23d0:	cmp    eax,0x3a
    23d3:	je     24d6 <get_json_token+0x246>
    23d9:	cmp    eax,0x3a
    23dc:	jg     2768 <get_json_token+0x4d8>
    23e2:	cmp    eax,0x39
    23e5:	jg     2768 <get_json_token+0x4d8>
    23eb:	cmp    eax,0x30
    23ee:	jge    2574 <get_json_token+0x2e4>
    23f4:	cmp    eax,0x2e
    23f7:	jg     2768 <get_json_token+0x4d8>
    23fd:	cmp    eax,0x2d
    2400:	jge    2574 <get_json_token+0x2e4>
    2406:	cmp    eax,0x22
    2409:	je     24fb <get_json_token+0x26b>
    240f:	cmp    eax,0x2c
    2412:	je     24b1 <get_json_token+0x221>
    2418:	jmp    2768 <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    241d:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    2424:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    242c:	mov    rax,QWORD PTR [rbp-0x50]
    2430:	mov    esi,0x1
    2435:	mov    rdi,rax
    2438:	call   21bf <parser_advance>
      }
      break;
    243d:	jmp    2768 <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2442:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    2449:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2451:	mov    rax,QWORD PTR [rbp-0x50]
    2455:	mov    esi,0x1
    245a:	mov    rdi,rax
    245d:	call   21bf <parser_advance>
      }
      break;
    2462:	jmp    2768 <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2467:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    246e:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2476:	mov    rax,QWORD PTR [rbp-0x50]
    247a:	mov    esi,0x1
    247f:	mov    rdi,rax
    2482:	call   21bf <parser_advance>
      }
      break;
    2487:	jmp    2768 <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    248c:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    2493:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    249b:	mov    rax,QWORD PTR [rbp-0x50]
    249f:	mov    esi,0x1
    24a4:	mov    rdi,rax
    24a7:	call   21bf <parser_advance>
      }
      break;
    24ac:	jmp    2768 <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    24b1:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    24b8:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24c0:	mov    rax,QWORD PTR [rbp-0x50]
    24c4:	mov    esi,0x1
    24c9:	mov    rdi,rax
    24cc:	call   21bf <parser_advance>
      }
      break;
    24d1:	jmp    2768 <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    24d6:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    24dd:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24e5:	mov    rax,QWORD PTR [rbp-0x50]
    24e9:	mov    esi,0x1
    24ee:	mov    rdi,rax
    24f1:	call   21bf <parser_advance>
      }
      break;
    24f6:	jmp    2768 <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    24fb:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    2502:	mov    rax,QWORD PTR [rbp-0x50]
    2506:	mov    esi,0x1
    250b:	mov    rdi,rax
    250e:	call   21bf <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    2513:	mov    rax,QWORD PTR [rbp-0x50]
    2517:	mov    rdi,rax
    251a:	call   2140 <parser_at>
    251f:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    2523:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    252b:	jmp    2543 <get_json_token+0x2b3>
        {
          string_count += 1;
    252d:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    2532:	mov    rax,QWORD PTR [rbp-0x50]
    2536:	mov    esi,0x1
    253b:	mov    rdi,rax
    253e:	call   21bf <parser_advance>
        while (*parser_at(parser) != '"')
    2543:	mov    rax,QWORD PTR [rbp-0x50]
    2547:	mov    rdi,rax
    254a:	call   2140 <parser_at>
    254f:	movzx  eax,BYTE PTR [rax]
    2552:	cmp    al,0x22
    2554:	jne    252d <get_json_token+0x29d>
        }
        token.value.count = string_count;
    2556:	mov    rax,QWORD PTR [rbp-0x40]
    255a:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    255e:	mov    rax,QWORD PTR [rbp-0x50]
    2562:	mov    esi,0x1
    2567:	mov    rdi,rax
    256a:	call   21bf <parser_advance>
      }
      break;
    256f:	jmp    2768 <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2574:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    257b:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2583:	jmp    259b <get_json_token+0x30b>
        {
          digit_count += 1;
    2585:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    258a:	mov    rax,QWORD PTR [rbp-0x50]
    258e:	mov    esi,0x1
    2593:	mov    rdi,rax
    2596:	call   21bf <parser_advance>
        while (is_numeric(*parser_at(parser)))
    259b:	mov    rax,QWORD PTR [rbp-0x50]
    259f:	mov    rdi,rax
    25a2:	call   2140 <parser_at>
    25a7:	movzx  eax,BYTE PTR [rax]
    25aa:	movzx  eax,al
    25ad:	mov    edi,eax
    25af:	call   2260 <is_numeric>
    25b4:	test   al,al
    25b6:	jne    2585 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    25b8:	mov    rax,QWORD PTR [rbp-0x38]
    25bc:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    25c0:	jmp    2768 <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    25c5:	lea    rax,[rip+0x1f10]        # 44dc <_IO_stdin_used+0x4dc>
    25cc:	mov    QWORD PTR [rbp-0x30],rax
    25d0:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25d8:	mov    rcx,QWORD PTR [rbp-0x30]
    25dc:	mov    rdx,QWORD PTR [rbp-0x28]
    25e0:	mov    rax,QWORD PTR [rbp-0x50]
    25e4:	mov    rsi,rcx
    25e7:	mov    rdi,rax
    25ea:	call   2205 <parser_token_is_literal>
    25ef:	test   al,al
    25f1:	je     2615 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    25f3:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    25fa:	mov    rax,QWORD PTR [rbp-0x28]
    25fe:	mov    rdx,rax
    2601:	mov    rax,QWORD PTR [rbp-0x50]
    2605:	mov    rsi,rdx
    2608:	mov    rdi,rax
    260b:	call   21bf <parser_advance>
    2610:	jmp    2768 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2615:	mov    rax,QWORD PTR [rbp-0x50]
    2619:	mov    rcx,QWORD PTR [rax+0x10]
    261d:	lea    rdx,[rip+0x1ec4]        # 44e8 <_IO_stdin_used+0x4e8>
    2624:	lea    rax,[rip+0x1e4d]        # 4478 <_IO_stdin_used+0x478>
    262b:	mov    r8,rcx
    262e:	mov    rcx,rdx
    2631:	mov    edx,0xdf
    2636:	mov    rsi,rax
    2639:	mov    edi,0x1
    263e:	mov    eax,0x0
    2643:	call   14a1 <log_message>
        }
      }
      break;
    2648:	jmp    2768 <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    264d:	lea    rax,[rip+0x1ec1]        # 4515 <_IO_stdin_used+0x515>
    2654:	mov    QWORD PTR [rbp-0x30],rax
    2658:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    2660:	mov    rcx,QWORD PTR [rbp-0x30]
    2664:	mov    rdx,QWORD PTR [rbp-0x28]
    2668:	mov    rax,QWORD PTR [rbp-0x50]
    266c:	mov    rsi,rcx
    266f:	mov    rdi,rax
    2672:	call   2205 <parser_token_is_literal>
    2677:	test   al,al
    2679:	je     269d <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    267b:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    2682:	mov    rax,QWORD PTR [rbp-0x28]
    2686:	mov    rdx,rax
    2689:	mov    rax,QWORD PTR [rbp-0x50]
    268d:	mov    rsi,rdx
    2690:	mov    rdi,rax
    2693:	call   21bf <parser_advance>
    2698:	jmp    2768 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    269d:	mov    rax,QWORD PTR [rbp-0x50]
    26a1:	mov    rcx,QWORD PTR [rax+0x10]
    26a5:	lea    rdx,[rip+0x1e3c]        # 44e8 <_IO_stdin_used+0x4e8>
    26ac:	lea    rax,[rip+0x1dc5]        # 4478 <_IO_stdin_used+0x478>
    26b3:	mov    r8,rcx
    26b6:	mov    rcx,rdx
    26b9:	mov    edx,0xee
    26be:	mov    rsi,rax
    26c1:	mov    edi,0x1
    26c6:	mov    eax,0x0
    26cb:	call   14a1 <log_message>
        }
      }
      break;
    26d0:	jmp    2768 <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    26d5:	lea    rax,[rip+0x1e3f]        # 451b <_IO_stdin_used+0x51b>
    26dc:	mov    QWORD PTR [rbp-0x30],rax
    26e0:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    26e8:	mov    rcx,QWORD PTR [rbp-0x30]
    26ec:	mov    rdx,QWORD PTR [rbp-0x28]
    26f0:	mov    rax,QWORD PTR [rbp-0x50]
    26f4:	mov    rsi,rcx
    26f7:	mov    rdi,rax
    26fa:	call   2205 <parser_token_is_literal>
    26ff:	test   al,al
    2701:	je     2722 <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    2703:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    270a:	mov    rax,QWORD PTR [rbp-0x28]
    270e:	mov    rdx,rax
    2711:	mov    rax,QWORD PTR [rbp-0x50]
    2715:	mov    rsi,rdx
    2718:	mov    rdi,rax
    271b:	call   21bf <parser_advance>
    2720:	jmp    2768 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2722:	mov    rax,QWORD PTR [rbp-0x50]
    2726:	mov    rcx,QWORD PTR [rax+0x10]
    272a:	lea    rdx,[rip+0x1db7]        # 44e8 <_IO_stdin_used+0x4e8>
    2731:	lea    rax,[rip+0x1d40]        # 4478 <_IO_stdin_used+0x478>
    2738:	mov    r8,rcx
    273b:	mov    rcx,rdx
    273e:	mov    edx,0xfd
    2743:	mov    rsi,rax
    2746:	mov    edi,0x1
    274b:	mov    eax,0x0
    2750:	call   14a1 <log_message>
        }
      }
      break;
    2755:	jmp    2768 <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    2757:	mov    rax,QWORD PTR [rbp-0x50]
    275b:	mov    esi,0x1
    2760:	mov    rdi,rax
    2763:	call   21bf <parser_advance>
  }

  return token;
    2768:	mov    rcx,QWORD PTR [rbp-0x48]
    276c:	mov    rax,QWORD PTR [rbp-0x20]
    2770:	mov    rdx,QWORD PTR [rbp-0x18]
    2774:	mov    QWORD PTR [rcx],rax
    2777:	mov    QWORD PTR [rcx+0x8],rdx
    277b:	mov    rax,QWORD PTR [rbp-0x10]
    277f:	mov    QWORD PTR [rcx+0x10],rax
}
    2783:	mov    rax,QWORD PTR [rbp-0x48]
    2787:	leave
    2788:	ret

0000000000002789 <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    2789:	push   rbp
    278a:	mov    rbp,rsp
    278d:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    2790:	cmp    DWORD PTR [rbp-0x14],0x7
    2794:	je     27ae <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2796:	cmp    DWORD PTR [rbp-0x14],0x9
    279a:	je     27ae <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    279c:	cmp    DWORD PTR [rbp-0x14],0xa
    27a0:	je     27ae <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    27a2:	cmp    DWORD PTR [rbp-0x14],0xb
    27a6:	je     27ae <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    27a8:	cmp    DWORD PTR [rbp-0x14],0x8
    27ac:	jne    27b5 <json_token_type_is_value_type+0x2c>
    27ae:	mov    eax,0x1
    27b3:	jmp    27ba <json_token_type_is_value_type+0x31>
    27b5:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    27ba:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    27bd:	mov    eax,DWORD PTR [rbp-0x4]
}
    27c0:	pop    rbp
    27c1:	ret

00000000000027c2 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    27c2:	push   rbp
    27c3:	mov    rbp,rsp
    27c6:	push   rbx
    27c7:	sub    rsp,0x88
    27ce:	mov    QWORD PTR [rbp-0x78],rdi
    27d2:	mov    QWORD PTR [rbp-0x80],rsi
    27d6:	mov    QWORD PTR [rbp-0x90],rdx
    27dd:	mov    QWORD PTR [rbp-0x88],rcx
    27e4:	mov    rax,QWORD PTR fs:0x28
    27ed:	mov    QWORD PTR [rbp-0x18],rax
    27f1:	xor    eax,eax
  profile_begin_func();
    27f3:	lea    r8,[rip+0x2006]        # 4800 <__func__.4>
    27fa:	mov    r9d,0x11
    2800:	lea    rax,[rbp-0x50]
    2804:	mov    rsi,r8
    2807:	mov    rdx,r9
    280a:	mov    r8d,0x0
    2810:	mov    ecx,0x1
    2815:	mov    rdi,rax
    2818:	call   1f68 <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    281d:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2825:	mov    eax,DWORD PTR [rbp+0x10]
    2828:	cmp    eax,0x1
    282b:	jne    2857 <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    282d:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    2834:	mov    edx,DWORD PTR [rbp-0x64]
    2837:	mov    rsi,QWORD PTR [rbp-0x80]
    283b:	mov    rax,QWORD PTR [rbp-0x78]
    283f:	mov    ecx,edx
    2841:	mov    edx,0x2
    2846:	mov    rdi,rax
    2849:	call   29a9 <parse_json_children>
    284e:	mov    QWORD PTR [rbp-0x60],rax
    2852:	jmp    28e1 <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2857:	mov    eax,DWORD PTR [rbp+0x10]
    285a:	cmp    eax,0x3
    285d:	jne    2886 <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    285f:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2866:	mov    edx,DWORD PTR [rbp-0x68]
    2869:	mov    rsi,QWORD PTR [rbp-0x80]
    286d:	mov    rax,QWORD PTR [rbp-0x78]
    2871:	mov    ecx,edx
    2873:	mov    edx,0x4
    2878:	mov    rdi,rax
    287b:	call   29a9 <parse_json_children>
    2880:	mov    QWORD PTR [rbp-0x60],rax
    2884:	jmp    28e1 <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    2886:	mov    eax,DWORD PTR [rbp+0x10]
    2889:	mov    edi,eax
    288b:	call   2789 <json_token_type_is_value_type>
    2890:	test   eax,eax
    2892:	jne    28e1 <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2894:	mov    eax,DWORD PTR [rbp+0x10]
    2897:	mov    eax,eax
    2899:	lea    rdx,[rax*8+0x0]
    28a1:	lea    rax,[rip+0x3838]        # 60e0 <JSON_Token_Type_strings>
    28a8:	mov    rcx,QWORD PTR [rdx+rax*1]
    28ac:	lea    rdx,[rip+0x1c6d]        # 4520 <_IO_stdin_used+0x520>
    28b3:	lea    rax,[rip+0x1bbe]        # 4478 <_IO_stdin_used+0x478>
    28ba:	push   QWORD PTR [rbp+0x20]
    28bd:	push   QWORD PTR [rbp+0x18]
    28c0:	mov    r8,rcx
    28c3:	mov    rcx,rdx
    28c6:	mov    edx,0x134
    28cb:	mov    rsi,rax
    28ce:	mov    edi,0x1
    28d3:	mov    eax,0x0
    28d8:	call   14a1 <log_message>
    28dd:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    28e1:	mov    rax,QWORD PTR [rbp-0x78]
    28e5:	mov    edx,0x8
    28ea:	mov    esi,0x30
    28ef:	mov    rdi,rax
    28f2:	call   17d3 <arena_alloc>
    28f7:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    28fb:	mov    rcx,QWORD PTR [rbp-0x58]
    28ff:	mov    rax,QWORD PTR [rbp-0x90]
    2906:	mov    rdx,QWORD PTR [rbp-0x88]
    290d:	mov    QWORD PTR [rcx],rax
    2910:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    2914:	mov    rax,QWORD PTR [rbp-0x58]
    2918:	mov    rdx,QWORD PTR [rbp-0x60]
    291c:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    2920:	mov    rax,QWORD PTR [rbp-0x58]
    2924:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    292c:	mov    rcx,QWORD PTR [rbp-0x58]
    2930:	mov    rax,QWORD PTR [rbp+0x18]
    2934:	mov    rdx,QWORD PTR [rbp+0x20]
    2938:	mov    QWORD PTR [rcx+0x10],rax
    293c:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    2940:	sub    rsp,0x8
    2944:	sub    rsp,0x38
    2948:	mov    rax,rsp
    294b:	mov    rcx,QWORD PTR [rbp-0x50]
    294f:	mov    rbx,QWORD PTR [rbp-0x48]
    2953:	mov    QWORD PTR [rax],rcx
    2956:	mov    QWORD PTR [rax+0x8],rbx
    295a:	mov    rcx,QWORD PTR [rbp-0x40]
    295e:	mov    rbx,QWORD PTR [rbp-0x38]
    2962:	mov    QWORD PTR [rax+0x10],rcx
    2966:	mov    QWORD PTR [rax+0x18],rbx
    296a:	mov    rcx,QWORD PTR [rbp-0x30]
    296e:	mov    rbx,QWORD PTR [rbp-0x28]
    2972:	mov    QWORD PTR [rax+0x20],rcx
    2976:	mov    QWORD PTR [rax+0x28],rbx
    297a:	mov    rdx,QWORD PTR [rbp-0x20]
    297e:	mov    QWORD PTR [rax+0x30],rdx
    2982:	call   2052 <__profile_end_pass>
    2987:	add    rsp,0x40

  return result;
    298b:	mov    rax,QWORD PTR [rbp-0x58]
}
    298f:	mov    rdx,QWORD PTR [rbp-0x18]
    2993:	sub    rdx,QWORD PTR fs:0x28
    299c:	je     29a3 <parse_json_object+0x1e1>
    299e:	call   1060 <__stack_chk_fail@plt>
    29a3:	mov    rbx,QWORD PTR [rbp-0x8]
    29a7:	leave
    29a8:	ret

00000000000029a9 <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    29a9:	push   rbp
    29aa:	mov    rbp,rsp
    29ad:	push   rbx
    29ae:	sub    rsp,0x108
    29b5:	mov    QWORD PTR [rbp-0xd8],rdi
    29bc:	mov    QWORD PTR [rbp-0xe0],rsi
    29c3:	mov    DWORD PTR [rbp-0xe4],edx
    29c9:	mov    DWORD PTR [rbp-0xe8],ecx
    29cf:	mov    rax,QWORD PTR fs:0x28
    29d8:	mov    QWORD PTR [rbp-0x18],rax
    29dc:	xor    eax,eax
  profile_begin_func();
    29de:	lea    r8,[rip+0x1e3b]        # 4820 <__func__.3>
    29e5:	mov    r9d,0x13
    29eb:	lea    rax,[rbp-0x50]
    29ef:	mov    rsi,r8
    29f2:	mov    rdx,r9
    29f5:	mov    r8d,0x0
    29fb:	mov    ecx,0x2
    2a00:	mov    rdi,rax
    2a03:	call   1f68 <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2a08:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    2a13:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2a1e:	jmp    2cf7 <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2a23:	pxor   xmm0,xmm0
    2a27:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2a2e:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2a36:	pxor   xmm0,xmm0
    2a3a:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2a41:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2a46:	cmp    DWORD PTR [rbp-0xe8],0x0
    2a4d:	je     2b5a <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2a53:	lea    rax,[rbp-0xb0]
    2a5a:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a61:	mov    rsi,rdx
    2a64:	mov    rdi,rax
    2a67:	call   2290 <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2a6c:	mov    eax,DWORD PTR [rbp-0xb0]
    2a72:	cmp    eax,0x7
    2a75:	jne    2af6 <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2a77:	lea    rax,[rbp-0x70]
    2a7b:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a82:	mov    rsi,rdx
    2a85:	mov    rdi,rax
    2a88:	call   2290 <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2a8d:	mov    eax,DWORD PTR [rbp-0x70]
    2a90:	cmp    eax,0x6
    2a93:	jne    2ab3 <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2a95:	lea    rax,[rbp-0x90]
    2a9c:	mov    rdx,QWORD PTR [rbp-0xe0]
    2aa3:	mov    rsi,rdx
    2aa6:	mov    rdi,rax
    2aa9:	call   2290 <get_json_token>
    2aae:	jmp    2b9a <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2ab3:	mov    rcx,QWORD PTR [rbp-0xa8]
    2aba:	mov    rax,QWORD PTR [rbp-0xa0]
    2ac1:	mov    esi,eax
    2ac3:	lea    rdx,[rip+0x1aa6]        # 4570 <_IO_stdin_used+0x570>
    2aca:	lea    rax,[rip+0x19a7]        # 4478 <_IO_stdin_used+0x478>
    2ad1:	mov    r9,rcx
    2ad4:	mov    r8d,esi
    2ad7:	mov    rcx,rdx
    2ada:	mov    edx,0x15f
    2adf:	mov    rsi,rax
    2ae2:	mov    edi,0x1
    2ae7:	mov    eax,0x0
    2aec:	call   14a1 <log_message>
    2af1:	jmp    2b9a <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2af6:	mov    rcx,QWORD PTR [rbp-0xa8]
    2afd:	mov    rax,QWORD PTR [rbp-0xa0]
    2b04:	mov    edi,eax
    2b06:	mov    eax,DWORD PTR [rbp-0xb0]
    2b0c:	mov    eax,eax
    2b0e:	lea    rdx,[rax*8+0x0]
    2b16:	lea    rax,[rip+0x35c3]        # 60e0 <JSON_Token_Type_strings>
    2b1d:	mov    rsi,QWORD PTR [rdx+rax*1]
    2b21:	lea    rdx,[rip+0x1a68]        # 4590 <_IO_stdin_used+0x590>
    2b28:	lea    rax,[rip+0x1949]        # 4478 <_IO_stdin_used+0x478>
    2b2f:	sub    rsp,0x8
    2b33:	push   rcx
    2b34:	mov    r9d,edi
    2b37:	mov    r8,rsi
    2b3a:	mov    rcx,rdx
    2b3d:	mov    edx,0x164
    2b42:	mov    rsi,rax
    2b45:	mov    edi,0x1
    2b4a:	mov    eax,0x0
    2b4f:	call   14a1 <log_message>
    2b54:	add    rsp,0x10
    2b58:	jmp    2b9a <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2b5a:	lea    rax,[rbp-0x110]
    2b61:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b68:	mov    rsi,rdx
    2b6b:	mov    rdi,rax
    2b6e:	call   2290 <get_json_token>
    2b73:	mov    rax,QWORD PTR [rbp-0x110]
    2b7a:	mov    rdx,QWORD PTR [rbp-0x108]
    2b81:	mov    QWORD PTR [rbp-0x90],rax
    2b88:	mov    QWORD PTR [rbp-0x88],rdx
    2b8f:	mov    rax,QWORD PTR [rbp-0x100]
    2b96:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2b9a:	mov    eax,DWORD PTR [rbp-0x90]
    2ba0:	cmp    DWORD PTR [rbp-0xe4],eax
    2ba6:	je     2d10 <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2bac:	mov    rax,QWORD PTR [rbp-0xa8]
    2bb3:	mov    rdx,QWORD PTR [rbp-0xa0]
    2bba:	mov    r8,QWORD PTR [rbp-0xe0]
    2bc1:	mov    rdi,QWORD PTR [rbp-0xd8]
    2bc8:	sub    rsp,0x8
    2bcc:	sub    rsp,0x18
    2bd0:	mov    rsi,rsp
    2bd3:	mov    rcx,QWORD PTR [rbp-0x90]
    2bda:	mov    rbx,QWORD PTR [rbp-0x88]
    2be1:	mov    QWORD PTR [rsi],rcx
    2be4:	mov    QWORD PTR [rsi+0x8],rbx
    2be8:	mov    rcx,QWORD PTR [rbp-0x80]
    2bec:	mov    QWORD PTR [rsi+0x10],rcx
    2bf0:	mov    rcx,rdx
    2bf3:	mov    rdx,rax
    2bf6:	mov    rsi,r8
    2bf9:	call   27c2 <parse_json_object>
    2bfe:	add    rsp,0x20
    2c02:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2c09:	cmp    QWORD PTR [rbp-0xb8],0x0
    2c11:	je     2c5b <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2c13:	cmp    QWORD PTR [rbp-0xc8],0x0
    2c1b:	jne    2c3b <parse_json_children+0x292>
      {
        first_child        = object;
    2c1d:	mov    rax,QWORD PTR [rbp-0xb8]
    2c24:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2c2b:	mov    rax,QWORD PTR [rbp-0xb8]
    2c32:	mov    QWORD PTR [rbp-0xc0],rax
    2c39:	jmp    2c5b <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2c3b:	mov    rax,QWORD PTR [rbp-0xc0]
    2c42:	mov    rdx,QWORD PTR [rbp-0xb8]
    2c49:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2c4d:	mov    rax,QWORD PTR [rbp-0xb8]
    2c54:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2c5b:	lea    rax,[rbp-0x70]
    2c5f:	mov    rdx,QWORD PTR [rbp-0xe0]
    2c66:	mov    rsi,rdx
    2c69:	mov    rdi,rax
    2c6c:	call   2290 <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2c71:	mov    eax,DWORD PTR [rbp-0x70]
    2c74:	cmp    DWORD PTR [rbp-0xe4],eax
    2c7a:	je     2d13 <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2c80:	mov    eax,DWORD PTR [rbp-0x70]
    2c83:	cmp    eax,0x5
    2c86:	je     2cf7 <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2c88:	mov    r8,QWORD PTR [rbp-0x68]
    2c8c:	mov    rax,QWORD PTR [rbp-0x60]
    2c90:	mov    r9d,eax
    2c93:	mov    eax,DWORD PTR [rbp-0x70]
    2c96:	mov    eax,eax
    2c98:	lea    rdx,[rax*8+0x0]
    2ca0:	lea    rax,[rip+0x3439]        # 60e0 <JSON_Token_Type_strings>
    2ca7:	mov    r10,QWORD PTR [rdx+rax*1]
    2cab:	lea    rdi,[rip+0x1906]        # 45b8 <_IO_stdin_used+0x5b8>
    2cb2:	lea    rsi,[rip+0x17bf]        # 4478 <_IO_stdin_used+0x478>
    2cb9:	sub    rsp,0x18
    2cbd:	mov    rcx,rsp
    2cc0:	mov    rax,QWORD PTR [rbp-0x70]
    2cc4:	mov    rdx,QWORD PTR [rbp-0x68]
    2cc8:	mov    QWORD PTR [rcx],rax
    2ccb:	mov    QWORD PTR [rcx+0x8],rdx
    2ccf:	mov    rax,QWORD PTR [rbp-0x60]
    2cd3:	mov    QWORD PTR [rcx+0x10],rax
    2cd7:	push   r8
    2cd9:	mov    r8,r10
    2cdc:	mov    rcx,rdi
    2cdf:	mov    edx,0x18b
    2ce4:	mov    edi,0x1
    2ce9:	mov    eax,0x0
    2cee:	call   14a1 <log_message>
    2cf3:	add    rsp,0x20
  while (parser_incomplete(parser))
    2cf7:	mov    rax,QWORD PTR [rbp-0xe0]
    2cfe:	mov    rdi,rax
    2d01:	call   21e5 <parser_incomplete>
    2d06:	test   al,al
    2d08:	jne    2a23 <parse_json_children+0x7a>
    2d0e:	jmp    2d14 <parse_json_children+0x36b>
      break;
    2d10:	nop
    2d11:	jmp    2d14 <parse_json_children+0x36b>
      break;
    2d13:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2d14:	sub    rsp,0x8
    2d18:	sub    rsp,0x38
    2d1c:	mov    rax,rsp
    2d1f:	mov    rcx,QWORD PTR [rbp-0x50]
    2d23:	mov    rbx,QWORD PTR [rbp-0x48]
    2d27:	mov    QWORD PTR [rax],rcx
    2d2a:	mov    QWORD PTR [rax+0x8],rbx
    2d2e:	mov    rcx,QWORD PTR [rbp-0x40]
    2d32:	mov    rbx,QWORD PTR [rbp-0x38]
    2d36:	mov    QWORD PTR [rax+0x10],rcx
    2d3a:	mov    QWORD PTR [rax+0x18],rbx
    2d3e:	mov    rcx,QWORD PTR [rbp-0x30]
    2d42:	mov    rbx,QWORD PTR [rbp-0x28]
    2d46:	mov    QWORD PTR [rax+0x20],rcx
    2d4a:	mov    QWORD PTR [rax+0x28],rbx
    2d4e:	mov    rdx,QWORD PTR [rbp-0x20]
    2d52:	mov    QWORD PTR [rax+0x30],rdx
    2d56:	call   2052 <__profile_end_pass>
    2d5b:	add    rsp,0x40

  return first_child;
    2d5f:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2d66:	mov    rdx,QWORD PTR [rbp-0x18]
    2d6a:	sub    rdx,QWORD PTR fs:0x28
    2d73:	je     2d7a <parse_json_children+0x3d1>
    2d75:	call   1060 <__stack_chk_fail@plt>
    2d7a:	mov    rbx,QWORD PTR [rbp-0x8]
    2d7e:	leave
    2d7f:	ret

0000000000002d80 <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2d80:	push   rbp
    2d81:	mov    rbp,rsp
    2d84:	push   rbx
    2d85:	sub    rsp,0xb8
    2d8c:	mov    QWORD PTR [rbp-0xa8],rdi
    2d93:	mov    rax,rsi
    2d96:	mov    rsi,rdx
    2d99:	mov    rax,rax
    2d9c:	mov    edx,0x0
    2da1:	mov    rdx,rsi
    2da4:	mov    QWORD PTR [rbp-0xc0],rax
    2dab:	mov    QWORD PTR [rbp-0xb8],rdx
    2db2:	mov    rax,QWORD PTR fs:0x28
    2dbb:	mov    QWORD PTR [rbp-0x18],rax
    2dbf:	xor    eax,eax
  profile_begin_func();
    2dc1:	lea    rcx,[rip+0x1a70]        # 4838 <__func__.2>
    2dc8:	mov    ebx,0xa
    2dcd:	lea    rax,[rbp-0x50]
    2dd1:	mov    rsi,rcx
    2dd4:	mov    rdx,rbx
    2dd7:	mov    r8d,0x0
    2ddd:	mov    ecx,0x3
    2de2:	mov    rdi,rax
    2de5:	call   1f68 <__profile_begin_pass>

  JSON_Parser parser =
    2dea:	mov    rax,QWORD PTR [rbp-0xc0]
    2df1:	mov    rdx,QWORD PTR [rbp-0xb8]
    2df8:	mov    QWORD PTR [rbp-0x90],rax
    2dff:	mov    QWORD PTR [rbp-0x88],rdx
    2e06:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2e0e:	lea    rax,[rbp-0x70]
    2e12:	lea    rdx,[rbp-0x90]
    2e19:	mov    rsi,rdx
    2e1c:	mov    rdi,rax
    2e1f:	call   2290 <get_json_token>
    2e24:	mov    ecx,0x0
    2e29:	mov    ebx,0x0
    2e2e:	lea    r8,[rbp-0x90]
    2e35:	mov    rdi,QWORD PTR [rbp-0xa8]
    2e3c:	sub    rsp,0x8
    2e40:	sub    rsp,0x18
    2e44:	mov    rsi,rsp
    2e47:	mov    rax,QWORD PTR [rbp-0x70]
    2e4b:	mov    rdx,QWORD PTR [rbp-0x68]
    2e4f:	mov    QWORD PTR [rsi],rax
    2e52:	mov    QWORD PTR [rsi+0x8],rdx
    2e56:	mov    rax,QWORD PTR [rbp-0x60]
    2e5a:	mov    QWORD PTR [rsi+0x10],rax
    2e5e:	mov    rdx,rcx
    2e61:	mov    rcx,rbx
    2e64:	mov    rsi,r8
    2e67:	call   27c2 <parse_json_object>
    2e6c:	add    rsp,0x20
    2e70:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2e77:	sub    rsp,0x8
    2e7b:	sub    rsp,0x38
    2e7f:	mov    rax,rsp
    2e82:	mov    rcx,QWORD PTR [rbp-0x50]
    2e86:	mov    rbx,QWORD PTR [rbp-0x48]
    2e8a:	mov    QWORD PTR [rax],rcx
    2e8d:	mov    QWORD PTR [rax+0x8],rbx
    2e91:	mov    rcx,QWORD PTR [rbp-0x40]
    2e95:	mov    rbx,QWORD PTR [rbp-0x38]
    2e99:	mov    QWORD PTR [rax+0x10],rcx
    2e9d:	mov    QWORD PTR [rax+0x18],rbx
    2ea1:	mov    rcx,QWORD PTR [rbp-0x30]
    2ea5:	mov    rbx,QWORD PTR [rbp-0x28]
    2ea9:	mov    QWORD PTR [rax+0x20],rcx
    2ead:	mov    QWORD PTR [rax+0x28],rbx
    2eb1:	mov    rdx,QWORD PTR [rbp-0x20]
    2eb5:	mov    QWORD PTR [rax+0x30],rdx
    2eb9:	call   2052 <__profile_end_pass>
    2ebe:	add    rsp,0x40

  return outer;
    2ec2:	mov    rax,QWORD PTR [rbp-0x98]
}
    2ec9:	mov    rdx,QWORD PTR [rbp-0x18]
    2ecd:	sub    rdx,QWORD PTR fs:0x28
    2ed6:	je     2edd <parse_json+0x15d>
    2ed8:	call   1060 <__stack_chk_fail@plt>
    2edd:	mov    rbx,QWORD PTR [rbp-0x8]
    2ee1:	leave
    2ee2:	ret

0000000000002ee3 <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2ee3:	push   rbp
    2ee4:	mov    rbp,rsp
    2ee7:	push   rbx
    2ee8:	sub    rsp,0x78
    2eec:	mov    QWORD PTR [rbp-0x68],rdi
    2ef0:	mov    rax,rsi
    2ef3:	mov    rsi,rdx
    2ef6:	mov    rax,rax
    2ef9:	mov    edx,0x0
    2efe:	mov    rdx,rsi
    2f01:	mov    QWORD PTR [rbp-0x80],rax
    2f05:	mov    QWORD PTR [rbp-0x78],rdx
    2f09:	mov    rax,QWORD PTR fs:0x28
    2f12:	mov    QWORD PTR [rbp-0x18],rax
    2f16:	xor    eax,eax
  profile_begin_func();
    2f18:	lea    rcx,[rip+0x1931]        # 4850 <__func__.1>
    2f1f:	mov    ebx,0x12
    2f24:	lea    rax,[rbp-0x50]
    2f28:	mov    rsi,rcx
    2f2b:	mov    rdx,rbx
    2f2e:	mov    r8d,0x0
    2f34:	mov    ecx,0x4
    2f39:	mov    rdi,rax
    2f3c:	call   1f68 <__profile_begin_pass>

  JSON_Object *result = NULL;
    2f41:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2f49:	cmp    QWORD PTR [rbp-0x68],0x0
    2f4e:	je     2f9d <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f50:	mov    rax,QWORD PTR [rbp-0x68]
    2f54:	mov    rax,QWORD PTR [rax+0x20]
    2f58:	mov    QWORD PTR [rbp-0x58],rax
    2f5c:	jmp    2f96 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2f5e:	mov    rax,QWORD PTR [rbp-0x58]
    2f62:	mov    rdx,QWORD PTR [rax+0x8]
    2f66:	mov    rax,QWORD PTR [rax]
    2f69:	mov    rdi,QWORD PTR [rbp-0x80]
    2f6d:	mov    rsi,QWORD PTR [rbp-0x78]
    2f71:	mov    rcx,rdx
    2f74:	mov    rdx,rax
    2f77:	call   143f <strings_equal>
    2f7c:	test   al,al
    2f7e:	je     2f8a <lookup_json_object+0xa7>
      {
        result = cursor;
    2f80:	mov    rax,QWORD PTR [rbp-0x58]
    2f84:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2f88:	jmp    2f9d <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f8a:	mov    rax,QWORD PTR [rbp-0x58]
    2f8e:	mov    rax,QWORD PTR [rax+0x28]
    2f92:	mov    QWORD PTR [rbp-0x58],rax
    2f96:	cmp    QWORD PTR [rbp-0x58],0x0
    2f9b:	jne    2f5e <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2f9d:	sub    rsp,0x8
    2fa1:	sub    rsp,0x38
    2fa5:	mov    rax,rsp
    2fa8:	mov    rcx,QWORD PTR [rbp-0x50]
    2fac:	mov    rbx,QWORD PTR [rbp-0x48]
    2fb0:	mov    QWORD PTR [rax],rcx
    2fb3:	mov    QWORD PTR [rax+0x8],rbx
    2fb7:	mov    rcx,QWORD PTR [rbp-0x40]
    2fbb:	mov    rbx,QWORD PTR [rbp-0x38]
    2fbf:	mov    QWORD PTR [rax+0x10],rcx
    2fc3:	mov    QWORD PTR [rax+0x18],rbx
    2fc7:	mov    rcx,QWORD PTR [rbp-0x30]
    2fcb:	mov    rbx,QWORD PTR [rbp-0x28]
    2fcf:	mov    QWORD PTR [rax+0x20],rcx
    2fd3:	mov    QWORD PTR [rax+0x28],rbx
    2fd7:	mov    rdx,QWORD PTR [rbp-0x20]
    2fdb:	mov    QWORD PTR [rax+0x30],rdx
    2fdf:	call   2052 <__profile_end_pass>
    2fe4:	add    rsp,0x40

  return result;
    2fe8:	mov    rax,QWORD PTR [rbp-0x60]
}
    2fec:	mov    rdx,QWORD PTR [rbp-0x18]
    2ff0:	sub    rdx,QWORD PTR fs:0x28
    2ff9:	je     3000 <lookup_json_object+0x11d>
    2ffb:	call   1060 <__stack_chk_fail@plt>
    3000:	mov    rbx,QWORD PTR [rbp-0x8]
    3004:	leave
    3005:	ret

0000000000003006 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    3006:	push   rbp
    3007:	mov    rbp,rsp
    300a:	sub    rsp,0x50
    300e:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    3012:	cmp    QWORD PTR [rbp-0x48],0x0
    3017:	jne    303e <json_object_to_f64+0x38>
    3019:	lea    rdx,[rip+0x1850]        # 4870 <__PRETTY_FUNCTION__.0>
    3020:	lea    rsi,[rip+0x1451]        # 4478 <_IO_stdin_used+0x478>
    3027:	lea    rax,[rip+0x15ca]        # 45f8 <_IO_stdin_used+0x5f8>
    302e:	mov    rcx,rdx
    3031:	mov    edx,0x1c2
    3036:	mov    rdi,rax
    3039:	call   1090 <__assert_fail@plt>

  String val = object->value;
    303e:	mov    rax,QWORD PTR [rbp-0x48]
    3042:	mov    rdx,QWORD PTR [rax+0x18]
    3046:	mov    rax,QWORD PTR [rax+0x10]
    304a:	mov    QWORD PTR [rbp-0x10],rax
    304e:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    3052:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    305a:	movsd  xmm0,QWORD PTR [rip+0x1846]        # 48a8 <__PRETTY_FUNCTION__.0+0x38>
    3062:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    3067:	mov    rax,QWORD PTR [rbp-0x8]
    306b:	cmp    QWORD PTR [rbp-0x30],rax
    306f:	jae    3095 <json_object_to_f64+0x8f>
    3071:	mov    rdx,QWORD PTR [rbp-0x10]
    3075:	mov    rax,QWORD PTR [rbp-0x30]
    3079:	add    rax,rdx
    307c:	movzx  eax,BYTE PTR [rax]
    307f:	cmp    al,0x2d
    3081:	jne    3095 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    3083:	movsd  xmm0,QWORD PTR [rip+0x1825]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    308b:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    3090:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    3095:	pxor   xmm0,xmm0
    3099:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    309e:	jmp    30e5 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    30a0:	mov    rdx,QWORD PTR [rbp-0x10]
    30a4:	mov    rax,QWORD PTR [rbp-0x30]
    30a8:	add    rax,rdx
    30ab:	movzx  eax,BYTE PTR [rax]
    30ae:	sub    eax,0x30
    30b1:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    30b4:	cmp    BYTE PTR [rbp-0x32],0x9
    30b8:	ja     30f1 <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    30ba:	movsd  xmm1,QWORD PTR [rbp-0x20]
    30bf:	movsd  xmm0,QWORD PTR [rip+0x17f1]        # 48b8 <__PRETTY_FUNCTION__.0+0x48>
    30c7:	mulsd  xmm1,xmm0
    30cb:	movzx  eax,BYTE PTR [rbp-0x32]
    30cf:	pxor   xmm0,xmm0
    30d3:	cvtsi2sd xmm0,eax
    30d7:	addsd  xmm0,xmm1
    30db:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    30e0:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    30e5:	mov    rax,QWORD PTR [rbp-0x8]
    30e9:	cmp    QWORD PTR [rbp-0x30],rax
    30ed:	jb     30a0 <json_object_to_f64+0x9a>
    30ef:	jmp    30f2 <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    30f1:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    30f2:	mov    rax,QWORD PTR [rbp-0x8]
    30f6:	cmp    QWORD PTR [rbp-0x30],rax
    30fa:	jae    3187 <json_object_to_f64+0x181>
    3100:	mov    rdx,QWORD PTR [rbp-0x10]
    3104:	mov    rax,QWORD PTR [rbp-0x30]
    3108:	add    rax,rdx
    310b:	movzx  eax,BYTE PTR [rax]
    310e:	cmp    al,0x2e
    3110:	jne    3187 <json_object_to_f64+0x181>
  {
    at += 1;
    3112:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    3117:	movsd  xmm0,QWORD PTR [rip+0x17a1]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    311f:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    3124:	jmp    317a <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3126:	mov    rdx,QWORD PTR [rbp-0x10]
    312a:	mov    rax,QWORD PTR [rbp-0x30]
    312e:	add    rax,rdx
    3131:	movzx  eax,BYTE PTR [rax]
    3134:	sub    eax,0x30
    3137:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    313a:	cmp    BYTE PTR [rbp-0x31],0x9
    313e:	ja     3186 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    3140:	movzx  eax,BYTE PTR [rbp-0x31]
    3144:	pxor   xmm0,xmm0
    3148:	cvtsi2sd xmm0,eax
    314c:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    3151:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3156:	addsd  xmm0,xmm1
    315a:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    315f:	movsd  xmm1,QWORD PTR [rbp-0x18]
    3164:	movsd  xmm0,QWORD PTR [rip+0x1754]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    316c:	mulsd  xmm0,xmm1
    3170:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3175:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    317a:	mov    rax,QWORD PTR [rbp-0x8]
    317e:	cmp    QWORD PTR [rbp-0x30],rax
    3182:	jb     3126 <json_object_to_f64+0x120>
    3184:	jmp    3187 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    3186:	nop
      }
    }
  }

  return sign * result;
    3187:	movsd  xmm0,QWORD PTR [rbp-0x28]
    318c:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    3191:	leave
    3192:	ret

0000000000003193 <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    3193:	push   rbp
    3194:	mov    rbp,rsp
    3197:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    319c:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31a1:	movsd  xmm1,QWORD PTR [rip+0x171f]        # 48c8 <__PRETTY_FUNCTION__.0+0x58>
    31a9:	divsd  xmm0,xmm1
}
    31ad:	pop    rbp
    31ae:	ret

00000000000031af <square>:

static
f64 square(f64 x)
{
    31af:	push   rbp
    31b0:	mov    rbp,rsp
    31b3:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    31b8:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31bd:	mulsd  xmm0,xmm0
}
    31c1:	pop    rbp
    31c2:	ret

00000000000031c3 <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    31c3:	push   rbp
    31c4:	mov    rbp,rsp
    31c7:	sub    rsp,0x90
    31ce:	movsd  QWORD PTR [rbp-0x58],xmm0
    31d3:	movsd  QWORD PTR [rbp-0x60],xmm1
    31d8:	movsd  QWORD PTR [rbp-0x68],xmm2
    31dd:	movsd  QWORD PTR [rbp-0x70],xmm3
    31e2:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    31e7:	movsd  xmm0,QWORD PTR [rbp-0x60]
    31ec:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    31f1:	movsd  xmm0,QWORD PTR [rbp-0x70]
    31f6:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    31fb:	movsd  xmm0,QWORD PTR [rbp-0x58]
    3200:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    3205:	movsd  xmm0,QWORD PTR [rbp-0x68]
    320a:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    320f:	movsd  xmm0,QWORD PTR [rbp-0x40]
    3214:	subsd  xmm0,QWORD PTR [rbp-0x48]
    3219:	movq   rax,xmm0
    321e:	movq   xmm0,rax
    3223:	call   3193 <to_radians>
    3228:	movq   rax,xmm0
    322d:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    3231:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3236:	subsd  xmm0,QWORD PTR [rbp-0x38]
    323b:	movq   rax,xmm0
    3240:	movq   xmm0,rax
    3245:	call   3193 <to_radians>
    324a:	movq   rax,xmm0
    324f:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    3253:	mov    rax,QWORD PTR [rbp-0x48]
    3257:	movq   xmm0,rax
    325c:	call   3193 <to_radians>
    3261:	movq   rax,xmm0
    3266:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    326a:	mov    rax,QWORD PTR [rbp-0x40]
    326e:	movq   xmm0,rax
    3273:	call   3193 <to_radians>
    3278:	movq   rax,xmm0
    327d:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    3281:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3286:	movsd  xmm1,QWORD PTR [rip+0x1642]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    328e:	divsd  xmm0,xmm1
    3292:	movq   rax,xmm0
    3297:	movq   xmm0,rax
    329c:	call   1130 <sin@plt>
    32a1:	movq   rax,xmm0
    32a6:	movq   xmm0,rax
    32ab:	call   31af <square>
    32b0:	movsd  QWORD PTR [rbp-0x80],xmm0
    32b5:	mov    rax,QWORD PTR [rbp-0x48]
    32b9:	movq   xmm0,rax
    32be:	call   10b0 <cos@plt>
    32c3:	movsd  QWORD PTR [rbp-0x88],xmm0
    32cb:	mov    rax,QWORD PTR [rbp-0x40]
    32cf:	movq   xmm0,rax
    32d4:	call   10b0 <cos@plt>
    32d9:	movapd xmm5,xmm0
    32dd:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    32e5:	movsd  QWORD PTR [rbp-0x88],xmm5
    32ed:	movsd  xmm0,QWORD PTR [rbp-0x20]
    32f2:	movsd  xmm1,QWORD PTR [rip+0x15d6]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    32fa:	movapd xmm6,xmm0
    32fe:	divsd  xmm6,xmm1
    3302:	movq   rax,xmm6
    3307:	movq   xmm0,rax
    330c:	call   1130 <sin@plt>
    3311:	movq   rax,xmm0
    3316:	movq   xmm0,rax
    331b:	call   31af <square>
    3320:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    3328:	addsd  xmm0,QWORD PTR [rbp-0x80]
    332d:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    3332:	mov    rax,QWORD PTR [rbp-0x18]
    3336:	movq   xmm0,rax
    333b:	call   1160 <sqrt@plt>
    3340:	movq   rax,xmm0
    3345:	movq   xmm0,rax
    334a:	call   1140 <asin@plt>
    334f:	addsd  xmm0,xmm0
    3353:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    3358:	movsd  xmm0,QWORD PTR [rbp-0x78]
    335d:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    3362:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3367:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    336c:	leave
    336d:	ret

000000000000336e <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    336e:	push   rbp
    336f:	mov    rbp,rsp
    3372:	movsd  QWORD PTR [rbp-0x18],xmm0
    3377:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    337c:	movsd  xmm0,QWORD PTR [rip+0x1554]        # 48d8 <__PRETTY_FUNCTION__.0+0x68>
    3384:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    3389:	movsd  xmm0,QWORD PTR [rbp-0x18]
    338e:	movq   xmm1,QWORD PTR [rip+0x154a]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    3396:	andpd  xmm0,xmm1
    339a:	movsd  xmm1,QWORD PTR [rbp-0x20]
    339f:	movq   xmm2,QWORD PTR [rip+0x1539]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    33a7:	andpd  xmm2,xmm1
    33ab:	movapd xmm1,xmm0
    33af:	subsd  xmm1,xmm2
    33b3:	movsd  xmm0,QWORD PTR [rbp-0x8]
    33b8:	comisd xmm0,xmm1
    33bc:	setae  al
    33bf:	movzx  eax,al
}
    33c2:	pop    rbp
    33c3:	ret

00000000000033c4 <main>:

int main(int args_count, char **args)
{
    33c4:	push   rbp
    33c5:	mov    rbp,rsp
    33c8:	push   r15
    33ca:	push   r14
    33cc:	push   r13
    33ce:	push   r12
    33d0:	push   rbx
    33d1:	sub    rsp,0x268
    33d8:	mov    DWORD PTR [rbp-0x1f4],edi
    33de:	mov    QWORD PTR [rbp-0x200],rsi
    33e5:	mov    rax,QWORD PTR fs:0x28
    33ee:	mov    QWORD PTR [rbp-0x38],rax
    33f2:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    33f4:	cmp    DWORD PTR [rbp-0x1f4],0x3
    33fb:	je     3428 <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    33fd:	mov    rax,QWORD PTR [rbp-0x200]
    3404:	mov    rax,QWORD PTR [rax]
    3407:	lea    rdx,[rip+0x1222]        # 4630 <_IO_stdin_used+0x630>
    340e:	mov    rsi,rax
    3411:	mov    rdi,rdx
    3414:	mov    eax,0x0
    3419:	call   1070 <printf@plt>
    return 1;
    341e:	mov    eax,0x1
    3423:	jmp    3d5e <main+0x99a>
  }

  begin_profiling();
    3428:	call   1b3d <begin_profiling>

  Arena arena = {0};
    342d:	pxor   xmm0,xmm0
    3431:	movaps XMMWORD PTR [rbp-0x150],xmm0
    3438:	movaps XMMWORD PTR [rbp-0x140],xmm0
  arena = arena_make(GB(4));
    343f:	lea    rdx,[rbp-0x220]
    3446:	movabs rax,0x100000000
    3450:	mov    rsi,rax
    3453:	mov    rdi,rdx
    3456:	call   1632 <arena_make>
    345b:	mov    rax,QWORD PTR [rbp-0x220]
    3462:	mov    rdx,QWORD PTR [rbp-0x218]
    3469:	mov    QWORD PTR [rbp-0x150],rax
    3470:	mov    QWORD PTR [rbp-0x148],rdx
    3477:	mov    rax,QWORD PTR [rbp-0x210]
    347e:	mov    rdx,QWORD PTR [rbp-0x208]
    3485:	mov    QWORD PTR [rbp-0x140],rax
    348c:	mov    QWORD PTR [rbp-0x138],rdx

  String source = {0};
    3493:	mov    QWORD PTR [rbp-0x160],0x0
    349e:	mov    QWORD PTR [rbp-0x158],0x0
  printf("%lu", file_size(args[1]));
    34a9:	mov    rax,QWORD PTR [rbp-0x200]
    34b0:	add    rax,0x8
    34b4:	mov    rax,QWORD PTR [rax]
    34b7:	mov    rdi,rax
    34ba:	call   1303 <file_size>
    34bf:	mov    rdx,rax
    34c2:	lea    rax,[rip+0x1193]        # 465c <_IO_stdin_used+0x65c>
    34c9:	mov    rsi,rdx
    34cc:	mov    rdi,rax
    34cf:	mov    eax,0x0
    34d4:	call   1070 <printf@plt>
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    34d9:	mov    rax,QWORD PTR [rbp-0x200]
    34e0:	add    rax,0x8
    34e4:	mov    rax,QWORD PTR [rax]
    34e7:	mov    rdi,rax
    34ea:	call   1303 <file_size>
    34ef:	mov    rcx,rax
    34f2:	lea    r12,[rip+0x1167]        # 4660 <_IO_stdin_used+0x660>
    34f9:	mov    r13d,0x4
    34ff:	lea    rdi,[rbp-0x130]
    3506:	mov    rdx,r12
    3509:	mov    rax,r13
    350c:	mov    r8,rcx
    350f:	mov    ecx,0x5
    3514:	mov    rsi,rdx
    3517:	mov    rdx,rax
    351a:	call   1f68 <__profile_begin_pass>
    351f:	mov    QWORD PTR [rbp-0x1e0],0x0
    352a:	jmp    35c5 <main+0x201>
  {
    source = read_file_to_arena(&arena, args[1]);
    352f:	mov    rax,QWORD PTR [rbp-0x200]
    3536:	add    rax,0x8
    353a:	mov    rdx,QWORD PTR [rax]
    353d:	lea    rax,[rbp-0x150]
    3544:	mov    rsi,rdx
    3547:	mov    rdi,rax
    354a:	call   1357 <read_file_to_arena>
    354f:	mov    QWORD PTR [rbp-0x160],rax
    3556:	mov    QWORD PTR [rbp-0x158],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    355d:	add    QWORD PTR [rbp-0x1e0],0x1
    3565:	sub    rsp,0x8
    3569:	sub    rsp,0x38
    356d:	mov    rcx,rsp
    3570:	mov    rax,QWORD PTR [rbp-0x130]
    3577:	mov    rdx,QWORD PTR [rbp-0x128]
    357e:	mov    QWORD PTR [rcx],rax
    3581:	mov    QWORD PTR [rcx+0x8],rdx
    3585:	mov    rax,QWORD PTR [rbp-0x120]
    358c:	mov    rdx,QWORD PTR [rbp-0x118]
    3593:	mov    QWORD PTR [rcx+0x10],rax
    3597:	mov    QWORD PTR [rcx+0x18],rdx
    359b:	mov    rax,QWORD PTR [rbp-0x110]
    35a2:	mov    rdx,QWORD PTR [rbp-0x108]
    35a9:	mov    QWORD PTR [rcx+0x20],rax
    35ad:	mov    QWORD PTR [rcx+0x28],rdx
    35b1:	mov    rax,QWORD PTR [rbp-0x100]
    35b8:	mov    QWORD PTR [rcx+0x30],rax
    35bc:	call   2052 <__profile_end_pass>
    35c1:	add    rsp,0x40
    35c5:	cmp    QWORD PTR [rbp-0x1e0],0x0
    35cd:	je     352f <main+0x16b>
  }

  usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    35d3:	mov    QWORD PTR [rbp-0x1a8],0x18
  usize max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    35de:	mov    rax,QWORD PTR [rbp-0x158]
    35e5:	mov    edx,0x0
    35ea:	div    QWORD PTR [rbp-0x1a8]
    35f1:	mov    QWORD PTR [rbp-0x1a0],rax
  Haversine_Pair * pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    35f8:	mov    rax,QWORD PTR [rbp-0x1a0]
    35ff:	shl    rax,0x5
    3603:	mov    rcx,rax
    3606:	lea    rax,[rbp-0x150]
    360d:	mov    edx,0x8
    3612:	mov    rsi,rcx
    3615:	mov    rdi,rax
    3618:	call   17d3 <arena_alloc>
    361d:	mov    QWORD PTR [rbp-0x198],rax
  i32 pair_count = 0;
    3624:	mov    DWORD PTR [rbp-0x1e8],0x0

  JSON_Object *root = NULL;
    362e:	mov    QWORD PTR [rbp-0x190],0x0
  root = parse_json(&arena, source);
    3639:	mov    rcx,QWORD PTR [rbp-0x160]
    3640:	mov    rdx,QWORD PTR [rbp-0x158]
    3647:	lea    rax,[rbp-0x150]
    364e:	mov    rsi,rcx
    3651:	mov    rdi,rax
    3654:	call   2d80 <parse_json>
    3659:	mov    QWORD PTR [rbp-0x190],rax

  f64 haversine_sum = 0.0;
    3660:	pxor   xmm0,xmm0
    3664:	movsd  QWORD PTR [rbp-0x188],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    366c:	lea    r14,[rip+0xff2]        # 4665 <_IO_stdin_used+0x665>
    3673:	mov    r15d,0x5
    3679:	mov    rcx,r14
    367c:	mov    rdx,r15
    367f:	mov    rax,QWORD PTR [rbp-0x190]
    3686:	mov    rsi,rcx
    3689:	mov    rdi,rax
    368c:	call   2ee3 <lookup_json_object>
    3691:	mov    QWORD PTR [rbp-0x180],rax
  if (pairs)
    3698:	cmp    QWORD PTR [rbp-0x198],0x0
    36a0:	je     3865 <main+0x4a1>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    36a6:	mov    rax,QWORD PTR [rbp-0x180]
    36ad:	mov    rax,QWORD PTR [rax+0x20]
    36b1:	mov    QWORD PTR [rbp-0x1d8],rax
    36b8:	jmp    3846 <main+0x482>
    {
      Haversine_Pair pair =
      {
        .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    36bd:	lea    rax,[rip+0xfa7]        # 466b <_IO_stdin_used+0x66b>
    36c4:	mov    QWORD PTR [rbp-0x260],rax
    36cb:	mov    QWORD PTR [rbp-0x258],0x2
    36d6:	mov    rbx,QWORD PTR [rbp-0x260]
    36dd:	mov    rsi,QWORD PTR [rbp-0x258]
    36e4:	mov    rax,rbx
    36e7:	mov    rdx,rsi
    36ea:	mov    rcx,QWORD PTR [rbp-0x1d8]
    36f1:	mov    rsi,rax
    36f4:	mov    rdi,rcx
    36f7:	call   2ee3 <lookup_json_object>
    36fc:	mov    rdi,rax
    36ff:	call   3006 <json_object_to_f64>
    3704:	movq   rax,xmm0
      Haversine_Pair pair =
    3709:	mov    QWORD PTR [rbp-0x70],rax
        .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    370d:	lea    rax,[rip+0xf5a]        # 466e <_IO_stdin_used+0x66e>
    3714:	mov    QWORD PTR [rbp-0x270],rax
    371b:	mov    QWORD PTR [rbp-0x268],0x2
    3726:	mov    rax,QWORD PTR [rbp-0x270]
    372d:	mov    rdx,QWORD PTR [rbp-0x268]
    3734:	mov    rcx,rax
    3737:	mov    rax,QWORD PTR [rbp-0x1d8]
    373e:	mov    rsi,rcx
    3741:	mov    rdi,rax
    3744:	call   2ee3 <lookup_json_object>
    3749:	mov    rdi,rax
    374c:	call   3006 <json_object_to_f64>
    3751:	movq   rax,xmm0
      Haversine_Pair pair =
    3756:	mov    QWORD PTR [rbp-0x68],rax
        .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    375a:	lea    rax,[rip+0xf10]        # 4671 <_IO_stdin_used+0x671>
    3761:	mov    QWORD PTR [rbp-0x280],rax
    3768:	mov    QWORD PTR [rbp-0x278],0x2
    3773:	mov    rax,QWORD PTR [rbp-0x280]
    377a:	mov    rdx,QWORD PTR [rbp-0x278]
    3781:	mov    rcx,rax
    3784:	mov    rax,QWORD PTR [rbp-0x1d8]
    378b:	mov    rsi,rcx
    378e:	mov    rdi,rax
    3791:	call   2ee3 <lookup_json_object>
    3796:	mov    rdi,rax
    3799:	call   3006 <json_object_to_f64>
    379e:	movq   rax,xmm0
      Haversine_Pair pair =
    37a3:	mov    QWORD PTR [rbp-0x60],rax
        .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    37a7:	lea    rax,[rip+0xec6]        # 4674 <_IO_stdin_used+0x674>
    37ae:	mov    QWORD PTR [rbp-0x290],rax
    37b5:	mov    QWORD PTR [rbp-0x288],0x2
    37c0:	mov    rax,QWORD PTR [rbp-0x290]
    37c7:	mov    rdx,QWORD PTR [rbp-0x288]
    37ce:	mov    rcx,rax
    37d1:	mov    rax,QWORD PTR [rbp-0x1d8]
    37d8:	mov    rsi,rcx
    37db:	mov    rdi,rax
    37de:	call   2ee3 <lookup_json_object>
    37e3:	mov    rdi,rax
    37e6:	call   3006 <json_object_to_f64>
    37eb:	movq   rax,xmm0
      Haversine_Pair pair =
    37f0:	mov    QWORD PTR [rbp-0x58],rax
      };

      pairs[pair_count] = pair;
    37f4:	mov    eax,DWORD PTR [rbp-0x1e8]
    37fa:	cdqe
    37fc:	shl    rax,0x5
    3800:	mov    rdx,rax
    3803:	mov    rax,QWORD PTR [rbp-0x198]
    380a:	lea    rcx,[rdx+rax*1]
    380e:	mov    rax,QWORD PTR [rbp-0x70]
    3812:	mov    rdx,QWORD PTR [rbp-0x68]
    3816:	mov    QWORD PTR [rcx],rax
    3819:	mov    QWORD PTR [rcx+0x8],rdx
    381d:	mov    rax,QWORD PTR [rbp-0x60]
    3821:	mov    rdx,QWORD PTR [rbp-0x58]
    3825:	mov    QWORD PTR [rcx+0x10],rax
    3829:	mov    QWORD PTR [rcx+0x18],rdx
      pair_count += 1;
    382d:	add    DWORD PTR [rbp-0x1e8],0x1
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    3834:	mov    rax,QWORD PTR [rbp-0x1d8]
    383b:	mov    rax,QWORD PTR [rax+0x28]
    383f:	mov    QWORD PTR [rbp-0x1d8],rax
    3846:	cmp    QWORD PTR [rbp-0x1d8],0x0
    384e:	je     3865 <main+0x4a1>
    3850:	mov    eax,DWORD PTR [rbp-0x1e8]
    3856:	cdqe
    3858:	cmp    rax,QWORD PTR [rbp-0x1a0]
    385f:	jb     36bd <main+0x2f9>
    }
  }

  f64 sum = 0.0;
    3865:	pxor   xmm0,xmm0
    3869:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    3871:	mov    eax,DWORD PTR [rbp-0x1e8]
    3877:	cdqe
    3879:	shl    rax,0x5
    387d:	mov    rdx,rax
    3880:	lea    rax,[rip+0xdf0]        # 4677 <_IO_stdin_used+0x677>
    3887:	mov    QWORD PTR [rbp-0x230],rax
    388e:	mov    QWORD PTR [rbp-0x228],0x3
    3899:	lea    rax,[rbp-0xf0]
    38a0:	mov    rcx,QWORD PTR [rbp-0x230]
    38a7:	mov    rbx,QWORD PTR [rbp-0x228]
    38ae:	mov    rsi,rcx
    38b1:	mov    rdi,rbx
    38b4:	mov    r8,rdx
    38b7:	mov    ecx,0x6
    38bc:	mov    rdx,rdi
    38bf:	mov    rdi,rax
    38c2:	call   1f68 <__profile_begin_pass>
    38c7:	mov    QWORD PTR [rbp-0x1c8],0x0
    38d2:	jmp    3a54 <main+0x690>
  {
    for (usize i = 0; i < pair_count; i++)
    38d7:	mov    QWORD PTR [rbp-0x1c0],0x0
    38e2:	jmp    39b7 <main+0x5f3>
    {
      f64 earth_radius = 6372.8;
    38e7:	movsd  xmm0,QWORD PTR [rip+0x1001]        # 48f0 <__PRETTY_FUNCTION__.0+0x80>
    38ef:	movsd  QWORD PTR [rbp-0x170],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    38f7:	mov    rax,QWORD PTR [rbp-0x1c0]
    38fe:	shl    rax,0x5
    3902:	mov    rdx,rax
    3905:	mov    rax,QWORD PTR [rbp-0x198]
    390c:	add    rax,rdx
    390f:	movsd  xmm2,QWORD PTR [rax+0x18]
    3914:	mov    rax,QWORD PTR [rbp-0x1c0]
    391b:	shl    rax,0x5
    391f:	mov    rdx,rax
    3922:	mov    rax,QWORD PTR [rbp-0x198]
    3929:	add    rax,rdx
    392c:	movsd  xmm1,QWORD PTR [rax+0x10]
    3931:	mov    rax,QWORD PTR [rbp-0x1c0]
    3938:	shl    rax,0x5
    393c:	mov    rdx,rax
    393f:	mov    rax,QWORD PTR [rbp-0x198]
    3946:	add    rax,rdx
    3949:	movsd  xmm0,QWORD PTR [rax+0x8]
    394e:	mov    rax,QWORD PTR [rbp-0x1c0]
    3955:	shl    rax,0x5
    3959:	mov    rdx,rax
    395c:	mov    rax,QWORD PTR [rbp-0x198]
    3963:	add    rax,rdx
    3966:	mov    rax,QWORD PTR [rax]
    3969:	movsd  xmm3,QWORD PTR [rbp-0x170]
    3971:	movapd xmm4,xmm3
    3975:	movapd xmm3,xmm2
    3979:	movapd xmm2,xmm1
    397d:	movapd xmm1,xmm0
    3981:	movq   xmm0,rax
    3986:	call   31c3 <reference_haversine>
    398b:	movq   rax,xmm0
    3990:	mov    QWORD PTR [rbp-0x168],rax
      sum += result;
    3997:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    399f:	addsd  xmm0,QWORD PTR [rbp-0x168]
    39a7:	movsd  QWORD PTR [rbp-0x1d0],xmm0
    for (usize i = 0; i < pair_count; i++)
    39af:	add    QWORD PTR [rbp-0x1c0],0x1
    39b7:	mov    eax,DWORD PTR [rbp-0x1e8]
    39bd:	cdqe
    39bf:	cmp    QWORD PTR [rbp-0x1c0],rax
    39c6:	jb     38e7 <main+0x523>
    }
    sum /= pair_count;
    39cc:	pxor   xmm1,xmm1
    39d0:	cvtsi2sd xmm1,DWORD PTR [rbp-0x1e8]
    39d8:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    39e0:	divsd  xmm0,xmm1
    39e4:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    39ec:	add    QWORD PTR [rbp-0x1c8],0x1
    39f4:	sub    rsp,0x8
    39f8:	sub    rsp,0x38
    39fc:	mov    rax,rsp
    39ff:	mov    rcx,QWORD PTR [rbp-0xf0]
    3a06:	mov    rbx,QWORD PTR [rbp-0xe8]
    3a0d:	mov    QWORD PTR [rax],rcx
    3a10:	mov    QWORD PTR [rax+0x8],rbx
    3a14:	mov    rcx,QWORD PTR [rbp-0xe0]
    3a1b:	mov    rbx,QWORD PTR [rbp-0xd8]
    3a22:	mov    QWORD PTR [rax+0x10],rcx
    3a26:	mov    QWORD PTR [rax+0x18],rbx
    3a2a:	mov    rcx,QWORD PTR [rbp-0xd0]
    3a31:	mov    rbx,QWORD PTR [rbp-0xc8]
    3a38:	mov    QWORD PTR [rax+0x20],rcx
    3a3c:	mov    QWORD PTR [rax+0x28],rbx
    3a40:	mov    rdx,QWORD PTR [rbp-0xc0]
    3a47:	mov    QWORD PTR [rax+0x30],rdx
    3a4b:	call   2052 <__profile_end_pass>
    3a50:	add    rsp,0x40
    3a54:	cmp    QWORD PTR [rbp-0x1c8],0x0
    3a5c:	je     38d7 <main+0x513>
  }

  PROFILE_SCOPE("check")
    3a62:	lea    rax,[rip+0xc12]        # 467b <_IO_stdin_used+0x67b>
    3a69:	mov    QWORD PTR [rbp-0x240],rax
    3a70:	mov    QWORD PTR [rbp-0x238],0x5
    3a7b:	lea    rax,[rbp-0xb0]
    3a82:	mov    rcx,QWORD PTR [rbp-0x240]
    3a89:	mov    rbx,QWORD PTR [rbp-0x238]
    3a90:	mov    rsi,rcx
    3a93:	mov    rdx,rbx
    3a96:	mov    r8d,0x0
    3a9c:	mov    ecx,0x7
    3aa1:	mov    rdi,rax
    3aa4:	call   1f68 <__profile_begin_pass>
    3aa9:	mov    QWORD PTR [rbp-0x1b8],0x0
    3ab4:	jmp    3c89 <main+0x8c5>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3ab9:	mov    rax,QWORD PTR [rbp-0x200]
    3ac0:	add    rax,0x10
    3ac4:	mov    rdx,QWORD PTR [rax]
    3ac7:	lea    rax,[rbp-0x150]
    3ace:	mov    rsi,rdx
    3ad1:	mov    rdi,rax
    3ad4:	call   1357 <read_file_to_arena>
    3ad9:	mov    QWORD PTR [rbp-0x70],rax
    3add:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3ae1:	mov    rax,QWORD PTR [rbp-0x68]
    3ae5:	cmp    rax,0xb
    3ae9:	jbe    3bfc <main+0x838>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3aef:	mov    rax,QWORD PTR [rbp-0x70]
    3af3:	movsd  xmm0,QWORD PTR [rax]
    3af7:	movsd  QWORD PTR [rbp-0x178],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3aff:	mov    rax,QWORD PTR [rbp-0x70]
    3b03:	mov    eax,DWORD PTR [rax+0x8]
    3b06:	mov    DWORD PTR [rbp-0x1e4],eax

      if (solution_pairs == pair_count)
    3b0c:	mov    eax,DWORD PTR [rbp-0x1e4]
    3b12:	cmp    eax,DWORD PTR [rbp-0x1e8]
    3b18:	jne    3bc0 <main+0x7fc>
      {
        if (epsilon_equal(solution_sum, sum))
    3b1e:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3b26:	mov    rax,QWORD PTR [rbp-0x178]
    3b2d:	movapd xmm1,xmm0
    3b31:	movq   xmm0,rax
    3b36:	call   336e <epsilon_equal>
    3b3b:	test   eax,eax
    3b3d:	je     3b81 <main+0x7bd>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3b3f:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3b47:	mov    rax,QWORD PTR [rbp-0x178]
    3b4e:	lea    rdx,[rip+0xb33]        # 4688 <_IO_stdin_used+0x688>
    3b55:	lea    rsi,[rip+0xb5f]        # 46bb <_IO_stdin_used+0x6bb>
    3b5c:	movapd xmm1,xmm0
    3b60:	movq   xmm0,rax
    3b65:	mov    rcx,rdx
    3b68:	mov    edx,0x5b
    3b6d:	mov    edi,0x3
    3b72:	mov    eax,0x2
    3b77:	call   14a1 <log_message>
    3b7c:	jmp    3c24 <main+0x860>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3b81:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3b89:	mov    rax,QWORD PTR [rbp-0x178]
    3b90:	lea    rdx,[rip+0xb39]        # 46d0 <_IO_stdin_used+0x6d0>
    3b97:	lea    rsi,[rip+0xb1d]        # 46bb <_IO_stdin_used+0x6bb>
    3b9e:	movapd xmm1,xmm0
    3ba2:	movq   xmm0,rax
    3ba7:	mov    rcx,rdx
    3baa:	mov    edx,0x5f
    3baf:	mov    edi,0x1
    3bb4:	mov    eax,0x2
    3bb9:	call   14a1 <log_message>
    3bbe:	jmp    3c24 <main+0x860>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3bc0:	mov    esi,DWORD PTR [rbp-0x1e8]
    3bc6:	mov    ecx,DWORD PTR [rbp-0x1e4]
    3bcc:	lea    rdx,[rip+0xb35]        # 4708 <_IO_stdin_used+0x708>
    3bd3:	lea    rax,[rip+0xae1]        # 46bb <_IO_stdin_used+0x6bb>
    3bda:	mov    r9d,esi
    3bdd:	mov    r8d,ecx
    3be0:	mov    rcx,rdx
    3be3:	mov    edx,0x64
    3be8:	mov    rsi,rax
    3beb:	mov    edi,0x1
    3bf0:	mov    eax,0x0
    3bf5:	call   14a1 <log_message>
    3bfa:	jmp    3c24 <main+0x860>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3bfc:	lea    rdx,[rip+0xb4d]        # 4750 <_IO_stdin_used+0x750>
    3c03:	lea    rax,[rip+0xab1]        # 46bb <_IO_stdin_used+0x6bb>
    3c0a:	mov    rcx,rdx
    3c0d:	mov    edx,0x69
    3c12:	mov    rsi,rax
    3c15:	mov    edi,0x1
    3c1a:	mov    eax,0x0
    3c1f:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3c24:	add    QWORD PTR [rbp-0x1b8],0x1
    3c2c:	sub    rsp,0x8
    3c30:	sub    rsp,0x38
    3c34:	mov    rax,rsp
    3c37:	mov    rcx,QWORD PTR [rbp-0xb0]
    3c3e:	mov    rbx,QWORD PTR [rbp-0xa8]
    3c45:	mov    QWORD PTR [rax],rcx
    3c48:	mov    QWORD PTR [rax+0x8],rbx
    3c4c:	mov    rcx,QWORD PTR [rbp-0xa0]
    3c53:	mov    rbx,QWORD PTR [rbp-0x98]
    3c5a:	mov    QWORD PTR [rax+0x10],rcx
    3c5e:	mov    QWORD PTR [rax+0x18],rbx
    3c62:	mov    rcx,QWORD PTR [rbp-0x90]
    3c69:	mov    rbx,QWORD PTR [rbp-0x88]
    3c70:	mov    QWORD PTR [rax+0x20],rcx
    3c74:	mov    QWORD PTR [rax+0x28],rbx
    3c78:	mov    rdx,QWORD PTR [rbp-0x80]
    3c7c:	mov    QWORD PTR [rax+0x30],rdx
    3c80:	call   2052 <__profile_end_pass>
    3c85:	add    rsp,0x40
    3c89:	cmp    QWORD PTR [rbp-0x1b8],0x0
    3c91:	je     3ab9 <main+0x6f5>
    }
  }

  PROFILE_SCOPE("free")
    3c97:	lea    rax,[rip+0xaed]        # 478b <_IO_stdin_used+0x78b>
    3c9e:	mov    QWORD PTR [rbp-0x250],rax
    3ca5:	mov    QWORD PTR [rbp-0x248],0x4
    3cb0:	lea    rax,[rbp-0x70]
    3cb4:	mov    rcx,QWORD PTR [rbp-0x250]
    3cbb:	mov    rbx,QWORD PTR [rbp-0x248]
    3cc2:	mov    rsi,rcx
    3cc5:	mov    rdx,rbx
    3cc8:	mov    r8d,0x0
    3cce:	mov    ecx,0x8
    3cd3:	mov    rdi,rax
    3cd6:	call   1f68 <__profile_begin_pass>
    3cdb:	mov    QWORD PTR [rbp-0x1b0],0x0
    3ce6:	jmp    3d4a <main+0x986>
  {
    arena_free(&arena);
    3ce8:	lea    rax,[rbp-0x150]
    3cef:	mov    rdi,rax
    3cf2:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3cf7:	add    QWORD PTR [rbp-0x1b0],0x1
    3cff:	sub    rsp,0x8
    3d03:	sub    rsp,0x38
    3d07:	mov    rax,rsp
    3d0a:	mov    rcx,QWORD PTR [rbp-0x70]
    3d0e:	mov    rbx,QWORD PTR [rbp-0x68]
    3d12:	mov    QWORD PTR [rax],rcx
    3d15:	mov    QWORD PTR [rax+0x8],rbx
    3d19:	mov    rcx,QWORD PTR [rbp-0x60]
    3d1d:	mov    rbx,QWORD PTR [rbp-0x58]
    3d21:	mov    QWORD PTR [rax+0x10],rcx
    3d25:	mov    QWORD PTR [rax+0x18],rbx
    3d29:	mov    rcx,QWORD PTR [rbp-0x50]
    3d2d:	mov    rbx,QWORD PTR [rbp-0x48]
    3d31:	mov    QWORD PTR [rax+0x20],rcx
    3d35:	mov    QWORD PTR [rax+0x28],rbx
    3d39:	mov    rdx,QWORD PTR [rbp-0x40]
    3d3d:	mov    QWORD PTR [rax+0x30],rdx
    3d41:	call   2052 <__profile_end_pass>
    3d46:	add    rsp,0x40
    3d4a:	cmp    QWORD PTR [rbp-0x1b0],0x0
    3d52:	je     3ce8 <main+0x924>
  }

  end_profiling();
    3d54:	call   1b9b <end_profiling>
    3d59:	mov    eax,0x0
}
    3d5e:	mov    rdx,QWORD PTR [rbp-0x38]
    3d62:	sub    rdx,QWORD PTR fs:0x28
    3d6b:	je     3d72 <main+0x9ae>
    3d6d:	call   1060 <__stack_chk_fail@plt>
    3d72:	lea    rsp,[rbp-0x28]
    3d76:	pop    rbx
    3d77:	pop    r12
    3d79:	pop    r13
    3d7b:	pop    r14
    3d7d:	pop    r15
    3d7f:	pop    rbp
    3d80:	ret

Disassembly of section .fini:

0000000000003d84 <_fini>:
    3d84:	endbr64
    3d88:	sub    rsp,0x8
    3d8c:	add    rsp,0x8
    3d90:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x4fc1]        # 5fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x4fca]        # 5ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x4fcc]        # 5ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x4fca]        # 6000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x4fc2]        # 6008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x4fba]        # 6010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x4fb2]        # 6018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x4faa]        # 6020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x4fa2]        # 6028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x4f9a]        # 6030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x4f92]        # 6038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x4f8a]        # 6040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x4f82]        # 6048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x4f7a]        # 6050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x4f72]        # 6058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x4f6a]        # 6060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x4f62]        # 6068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x4f5a]        # 6070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x4f52]        # 6078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x4f4a]        # 6080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x4f42]        # 6088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x4f3a]        # 6090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x4f32]        # 6098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2235]        # 33c4 <main>
    118f:	call   QWORD PTR [rip+0x4e2b]        # 5fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x4fa1]        # 6148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x4f9a]        # 6148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x4e0e]        # 5fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x4f71]        # 6148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x4f6a]        # 6148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x4ddd]        # 5fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x4f6d],0x0        # 6188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x4dba],0x0        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x4e76]        # 60a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x4da8]        # 5fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x4f44],0x1        # 6188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  FILE *file = fopen(name, "rb");
    127d:	lea    rdx,[rip+0x2d8c]        # 4010 <_IO_stdin_used+0x10>
    1284:	mov    rax,QWORD PTR [rbp-0x18]
    1288:	mov    rsi,rdx
    128b:	mov    rdi,rax
    128e:	call   1110 <fopen@plt>
    1293:	mov    QWORD PTR [rbp-0x10],rax
  if (file == NULL)
    1297:	cmp    QWORD PTR [rbp-0x10],0x0
    129c:	jne    12d4 <read_file_to_memory+0x6b>
  {
    LOG_ERROR("Unable to open file: %s", name);
    129e:	mov    rcx,QWORD PTR [rbp-0x18]
    12a2:	lea    rdx,[rip+0x2d6a]        # 4013 <_IO_stdin_used+0x13>
    12a9:	lea    rax,[rip+0x2d7b]        # 402b <_IO_stdin_used+0x2b>
    12b0:	mov    r8,rcx
    12b3:	mov    rcx,rdx
    12b6:	mov    edx,0x17b
    12bb:	mov    rsi,rax
    12be:	mov    edi,0x1
    12c3:	mov    eax,0x0
    12c8:	call   14a1 <log_message>
    return 0;
    12cd:	mov    eax,0x0
    12d2:	jmp    1301 <read_file_to_memory+0x98>
  }

  usize byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12d4:	mov    rcx,QWORD PTR [rbp-0x10]
    12d8:	mov    rdx,QWORD PTR [rbp-0x28]
    12dc:	mov    rax,QWORD PTR [rbp-0x20]
    12e0:	mov    esi,0x1
    12e5:	mov    rdi,rax
    12e8:	call   1040 <fread@plt>
    12ed:	mov    QWORD PTR [rbp-0x8],rax
  fclose(file);
    12f1:	mov    rax,QWORD PTR [rbp-0x10]
    12f5:	mov    rdi,rax
    12f8:	call   1050 <fclose@plt>

  return byte_count;
    12fd:	mov    rax,QWORD PTR [rbp-0x8]
}
    1301:	leave
    1302:	ret

0000000000001303 <file_size>:

usize file_size(const char *name)
{
    1303:	push   rbp
    1304:	mov    rbp,rsp
    1307:	sub    rsp,0xb0
    130e:	mov    QWORD PTR [rbp-0xa8],rdi
    1315:	mov    rax,QWORD PTR fs:0x28
    131e:	mov    QWORD PTR [rbp-0x8],rax
    1322:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1324:	lea    rdx,[rbp-0xa0]
    132b:	mov    rax,QWORD PTR [rbp-0xa8]
    1332:	mov    rsi,rdx
    1335:	mov    rdi,rax
    1338:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    133d:	mov    rax,QWORD PTR [rbp-0x70]
}
    1341:	mov    rdx,QWORD PTR [rbp-0x8]
    1345:	sub    rdx,QWORD PTR fs:0x28
    134e:	je     1355 <file_size+0x52>
    1350:	call   1060 <__stack_chk_fail@plt>
    1355:	leave
    1356:	ret

0000000000001357 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1357:	push   rbp
    1358:	mov    rbp,rsp
    135b:	sub    rsp,0x50
    135f:	mov    QWORD PTR [rbp-0x48],rdi
    1363:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1367:	mov    rax,QWORD PTR [rbp-0x50]
    136b:	mov    rdi,rax
    136e:	call   1303 <file_size>
    1373:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1377:	mov    rcx,QWORD PTR [rbp-0x48]
    137b:	mov    rax,QWORD PTR [rcx]
    137e:	mov    rdx,QWORD PTR [rcx+0x8]
    1382:	mov    QWORD PTR [rbp-0x20],rax
    1386:	mov    QWORD PTR [rbp-0x18],rdx
    138a:	mov    rax,QWORD PTR [rcx+0x10]
    138e:	mov    rdx,QWORD PTR [rcx+0x18]
    1392:	mov    QWORD PTR [rbp-0x10],rax
    1396:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139a:	mov    rcx,QWORD PTR [rbp-0x40]
    139e:	mov    rax,QWORD PTR [rbp-0x48]
    13a2:	mov    edx,0x1
    13a7:	mov    rsi,rcx
    13aa:	mov    rdi,rax
    13ad:	call   17d3 <arena_alloc>
    13b2:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b6:	mov    rdx,QWORD PTR [rbp-0x40]
    13ba:	mov    rcx,QWORD PTR [rbp-0x38]
    13be:	mov    rax,QWORD PTR [rbp-0x50]
    13c2:	mov    rsi,rcx
    13c5:	mov    rdi,rax
    13c8:	call   1269 <read_file_to_memory>
    13cd:	cmp    QWORD PTR [rbp-0x40],rax
    13d1:	je     1425 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d3:	mov    rcx,QWORD PTR [rbp-0x50]
    13d7:	lea    rdx,[rip+0x2c5a]        # 4038 <_IO_stdin_used+0x38>
    13de:	lea    rax,[rip+0x2c46]        # 402b <_IO_stdin_used+0x2b>
    13e5:	mov    r8,rcx
    13e8:	mov    rcx,rdx
    13eb:	mov    edx,0x19d
    13f0:	mov    rsi,rax
    13f3:	mov    edi,0x1
    13f8:	mov    eax,0x0
    13fd:	call   14a1 <log_message>
    *arena = save; // Rollback allocation
    1402:	mov    rcx,QWORD PTR [rbp-0x48]
    1406:	mov    rax,QWORD PTR [rbp-0x20]
    140a:	mov    rdx,QWORD PTR [rbp-0x18]
    140e:	mov    QWORD PTR [rcx],rax
    1411:	mov    QWORD PTR [rcx+0x8],rdx
    1415:	mov    rax,QWORD PTR [rbp-0x10]
    1419:	mov    rdx,QWORD PTR [rbp-0x8]
    141d:	mov    QWORD PTR [rcx+0x10],rax
    1421:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1425:	mov    rax,QWORD PTR [rbp-0x38]
    1429:	mov    QWORD PTR [rbp-0x30],rax
    142d:	mov    rax,QWORD PTR [rbp-0x40]
    1431:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1435:	mov    rax,QWORD PTR [rbp-0x30]
    1439:	mov    rdx,QWORD PTR [rbp-0x28]
}
    143d:	leave
    143e:	ret

000000000000143f <strings_equal>:

b8 strings_equal(String a, String b)
{
    143f:	push   rbp
    1440:	mov    rbp,rsp
    1443:	sub    rsp,0x20
    1447:	mov    rax,rdi
    144a:	mov    r8,rsi
    144d:	mov    rsi,rax
    1450:	mov    edi,0x0
    1455:	mov    rdi,r8
    1458:	mov    QWORD PTR [rbp-0x10],rsi
    145c:	mov    QWORD PTR [rbp-0x8],rdi
    1460:	mov    QWORD PTR [rbp-0x20],rdx
    1464:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    1468:	mov    rdx,QWORD PTR [rbp-0x8]
    146c:	mov    rax,QWORD PTR [rbp-0x18]
    1470:	cmp    rdx,rax
    1473:	jne    149a <strings_equal+0x5b>
    1475:	mov    rax,QWORD PTR [rbp-0x8]
    1479:	mov    rdx,rax
    147c:	mov    rcx,QWORD PTR [rbp-0x20]
    1480:	mov    rax,QWORD PTR [rbp-0x10]
    1484:	mov    rsi,rcx
    1487:	mov    rdi,rax
    148a:	call   10d0 <memcmp@plt>
    148f:	test   eax,eax
    1491:	jne    149a <strings_equal+0x5b>
    1493:	mov    eax,0x1
    1498:	jmp    149f <strings_equal+0x60>
    149a:	mov    eax,0x0
}
    149f:	leave
    14a0:	ret

00000000000014a1 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a1:	push   rbp
    14a2:	mov    rbp,rsp
    14a5:	sub    rsp,0x100
    14ac:	mov    DWORD PTR [rbp-0xe4],edi
    14b2:	mov    QWORD PTR [rbp-0xf0],rsi
    14b9:	mov    QWORD PTR [rbp-0xf8],rdx
    14c0:	mov    QWORD PTR [rbp-0x100],rcx
    14c7:	mov    QWORD PTR [rbp-0x90],r8
    14ce:	mov    QWORD PTR [rbp-0x88],r9
    14d5:	test   al,al
    14d7:	je     14f9 <log_message+0x58>
    14d9:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14dd:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e1:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e5:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14e9:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14ed:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f1:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f5:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14f9:	mov    rax,QWORD PTR fs:0x28
    1502:	mov    QWORD PTR [rbp-0xb8],rax
    1509:	xor    eax,eax
  FILE *stream = stderr;
    150b:	mov    rax,QWORD PTR [rip+0x4c6e]        # 6180 <stderr@GLIBC_2.2.5>
    1512:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1519:	cmp    DWORD PTR [rbp-0xe4],0x1
    1520:	ja     1569 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1522:	mov    eax,DWORD PTR [rbp-0xe4]
    1528:	lea    rdx,[rax*8+0x0]
    1530:	lea    rax,[rip+0x4b89]        # 60c0 <level_strings>
    1537:	mov    rdx,QWORD PTR [rdx+rax*1]
    153b:	mov    rdi,QWORD PTR [rbp-0xf8]
    1542:	mov    rcx,QWORD PTR [rbp-0xf0]
    1549:	lea    rsi,[rip+0x2b27]        # 4077 <_IO_stdin_used+0x77>
    1550:	mov    rax,QWORD PTR [rbp-0xd8]
    1557:	mov    r8,rdi
    155a:	mov    rdi,rax
    155d:	mov    eax,0x0
    1562:	call   10f0 <fprintf@plt>
    1567:	jmp    15b7 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    1569:	cmp    DWORD PTR [rbp-0xe4],0x3
    1570:	jne    1580 <log_message+0xdf>
    {
      stream = stdout;
    1572:	mov    rax,QWORD PTR [rip+0x4be7]        # 6160 <stdout@GLIBC_2.2.5>
    1579:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1580:	mov    eax,DWORD PTR [rbp-0xe4]
    1586:	lea    rdx,[rax*8+0x0]
    158e:	lea    rax,[rip+0x4b2b]        # 60c0 <level_strings>
    1595:	mov    rdx,QWORD PTR [rdx+rax*1]
    1599:	lea    rcx,[rip+0x2aee]        # 408e <_IO_stdin_used+0x8e>
    15a0:	mov    rax,QWORD PTR [rbp-0xd8]
    15a7:	mov    rsi,rcx
    15aa:	mov    rdi,rax
    15ad:	mov    eax,0x0
    15b2:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15b7:	mov    DWORD PTR [rbp-0xd0],0x20
    15c1:	mov    DWORD PTR [rbp-0xcc],0x30
    15cb:	lea    rax,[rbp+0x10]
    15cf:	mov    QWORD PTR [rbp-0xc8],rax
    15d6:	lea    rax,[rbp-0xb0]
    15dd:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e4:	lea    rdx,[rbp-0xd0]
    15eb:	mov    rcx,QWORD PTR [rbp-0x100]
    15f2:	mov    rax,QWORD PTR [rbp-0xd8]
    15f9:	mov    rsi,rcx
    15fc:	mov    rdi,rax
    15ff:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1604:	mov    rax,QWORD PTR [rbp-0xd8]
    160b:	mov    rsi,rax
    160e:	mov    edi,0xa
    1613:	call   10c0 <fputc@plt>
}
    1618:	nop
    1619:	mov    rax,QWORD PTR [rbp-0xb8]
    1620:	sub    rax,QWORD PTR fs:0x28
    1629:	je     1630 <log_message+0x18f>
    162b:	call   1060 <__stack_chk_fail@plt>
    1630:	leave
    1631:	ret

0000000000001632 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1632:	push   rbp
    1633:	mov    rbp,rsp
    1636:	sub    rsp,0x30
    163a:	mov    QWORD PTR [rbp-0x28],rdi
    163e:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1642:	pxor   xmm0,xmm0
    1646:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164a:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    164e:	mov    rax,QWORD PTR [rbp-0x30]
    1652:	mov    esi,0x1
    1657:	mov    rdi,rax
    165a:	call   10e0 <calloc@plt>
    165f:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1663:	mov    rax,QWORD PTR [rbp-0x20]
    1667:	test   rax,rax
    166a:	jne    169e <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166c:	lea    rdx,[rip+0x2a2d]        # 40a0 <_IO_stdin_used+0xa0>
    1673:	lea    rax,[rip+0x29b1]        # 402b <_IO_stdin_used+0x2b>
    167a:	mov    rcx,rdx
    167d:	mov    edx,0x1d9
    1682:	mov    rsi,rax
    1685:	mov    edi,0x0
    168a:	mov    eax,0x0
    168f:	call   14a1 <log_message>
    1694:	mov    edi,0xffffffff
    1699:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    169e:	mov    rax,QWORD PTR [rbp-0x30]
    16a2:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a6:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16ae:	mov    rcx,QWORD PTR [rbp-0x28]
    16b2:	mov    rax,QWORD PTR [rbp-0x20]
    16b6:	mov    rdx,QWORD PTR [rbp-0x18]
    16ba:	mov    QWORD PTR [rcx],rax
    16bd:	mov    QWORD PTR [rcx+0x8],rdx
    16c1:	mov    rax,QWORD PTR [rbp-0x10]
    16c5:	mov    rdx,QWORD PTR [rbp-0x8]
    16c9:	mov    QWORD PTR [rcx+0x10],rax
    16cd:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d1:	mov    rax,QWORD PTR [rbp-0x28]
    16d5:	leave
    16d6:	ret

00000000000016d7 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16d7:	push   rbp
    16d8:	mov    rbp,rsp
    16db:	sub    rsp,0x40
    16df:	mov    QWORD PTR [rbp-0x28],rdi
    16e3:	mov    QWORD PTR [rbp-0x30],rsi
    16e7:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16eb:	cmp    QWORD PTR [rbp-0x30],0x0
    16f0:	jne    1717 <arena_make_backed+0x40>
    16f2:	lea    rdx,[rip+0x3097]        # 4790 <__PRETTY_FUNCTION__.9>
    16f9:	lea    rsi,[rip+0x292b]        # 402b <_IO_stdin_used+0x2b>
    1700:	lea    rax,[rip+0x29b9]        # 40c0 <_IO_stdin_used+0xc0>
    1707:	mov    rcx,rdx
    170a:	mov    edx,0x1e5
    170f:	mov    rdi,rax
    1712:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1717:	cmp    QWORD PTR [rbp-0x38],0x0
    171c:	jne    1743 <arena_make_backed+0x6c>
    171e:	lea    rdx,[rip+0x306b]        # 4790 <__PRETTY_FUNCTION__.9>
    1725:	lea    rsi,[rip+0x28ff]        # 402b <_IO_stdin_used+0x2b>
    172c:	lea    rax,[rip+0x29dd]        # 4110 <_IO_stdin_used+0x110>
    1733:	mov    rcx,rdx
    1736:	mov    edx,0x1e6
    173b:	mov    rdi,rax
    173e:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1743:	pxor   xmm0,xmm0
    1747:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174b:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    174f:	mov    rax,QWORD PTR [rbp-0x30]
    1753:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1757:	mov    rax,QWORD PTR [rbp-0x38]
    175b:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    175f:	mov    eax,DWORD PTR [rbp-0x8]
    1762:	or     eax,0x1
    1765:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    1768:	mov    rcx,QWORD PTR [rbp-0x28]
    176c:	mov    rax,QWORD PTR [rbp-0x20]
    1770:	mov    rdx,QWORD PTR [rbp-0x18]
    1774:	mov    QWORD PTR [rcx],rax
    1777:	mov    QWORD PTR [rcx+0x8],rdx
    177b:	mov    rax,QWORD PTR [rbp-0x10]
    177f:	mov    rdx,QWORD PTR [rbp-0x8]
    1783:	mov    QWORD PTR [rcx+0x10],rax
    1787:	mov    QWORD PTR [rcx+0x18],rdx
}
    178b:	mov    rax,QWORD PTR [rbp-0x28]
    178f:	leave
    1790:	ret

0000000000001791 <arena_free>:

void arena_free(Arena *arena)
{
    1791:	push   rbp
    1792:	mov    rbp,rsp
    1795:	sub    rsp,0x10
    1799:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    179d:	mov    rax,QWORD PTR [rbp-0x8]
    17a1:	mov    eax,DWORD PTR [rax+0x18]
    17a4:	and    eax,0x1
    17a7:	test   eax,eax
    17a9:	jne    17ba <arena_free+0x29>
  {
    free(arena->base);
    17ab:	mov    rax,QWORD PTR [rbp-0x8]
    17af:	mov    rax,QWORD PTR [rax]
    17b2:	mov    rdi,rax
    17b5:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17ba:	mov    rax,QWORD PTR [rbp-0x8]
    17be:	mov    edx,0x20
    17c3:	mov    esi,0x0
    17c8:	mov    rdi,rax
    17cb:	call   10a0 <memset@plt>
}
    17d0:	nop
    17d1:	leave
    17d2:	ret

00000000000017d3 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d3:	push   rbp
    17d4:	mov    rbp,rsp
    17d7:	sub    rsp,0x40
    17db:	mov    QWORD PTR [rbp-0x28],rdi
    17df:	mov    QWORD PTR [rbp-0x30],rsi
    17e3:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17e7:	mov    rax,QWORD PTR [rbp-0x28]
    17eb:	mov    rax,QWORD PTR [rax]
    17ee:	test   rax,rax
    17f1:	jne    1818 <arena_alloc+0x45>
    17f3:	lea    rdx,[rip+0x2fae]        # 47a8 <__PRETTY_FUNCTION__.8>
    17fa:	lea    rsi,[rip+0x282a]        # 402b <_IO_stdin_used+0x2b>
    1801:	lea    rax,[rip+0x2950]        # 4158 <_IO_stdin_used+0x158>
    1808:	mov    rcx,rdx
    180b:	mov    edx,0x1fe
    1810:	mov    rdi,rax
    1813:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1818:	mov    rax,QWORD PTR [rbp-0x28]
    181c:	mov    rdx,QWORD PTR [rax+0x10]
    1820:	mov    rax,QWORD PTR [rbp-0x38]
    1824:	add    rax,rdx
    1827:	lea    rdx,[rax-0x1]
    182b:	mov    rax,QWORD PTR [rbp-0x38]
    182f:	neg    rax
    1832:	and    rax,rdx
    1835:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1839:	mov    rdx,QWORD PTR [rbp-0x18]
    183d:	mov    rax,QWORD PTR [rbp-0x30]
    1841:	add    rdx,rax
    1844:	mov    rax,QWORD PTR [rbp-0x28]
    1848:	mov    rax,QWORD PTR [rax+0x8]
    184c:	cmp    rdx,rax
    184f:	jle    18a4 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1851:	mov    rdx,QWORD PTR [rbp-0x18]
    1855:	mov    rax,QWORD PTR [rbp-0x30]
    1859:	add    rax,rdx
    185c:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1860:	mov    rax,QWORD PTR [rbp-0x28]
    1864:	mov    rsi,QWORD PTR [rax+0x8]
    1868:	mov    rcx,QWORD PTR [rbp-0x8]
    186c:	lea    rdx,[rip+0x291d]        # 4190 <_IO_stdin_used+0x190>
    1873:	lea    rax,[rip+0x27b1]        # 402b <_IO_stdin_used+0x2b>
    187a:	mov    r9,rsi
    187d:	mov    r8,rcx
    1880:	mov    rcx,rdx
    1883:	mov    edx,0x207
    1888:	mov    rsi,rax
    188b:	mov    edi,0x0
    1890:	mov    eax,0x0
    1895:	call   14a1 <log_message>
    189a:	mov    edi,0xffffffff
    189f:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a4:	mov    rax,QWORD PTR [rbp-0x28]
    18a8:	mov    rdx,QWORD PTR [rax]
    18ab:	mov    rax,QWORD PTR [rbp-0x18]
    18af:	add    rax,rdx
    18b2:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b6:	mov    rdx,QWORD PTR [rbp-0x30]
    18ba:	mov    rax,QWORD PTR [rbp-0x10]
    18be:	mov    esi,0x0
    18c3:	mov    rdi,rax
    18c6:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18cb:	mov    rdx,QWORD PTR [rbp-0x18]
    18cf:	mov    rax,QWORD PTR [rbp-0x30]
    18d3:	add    rdx,rax
    18d6:	mov    rax,QWORD PTR [rbp-0x28]
    18da:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18de:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e2:	leave
    18e3:	ret

00000000000018e4 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e4:	push   rbp
    18e5:	mov    rbp,rsp
    18e8:	sub    rsp,0x10
    18ec:	mov    QWORD PTR [rbp-0x8],rdi
    18f0:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f4:	mov    rax,QWORD PTR [rbp-0x8]
    18f8:	mov    rax,QWORD PTR [rax+0x10]
    18fc:	cmp    QWORD PTR [rbp-0x10],rax
    1900:	jl     1927 <arena_pop_to+0x43>
    1902:	lea    rdx,[rip+0x2eaf]        # 47b8 <__PRETTY_FUNCTION__.7>
    1909:	lea    rsi,[rip+0x271b]        # 402b <_IO_stdin_used+0x2b>
    1910:	lea    rax,[rip+0x28b9]        # 41d0 <_IO_stdin_used+0x1d0>
    1917:	mov    rcx,rdx
    191a:	mov    edx,0x217
    191f:	mov    rdi,rax
    1922:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1927:	mov    rax,QWORD PTR [rbp-0x8]
    192b:	mov    rdx,QWORD PTR [rbp-0x10]
    192f:	mov    QWORD PTR [rax+0x10],rdx
}
    1933:	nop
    1934:	leave
    1935:	ret

0000000000001936 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1936:	push   rbp
    1937:	mov    rbp,rsp
    193a:	sub    rsp,0x10
    193e:	mov    QWORD PTR [rbp-0x8],rdi
    1942:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1946:	mov    rax,QWORD PTR [rbp-0x8]
    194a:	mov    rax,QWORD PTR [rax+0x10]
    194e:	sub    rax,QWORD PTR [rbp-0x10]
    1952:	mov    rdx,rax
    1955:	mov    rax,QWORD PTR [rbp-0x8]
    1959:	mov    rsi,rdx
    195c:	mov    rdi,rax
    195f:	call   18e4 <arena_pop_to>
}
    1964:	nop
    1965:	leave
    1966:	ret

0000000000001967 <arena_clear>:

void arena_clear(Arena *arena)
{
    1967:	push   rbp
    1968:	mov    rbp,rsp
    196b:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    196f:	mov    rax,QWORD PTR [rbp-0x8]
    1973:	mov    QWORD PTR [rax+0x10],0x0
}
    197b:	nop
    197c:	pop    rbp
    197d:	ret

000000000000197e <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    197e:	push   rbp
    197f:	mov    rbp,rsp
    1982:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1986:	mov    rax,QWORD PTR [rbp-0x18]
    198a:	mov    QWORD PTR [rbp-0x10],rax
    198e:	mov    rax,QWORD PTR [rbp-0x18]
    1992:	mov    rax,QWORD PTR [rax+0x10]
    1996:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199a:	mov    rax,QWORD PTR [rbp-0x10]
    199e:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a2:	pop    rbp
    19a3:	ret

00000000000019a4 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a4:	push   rbp
    19a5:	mov    rbp,rsp
    19a8:	sub    rsp,0x10
    19ac:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b0:	mov    rax,QWORD PTR [rbp-0x8]
    19b4:	mov    rdx,QWORD PTR [rax+0x8]
    19b8:	mov    rax,QWORD PTR [rbp-0x8]
    19bc:	mov    rax,QWORD PTR [rax]
    19bf:	mov    rsi,rdx
    19c2:	mov    rdi,rax
    19c5:	call   18e4 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19ca:	mov    rax,QWORD PTR [rbp-0x8]
    19ce:	mov    edx,0x10
    19d3:	mov    esi,0x0
    19d8:	mov    rdi,rax
    19db:	call   10a0 <memset@plt>
}
    19e0:	nop
    19e1:	leave
    19e2:	ret

00000000000019e3 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e3:	push   rbp
    19e4:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19e7:	mov    eax,0xf4240
}
    19ec:	pop    rbp
    19ed:	ret

00000000000019ee <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19ee:	push   rbp
    19ef:	mov    rbp,rsp
    19f2:	sub    rsp,0x30
    19f6:	mov    rax,QWORD PTR fs:0x28
    19ff:	mov    QWORD PTR [rbp-0x8],rax
    1a03:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a05:	lea    rax,[rbp-0x20]
    1a09:	mov    esi,0x0
    1a0e:	mov    rdi,rax
    1a11:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a16:	call   19e3 <get_os_timer_freq>
    1a1b:	mov    rdx,QWORD PTR [rbp-0x20]
    1a1f:	imul   rax,rdx
    1a23:	mov    rdx,QWORD PTR [rbp-0x18]
    1a27:	add    rax,rdx
    1a2a:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a2e:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a32:	mov    rdx,QWORD PTR [rbp-0x8]
    1a36:	sub    rdx,QWORD PTR fs:0x28
    1a3f:	je     1a46 <read_os_timer+0x58>
    1a41:	call   1060 <__stack_chk_fail@plt>
    1a46:	leave
    1a47:	ret

0000000000001a48 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a48:	push   rbp
    1a49:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4c:	rdtsc
    1a4e:	shl    rdx,0x20
    1a52:	or     rax,rdx
  return __rdtsc();
}
    1a55:	pop    rbp
    1a56:	ret

0000000000001a57 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a57:	push   rbp
    1a58:	mov    rbp,rsp
    1a5b:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a5f:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a67:	call   19e3 <get_os_timer_freq>
    1a6c:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a70:	call   1a48 <read_cpu_timer>
    1a75:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a79:	call   19ee <read_os_timer>
    1a7e:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a82:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8a:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a92:	mov    rax,QWORD PTR [rbp-0x40]
    1a96:	imul   rax,QWORD PTR [rbp-0x48]
    1a9b:	shr    rax,0x3
    1a9f:	movabs rdx,0x20c49ba5e353f7cf
    1aa9:	mul    rdx
    1aac:	mov    rax,rdx
    1aaf:	shr    rax,0x4
    1ab3:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1ab7:	jmp    1ace <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1ab9:	call   19ee <read_os_timer>
    1abe:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac2:	mov    rax,QWORD PTR [rbp-0x28]
    1ac6:	sub    rax,QWORD PTR [rbp-0x30]
    1aca:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ace:	mov    rax,QWORD PTR [rbp-0x50]
    1ad2:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad6:	jb     1ab9 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1ad8:	call   1a48 <read_cpu_timer>
    1add:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae1:	mov    rax,QWORD PTR [rbp-0x18]
    1ae5:	sub    rax,QWORD PTR [rbp-0x38]
    1ae9:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1aed:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af5:	cmp    QWORD PTR [rbp-0x50],0x0
    1afa:	jne    1b21 <estimate_cpu_freq+0xca>
    1afc:	lea    rdx,[rip+0x2ccd]        # 47d0 <__PRETTY_FUNCTION__.6>
    1b03:	lea    rsi,[rip+0x2725]        # 422f <_IO_stdin_used+0x22f>
    1b0a:	lea    rax,[rip+0x272f]        # 4240 <_IO_stdin_used+0x240>
    1b11:	mov    rcx,rdx
    1b14:	mov    edx,0x3b
    1b19:	mov    rdi,rax
    1b1c:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b21:	mov    rax,QWORD PTR [rbp-0x40]
    1b25:	imul   rax,QWORD PTR [rbp-0x10]
    1b2a:	mov    edx,0x0
    1b2f:	div    QWORD PTR [rbp-0x50]
    1b33:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b37:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3b:	leave
    1b3c:	ret

0000000000001b3d <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1b3d:	push   rbp
    1b3e:	mov    rbp,rsp
    1b41:	push   rbx
    1b42:	sub    rsp,0x30028
    1b49:	mov    rax,QWORD PTR fs:0x28
    1b52:	mov    QWORD PTR [rbp-0x18],rax
    1b56:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1b58:	call   1a48 <read_cpu_timer>
    1b5d:	mov    rbx,rax
  g_profiler = (Profiler)
    1b60:	lea    rax,[rip+0x4639]        # 61a0 <g_profiler>
    1b67:	mov    edx,0x30010
    1b6c:	mov    esi,0x0
    1b71:	mov    rdi,rax
    1b74:	call   10a0 <memset@plt>
    1b79:	mov    QWORD PTR [rip+0x4620],rbx        # 61a0 <g_profiler>
  };
}
    1b80:	nop
    1b81:	mov    rax,QWORD PTR [rbp-0x18]
    1b85:	sub    rax,QWORD PTR fs:0x28
    1b8e:	je     1b95 <begin_profiling+0x58>
    1b90:	call   1060 <__stack_chk_fail@plt>
    1b95:	mov    rbx,QWORD PTR [rbp-0x8]
    1b99:	leave
    1b9a:	ret

0000000000001b9b <end_profiling>:

static
void end_profiling()
{
    1b9b:	push   rbp
    1b9c:	mov    rbp,rsp
    1b9f:	sub    rsp,0x50
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1ba3:	call   1a48 <read_cpu_timer>
    1ba8:	mov    rdx,rax
    1bab:	mov    rax,QWORD PTR [rip+0x45ee]        # 61a0 <g_profiler>
    1bb2:	sub    rdx,rax
    1bb5:	mov    QWORD PTR [rbp-0x38],rdx

  if (total_delta)
    1bb9:	cmp    QWORD PTR [rbp-0x38],0x0
    1bbe:	je     1f65 <end_profiling+0x3ca>
  {
    u64 freq = estimate_cpu_freq();
    1bc4:	call   1a57 <estimate_cpu_freq>
    1bc9:	mov    QWORD PTR [rbp-0x30],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1bcd:	mov    rax,QWORD PTR [rbp-0x38]
    1bd1:	test   rax,rax
    1bd4:	js     1be1 <end_profiling+0x46>
    1bd6:	pxor   xmm0,xmm0
    1bda:	cvtsi2sd xmm0,rax
    1bdf:	jmp    1bfa <end_profiling+0x5f>
    1be1:	mov    rdx,rax
    1be4:	shr    rdx,1
    1be7:	and    eax,0x1
    1bea:	or     rdx,rax
    1bed:	pxor   xmm0,xmm0
    1bf1:	cvtsi2sd xmm0,rdx
    1bf6:	addsd  xmm0,xmm0
    1bfa:	mov    rax,QWORD PTR [rbp-0x30]
    1bfe:	test   rax,rax
    1c01:	js     1c0e <end_profiling+0x73>
    1c03:	pxor   xmm1,xmm1
    1c07:	cvtsi2sd xmm1,rax
    1c0c:	jmp    1c27 <end_profiling+0x8c>
    1c0e:	mov    rdx,rax
    1c11:	shr    rdx,1
    1c14:	and    eax,0x1
    1c17:	or     rdx,rax
    1c1a:	pxor   xmm1,xmm1
    1c1e:	cvtsi2sd xmm1,rdx
    1c23:	addsd  xmm1,xmm1
    1c27:	movapd xmm2,xmm0
    1c2b:	divsd  xmm2,xmm1
    1c2f:	movsd  xmm0,QWORD PTR [rip+0x2c51]        # 4888 <__PRETTY_FUNCTION__.0+0x18>
    1c37:	mulsd  xmm2,xmm0
    1c3b:	movq   rcx,xmm2
    1c40:	mov    rdx,QWORD PTR [rbp-0x30]
    1c44:	mov    rax,QWORD PTR [rbp-0x38]
    1c48:	lea    rdi,[rip+0x2641]        # 4290 <_IO_stdin_used+0x290>
    1c4f:	movq   xmm0,rcx
    1c54:	mov    rsi,rax
    1c57:	mov    eax,0x1
    1c5c:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1c61:	pxor   xmm0,xmm0
    1c65:	movsd  QWORD PTR [rbp-0x48],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1c6a:	mov    QWORD PTR [rbp-0x40],0x0
    1c72:	jmp    1f57 <end_profiling+0x3bc>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1c77:	mov    rdx,QWORD PTR [rbp-0x40]
    1c7b:	mov    rax,rdx
    1c7e:	add    rax,rax
    1c81:	add    rax,rdx
    1c84:	shl    rax,0x4
    1c88:	lea    rdx,[rax+0x10]
    1c8c:	lea    rax,[rip+0x450d]        # 61a0 <g_profiler>
    1c93:	add    rax,rdx
    1c96:	mov    QWORD PTR [rbp-0x28],rax

      if (zone->elapsed_inclusive)
    1c9a:	mov    rax,QWORD PTR [rbp-0x28]
    1c9e:	mov    rax,QWORD PTR [rax+0x18]
    1ca2:	test   rax,rax
    1ca5:	je     1f52 <end_profiling+0x3b7>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1cab:	mov    rax,QWORD PTR [rbp-0x28]
    1caf:	mov    rax,QWORD PTR [rax+0x10]
    1cb3:	test   rax,rax
    1cb6:	js     1cc3 <end_profiling+0x128>
    1cb8:	pxor   xmm0,xmm0
    1cbc:	cvtsi2sd xmm0,rax
    1cc1:	jmp    1cdc <end_profiling+0x141>
    1cc3:	mov    rdx,rax
    1cc6:	shr    rdx,1
    1cc9:	and    eax,0x1
    1ccc:	or     rdx,rax
    1ccf:	pxor   xmm0,xmm0
    1cd3:	cvtsi2sd xmm0,rdx
    1cd8:	addsd  xmm0,xmm0
    1cdc:	mov    rax,QWORD PTR [rbp-0x38]
    1ce0:	test   rax,rax
    1ce3:	js     1cf0 <end_profiling+0x155>
    1ce5:	pxor   xmm1,xmm1
    1ce9:	cvtsi2sd xmm1,rax
    1cee:	jmp    1d09 <end_profiling+0x16e>
    1cf0:	mov    rdx,rax
    1cf3:	shr    rdx,1
    1cf6:	and    eax,0x1
    1cf9:	or     rdx,rax
    1cfc:	pxor   xmm1,xmm1
    1d00:	cvtsi2sd xmm1,rdx
    1d05:	addsd  xmm1,xmm1
    1d09:	movapd xmm2,xmm0
    1d0d:	divsd  xmm2,xmm1
    1d11:	movsd  xmm0,QWORD PTR [rip+0x2b77]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1d19:	mulsd  xmm0,xmm2
    1d1d:	movsd  QWORD PTR [rbp-0x20],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1d22:	mov    rax,QWORD PTR [rbp-0x28]
    1d26:	mov    rsi,QWORD PTR [rax+0x10]
    1d2a:	mov    rax,QWORD PTR [rbp-0x28]
    1d2e:	mov    rdx,QWORD PTR [rax+0x20]
    1d32:	mov    rax,QWORD PTR [rbp-0x28]
    1d36:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1d39:	mov    rcx,QWORD PTR [rbp-0x28]
    1d3d:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1d41:	mov    r9d,ecx
    1d44:	mov    rcx,QWORD PTR [rbp-0x20]
    1d48:	lea    rdi,[rip+0x2571]        # 42c0 <_IO_stdin_used+0x2c0>
    1d4f:	movq   xmm0,rcx
    1d54:	mov    r8,rsi
    1d57:	mov    rcx,rdx
    1d5a:	mov    rdx,rax
    1d5d:	mov    esi,r9d
    1d60:	mov    eax,0x1
    1d65:	call   1070 <printf@plt>

        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1d6a:	mov    rax,QWORD PTR [rbp-0x28]
    1d6e:	mov    rdx,QWORD PTR [rax+0x10]
    1d72:	mov    rax,QWORD PTR [rbp-0x28]
    1d76:	mov    rax,QWORD PTR [rax+0x18]
    1d7a:	cmp    rdx,rax
    1d7d:	je     1e22 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1d83:	mov    rax,QWORD PTR [rbp-0x28]
    1d87:	mov    rax,QWORD PTR [rax+0x18]
    1d8b:	test   rax,rax
    1d8e:	js     1d9b <end_profiling+0x200>
    1d90:	pxor   xmm0,xmm0
    1d94:	cvtsi2sd xmm0,rax
    1d99:	jmp    1db4 <end_profiling+0x219>
    1d9b:	mov    rdx,rax
    1d9e:	shr    rdx,1
    1da1:	and    eax,0x1
    1da4:	or     rdx,rax
    1da7:	pxor   xmm0,xmm0
    1dab:	cvtsi2sd xmm0,rdx
    1db0:	addsd  xmm0,xmm0
    1db4:	mov    rax,QWORD PTR [rbp-0x38]
    1db8:	test   rax,rax
    1dbb:	js     1dc8 <end_profiling+0x22d>
    1dbd:	pxor   xmm1,xmm1
    1dc1:	cvtsi2sd xmm1,rax
    1dc6:	jmp    1de1 <end_profiling+0x246>
    1dc8:	mov    rdx,rax
    1dcb:	shr    rdx,1
    1dce:	and    eax,0x1
    1dd1:	or     rdx,rax
    1dd4:	pxor   xmm1,xmm1
    1dd8:	cvtsi2sd xmm1,rdx
    1ddd:	addsd  xmm1,xmm1
    1de1:	movapd xmm2,xmm0
    1de5:	divsd  xmm2,xmm1
    1de9:	movsd  xmm0,QWORD PTR [rip+0x2a9f]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1df1:	mulsd  xmm0,xmm2
    1df5:	movsd  QWORD PTR [rbp-0x18],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1dfa:	mov    rax,QWORD PTR [rbp-0x28]
    1dfe:	mov    rax,QWORD PTR [rax+0x18]
    1e02:	mov    rdx,QWORD PTR [rbp-0x18]
    1e06:	lea    rcx,[rip+0x250b]        # 4318 <_IO_stdin_used+0x318>
    1e0d:	movq   xmm0,rdx
    1e12:	mov    rsi,rax
    1e15:	mov    rdi,rcx
    1e18:	mov    eax,0x1
    1e1d:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1e22:	movsd  xmm0,QWORD PTR [rbp-0x48]
    1e27:	addsd  xmm0,QWORD PTR [rbp-0x20]
    1e2c:	movsd  QWORD PTR [rbp-0x48],xmm0

        if (zone->bytes_processed)
    1e31:	mov    rax,QWORD PTR [rbp-0x28]
    1e35:	mov    rax,QWORD PTR [rax+0x28]
    1e39:	test   rax,rax
    1e3c:	je     1f52 <end_profiling+0x3b7>
        {
          f64 megabytes = (f64)zone->bytes_processed / MB(1);
    1e42:	mov    rax,QWORD PTR [rbp-0x28]
    1e46:	mov    rax,QWORD PTR [rax+0x28]
    1e4a:	test   rax,rax
    1e4d:	js     1e5a <end_profiling+0x2bf>
    1e4f:	pxor   xmm0,xmm0
    1e53:	cvtsi2sd xmm0,rax
    1e58:	jmp    1e73 <end_profiling+0x2d8>
    1e5a:	mov    rdx,rax
    1e5d:	shr    rdx,1
    1e60:	and    eax,0x1
    1e63:	or     rdx,rax
    1e66:	pxor   xmm0,xmm0
    1e6a:	cvtsi2sd xmm0,rdx
    1e6f:	addsd  xmm0,xmm0
    1e73:	movsd  xmm1,QWORD PTR [rip+0x2a1d]        # 4898 <__PRETTY_FUNCTION__.0+0x28>
    1e7b:	divsd  xmm0,xmm1
    1e7f:	movsd  QWORD PTR [rbp-0x10],xmm0

          f64 gb_per_s = (f64)zone->bytes_processed / ((f64)zone->elapsed_inclusive / (f64)freq) / (f64)GB(1.0);
    1e84:	mov    rax,QWORD PTR [rbp-0x28]
    1e88:	mov    rax,QWORD PTR [rax+0x28]
    1e8c:	test   rax,rax
    1e8f:	js     1e9c <end_profiling+0x301>
    1e91:	pxor   xmm0,xmm0
    1e95:	cvtsi2sd xmm0,rax
    1e9a:	jmp    1eb5 <end_profiling+0x31a>
    1e9c:	mov    rdx,rax
    1e9f:	shr    rdx,1
    1ea2:	and    eax,0x1
    1ea5:	or     rdx,rax
    1ea8:	pxor   xmm0,xmm0
    1eac:	cvtsi2sd xmm0,rdx
    1eb1:	addsd  xmm0,xmm0
    1eb5:	mov    rax,QWORD PTR [rbp-0x28]
    1eb9:	mov    rax,QWORD PTR [rax+0x18]
    1ebd:	test   rax,rax
    1ec0:	js     1ecd <end_profiling+0x332>
    1ec2:	pxor   xmm1,xmm1
    1ec6:	cvtsi2sd xmm1,rax
    1ecb:	jmp    1ee6 <end_profiling+0x34b>
    1ecd:	mov    rdx,rax
    1ed0:	shr    rdx,1
    1ed3:	and    eax,0x1
    1ed6:	or     rdx,rax
    1ed9:	pxor   xmm1,xmm1
    1edd:	cvtsi2sd xmm1,rdx
    1ee2:	addsd  xmm1,xmm1
    1ee6:	mov    rax,QWORD PTR [rbp-0x30]
    1eea:	test   rax,rax
    1eed:	js     1efa <end_profiling+0x35f>
    1eef:	pxor   xmm2,xmm2
    1ef3:	cvtsi2sd xmm2,rax
    1ef8:	jmp    1f13 <end_profiling+0x378>
    1efa:	mov    rdx,rax
    1efd:	shr    rdx,1
    1f00:	and    eax,0x1
    1f03:	or     rdx,rax
    1f06:	pxor   xmm2,xmm2
    1f0a:	cvtsi2sd xmm2,rdx
    1f0f:	addsd  xmm2,xmm2
    1f13:	divsd  xmm1,xmm2
    1f17:	divsd  xmm0,xmm1
    1f1b:	movsd  xmm1,QWORD PTR [rip+0x297d]        # 48a0 <__PRETTY_FUNCTION__.0+0x30>
    1f23:	divsd  xmm0,xmm1
    1f27:	movsd  QWORD PTR [rbp-0x8],xmm0

          printf("  Megabytes Processed: %fMB @ %f GB/s\n", megabytes, gb_per_s);
    1f2c:	movsd  xmm0,QWORD PTR [rbp-0x8]
    1f31:	mov    rax,QWORD PTR [rbp-0x10]
    1f35:	lea    rdx,[rip+0x240c]        # 4348 <_IO_stdin_used+0x348>
    1f3c:	movapd xmm1,xmm0
    1f40:	movq   xmm0,rax
    1f45:	mov    rdi,rdx
    1f48:	mov    eax,0x2
    1f4d:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1f52:	add    QWORD PTR [rbp-0x40],0x1
    1f57:	cmp    QWORD PTR [rbp-0x40],0xfff
    1f5f:	jbe    1c77 <end_profiling+0xdc>
        }
      }
    }
  }
}
    1f65:	nop
    1f66:	leave
    1f67:	ret

0000000000001f68 <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1f68:	push   rbp
    1f69:	mov    rbp,rsp
    1f6c:	push   rbx
    1f6d:	sub    rsp,0x78
    1f71:	mov    QWORD PTR [rbp-0x58],rdi
    1f75:	mov    rax,rsi
    1f78:	mov    rsi,rdx
    1f7b:	mov    rax,rax
    1f7e:	mov    edx,0x0
    1f83:	mov    rdx,rsi
    1f86:	mov    QWORD PTR [rbp-0x70],rax
    1f8a:	mov    QWORD PTR [rbp-0x68],rdx
    1f8e:	mov    QWORD PTR [rbp-0x60],rcx
    1f92:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    1f96:	pxor   xmm0,xmm0
    1f9a:	movaps XMMWORD PTR [rbp-0x50],xmm0
    1f9e:	movaps XMMWORD PTR [rbp-0x40],xmm0
    1fa2:	movaps XMMWORD PTR [rbp-0x30],xmm0
    1fa6:	movq   QWORD PTR [rbp-0x20],xmm0
    1fab:	mov    rax,QWORD PTR [rbp-0x70]
    1faf:	mov    rdx,QWORD PTR [rbp-0x68]
    1fb3:	mov    QWORD PTR [rbp-0x50],rax
    1fb7:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    1fbb:	mov    rdx,QWORD PTR [rbp-0x60]
    1fbf:	mov    rax,rdx
    1fc2:	add    rax,rax
    1fc5:	add    rax,rdx
    1fc8:	shl    rax,0x4
    1fcc:	mov    rdx,rax
    1fcf:	lea    rax,[rip+0x41f2]        # 61c8 <g_profiler+0x28>
    1fd6:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    1fda:	mov    QWORD PTR [rbp-0x38],rax
    1fde:	mov    rax,QWORD PTR [rbp-0x60]
    1fe2:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    1fe6:	mov    rax,QWORD PTR [rip+0x41bb]        # 61a8 <g_profiler+0x8>
  Profile_Pass pass =
    1fed:	mov    QWORD PTR [rbp-0x28],rax
    1ff1:	mov    rax,QWORD PTR [rbp-0x78]
    1ff5:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    1ff9:	mov    rax,QWORD PTR [rbp-0x60]
    1ffd:	mov    QWORD PTR [rip+0x41a4],rax        # 61a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    2004:	call   1a48 <read_cpu_timer>
    2009:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    200d:	mov    rax,QWORD PTR [rbp-0x58]
    2011:	mov    rcx,QWORD PTR [rbp-0x50]
    2015:	mov    rbx,QWORD PTR [rbp-0x48]
    2019:	mov    QWORD PTR [rax],rcx
    201c:	mov    QWORD PTR [rax+0x8],rbx
    2020:	mov    rcx,QWORD PTR [rbp-0x40]
    2024:	mov    rbx,QWORD PTR [rbp-0x38]
    2028:	mov    QWORD PTR [rax+0x10],rcx
    202c:	mov    QWORD PTR [rax+0x18],rbx
    2030:	mov    rcx,QWORD PTR [rbp-0x30]
    2034:	mov    rbx,QWORD PTR [rbp-0x28]
    2038:	mov    QWORD PTR [rax+0x20],rcx
    203c:	mov    QWORD PTR [rax+0x28],rbx
    2040:	mov    rdx,QWORD PTR [rbp-0x20]
    2044:	mov    QWORD PTR [rax+0x30],rdx
}
    2048:	mov    rax,QWORD PTR [rbp-0x58]
    204c:	mov    rbx,QWORD PTR [rbp-0x8]
    2050:	leave
    2051:	ret

0000000000002052 <__profile_end_pass>:

static
void __profile_end_pass(Profile_Pass pass)
{
    2052:	push   rbp
    2053:	mov    rbp,rsp
    2056:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    205a:	call   1a48 <read_cpu_timer>
    205f:	mov    rdx,rax
    2062:	mov    rax,QWORD PTR [rbp+0x20]
    2066:	sub    rdx,rax
    2069:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    206d:	mov    rax,QWORD PTR [rbp+0x38]
    2071:	mov    QWORD PTR [rip+0x4130],rax        # 61a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    2078:	mov    rdx,QWORD PTR [rbp+0x30]
    207c:	mov    rax,rdx
    207f:	add    rax,rax
    2082:	add    rax,rdx
    2085:	shl    rax,0x4
    2089:	lea    rdx,[rax+0x10]
    208d:	lea    rax,[rip+0x410c]        # 61a0 <g_profiler>
    2094:	add    rax,rdx
    2097:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    209b:	mov    rax,QWORD PTR [rbp-0x10]
    209f:	mov    rdx,QWORD PTR [rax+0x10]
    20a3:	mov    rax,QWORD PTR [rbp-0x18]
    20a7:	add    rdx,rax
    20aa:	mov    rax,QWORD PTR [rbp-0x10]
    20ae:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    20b2:	mov    rax,QWORD PTR [rbp-0x10]
    20b6:	mov    rax,QWORD PTR [rax+0x20]
    20ba:	lea    rdx,[rax+0x1]
    20be:	mov    rax,QWORD PTR [rbp-0x10]
    20c2:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    20c6:	mov    rcx,QWORD PTR [rbp-0x10]
    20ca:	mov    rax,QWORD PTR [rbp+0x10]
    20ce:	mov    rdx,QWORD PTR [rbp+0x18]
    20d2:	mov    QWORD PTR [rcx],rax
    20d5:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    20d9:	mov    rdx,QWORD PTR [rbp+0x28]
    20dd:	mov    rax,QWORD PTR [rbp-0x18]
    20e1:	add    rdx,rax
    20e4:	mov    rax,QWORD PTR [rbp-0x10]
    20e8:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    20ec:	mov    rax,QWORD PTR [rbp-0x10]
    20f0:	mov    rdx,QWORD PTR [rax+0x28]
    20f4:	mov    rax,QWORD PTR [rbp+0x40]
    20f8:	add    rdx,rax
    20fb:	mov    rax,QWORD PTR [rbp-0x10]
    20ff:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    2103:	mov    rdx,QWORD PTR [rbp+0x38]
    2107:	mov    rax,rdx
    210a:	add    rax,rax
    210d:	add    rax,rdx
    2110:	shl    rax,0x4
    2114:	lea    rdx,[rax+0x10]
    2118:	lea    rax,[rip+0x4081]        # 61a0 <g_profiler>
    211f:	add    rax,rdx
    2122:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    2126:	mov    rax,QWORD PTR [rbp-0x8]
    212a:	mov    rax,QWORD PTR [rax+0x10]
    212e:	sub    rax,QWORD PTR [rbp-0x18]
    2132:	mov    rdx,rax
    2135:	mov    rax,QWORD PTR [rbp-0x8]
    2139:	mov    QWORD PTR [rax+0x10],rdx
}
    213d:	nop
    213e:	leave
    213f:	ret

0000000000002140 <parser_at>:
  usize  at;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    2140:	push   rbp
    2141:	mov    rbp,rsp
    2144:	sub    rsp,0x10
    2148:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    214c:	mov    rax,QWORD PTR [rbp-0x8]
    2150:	mov    rdx,QWORD PTR [rax+0x10]
    2154:	mov    rax,QWORD PTR [rbp-0x8]
    2158:	mov    rax,QWORD PTR [rax+0x8]
    215c:	cmp    rdx,rax
    215f:	jb     2186 <parser_at+0x46>
    2161:	lea    rdx,[rip+0x2680]        # 47e8 <__PRETTY_FUNCTION__.5>
    2168:	lea    rsi,[rip+0x230b]        # 447a <_IO_stdin_used+0x47a>
    216f:	lea    rax,[rip+0x231a]        # 4490 <_IO_stdin_used+0x490>
    2176:	mov    rcx,rdx
    2179:	mov    edx,0x2f
    217e:	mov    rdi,rax
    2181:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    2186:	mov    rax,QWORD PTR [rbp-0x8]
    218a:	mov    rdx,QWORD PTR [rax]
    218d:	mov    rax,QWORD PTR [rbp-0x8]
    2191:	mov    rax,QWORD PTR [rax+0x10]
    2195:	add    rax,rdx
}
    2198:	leave
    2199:	ret

000000000000219a <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    219a:	push   rbp
    219b:	mov    rbp,rsp
    219e:	sub    rsp,0x10
    21a2:	mov    QWORD PTR [rbp-0x8],rdi
    21a6:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    21aa:	mov    rax,QWORD PTR [rbp-0x8]
    21ae:	mov    rdi,rax
    21b1:	call   2140 <parser_at>
    21b6:	mov    rdx,QWORD PTR [rbp-0x10]
    21ba:	add    rax,rdx
}
    21bd:	leave
    21be:	ret

00000000000021bf <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    21bf:	push   rbp
    21c0:	mov    rbp,rsp
    21c3:	mov    QWORD PTR [rbp-0x8],rdi
    21c7:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    21cb:	mov    rax,QWORD PTR [rbp-0x8]
    21cf:	mov    rdx,QWORD PTR [rax+0x10]
    21d3:	mov    rax,QWORD PTR [rbp-0x10]
    21d7:	add    rdx,rax
    21da:	mov    rax,QWORD PTR [rbp-0x8]
    21de:	mov    QWORD PTR [rax+0x10],rdx
}
    21e2:	nop
    21e3:	pop    rbp
    21e4:	ret

00000000000021e5 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    21e5:	push   rbp
    21e6:	mov    rbp,rsp
    21e9:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count;
    21ed:	mov    rax,QWORD PTR [rbp-0x8]
    21f1:	mov    rdx,QWORD PTR [rax+0x10]
    21f5:	mov    rax,QWORD PTR [rbp-0x8]
    21f9:	mov    rax,QWORD PTR [rax+0x8]
    21fd:	cmp    rdx,rax
    2200:	setb   al
}
    2203:	pop    rbp
    2204:	ret

0000000000002205 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    2205:	push   rbp
    2206:	mov    rbp,rsp
    2209:	push   r12
    220b:	push   rbx
    220c:	sub    rsp,0x20
    2210:	mov    QWORD PTR [rbp-0x18],rdi
    2214:	mov    rax,rsi
    2217:	mov    rcx,rdx
    221a:	mov    rax,rax
    221d:	mov    edx,0x0
    2222:	mov    rdx,rcx
    2225:	mov    QWORD PTR [rbp-0x30],rax
    2229:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    222d:	mov    rax,QWORD PTR [rbp-0x28]
    2231:	mov    r12,rax
    2234:	mov    rbx,QWORD PTR [rbp-0x30]
    2238:	mov    rax,QWORD PTR [rbp-0x18]
    223c:	mov    rdi,rax
    223f:	call   2140 <parser_at>
    2244:	mov    rdx,r12
    2247:	mov    rsi,rbx
    224a:	mov    rdi,rax
    224d:	call   10d0 <memcmp@plt>
    2252:	test   eax,eax
    2254:	sete   al
}
    2257:	add    rsp,0x20
    225b:	pop    rbx
    225c:	pop    r12
    225e:	pop    rbp
    225f:	ret

0000000000002260 <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    2260:	push   rbp
    2261:	mov    rbp,rsp
    2264:	mov    eax,edi
    2266:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    2269:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    226d:	movzx  eax,BYTE PTR [rbp-0x14]
    2271:	cmp    eax,0x2e
    2274:	jg     227d <is_numeric+0x1d>
    2276:	cmp    eax,0x2d
    2279:	jge    2285 <is_numeric+0x25>
    227b:	jmp    228a <is_numeric+0x2a>
    227d:	sub    eax,0x30
    2280:	cmp    eax,0x9
    2283:	ja     228a <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2285:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    2289:	nop
  }


  return result;
    228a:	movzx  eax,BYTE PTR [rbp-0x1]
}
    228e:	pop    rbp
    228f:	ret

0000000000002290 <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    2290:	push   rbp
    2291:	mov    rbp,rsp
    2294:	sub    rsp,0x50
    2298:	mov    QWORD PTR [rbp-0x48],rdi
    229c:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    22a0:	pxor   xmm0,xmm0
    22a4:	movaps XMMWORD PTR [rbp-0x20],xmm0
    22a8:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    22ad:	jmp    22c0 <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    22af:	mov    rax,QWORD PTR [rbp-0x50]
    22b3:	mov    esi,0x1
    22b8:	mov    rdi,rax
    22bb:	call   21bf <parser_advance>
  while (parser_incomplete(parser)  &&
    22c0:	mov    rax,QWORD PTR [rbp-0x50]
    22c4:	mov    rdi,rax
    22c7:	call   21e5 <parser_incomplete>
    22cc:	test   al,al
    22ce:	je     231c <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    22d0:	mov    rax,QWORD PTR [rbp-0x50]
    22d4:	mov    rdi,rax
    22d7:	call   2140 <parser_at>
    22dc:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    22df:	cmp    al,0x20
    22e1:	je     22af <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    22e3:	mov    rax,QWORD PTR [rbp-0x50]
    22e7:	mov    rdi,rax
    22ea:	call   2140 <parser_at>
    22ef:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    22f2:	cmp    al,0xa
    22f4:	je     22af <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    22f6:	mov    rax,QWORD PTR [rbp-0x50]
    22fa:	mov    rdi,rax
    22fd:	call   2140 <parser_at>
    2302:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    2305:	cmp    al,0xd
    2307:	je     22af <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    2309:	mov    rax,QWORD PTR [rbp-0x50]
    230d:	mov    rdi,rax
    2310:	call   2140 <parser_at>
    2315:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    2318:	cmp    al,0x9
    231a:	je     22af <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    231c:	mov    rax,QWORD PTR [rbp-0x50]
    2320:	mov    rdi,rax
    2323:	call   21e5 <parser_incomplete>
    2328:	test   al,al
    232a:	je     2757 <get_json_token+0x4c7>
  {
    token.value.data = parser_at(parser);
    2330:	mov    rax,QWORD PTR [rbp-0x50]
    2334:	mov    rdi,rax
    2337:	call   2140 <parser_at>
    233c:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    2340:	mov    rax,QWORD PTR [rbp-0x50]
    2344:	mov    rdi,rax
    2347:	call   2140 <parser_at>
    234c:	movzx  eax,BYTE PTR [rax]
    234f:	movzx  eax,al
    2352:	cmp    eax,0x7d
    2355:	je     2442 <get_json_token+0x1b2>
    235b:	cmp    eax,0x7d
    235e:	jg     2768 <get_json_token+0x4d8>
    2364:	cmp    eax,0x7b
    2367:	je     241d <get_json_token+0x18d>
    236d:	cmp    eax,0x7b
    2370:	jg     2768 <get_json_token+0x4d8>
    2376:	cmp    eax,0x74
    2379:	je     25c5 <get_json_token+0x335>
    237f:	cmp    eax,0x74
    2382:	jg     2768 <get_json_token+0x4d8>
    2388:	cmp    eax,0x6e
    238b:	je     26d5 <get_json_token+0x445>
    2391:	cmp    eax,0x6e
    2394:	jg     2768 <get_json_token+0x4d8>
    239a:	cmp    eax,0x66
    239d:	je     264d <get_json_token+0x3bd>
    23a3:	cmp    eax,0x66
    23a6:	jg     2768 <get_json_token+0x4d8>
    23ac:	cmp    eax,0x5d
    23af:	je     248c <get_json_token+0x1fc>
    23b5:	cmp    eax,0x5d
    23b8:	jg     2768 <get_json_token+0x4d8>
    23be:	cmp    eax,0x5b
    23c1:	je     2467 <get_json_token+0x1d7>
    23c7:	cmp    eax,0x5b
    23ca:	jg     2768 <get_json_token+0x4d8>
    23d0:	cmp    eax,0x3a
    23d3:	je     24d6 <get_json_token+0x246>
    23d9:	cmp    eax,0x3a
    23dc:	jg     2768 <get_json_token+0x4d8>
    23e2:	cmp    eax,0x39
    23e5:	jg     2768 <get_json_token+0x4d8>
    23eb:	cmp    eax,0x30
    23ee:	jge    2574 <get_json_token+0x2e4>
    23f4:	cmp    eax,0x2e
    23f7:	jg     2768 <get_json_token+0x4d8>
    23fd:	cmp    eax,0x2d
    2400:	jge    2574 <get_json_token+0x2e4>
    2406:	cmp    eax,0x22
    2409:	je     24fb <get_json_token+0x26b>
    240f:	cmp    eax,0x2c
    2412:	je     24b1 <get_json_token+0x221>
    2418:	jmp    2768 <get_json_token+0x4d8>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    241d:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    2424:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    242c:	mov    rax,QWORD PTR [rbp-0x50]
    2430:	mov    esi,0x1
    2435:	mov    rdi,rax
    2438:	call   21bf <parser_advance>
      }
      break;
    243d:	jmp    2768 <get_json_token+0x4d8>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2442:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    2449:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2451:	mov    rax,QWORD PTR [rbp-0x50]
    2455:	mov    esi,0x1
    245a:	mov    rdi,rax
    245d:	call   21bf <parser_advance>
      }
      break;
    2462:	jmp    2768 <get_json_token+0x4d8>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2467:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    246e:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2476:	mov    rax,QWORD PTR [rbp-0x50]
    247a:	mov    esi,0x1
    247f:	mov    rdi,rax
    2482:	call   21bf <parser_advance>
      }
      break;
    2487:	jmp    2768 <get_json_token+0x4d8>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    248c:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    2493:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    249b:	mov    rax,QWORD PTR [rbp-0x50]
    249f:	mov    esi,0x1
    24a4:	mov    rdi,rax
    24a7:	call   21bf <parser_advance>
      }
      break;
    24ac:	jmp    2768 <get_json_token+0x4d8>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    24b1:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    24b8:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24c0:	mov    rax,QWORD PTR [rbp-0x50]
    24c4:	mov    esi,0x1
    24c9:	mov    rdi,rax
    24cc:	call   21bf <parser_advance>
      }
      break;
    24d1:	jmp    2768 <get_json_token+0x4d8>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    24d6:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    24dd:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24e5:	mov    rax,QWORD PTR [rbp-0x50]
    24e9:	mov    esi,0x1
    24ee:	mov    rdi,rax
    24f1:	call   21bf <parser_advance>
      }
      break;
    24f6:	jmp    2768 <get_json_token+0x4d8>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    24fb:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    2502:	mov    rax,QWORD PTR [rbp-0x50]
    2506:	mov    esi,0x1
    250b:	mov    rdi,rax
    250e:	call   21bf <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    2513:	mov    rax,QWORD PTR [rbp-0x50]
    2517:	mov    rdi,rax
    251a:	call   2140 <parser_at>
    251f:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    2523:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    252b:	jmp    2543 <get_json_token+0x2b3>
        {
          string_count += 1;
    252d:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    2532:	mov    rax,QWORD PTR [rbp-0x50]
    2536:	mov    esi,0x1
    253b:	mov    rdi,rax
    253e:	call   21bf <parser_advance>
        while (*parser_at(parser) != '"')
    2543:	mov    rax,QWORD PTR [rbp-0x50]
    2547:	mov    rdi,rax
    254a:	call   2140 <parser_at>
    254f:	movzx  eax,BYTE PTR [rax]
    2552:	cmp    al,0x22
    2554:	jne    252d <get_json_token+0x29d>
        }
        token.value.count = string_count;
    2556:	mov    rax,QWORD PTR [rbp-0x40]
    255a:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    255e:	mov    rax,QWORD PTR [rbp-0x50]
    2562:	mov    esi,0x1
    2567:	mov    rdi,rax
    256a:	call   21bf <parser_advance>
      }
      break;
    256f:	jmp    2768 <get_json_token+0x4d8>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2574:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    257b:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2583:	jmp    259b <get_json_token+0x30b>
        {
          digit_count += 1;
    2585:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    258a:	mov    rax,QWORD PTR [rbp-0x50]
    258e:	mov    esi,0x1
    2593:	mov    rdi,rax
    2596:	call   21bf <parser_advance>
        while (is_numeric(*parser_at(parser)))
    259b:	mov    rax,QWORD PTR [rbp-0x50]
    259f:	mov    rdi,rax
    25a2:	call   2140 <parser_at>
    25a7:	movzx  eax,BYTE PTR [rax]
    25aa:	movzx  eax,al
    25ad:	mov    edi,eax
    25af:	call   2260 <is_numeric>
    25b4:	test   al,al
    25b6:	jne    2585 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    25b8:	mov    rax,QWORD PTR [rbp-0x38]
    25bc:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    25c0:	jmp    2768 <get_json_token+0x4d8>
      case 't':
      {
        String string = String("true");
    25c5:	lea    rax,[rip+0x1f10]        # 44dc <_IO_stdin_used+0x4dc>
    25cc:	mov    QWORD PTR [rbp-0x30],rax
    25d0:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    25d8:	mov    rcx,QWORD PTR [rbp-0x30]
    25dc:	mov    rdx,QWORD PTR [rbp-0x28]
    25e0:	mov    rax,QWORD PTR [rbp-0x50]
    25e4:	mov    rsi,rcx
    25e7:	mov    rdi,rax
    25ea:	call   2205 <parser_token_is_literal>
    25ef:	test   al,al
    25f1:	je     2615 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    25f3:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    25fa:	mov    rax,QWORD PTR [rbp-0x28]
    25fe:	mov    rdx,rax
    2601:	mov    rax,QWORD PTR [rbp-0x50]
    2605:	mov    rsi,rdx
    2608:	mov    rdi,rax
    260b:	call   21bf <parser_advance>
    2610:	jmp    2768 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2615:	mov    rax,QWORD PTR [rbp-0x50]
    2619:	mov    rcx,QWORD PTR [rax+0x10]
    261d:	lea    rdx,[rip+0x1ec4]        # 44e8 <_IO_stdin_used+0x4e8>
    2624:	lea    rax,[rip+0x1e4f]        # 447a <_IO_stdin_used+0x47a>
    262b:	mov    r8,rcx
    262e:	mov    rcx,rdx
    2631:	mov    edx,0xdf
    2636:	mov    rsi,rax
    2639:	mov    edi,0x1
    263e:	mov    eax,0x0
    2643:	call   14a1 <log_message>
        }
      }
      break;
    2648:	jmp    2768 <get_json_token+0x4d8>
      case 'f':
      {
        String string = String("false");
    264d:	lea    rax,[rip+0x1ec1]        # 4515 <_IO_stdin_used+0x515>
    2654:	mov    QWORD PTR [rbp-0x30],rax
    2658:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    2660:	mov    rcx,QWORD PTR [rbp-0x30]
    2664:	mov    rdx,QWORD PTR [rbp-0x28]
    2668:	mov    rax,QWORD PTR [rbp-0x50]
    266c:	mov    rsi,rcx
    266f:	mov    rdi,rax
    2672:	call   2205 <parser_token_is_literal>
    2677:	test   al,al
    2679:	je     269d <get_json_token+0x40d>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    267b:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    2682:	mov    rax,QWORD PTR [rbp-0x28]
    2686:	mov    rdx,rax
    2689:	mov    rax,QWORD PTR [rbp-0x50]
    268d:	mov    rsi,rdx
    2690:	mov    rdi,rax
    2693:	call   21bf <parser_advance>
    2698:	jmp    2768 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    269d:	mov    rax,QWORD PTR [rbp-0x50]
    26a1:	mov    rcx,QWORD PTR [rax+0x10]
    26a5:	lea    rdx,[rip+0x1e3c]        # 44e8 <_IO_stdin_used+0x4e8>
    26ac:	lea    rax,[rip+0x1dc7]        # 447a <_IO_stdin_used+0x47a>
    26b3:	mov    r8,rcx
    26b6:	mov    rcx,rdx
    26b9:	mov    edx,0xee
    26be:	mov    rsi,rax
    26c1:	mov    edi,0x1
    26c6:	mov    eax,0x0
    26cb:	call   14a1 <log_message>
        }
      }
      break;
    26d0:	jmp    2768 <get_json_token+0x4d8>
      case 'n':
      {
        String string = String("null");
    26d5:	lea    rax,[rip+0x1e3f]        # 451b <_IO_stdin_used+0x51b>
    26dc:	mov    QWORD PTR [rbp-0x30],rax
    26e0:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    26e8:	mov    rcx,QWORD PTR [rbp-0x30]
    26ec:	mov    rdx,QWORD PTR [rbp-0x28]
    26f0:	mov    rax,QWORD PTR [rbp-0x50]
    26f4:	mov    rsi,rcx
    26f7:	mov    rdi,rax
    26fa:	call   2205 <parser_token_is_literal>
    26ff:	test   al,al
    2701:	je     2722 <get_json_token+0x492>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    2703:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    270a:	mov    rax,QWORD PTR [rbp-0x28]
    270e:	mov    rdx,rax
    2711:	mov    rax,QWORD PTR [rbp-0x50]
    2715:	mov    rsi,rdx
    2718:	mov    rdi,rax
    271b:	call   21bf <parser_advance>
    2720:	jmp    2768 <get_json_token+0x4d8>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2722:	mov    rax,QWORD PTR [rbp-0x50]
    2726:	mov    rcx,QWORD PTR [rax+0x10]
    272a:	lea    rdx,[rip+0x1db7]        # 44e8 <_IO_stdin_used+0x4e8>
    2731:	lea    rax,[rip+0x1d42]        # 447a <_IO_stdin_used+0x47a>
    2738:	mov    r8,rcx
    273b:	mov    rcx,rdx
    273e:	mov    edx,0xfd
    2743:	mov    rsi,rax
    2746:	mov    edi,0x1
    274b:	mov    eax,0x0
    2750:	call   14a1 <log_message>
        }
      }
      break;
    2755:	jmp    2768 <get_json_token+0x4d8>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    2757:	mov    rax,QWORD PTR [rbp-0x50]
    275b:	mov    esi,0x1
    2760:	mov    rdi,rax
    2763:	call   21bf <parser_advance>
  }

  return token;
    2768:	mov    rcx,QWORD PTR [rbp-0x48]
    276c:	mov    rax,QWORD PTR [rbp-0x20]
    2770:	mov    rdx,QWORD PTR [rbp-0x18]
    2774:	mov    QWORD PTR [rcx],rax
    2777:	mov    QWORD PTR [rcx+0x8],rdx
    277b:	mov    rax,QWORD PTR [rbp-0x10]
    277f:	mov    QWORD PTR [rcx+0x10],rax
}
    2783:	mov    rax,QWORD PTR [rbp-0x48]
    2787:	leave
    2788:	ret

0000000000002789 <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    2789:	push   rbp
    278a:	mov    rbp,rsp
    278d:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    2790:	cmp    DWORD PTR [rbp-0x14],0x7
    2794:	je     27ae <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2796:	cmp    DWORD PTR [rbp-0x14],0x9
    279a:	je     27ae <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    279c:	cmp    DWORD PTR [rbp-0x14],0xa
    27a0:	je     27ae <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    27a2:	cmp    DWORD PTR [rbp-0x14],0xb
    27a6:	je     27ae <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    27a8:	cmp    DWORD PTR [rbp-0x14],0x8
    27ac:	jne    27b5 <json_token_type_is_value_type+0x2c>
    27ae:	mov    eax,0x1
    27b3:	jmp    27ba <json_token_type_is_value_type+0x31>
    27b5:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    27ba:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    27bd:	mov    eax,DWORD PTR [rbp-0x4]
}
    27c0:	pop    rbp
    27c1:	ret

00000000000027c2 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    27c2:	push   rbp
    27c3:	mov    rbp,rsp
    27c6:	push   rbx
    27c7:	sub    rsp,0x88
    27ce:	mov    QWORD PTR [rbp-0x78],rdi
    27d2:	mov    QWORD PTR [rbp-0x80],rsi
    27d6:	mov    QWORD PTR [rbp-0x90],rdx
    27dd:	mov    QWORD PTR [rbp-0x88],rcx
    27e4:	mov    rax,QWORD PTR fs:0x28
    27ed:	mov    QWORD PTR [rbp-0x18],rax
    27f1:	xor    eax,eax
  profile_begin_func();
    27f3:	lea    r8,[rip+0x2006]        # 4800 <__func__.4>
    27fa:	mov    r9d,0x11
    2800:	lea    rax,[rbp-0x50]
    2804:	mov    rsi,r8
    2807:	mov    rdx,r9
    280a:	mov    r8d,0x0
    2810:	mov    ecx,0x1
    2815:	mov    rdi,rax
    2818:	call   1f68 <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    281d:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    2825:	mov    eax,DWORD PTR [rbp+0x10]
    2828:	cmp    eax,0x1
    282b:	jne    2857 <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    282d:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    2834:	mov    edx,DWORD PTR [rbp-0x64]
    2837:	mov    rsi,QWORD PTR [rbp-0x80]
    283b:	mov    rax,QWORD PTR [rbp-0x78]
    283f:	mov    ecx,edx
    2841:	mov    edx,0x2
    2846:	mov    rdi,rax
    2849:	call   29a9 <parse_json_children>
    284e:	mov    QWORD PTR [rbp-0x60],rax
    2852:	jmp    28e1 <parse_json_object+0x11f>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2857:	mov    eax,DWORD PTR [rbp+0x10]
    285a:	cmp    eax,0x3
    285d:	jne    2886 <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    285f:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2866:	mov    edx,DWORD PTR [rbp-0x68]
    2869:	mov    rsi,QWORD PTR [rbp-0x80]
    286d:	mov    rax,QWORD PTR [rbp-0x78]
    2871:	mov    ecx,edx
    2873:	mov    edx,0x4
    2878:	mov    rdi,rax
    287b:	call   29a9 <parse_json_children>
    2880:	mov    QWORD PTR [rbp-0x60],rax
    2884:	jmp    28e1 <parse_json_object+0x11f>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    2886:	mov    eax,DWORD PTR [rbp+0x10]
    2889:	mov    edi,eax
    288b:	call   2789 <json_token_type_is_value_type>
    2890:	test   eax,eax
    2892:	jne    28e1 <parse_json_object+0x11f>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2894:	mov    eax,DWORD PTR [rbp+0x10]
    2897:	mov    eax,eax
    2899:	lea    rdx,[rax*8+0x0]
    28a1:	lea    rax,[rip+0x3838]        # 60e0 <JSON_Token_Type_strings>
    28a8:	mov    rcx,QWORD PTR [rdx+rax*1]
    28ac:	lea    rdx,[rip+0x1c6d]        # 4520 <_IO_stdin_used+0x520>
    28b3:	lea    rax,[rip+0x1bc0]        # 447a <_IO_stdin_used+0x47a>
    28ba:	push   QWORD PTR [rbp+0x20]
    28bd:	push   QWORD PTR [rbp+0x18]
    28c0:	mov    r8,rcx
    28c3:	mov    rcx,rdx
    28c6:	mov    edx,0x134
    28cb:	mov    rsi,rax
    28ce:	mov    edi,0x1
    28d3:	mov    eax,0x0
    28d8:	call   14a1 <log_message>
    28dd:	add    rsp,0x10
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    28e1:	mov    rax,QWORD PTR [rbp-0x78]
    28e5:	mov    edx,0x8
    28ea:	mov    esi,0x30
    28ef:	mov    rdi,rax
    28f2:	call   17d3 <arena_alloc>
    28f7:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    28fb:	mov    rcx,QWORD PTR [rbp-0x58]
    28ff:	mov    rax,QWORD PTR [rbp-0x90]
    2906:	mov    rdx,QWORD PTR [rbp-0x88]
    290d:	mov    QWORD PTR [rcx],rax
    2910:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    2914:	mov    rax,QWORD PTR [rbp-0x58]
    2918:	mov    rdx,QWORD PTR [rbp-0x60]
    291c:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    2920:	mov    rax,QWORD PTR [rbp-0x58]
    2924:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    292c:	mov    rcx,QWORD PTR [rbp-0x58]
    2930:	mov    rax,QWORD PTR [rbp+0x18]
    2934:	mov    rdx,QWORD PTR [rbp+0x20]
    2938:	mov    QWORD PTR [rcx+0x10],rax
    293c:	mov    QWORD PTR [rcx+0x18],rdx

  profile_end_func();
    2940:	sub    rsp,0x8
    2944:	sub    rsp,0x38
    2948:	mov    rax,rsp
    294b:	mov    rcx,QWORD PTR [rbp-0x50]
    294f:	mov    rbx,QWORD PTR [rbp-0x48]
    2953:	mov    QWORD PTR [rax],rcx
    2956:	mov    QWORD PTR [rax+0x8],rbx
    295a:	mov    rcx,QWORD PTR [rbp-0x40]
    295e:	mov    rbx,QWORD PTR [rbp-0x38]
    2962:	mov    QWORD PTR [rax+0x10],rcx
    2966:	mov    QWORD PTR [rax+0x18],rbx
    296a:	mov    rcx,QWORD PTR [rbp-0x30]
    296e:	mov    rbx,QWORD PTR [rbp-0x28]
    2972:	mov    QWORD PTR [rax+0x20],rcx
    2976:	mov    QWORD PTR [rax+0x28],rbx
    297a:	mov    rdx,QWORD PTR [rbp-0x20]
    297e:	mov    QWORD PTR [rax+0x30],rdx
    2982:	call   2052 <__profile_end_pass>
    2987:	add    rsp,0x40

  return result;
    298b:	mov    rax,QWORD PTR [rbp-0x58]
}
    298f:	mov    rdx,QWORD PTR [rbp-0x18]
    2993:	sub    rdx,QWORD PTR fs:0x28
    299c:	je     29a3 <parse_json_object+0x1e1>
    299e:	call   1060 <__stack_chk_fail@plt>
    29a3:	mov    rbx,QWORD PTR [rbp-0x8]
    29a7:	leave
    29a8:	ret

00000000000029a9 <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    29a9:	push   rbp
    29aa:	mov    rbp,rsp
    29ad:	push   rbx
    29ae:	sub    rsp,0x108
    29b5:	mov    QWORD PTR [rbp-0xd8],rdi
    29bc:	mov    QWORD PTR [rbp-0xe0],rsi
    29c3:	mov    DWORD PTR [rbp-0xe4],edx
    29c9:	mov    DWORD PTR [rbp-0xe8],ecx
    29cf:	mov    rax,QWORD PTR fs:0x28
    29d8:	mov    QWORD PTR [rbp-0x18],rax
    29dc:	xor    eax,eax
  profile_begin_func();
    29de:	lea    r8,[rip+0x1e3b]        # 4820 <__func__.3>
    29e5:	mov    r9d,0x13
    29eb:	lea    rax,[rbp-0x50]
    29ef:	mov    rsi,r8
    29f2:	mov    rdx,r9
    29f5:	mov    r8d,0x0
    29fb:	mov    ecx,0x2
    2a00:	mov    rdi,rax
    2a03:	call   1f68 <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2a08:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    2a13:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2a1e:	jmp    2cf7 <parse_json_children+0x34e>
  {
    JSON_Token key_token = {0};
    2a23:	pxor   xmm0,xmm0
    2a27:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2a2e:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2a36:	pxor   xmm0,xmm0
    2a3a:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2a41:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2a46:	cmp    DWORD PTR [rbp-0xe8],0x0
    2a4d:	je     2b5a <parse_json_children+0x1b1>
    {
      key_token = get_json_token(parser);
    2a53:	lea    rax,[rbp-0xb0]
    2a5a:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a61:	mov    rsi,rdx
    2a64:	mov    rdi,rax
    2a67:	call   2290 <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2a6c:	mov    eax,DWORD PTR [rbp-0xb0]
    2a72:	cmp    eax,0x7
    2a75:	jne    2af6 <parse_json_children+0x14d>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2a77:	lea    rax,[rbp-0x70]
    2a7b:	mov    rdx,QWORD PTR [rbp-0xe0]
    2a82:	mov    rsi,rdx
    2a85:	mov    rdi,rax
    2a88:	call   2290 <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2a8d:	mov    eax,DWORD PTR [rbp-0x70]
    2a90:	cmp    eax,0x6
    2a93:	jne    2ab3 <parse_json_children+0x10a>
        {
          value_token = get_json_token(parser);
    2a95:	lea    rax,[rbp-0x90]
    2a9c:	mov    rdx,QWORD PTR [rbp-0xe0]
    2aa3:	mov    rsi,rdx
    2aa6:	mov    rdi,rax
    2aa9:	call   2290 <get_json_token>
    2aae:	jmp    2b9a <parse_json_children+0x1f1>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2ab3:	mov    rcx,QWORD PTR [rbp-0xa8]
    2aba:	mov    rax,QWORD PTR [rbp-0xa0]
    2ac1:	mov    esi,eax
    2ac3:	lea    rdx,[rip+0x1aa6]        # 4570 <_IO_stdin_used+0x570>
    2aca:	lea    rax,[rip+0x19a9]        # 447a <_IO_stdin_used+0x47a>
    2ad1:	mov    r9,rcx
    2ad4:	mov    r8d,esi
    2ad7:	mov    rcx,rdx
    2ada:	mov    edx,0x15f
    2adf:	mov    rsi,rax
    2ae2:	mov    edi,0x1
    2ae7:	mov    eax,0x0
    2aec:	call   14a1 <log_message>
    2af1:	jmp    2b9a <parse_json_children+0x1f1>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2af6:	mov    rcx,QWORD PTR [rbp-0xa8]
    2afd:	mov    rax,QWORD PTR [rbp-0xa0]
    2b04:	mov    edi,eax
    2b06:	mov    eax,DWORD PTR [rbp-0xb0]
    2b0c:	mov    eax,eax
    2b0e:	lea    rdx,[rax*8+0x0]
    2b16:	lea    rax,[rip+0x35c3]        # 60e0 <JSON_Token_Type_strings>
    2b1d:	mov    rsi,QWORD PTR [rdx+rax*1]
    2b21:	lea    rdx,[rip+0x1a68]        # 4590 <_IO_stdin_used+0x590>
    2b28:	lea    rax,[rip+0x194b]        # 447a <_IO_stdin_used+0x47a>
    2b2f:	sub    rsp,0x8
    2b33:	push   rcx
    2b34:	mov    r9d,edi
    2b37:	mov    r8,rsi
    2b3a:	mov    rcx,rdx
    2b3d:	mov    edx,0x164
    2b42:	mov    rsi,rax
    2b45:	mov    edi,0x1
    2b4a:	mov    eax,0x0
    2b4f:	call   14a1 <log_message>
    2b54:	add    rsp,0x10
    2b58:	jmp    2b9a <parse_json_children+0x1f1>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2b5a:	lea    rax,[rbp-0x110]
    2b61:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b68:	mov    rsi,rdx
    2b6b:	mov    rdi,rax
    2b6e:	call   2290 <get_json_token>
    2b73:	mov    rax,QWORD PTR [rbp-0x110]
    2b7a:	mov    rdx,QWORD PTR [rbp-0x108]
    2b81:	mov    QWORD PTR [rbp-0x90],rax
    2b88:	mov    QWORD PTR [rbp-0x88],rdx
    2b8f:	mov    rax,QWORD PTR [rbp-0x100]
    2b96:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2b9a:	mov    eax,DWORD PTR [rbp-0x90]
    2ba0:	cmp    DWORD PTR [rbp-0xe4],eax
    2ba6:	je     2d10 <parse_json_children+0x367>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2bac:	mov    rax,QWORD PTR [rbp-0xa8]
    2bb3:	mov    rdx,QWORD PTR [rbp-0xa0]
    2bba:	mov    r8,QWORD PTR [rbp-0xe0]
    2bc1:	mov    rdi,QWORD PTR [rbp-0xd8]
    2bc8:	sub    rsp,0x8
    2bcc:	sub    rsp,0x18
    2bd0:	mov    rsi,rsp
    2bd3:	mov    rcx,QWORD PTR [rbp-0x90]
    2bda:	mov    rbx,QWORD PTR [rbp-0x88]
    2be1:	mov    QWORD PTR [rsi],rcx
    2be4:	mov    QWORD PTR [rsi+0x8],rbx
    2be8:	mov    rcx,QWORD PTR [rbp-0x80]
    2bec:	mov    QWORD PTR [rsi+0x10],rcx
    2bf0:	mov    rcx,rdx
    2bf3:	mov    rdx,rax
    2bf6:	mov    rsi,r8
    2bf9:	call   27c2 <parse_json_object>
    2bfe:	add    rsp,0x20
    2c02:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2c09:	cmp    QWORD PTR [rbp-0xb8],0x0
    2c11:	je     2c5b <parse_json_children+0x2b2>
    {
      // Create links
      if (!first_child)
    2c13:	cmp    QWORD PTR [rbp-0xc8],0x0
    2c1b:	jne    2c3b <parse_json_children+0x292>
      {
        first_child        = object;
    2c1d:	mov    rax,QWORD PTR [rbp-0xb8]
    2c24:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2c2b:	mov    rax,QWORD PTR [rbp-0xb8]
    2c32:	mov    QWORD PTR [rbp-0xc0],rax
    2c39:	jmp    2c5b <parse_json_children+0x2b2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2c3b:	mov    rax,QWORD PTR [rbp-0xc0]
    2c42:	mov    rdx,QWORD PTR [rbp-0xb8]
    2c49:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2c4d:	mov    rax,QWORD PTR [rbp-0xb8]
    2c54:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2c5b:	lea    rax,[rbp-0x70]
    2c5f:	mov    rdx,QWORD PTR [rbp-0xe0]
    2c66:	mov    rsi,rdx
    2c69:	mov    rdi,rax
    2c6c:	call   2290 <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2c71:	mov    eax,DWORD PTR [rbp-0x70]
    2c74:	cmp    DWORD PTR [rbp-0xe4],eax
    2c7a:	je     2d13 <parse_json_children+0x36a>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2c80:	mov    eax,DWORD PTR [rbp-0x70]
    2c83:	cmp    eax,0x5
    2c86:	je     2cf7 <parse_json_children+0x34e>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2c88:	mov    r8,QWORD PTR [rbp-0x68]
    2c8c:	mov    rax,QWORD PTR [rbp-0x60]
    2c90:	mov    r9d,eax
    2c93:	mov    eax,DWORD PTR [rbp-0x70]
    2c96:	mov    eax,eax
    2c98:	lea    rdx,[rax*8+0x0]
    2ca0:	lea    rax,[rip+0x3439]        # 60e0 <JSON_Token_Type_strings>
    2ca7:	mov    r10,QWORD PTR [rdx+rax*1]
    2cab:	lea    rdi,[rip+0x1906]        # 45b8 <_IO_stdin_used+0x5b8>
    2cb2:	lea    rsi,[rip+0x17c1]        # 447a <_IO_stdin_used+0x47a>
    2cb9:	sub    rsp,0x18
    2cbd:	mov    rcx,rsp
    2cc0:	mov    rax,QWORD PTR [rbp-0x70]
    2cc4:	mov    rdx,QWORD PTR [rbp-0x68]
    2cc8:	mov    QWORD PTR [rcx],rax
    2ccb:	mov    QWORD PTR [rcx+0x8],rdx
    2ccf:	mov    rax,QWORD PTR [rbp-0x60]
    2cd3:	mov    QWORD PTR [rcx+0x10],rax
    2cd7:	push   r8
    2cd9:	mov    r8,r10
    2cdc:	mov    rcx,rdi
    2cdf:	mov    edx,0x18b
    2ce4:	mov    edi,0x1
    2ce9:	mov    eax,0x0
    2cee:	call   14a1 <log_message>
    2cf3:	add    rsp,0x20
  while (parser_incomplete(parser))
    2cf7:	mov    rax,QWORD PTR [rbp-0xe0]
    2cfe:	mov    rdi,rax
    2d01:	call   21e5 <parser_incomplete>
    2d06:	test   al,al
    2d08:	jne    2a23 <parse_json_children+0x7a>
    2d0e:	jmp    2d14 <parse_json_children+0x36b>
      break;
    2d10:	nop
    2d11:	jmp    2d14 <parse_json_children+0x36b>
      break;
    2d13:	nop
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
    }
  }

  profile_end_func();
    2d14:	sub    rsp,0x8
    2d18:	sub    rsp,0x38
    2d1c:	mov    rax,rsp
    2d1f:	mov    rcx,QWORD PTR [rbp-0x50]
    2d23:	mov    rbx,QWORD PTR [rbp-0x48]
    2d27:	mov    QWORD PTR [rax],rcx
    2d2a:	mov    QWORD PTR [rax+0x8],rbx
    2d2e:	mov    rcx,QWORD PTR [rbp-0x40]
    2d32:	mov    rbx,QWORD PTR [rbp-0x38]
    2d36:	mov    QWORD PTR [rax+0x10],rcx
    2d3a:	mov    QWORD PTR [rax+0x18],rbx
    2d3e:	mov    rcx,QWORD PTR [rbp-0x30]
    2d42:	mov    rbx,QWORD PTR [rbp-0x28]
    2d46:	mov    QWORD PTR [rax+0x20],rcx
    2d4a:	mov    QWORD PTR [rax+0x28],rbx
    2d4e:	mov    rdx,QWORD PTR [rbp-0x20]
    2d52:	mov    QWORD PTR [rax+0x30],rdx
    2d56:	call   2052 <__profile_end_pass>
    2d5b:	add    rsp,0x40

  return first_child;
    2d5f:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2d66:	mov    rdx,QWORD PTR [rbp-0x18]
    2d6a:	sub    rdx,QWORD PTR fs:0x28
    2d73:	je     2d7a <parse_json_children+0x3d1>
    2d75:	call   1060 <__stack_chk_fail@plt>
    2d7a:	mov    rbx,QWORD PTR [rbp-0x8]
    2d7e:	leave
    2d7f:	ret

0000000000002d80 <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2d80:	push   rbp
    2d81:	mov    rbp,rsp
    2d84:	push   rbx
    2d85:	sub    rsp,0xb8
    2d8c:	mov    QWORD PTR [rbp-0xa8],rdi
    2d93:	mov    rax,rsi
    2d96:	mov    rsi,rdx
    2d99:	mov    rax,rax
    2d9c:	mov    edx,0x0
    2da1:	mov    rdx,rsi
    2da4:	mov    QWORD PTR [rbp-0xc0],rax
    2dab:	mov    QWORD PTR [rbp-0xb8],rdx
    2db2:	mov    rax,QWORD PTR fs:0x28
    2dbb:	mov    QWORD PTR [rbp-0x18],rax
    2dbf:	xor    eax,eax
  profile_begin_func();
    2dc1:	lea    rcx,[rip+0x1a70]        # 4838 <__func__.2>
    2dc8:	mov    ebx,0xa
    2dcd:	lea    rax,[rbp-0x50]
    2dd1:	mov    rsi,rcx
    2dd4:	mov    rdx,rbx
    2dd7:	mov    r8d,0x0
    2ddd:	mov    ecx,0x3
    2de2:	mov    rdi,rax
    2de5:	call   1f68 <__profile_begin_pass>

  JSON_Parser parser =
    2dea:	mov    rax,QWORD PTR [rbp-0xc0]
    2df1:	mov    rdx,QWORD PTR [rbp-0xb8]
    2df8:	mov    QWORD PTR [rbp-0x90],rax
    2dff:	mov    QWORD PTR [rbp-0x88],rdx
    2e06:	mov    QWORD PTR [rbp-0x80],0x0
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2e0e:	lea    rax,[rbp-0x70]
    2e12:	lea    rdx,[rbp-0x90]
    2e19:	mov    rsi,rdx
    2e1c:	mov    rdi,rax
    2e1f:	call   2290 <get_json_token>
    2e24:	mov    ecx,0x0
    2e29:	mov    ebx,0x0
    2e2e:	lea    r8,[rbp-0x90]
    2e35:	mov    rdi,QWORD PTR [rbp-0xa8]
    2e3c:	sub    rsp,0x8
    2e40:	sub    rsp,0x18
    2e44:	mov    rsi,rsp
    2e47:	mov    rax,QWORD PTR [rbp-0x70]
    2e4b:	mov    rdx,QWORD PTR [rbp-0x68]
    2e4f:	mov    QWORD PTR [rsi],rax
    2e52:	mov    QWORD PTR [rsi+0x8],rdx
    2e56:	mov    rax,QWORD PTR [rbp-0x60]
    2e5a:	mov    QWORD PTR [rsi+0x10],rax
    2e5e:	mov    rdx,rcx
    2e61:	mov    rcx,rbx
    2e64:	mov    rsi,r8
    2e67:	call   27c2 <parse_json_object>
    2e6c:	add    rsp,0x20
    2e70:	mov    QWORD PTR [rbp-0x98],rax

  profile_end_func();
    2e77:	sub    rsp,0x8
    2e7b:	sub    rsp,0x38
    2e7f:	mov    rax,rsp
    2e82:	mov    rcx,QWORD PTR [rbp-0x50]
    2e86:	mov    rbx,QWORD PTR [rbp-0x48]
    2e8a:	mov    QWORD PTR [rax],rcx
    2e8d:	mov    QWORD PTR [rax+0x8],rbx
    2e91:	mov    rcx,QWORD PTR [rbp-0x40]
    2e95:	mov    rbx,QWORD PTR [rbp-0x38]
    2e99:	mov    QWORD PTR [rax+0x10],rcx
    2e9d:	mov    QWORD PTR [rax+0x18],rbx
    2ea1:	mov    rcx,QWORD PTR [rbp-0x30]
    2ea5:	mov    rbx,QWORD PTR [rbp-0x28]
    2ea9:	mov    QWORD PTR [rax+0x20],rcx
    2ead:	mov    QWORD PTR [rax+0x28],rbx
    2eb1:	mov    rdx,QWORD PTR [rbp-0x20]
    2eb5:	mov    QWORD PTR [rax+0x30],rdx
    2eb9:	call   2052 <__profile_end_pass>
    2ebe:	add    rsp,0x40

  return outer;
    2ec2:	mov    rax,QWORD PTR [rbp-0x98]
}
    2ec9:	mov    rdx,QWORD PTR [rbp-0x18]
    2ecd:	sub    rdx,QWORD PTR fs:0x28
    2ed6:	je     2edd <parse_json+0x15d>
    2ed8:	call   1060 <__stack_chk_fail@plt>
    2edd:	mov    rbx,QWORD PTR [rbp-0x8]
    2ee1:	leave
    2ee2:	ret

0000000000002ee3 <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2ee3:	push   rbp
    2ee4:	mov    rbp,rsp
    2ee7:	push   rbx
    2ee8:	sub    rsp,0x78
    2eec:	mov    QWORD PTR [rbp-0x68],rdi
    2ef0:	mov    rax,rsi
    2ef3:	mov    rsi,rdx
    2ef6:	mov    rax,rax
    2ef9:	mov    edx,0x0
    2efe:	mov    rdx,rsi
    2f01:	mov    QWORD PTR [rbp-0x80],rax
    2f05:	mov    QWORD PTR [rbp-0x78],rdx
    2f09:	mov    rax,QWORD PTR fs:0x28
    2f12:	mov    QWORD PTR [rbp-0x18],rax
    2f16:	xor    eax,eax
  profile_begin_func();
    2f18:	lea    rcx,[rip+0x1931]        # 4850 <__func__.1>
    2f1f:	mov    ebx,0x12
    2f24:	lea    rax,[rbp-0x50]
    2f28:	mov    rsi,rcx
    2f2b:	mov    rdx,rbx
    2f2e:	mov    r8d,0x0
    2f34:	mov    ecx,0x4
    2f39:	mov    rdi,rax
    2f3c:	call   1f68 <__profile_begin_pass>

  JSON_Object *result = NULL;
    2f41:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    2f49:	cmp    QWORD PTR [rbp-0x68],0x0
    2f4e:	je     2f9d <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f50:	mov    rax,QWORD PTR [rbp-0x68]
    2f54:	mov    rax,QWORD PTR [rax+0x20]
    2f58:	mov    QWORD PTR [rbp-0x58],rax
    2f5c:	jmp    2f96 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    2f5e:	mov    rax,QWORD PTR [rbp-0x58]
    2f62:	mov    rdx,QWORD PTR [rax+0x8]
    2f66:	mov    rax,QWORD PTR [rax]
    2f69:	mov    rdi,QWORD PTR [rbp-0x80]
    2f6d:	mov    rsi,QWORD PTR [rbp-0x78]
    2f71:	mov    rcx,rdx
    2f74:	mov    rdx,rax
    2f77:	call   143f <strings_equal>
    2f7c:	test   al,al
    2f7e:	je     2f8a <lookup_json_object+0xa7>
      {
        result = cursor;
    2f80:	mov    rax,QWORD PTR [rbp-0x58]
    2f84:	mov    QWORD PTR [rbp-0x60],rax
        break;
    2f88:	jmp    2f9d <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    2f8a:	mov    rax,QWORD PTR [rbp-0x58]
    2f8e:	mov    rax,QWORD PTR [rax+0x28]
    2f92:	mov    QWORD PTR [rbp-0x58],rax
    2f96:	cmp    QWORD PTR [rbp-0x58],0x0
    2f9b:	jne    2f5e <lookup_json_object+0x7b>
      }
    }
  }

  profile_end_func();
    2f9d:	sub    rsp,0x8
    2fa1:	sub    rsp,0x38
    2fa5:	mov    rax,rsp
    2fa8:	mov    rcx,QWORD PTR [rbp-0x50]
    2fac:	mov    rbx,QWORD PTR [rbp-0x48]
    2fb0:	mov    QWORD PTR [rax],rcx
    2fb3:	mov    QWORD PTR [rax+0x8],rbx
    2fb7:	mov    rcx,QWORD PTR [rbp-0x40]
    2fbb:	mov    rbx,QWORD PTR [rbp-0x38]
    2fbf:	mov    QWORD PTR [rax+0x10],rcx
    2fc3:	mov    QWORD PTR [rax+0x18],rbx
    2fc7:	mov    rcx,QWORD PTR [rbp-0x30]
    2fcb:	mov    rbx,QWORD PTR [rbp-0x28]
    2fcf:	mov    QWORD PTR [rax+0x20],rcx
    2fd3:	mov    QWORD PTR [rax+0x28],rbx
    2fd7:	mov    rdx,QWORD PTR [rbp-0x20]
    2fdb:	mov    QWORD PTR [rax+0x30],rdx
    2fdf:	call   2052 <__profile_end_pass>
    2fe4:	add    rsp,0x40

  return result;
    2fe8:	mov    rax,QWORD PTR [rbp-0x60]
}
    2fec:	mov    rdx,QWORD PTR [rbp-0x18]
    2ff0:	sub    rdx,QWORD PTR fs:0x28
    2ff9:	je     3000 <lookup_json_object+0x11d>
    2ffb:	call   1060 <__stack_chk_fail@plt>
    3000:	mov    rbx,QWORD PTR [rbp-0x8]
    3004:	leave
    3005:	ret

0000000000003006 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    3006:	push   rbp
    3007:	mov    rbp,rsp
    300a:	sub    rsp,0x50
    300e:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    3012:	cmp    QWORD PTR [rbp-0x48],0x0
    3017:	jne    303e <json_object_to_f64+0x38>
    3019:	lea    rdx,[rip+0x1850]        # 4870 <__PRETTY_FUNCTION__.0>
    3020:	lea    rsi,[rip+0x1453]        # 447a <_IO_stdin_used+0x47a>
    3027:	lea    rax,[rip+0x15ca]        # 45f8 <_IO_stdin_used+0x5f8>
    302e:	mov    rcx,rdx
    3031:	mov    edx,0x1c2
    3036:	mov    rdi,rax
    3039:	call   1090 <__assert_fail@plt>

  String val = object->value;
    303e:	mov    rax,QWORD PTR [rbp-0x48]
    3042:	mov    rdx,QWORD PTR [rax+0x18]
    3046:	mov    rax,QWORD PTR [rax+0x10]
    304a:	mov    QWORD PTR [rbp-0x10],rax
    304e:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    3052:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    305a:	movsd  xmm0,QWORD PTR [rip+0x1846]        # 48a8 <__PRETTY_FUNCTION__.0+0x38>
    3062:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    3067:	mov    rax,QWORD PTR [rbp-0x8]
    306b:	cmp    QWORD PTR [rbp-0x30],rax
    306f:	jae    3095 <json_object_to_f64+0x8f>
    3071:	mov    rdx,QWORD PTR [rbp-0x10]
    3075:	mov    rax,QWORD PTR [rbp-0x30]
    3079:	add    rax,rdx
    307c:	movzx  eax,BYTE PTR [rax]
    307f:	cmp    al,0x2d
    3081:	jne    3095 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    3083:	movsd  xmm0,QWORD PTR [rip+0x1825]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    308b:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    3090:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    3095:	pxor   xmm0,xmm0
    3099:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    309e:	jmp    30e5 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    30a0:	mov    rdx,QWORD PTR [rbp-0x10]
    30a4:	mov    rax,QWORD PTR [rbp-0x30]
    30a8:	add    rax,rdx
    30ab:	movzx  eax,BYTE PTR [rax]
    30ae:	sub    eax,0x30
    30b1:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    30b4:	cmp    BYTE PTR [rbp-0x32],0x9
    30b8:	ja     30f1 <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    30ba:	movsd  xmm1,QWORD PTR [rbp-0x20]
    30bf:	movsd  xmm0,QWORD PTR [rip+0x17f1]        # 48b8 <__PRETTY_FUNCTION__.0+0x48>
    30c7:	mulsd  xmm1,xmm0
    30cb:	movzx  eax,BYTE PTR [rbp-0x32]
    30cf:	pxor   xmm0,xmm0
    30d3:	cvtsi2sd xmm0,eax
    30d7:	addsd  xmm0,xmm1
    30db:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    30e0:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    30e5:	mov    rax,QWORD PTR [rbp-0x8]
    30e9:	cmp    QWORD PTR [rbp-0x30],rax
    30ed:	jb     30a0 <json_object_to_f64+0x9a>
    30ef:	jmp    30f2 <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    30f1:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    30f2:	mov    rax,QWORD PTR [rbp-0x8]
    30f6:	cmp    QWORD PTR [rbp-0x30],rax
    30fa:	jae    3187 <json_object_to_f64+0x181>
    3100:	mov    rdx,QWORD PTR [rbp-0x10]
    3104:	mov    rax,QWORD PTR [rbp-0x30]
    3108:	add    rax,rdx
    310b:	movzx  eax,BYTE PTR [rax]
    310e:	cmp    al,0x2e
    3110:	jne    3187 <json_object_to_f64+0x181>
  {
    at += 1;
    3112:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    3117:	movsd  xmm0,QWORD PTR [rip+0x17a1]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    311f:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    3124:	jmp    317a <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3126:	mov    rdx,QWORD PTR [rbp-0x10]
    312a:	mov    rax,QWORD PTR [rbp-0x30]
    312e:	add    rax,rdx
    3131:	movzx  eax,BYTE PTR [rax]
    3134:	sub    eax,0x30
    3137:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    313a:	cmp    BYTE PTR [rbp-0x31],0x9
    313e:	ja     3186 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    3140:	movzx  eax,BYTE PTR [rbp-0x31]
    3144:	pxor   xmm0,xmm0
    3148:	cvtsi2sd xmm0,eax
    314c:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    3151:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3156:	addsd  xmm0,xmm1
    315a:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    315f:	movsd  xmm1,QWORD PTR [rbp-0x18]
    3164:	movsd  xmm0,QWORD PTR [rip+0x1754]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    316c:	mulsd  xmm0,xmm1
    3170:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    3175:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    317a:	mov    rax,QWORD PTR [rbp-0x8]
    317e:	cmp    QWORD PTR [rbp-0x30],rax
    3182:	jb     3126 <json_object_to_f64+0x120>
    3184:	jmp    3187 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    3186:	nop
      }
    }
  }

  return sign * result;
    3187:	movsd  xmm0,QWORD PTR [rbp-0x28]
    318c:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    3191:	leave
    3192:	ret

0000000000003193 <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    3193:	push   rbp
    3194:	mov    rbp,rsp
    3197:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    319c:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31a1:	movsd  xmm1,QWORD PTR [rip+0x171f]        # 48c8 <__PRETTY_FUNCTION__.0+0x58>
    31a9:	divsd  xmm0,xmm1
}
    31ad:	pop    rbp
    31ae:	ret

00000000000031af <square>:

static
f64 square(f64 x)
{
    31af:	push   rbp
    31b0:	mov    rbp,rsp
    31b3:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    31b8:	movsd  xmm0,QWORD PTR [rbp-0x8]
    31bd:	mulsd  xmm0,xmm0
}
    31c1:	pop    rbp
    31c2:	ret

00000000000031c3 <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    31c3:	push   rbp
    31c4:	mov    rbp,rsp
    31c7:	sub    rsp,0x90
    31ce:	movsd  QWORD PTR [rbp-0x58],xmm0
    31d3:	movsd  QWORD PTR [rbp-0x60],xmm1
    31d8:	movsd  QWORD PTR [rbp-0x68],xmm2
    31dd:	movsd  QWORD PTR [rbp-0x70],xmm3
    31e2:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    31e7:	movsd  xmm0,QWORD PTR [rbp-0x60]
    31ec:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    31f1:	movsd  xmm0,QWORD PTR [rbp-0x70]
    31f6:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    31fb:	movsd  xmm0,QWORD PTR [rbp-0x58]
    3200:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    3205:	movsd  xmm0,QWORD PTR [rbp-0x68]
    320a:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    320f:	movsd  xmm0,QWORD PTR [rbp-0x40]
    3214:	subsd  xmm0,QWORD PTR [rbp-0x48]
    3219:	movq   rax,xmm0
    321e:	movq   xmm0,rax
    3223:	call   3193 <to_radians>
    3228:	movq   rax,xmm0
    322d:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    3231:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3236:	subsd  xmm0,QWORD PTR [rbp-0x38]
    323b:	movq   rax,xmm0
    3240:	movq   xmm0,rax
    3245:	call   3193 <to_radians>
    324a:	movq   rax,xmm0
    324f:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    3253:	mov    rax,QWORD PTR [rbp-0x48]
    3257:	movq   xmm0,rax
    325c:	call   3193 <to_radians>
    3261:	movq   rax,xmm0
    3266:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    326a:	mov    rax,QWORD PTR [rbp-0x40]
    326e:	movq   xmm0,rax
    3273:	call   3193 <to_radians>
    3278:	movq   rax,xmm0
    327d:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    3281:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3286:	movsd  xmm1,QWORD PTR [rip+0x1642]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    328e:	divsd  xmm0,xmm1
    3292:	movq   rax,xmm0
    3297:	movq   xmm0,rax
    329c:	call   1130 <sin@plt>
    32a1:	movq   rax,xmm0
    32a6:	movq   xmm0,rax
    32ab:	call   31af <square>
    32b0:	movsd  QWORD PTR [rbp-0x80],xmm0
    32b5:	mov    rax,QWORD PTR [rbp-0x48]
    32b9:	movq   xmm0,rax
    32be:	call   10b0 <cos@plt>
    32c3:	movsd  QWORD PTR [rbp-0x88],xmm0
    32cb:	mov    rax,QWORD PTR [rbp-0x40]
    32cf:	movq   xmm0,rax
    32d4:	call   10b0 <cos@plt>
    32d9:	movapd xmm5,xmm0
    32dd:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    32e5:	movsd  QWORD PTR [rbp-0x88],xmm5
    32ed:	movsd  xmm0,QWORD PTR [rbp-0x20]
    32f2:	movsd  xmm1,QWORD PTR [rip+0x15d6]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    32fa:	movapd xmm6,xmm0
    32fe:	divsd  xmm6,xmm1
    3302:	movq   rax,xmm6
    3307:	movq   xmm0,rax
    330c:	call   1130 <sin@plt>
    3311:	movq   rax,xmm0
    3316:	movq   xmm0,rax
    331b:	call   31af <square>
    3320:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    3328:	addsd  xmm0,QWORD PTR [rbp-0x80]
    332d:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    3332:	mov    rax,QWORD PTR [rbp-0x18]
    3336:	movq   xmm0,rax
    333b:	call   1160 <sqrt@plt>
    3340:	movq   rax,xmm0
    3345:	movq   xmm0,rax
    334a:	call   1140 <asin@plt>
    334f:	addsd  xmm0,xmm0
    3353:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    3358:	movsd  xmm0,QWORD PTR [rbp-0x78]
    335d:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    3362:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3367:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    336c:	leave
    336d:	ret

000000000000336e <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    336e:	push   rbp
    336f:	mov    rbp,rsp
    3372:	movsd  QWORD PTR [rbp-0x18],xmm0
    3377:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    337c:	movsd  xmm0,QWORD PTR [rip+0x1554]        # 48d8 <__PRETTY_FUNCTION__.0+0x68>
    3384:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    3389:	movsd  xmm0,QWORD PTR [rbp-0x18]
    338e:	movq   xmm1,QWORD PTR [rip+0x154a]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    3396:	andpd  xmm0,xmm1
    339a:	movsd  xmm1,QWORD PTR [rbp-0x20]
    339f:	movq   xmm2,QWORD PTR [rip+0x1539]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    33a7:	andpd  xmm2,xmm1
    33ab:	movapd xmm1,xmm0
    33af:	subsd  xmm1,xmm2
    33b3:	movsd  xmm0,QWORD PTR [rbp-0x8]
    33b8:	comisd xmm0,xmm1
    33bc:	setae  al
    33bf:	movzx  eax,al
}
    33c2:	pop    rbp
    33c3:	ret

00000000000033c4 <main>:

int main(int args_count, char **args)
{
    33c4:	push   rbp
    33c5:	mov    rbp,rsp
    33c8:	push   r15
    33ca:	push   r14
    33cc:	push   r13
    33ce:	push   r12
    33d0:	push   rbx
    33d1:	sub    rsp,0x268
    33d8:	mov    DWORD PTR [rbp-0x1f4],edi
    33de:	mov    QWORD PTR [rbp-0x200],rsi
    33e5:	mov    rax,QWORD PTR fs:0x28
    33ee:	mov    QWORD PTR [rbp-0x38],rax
    33f2:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    33f4:	cmp    DWORD PTR [rbp-0x1f4],0x3
    33fb:	je     3428 <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    33fd:	mov    rax,QWORD PTR [rbp-0x200]
    3404:	mov    rax,QWORD PTR [rax]
    3407:	lea    rdx,[rip+0x1222]        # 4630 <_IO_stdin_used+0x630>
    340e:	mov    rsi,rax
    3411:	mov    rdi,rdx
    3414:	mov    eax,0x0
    3419:	call   1070 <printf@plt>
    return 1;
    341e:	mov    eax,0x1
    3423:	jmp    3d5e <main+0x99a>
  }

  begin_profiling();
    3428:	call   1b3d <begin_profiling>

  Arena arena = {0};
    342d:	pxor   xmm0,xmm0
    3431:	movaps XMMWORD PTR [rbp-0x150],xmm0
    3438:	movaps XMMWORD PTR [rbp-0x140],xmm0
  arena = arena_make(GB(4));
    343f:	lea    rdx,[rbp-0x220]
    3446:	movabs rax,0x100000000
    3450:	mov    rsi,rax
    3453:	mov    rdi,rdx
    3456:	call   1632 <arena_make>
    345b:	mov    rax,QWORD PTR [rbp-0x220]
    3462:	mov    rdx,QWORD PTR [rbp-0x218]
    3469:	mov    QWORD PTR [rbp-0x150],rax
    3470:	mov    QWORD PTR [rbp-0x148],rdx
    3477:	mov    rax,QWORD PTR [rbp-0x210]
    347e:	mov    rdx,QWORD PTR [rbp-0x208]
    3485:	mov    QWORD PTR [rbp-0x140],rax
    348c:	mov    QWORD PTR [rbp-0x138],rdx

  String source = {0};
    3493:	mov    QWORD PTR [rbp-0x160],0x0
    349e:	mov    QWORD PTR [rbp-0x158],0x0
  printf("%lu", file_size(args[1]));
    34a9:	mov    rax,QWORD PTR [rbp-0x200]
    34b0:	add    rax,0x8
    34b4:	mov    rax,QWORD PTR [rax]
    34b7:	mov    rdi,rax
    34ba:	call   1303 <file_size>
    34bf:	mov    rdx,rax
    34c2:	lea    rax,[rip+0x1193]        # 465c <_IO_stdin_used+0x65c>
    34c9:	mov    rsi,rdx
    34cc:	mov    rdi,rax
    34cf:	mov    eax,0x0
    34d4:	call   1070 <printf@plt>
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    34d9:	mov    rax,QWORD PTR [rbp-0x200]
    34e0:	add    rax,0x8
    34e4:	mov    rax,QWORD PTR [rax]
    34e7:	mov    rdi,rax
    34ea:	call   1303 <file_size>
    34ef:	mov    rcx,rax
    34f2:	lea    r12,[rip+0x1167]        # 4660 <_IO_stdin_used+0x660>
    34f9:	mov    r13d,0x4
    34ff:	lea    rdi,[rbp-0x130]
    3506:	mov    rdx,r12
    3509:	mov    rax,r13
    350c:	mov    r8,rcx
    350f:	mov    ecx,0x5
    3514:	mov    rsi,rdx
    3517:	mov    rdx,rax
    351a:	call   1f68 <__profile_begin_pass>
    351f:	mov    QWORD PTR [rbp-0x1e0],0x0
    352a:	jmp    35c5 <main+0x201>
  {
    source = read_file_to_arena(&arena, args[1]);
    352f:	mov    rax,QWORD PTR [rbp-0x200]
    3536:	add    rax,0x8
    353a:	mov    rdx,QWORD PTR [rax]
    353d:	lea    rax,[rbp-0x150]
    3544:	mov    rsi,rdx
    3547:	mov    rdi,rax
    354a:	call   1357 <read_file_to_arena>
    354f:	mov    QWORD PTR [rbp-0x160],rax
    3556:	mov    QWORD PTR [rbp-0x158],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    355d:	add    QWORD PTR [rbp-0x1e0],0x1
    3565:	sub    rsp,0x8
    3569:	sub    rsp,0x38
    356d:	mov    rcx,rsp
    3570:	mov    rax,QWORD PTR [rbp-0x130]
    3577:	mov    rdx,QWORD PTR [rbp-0x128]
    357e:	mov    QWORD PTR [rcx],rax
    3581:	mov    QWORD PTR [rcx+0x8],rdx
    3585:	mov    rax,QWORD PTR [rbp-0x120]
    358c:	mov    rdx,QWORD PTR [rbp-0x118]
    3593:	mov    QWORD PTR [rcx+0x10],rax
    3597:	mov    QWORD PTR [rcx+0x18],rdx
    359b:	mov    rax,QWORD PTR [rbp-0x110]
    35a2:	mov    rdx,QWORD PTR [rbp-0x108]
    35a9:	mov    QWORD PTR [rcx+0x20],rax
    35ad:	mov    QWORD PTR [rcx+0x28],rdx
    35b1:	mov    rax,QWORD PTR [rbp-0x100]
    35b8:	mov    QWORD PTR [rcx+0x30],rax
    35bc:	call   2052 <__profile_end_pass>
    35c1:	add    rsp,0x40
    35c5:	cmp    QWORD PTR [rbp-0x1e0],0x0
    35cd:	je     352f <main+0x16b>
  }

  usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    35d3:	mov    QWORD PTR [rbp-0x1a8],0x18
  usize max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    35de:	mov    rax,QWORD PTR [rbp-0x158]
    35e5:	mov    edx,0x0
    35ea:	div    QWORD PTR [rbp-0x1a8]
    35f1:	mov    QWORD PTR [rbp-0x1a0],rax
  Haversine_Pair * pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    35f8:	mov    rax,QWORD PTR [rbp-0x1a0]
    35ff:	shl    rax,0x5
    3603:	mov    rcx,rax
    3606:	lea    rax,[rbp-0x150]
    360d:	mov    edx,0x8
    3612:	mov    rsi,rcx
    3615:	mov    rdi,rax
    3618:	call   17d3 <arena_alloc>
    361d:	mov    QWORD PTR [rbp-0x198],rax
  i32 pair_count = 0;
    3624:	mov    DWORD PTR [rbp-0x1e8],0x0

  JSON_Object *root = NULL;
    362e:	mov    QWORD PTR [rbp-0x190],0x0
  root = parse_json(&arena, source);
    3639:	mov    rcx,QWORD PTR [rbp-0x160]
    3640:	mov    rdx,QWORD PTR [rbp-0x158]
    3647:	lea    rax,[rbp-0x150]
    364e:	mov    rsi,rcx
    3651:	mov    rdi,rax
    3654:	call   2d80 <parse_json>
    3659:	mov    QWORD PTR [rbp-0x190],rax

  f64 haversine_sum = 0.0;
    3660:	pxor   xmm0,xmm0
    3664:	movsd  QWORD PTR [rbp-0x188],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    366c:	lea    r14,[rip+0xff2]        # 4665 <_IO_stdin_used+0x665>
    3673:	mov    r15d,0x5
    3679:	mov    rcx,r14
    367c:	mov    rdx,r15
    367f:	mov    rax,QWORD PTR [rbp-0x190]
    3686:	mov    rsi,rcx
    3689:	mov    rdi,rax
    368c:	call   2ee3 <lookup_json_object>
    3691:	mov    QWORD PTR [rbp-0x180],rax
  if (pairs)
    3698:	cmp    QWORD PTR [rbp-0x198],0x0
    36a0:	je     3865 <main+0x4a1>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    36a6:	mov    rax,QWORD PTR [rbp-0x180]
    36ad:	mov    rax,QWORD PTR [rax+0x20]
    36b1:	mov    QWORD PTR [rbp-0x1d8],rax
    36b8:	jmp    3846 <main+0x482>
    {
      Haversine_Pair pair =
      {
        .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    36bd:	lea    rax,[rip+0xfa7]        # 466b <_IO_stdin_used+0x66b>
    36c4:	mov    QWORD PTR [rbp-0x260],rax
    36cb:	mov    QWORD PTR [rbp-0x258],0x2
    36d6:	mov    rbx,QWORD PTR [rbp-0x260]
    36dd:	mov    rsi,QWORD PTR [rbp-0x258]
    36e4:	mov    rax,rbx
    36e7:	mov    rdx,rsi
    36ea:	mov    rcx,QWORD PTR [rbp-0x1d8]
    36f1:	mov    rsi,rax
    36f4:	mov    rdi,rcx
    36f7:	call   2ee3 <lookup_json_object>
    36fc:	mov    rdi,rax
    36ff:	call   3006 <json_object_to_f64>
    3704:	movq   rax,xmm0
      Haversine_Pair pair =
    3709:	mov    QWORD PTR [rbp-0x70],rax
        .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    370d:	lea    rax,[rip+0xf5a]        # 466e <_IO_stdin_used+0x66e>
    3714:	mov    QWORD PTR [rbp-0x270],rax
    371b:	mov    QWORD PTR [rbp-0x268],0x2
    3726:	mov    rax,QWORD PTR [rbp-0x270]
    372d:	mov    rdx,QWORD PTR [rbp-0x268]
    3734:	mov    rcx,rax
    3737:	mov    rax,QWORD PTR [rbp-0x1d8]
    373e:	mov    rsi,rcx
    3741:	mov    rdi,rax
    3744:	call   2ee3 <lookup_json_object>
    3749:	mov    rdi,rax
    374c:	call   3006 <json_object_to_f64>
    3751:	movq   rax,xmm0
      Haversine_Pair pair =
    3756:	mov    QWORD PTR [rbp-0x68],rax
        .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    375a:	lea    rax,[rip+0xf10]        # 4671 <_IO_stdin_used+0x671>
    3761:	mov    QWORD PTR [rbp-0x280],rax
    3768:	mov    QWORD PTR [rbp-0x278],0x2
    3773:	mov    rax,QWORD PTR [rbp-0x280]
    377a:	mov    rdx,QWORD PTR [rbp-0x278]
    3781:	mov    rcx,rax
    3784:	mov    rax,QWORD PTR [rbp-0x1d8]
    378b:	mov    rsi,rcx
    378e:	mov    rdi,rax
    3791:	call   2ee3 <lookup_json_object>
    3796:	mov    rdi,rax
    3799:	call   3006 <json_object_to_f64>
    379e:	movq   rax,xmm0
      Haversine_Pair pair =
    37a3:	mov    QWORD PTR [rbp-0x60],rax
        .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    37a7:	lea    rax,[rip+0xec6]        # 4674 <_IO_stdin_used+0x674>
    37ae:	mov    QWORD PTR [rbp-0x290],rax
    37b5:	mov    QWORD PTR [rbp-0x288],0x2
    37c0:	mov    rax,QWORD PTR [rbp-0x290]
    37c7:	mov    rdx,QWORD PTR [rbp-0x288]
    37ce:	mov    rcx,rax
    37d1:	mov    rax,QWORD PTR [rbp-0x1d8]
    37d8:	mov    rsi,rcx
    37db:	mov    rdi,rax
    37de:	call   2ee3 <lookup_json_object>
    37e3:	mov    rdi,rax
    37e6:	call   3006 <json_object_to_f64>
    37eb:	movq   rax,xmm0
      Haversine_Pair pair =
    37f0:	mov    QWORD PTR [rbp-0x58],rax
      };

      pairs[pair_count] = pair;
    37f4:	mov    eax,DWORD PTR [rbp-0x1e8]
    37fa:	cdqe
    37fc:	shl    rax,0x5
    3800:	mov    rdx,rax
    3803:	mov    rax,QWORD PTR [rbp-0x198]
    380a:	lea    rcx,[rdx+rax*1]
    380e:	mov    rax,QWORD PTR [rbp-0x70]
    3812:	mov    rdx,QWORD PTR [rbp-0x68]
    3816:	mov    QWORD PTR [rcx],rax
    3819:	mov    QWORD PTR [rcx+0x8],rdx
    381d:	mov    rax,QWORD PTR [rbp-0x60]
    3821:	mov    rdx,QWORD PTR [rbp-0x58]
    3825:	mov    QWORD PTR [rcx+0x10],rax
    3829:	mov    QWORD PTR [rcx+0x18],rdx
      pair_count += 1;
    382d:	add    DWORD PTR [rbp-0x1e8],0x1
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    3834:	mov    rax,QWORD PTR [rbp-0x1d8]
    383b:	mov    rax,QWORD PTR [rax+0x28]
    383f:	mov    QWORD PTR [rbp-0x1d8],rax
    3846:	cmp    QWORD PTR [rbp-0x1d8],0x0
    384e:	je     3865 <main+0x4a1>
    3850:	mov    eax,DWORD PTR [rbp-0x1e8]
    3856:	cdqe
    3858:	cmp    rax,QWORD PTR [rbp-0x1a0]
    385f:	jb     36bd <main+0x2f9>
    }
  }

  f64 sum = 0.0;
    3865:	pxor   xmm0,xmm0
    3869:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    3871:	mov    eax,DWORD PTR [rbp-0x1e8]
    3877:	cdqe
    3879:	shl    rax,0x5
    387d:	mov    rdx,rax
    3880:	lea    rax,[rip+0xdf0]        # 4677 <_IO_stdin_used+0x677>
    3887:	mov    QWORD PTR [rbp-0x230],rax
    388e:	mov    QWORD PTR [rbp-0x228],0x3
    3899:	lea    rax,[rbp-0xf0]
    38a0:	mov    rcx,QWORD PTR [rbp-0x230]
    38a7:	mov    rbx,QWORD PTR [rbp-0x228]
    38ae:	mov    rsi,rcx
    38b1:	mov    rdi,rbx
    38b4:	mov    r8,rdx
    38b7:	mov    ecx,0x6
    38bc:	mov    rdx,rdi
    38bf:	mov    rdi,rax
    38c2:	call   1f68 <__profile_begin_pass>
    38c7:	mov    QWORD PTR [rbp-0x1c8],0x0
    38d2:	jmp    3a54 <main+0x690>
  {
    for (usize i = 0; i < pair_count; i++)
    38d7:	mov    QWORD PTR [rbp-0x1c0],0x0
    38e2:	jmp    39b7 <main+0x5f3>
    {
      f64 earth_radius = 6372.8;
    38e7:	movsd  xmm0,QWORD PTR [rip+0x1001]        # 48f0 <__PRETTY_FUNCTION__.0+0x80>
    38ef:	movsd  QWORD PTR [rbp-0x170],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    38f7:	mov    rax,QWORD PTR [rbp-0x1c0]
    38fe:	shl    rax,0x5
    3902:	mov    rdx,rax
    3905:	mov    rax,QWORD PTR [rbp-0x198]
    390c:	add    rax,rdx
    390f:	movsd  xmm2,QWORD PTR [rax+0x18]
    3914:	mov    rax,QWORD PTR [rbp-0x1c0]
    391b:	shl    rax,0x5
    391f:	mov    rdx,rax
    3922:	mov    rax,QWORD PTR [rbp-0x198]
    3929:	add    rax,rdx
    392c:	movsd  xmm1,QWORD PTR [rax+0x10]
    3931:	mov    rax,QWORD PTR [rbp-0x1c0]
    3938:	shl    rax,0x5
    393c:	mov    rdx,rax
    393f:	mov    rax,QWORD PTR [rbp-0x198]
    3946:	add    rax,rdx
    3949:	movsd  xmm0,QWORD PTR [rax+0x8]
    394e:	mov    rax,QWORD PTR [rbp-0x1c0]
    3955:	shl    rax,0x5
    3959:	mov    rdx,rax
    395c:	mov    rax,QWORD PTR [rbp-0x198]
    3963:	add    rax,rdx
    3966:	mov    rax,QWORD PTR [rax]
    3969:	movsd  xmm3,QWORD PTR [rbp-0x170]
    3971:	movapd xmm4,xmm3
    3975:	movapd xmm3,xmm2
    3979:	movapd xmm2,xmm1
    397d:	movapd xmm1,xmm0
    3981:	movq   xmm0,rax
    3986:	call   31c3 <reference_haversine>
    398b:	movq   rax,xmm0
    3990:	mov    QWORD PTR [rbp-0x168],rax
      sum += result;
    3997:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    399f:	addsd  xmm0,QWORD PTR [rbp-0x168]
    39a7:	movsd  QWORD PTR [rbp-0x1d0],xmm0
    for (usize i = 0; i < pair_count; i++)
    39af:	add    QWORD PTR [rbp-0x1c0],0x1
    39b7:	mov    eax,DWORD PTR [rbp-0x1e8]
    39bd:	cdqe
    39bf:	cmp    QWORD PTR [rbp-0x1c0],rax
    39c6:	jb     38e7 <main+0x523>
    }
    sum /= pair_count;
    39cc:	pxor   xmm1,xmm1
    39d0:	cvtsi2sd xmm1,DWORD PTR [rbp-0x1e8]
    39d8:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    39e0:	divsd  xmm0,xmm1
    39e4:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    39ec:	add    QWORD PTR [rbp-0x1c8],0x1
    39f4:	sub    rsp,0x8
    39f8:	sub    rsp,0x38
    39fc:	mov    rax,rsp
    39ff:	mov    rcx,QWORD PTR [rbp-0xf0]
    3a06:	mov    rbx,QWORD PTR [rbp-0xe8]
    3a0d:	mov    QWORD PTR [rax],rcx
    3a10:	mov    QWORD PTR [rax+0x8],rbx
    3a14:	mov    rcx,QWORD PTR [rbp-0xe0]
    3a1b:	mov    rbx,QWORD PTR [rbp-0xd8]
    3a22:	mov    QWORD PTR [rax+0x10],rcx
    3a26:	mov    QWORD PTR [rax+0x18],rbx
    3a2a:	mov    rcx,QWORD PTR [rbp-0xd0]
    3a31:	mov    rbx,QWORD PTR [rbp-0xc8]
    3a38:	mov    QWORD PTR [rax+0x20],rcx
    3a3c:	mov    QWORD PTR [rax+0x28],rbx
    3a40:	mov    rdx,QWORD PTR [rbp-0xc0]
    3a47:	mov    QWORD PTR [rax+0x30],rdx
    3a4b:	call   2052 <__profile_end_pass>
    3a50:	add    rsp,0x40
    3a54:	cmp    QWORD PTR [rbp-0x1c8],0x0
    3a5c:	je     38d7 <main+0x513>
  }

  PROFILE_SCOPE("check")
    3a62:	lea    rax,[rip+0xc12]        # 467b <_IO_stdin_used+0x67b>
    3a69:	mov    QWORD PTR [rbp-0x240],rax
    3a70:	mov    QWORD PTR [rbp-0x238],0x5
    3a7b:	lea    rax,[rbp-0xb0]
    3a82:	mov    rcx,QWORD PTR [rbp-0x240]
    3a89:	mov    rbx,QWORD PTR [rbp-0x238]
    3a90:	mov    rsi,rcx
    3a93:	mov    rdx,rbx
    3a96:	mov    r8d,0x0
    3a9c:	mov    ecx,0x7
    3aa1:	mov    rdi,rax
    3aa4:	call   1f68 <__profile_begin_pass>
    3aa9:	mov    QWORD PTR [rbp-0x1b8],0x0
    3ab4:	jmp    3c89 <main+0x8c5>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3ab9:	mov    rax,QWORD PTR [rbp-0x200]
    3ac0:	add    rax,0x10
    3ac4:	mov    rdx,QWORD PTR [rax]
    3ac7:	lea    rax,[rbp-0x150]
    3ace:	mov    rsi,rdx
    3ad1:	mov    rdi,rax
    3ad4:	call   1357 <read_file_to_arena>
    3ad9:	mov    QWORD PTR [rbp-0x70],rax
    3add:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3ae1:	mov    rax,QWORD PTR [rbp-0x68]
    3ae5:	cmp    rax,0xb
    3ae9:	jbe    3bfc <main+0x838>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3aef:	mov    rax,QWORD PTR [rbp-0x70]
    3af3:	movsd  xmm0,QWORD PTR [rax]
    3af7:	movsd  QWORD PTR [rbp-0x178],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3aff:	mov    rax,QWORD PTR [rbp-0x70]
    3b03:	mov    eax,DWORD PTR [rax+0x8]
    3b06:	mov    DWORD PTR [rbp-0x1e4],eax

      if (solution_pairs == pair_count)
    3b0c:	mov    eax,DWORD PTR [rbp-0x1e4]
    3b12:	cmp    eax,DWORD PTR [rbp-0x1e8]
    3b18:	jne    3bc0 <main+0x7fc>
      {
        if (epsilon_equal(solution_sum, sum))
    3b1e:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3b26:	mov    rax,QWORD PTR [rbp-0x178]
    3b2d:	movapd xmm1,xmm0
    3b31:	movq   xmm0,rax
    3b36:	call   336e <epsilon_equal>
    3b3b:	test   eax,eax
    3b3d:	je     3b81 <main+0x7bd>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3b3f:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3b47:	mov    rax,QWORD PTR [rbp-0x178]
    3b4e:	lea    rdx,[rip+0xb33]        # 4688 <_IO_stdin_used+0x688>
    3b55:	lea    rsi,[rip+0xb5f]        # 46bb <_IO_stdin_used+0x6bb>
    3b5c:	movapd xmm1,xmm0
    3b60:	movq   xmm0,rax
    3b65:	mov    rcx,rdx
    3b68:	mov    edx,0x5b
    3b6d:	mov    edi,0x3
    3b72:	mov    eax,0x2
    3b77:	call   14a1 <log_message>
    3b7c:	jmp    3c24 <main+0x860>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3b81:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3b89:	mov    rax,QWORD PTR [rbp-0x178]
    3b90:	lea    rdx,[rip+0xb39]        # 46d0 <_IO_stdin_used+0x6d0>
    3b97:	lea    rsi,[rip+0xb1d]        # 46bb <_IO_stdin_used+0x6bb>
    3b9e:	movapd xmm1,xmm0
    3ba2:	movq   xmm0,rax
    3ba7:	mov    rcx,rdx
    3baa:	mov    edx,0x5f
    3baf:	mov    edi,0x1
    3bb4:	mov    eax,0x2
    3bb9:	call   14a1 <log_message>
    3bbe:	jmp    3c24 <main+0x860>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3bc0:	mov    esi,DWORD PTR [rbp-0x1e8]
    3bc6:	mov    ecx,DWORD PTR [rbp-0x1e4]
    3bcc:	lea    rdx,[rip+0xb35]        # 4708 <_IO_stdin_used+0x708>
    3bd3:	lea    rax,[rip+0xae1]        # 46bb <_IO_stdin_used+0x6bb>
    3bda:	mov    r9d,esi
    3bdd:	mov    r8d,ecx
    3be0:	mov    rcx,rdx
    3be3:	mov    edx,0x64
    3be8:	mov    rsi,rax
    3beb:	mov    edi,0x1
    3bf0:	mov    eax,0x0
    3bf5:	call   14a1 <log_message>
    3bfa:	jmp    3c24 <main+0x860>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3bfc:	lea    rdx,[rip+0xb4d]        # 4750 <_IO_stdin_used+0x750>
    3c03:	lea    rax,[rip+0xab1]        # 46bb <_IO_stdin_used+0x6bb>
    3c0a:	mov    rcx,rdx
    3c0d:	mov    edx,0x69
    3c12:	mov    rsi,rax
    3c15:	mov    edi,0x1
    3c1a:	mov    eax,0x0
    3c1f:	call   14a1 <log_message>
  PROFILE_SCOPE("check")
    3c24:	add    QWORD PTR [rbp-0x1b8],0x1
    3c2c:	sub    rsp,0x8
    3c30:	sub    rsp,0x38
    3c34:	mov    rax,rsp
    3c37:	mov    rcx,QWORD PTR [rbp-0xb0]
    3c3e:	mov    rbx,QWORD PTR [rbp-0xa8]
    3c45:	mov    QWORD PTR [rax],rcx
    3c48:	mov    QWORD PTR [rax+0x8],rbx
    3c4c:	mov    rcx,QWORD PTR [rbp-0xa0]
    3c53:	mov    rbx,QWORD PTR [rbp-0x98]
    3c5a:	mov    QWORD PTR [rax+0x10],rcx
    3c5e:	mov    QWORD PTR [rax+0x18],rbx
    3c62:	mov    rcx,QWORD PTR [rbp-0x90]
    3c69:	mov    rbx,QWORD PTR [rbp-0x88]
    3c70:	mov    QWORD PTR [rax+0x20],rcx
    3c74:	mov    QWORD PTR [rax+0x28],rbx
    3c78:	mov    rdx,QWORD PTR [rbp-0x80]
    3c7c:	mov    QWORD PTR [rax+0x30],rdx
    3c80:	call   2052 <__profile_end_pass>
    3c85:	add    rsp,0x40
    3c89:	cmp    QWORD PTR [rbp-0x1b8],0x0
    3c91:	je     3ab9 <main+0x6f5>
    }
  }

  PROFILE_SCOPE("free")
    3c97:	lea    rax,[rip+0xaed]        # 478b <_IO_stdin_used+0x78b>
    3c9e:	mov    QWORD PTR [rbp-0x250],rax
    3ca5:	mov    QWORD PTR [rbp-0x248],0x4
    3cb0:	lea    rax,[rbp-0x70]
    3cb4:	mov    rcx,QWORD PTR [rbp-0x250]
    3cbb:	mov    rbx,QWORD PTR [rbp-0x248]
    3cc2:	mov    rsi,rcx
    3cc5:	mov    rdx,rbx
    3cc8:	mov    r8d,0x0
    3cce:	mov    ecx,0x8
    3cd3:	mov    rdi,rax
    3cd6:	call   1f68 <__profile_begin_pass>
    3cdb:	mov    QWORD PTR [rbp-0x1b0],0x0
    3ce6:	jmp    3d4a <main+0x986>
  {
    arena_free(&arena);
    3ce8:	lea    rax,[rbp-0x150]
    3cef:	mov    rdi,rax
    3cf2:	call   1791 <arena_free>
  PROFILE_SCOPE("free")
    3cf7:	add    QWORD PTR [rbp-0x1b0],0x1
    3cff:	sub    rsp,0x8
    3d03:	sub    rsp,0x38
    3d07:	mov    rax,rsp
    3d0a:	mov    rcx,QWORD PTR [rbp-0x70]
    3d0e:	mov    rbx,QWORD PTR [rbp-0x68]
    3d12:	mov    QWORD PTR [rax],rcx
    3d15:	mov    QWORD PTR [rax+0x8],rbx
    3d19:	mov    rcx,QWORD PTR [rbp-0x60]
    3d1d:	mov    rbx,QWORD PTR [rbp-0x58]
    3d21:	mov    QWORD PTR [rax+0x10],rcx
    3d25:	mov    QWORD PTR [rax+0x18],rbx
    3d29:	mov    rcx,QWORD PTR [rbp-0x50]
    3d2d:	mov    rbx,QWORD PTR [rbp-0x48]
    3d31:	mov    QWORD PTR [rax+0x20],rcx
    3d35:	mov    QWORD PTR [rax+0x28],rbx
    3d39:	mov    rdx,QWORD PTR [rbp-0x40]
    3d3d:	mov    QWORD PTR [rax+0x30],rdx
    3d41:	call   2052 <__profile_end_pass>
    3d46:	add    rsp,0x40
    3d4a:	cmp    QWORD PTR [rbp-0x1b0],0x0
    3d52:	je     3ce8 <main+0x924>
  }

  end_profiling();
    3d54:	call   1b9b <end_profiling>
    3d59:	mov    eax,0x0
}
    3d5e:	mov    rdx,QWORD PTR [rbp-0x38]
    3d62:	sub    rdx,QWORD PTR fs:0x28
    3d6b:	je     3d72 <main+0x9ae>
    3d6d:	call   1060 <__stack_chk_fail@plt>
    3d72:	lea    rsp,[rbp-0x28]
    3d76:	pop    rbx
    3d77:	pop    r12
    3d79:	pop    r13
    3d7b:	pop    r14
    3d7d:	pop    r15
    3d7f:	pop    rbp
    3d80:	ret

Disassembly of section .fini:

0000000000003d84 <_fini>:
    3d84:	endbr64
    3d88:	sub    rsp,0x8
    3d8c:	add    rsp,0x8
    3d90:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x5fc1]        # 6fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x5fca]        # 6ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x5fcc]        # 6ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x5fca]        # 7000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x5fc2]        # 7008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x5fba]        # 7010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x5fb2]        # 7018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x5faa]        # 7020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x5fa2]        # 7028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x5f9a]        # 7030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x5f92]        # 7038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x5f8a]        # 7040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x5f82]        # 7048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x5f7a]        # 7050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x5f72]        # 7058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x5f6a]        # 7060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x5f62]        # 7068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x5f5a]        # 7070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x5f52]        # 7078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x5f4a]        # 7080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x5f42]        # 7088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x5f3a]        # 7090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x5f32]        # 7098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x2365]        # 34f4 <main>
    118f:	call   QWORD PTR [rip+0x5e2b]        # 6fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x5fa1]        # 7148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x5f9a]        # 7148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x5e0e]        # 6fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x5f71]        # 7148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x5f6a]        # 7148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x5ddd]        # 6fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x5f6d],0x0        # 7188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x5dba],0x0        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x5e76]        # 70a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x5da8]        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x5f44],0x1        # 7188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  usize byte_count = 0;
    127d:	mov    QWORD PTR [rbp-0x10],0x0

  FILE *file = fopen(name, "rb");
    1285:	lea    rdx,[rip+0x2d84]        # 4010 <_IO_stdin_used+0x10>
    128c:	mov    rax,QWORD PTR [rbp-0x18]
    1290:	mov    rsi,rdx
    1293:	mov    rdi,rax
    1296:	call   1110 <fopen@plt>
    129b:	mov    QWORD PTR [rbp-0x8],rax
  if (file)
    129f:	cmp    QWORD PTR [rbp-0x8],0x0
    12a4:	je     12ec <read_file_to_memory+0x83>
  {
    byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12a6:	mov    rcx,QWORD PTR [rbp-0x8]
    12aa:	mov    rdx,QWORD PTR [rbp-0x28]
    12ae:	mov    rax,QWORD PTR [rbp-0x20]
    12b2:	mov    esi,0x1
    12b7:	mov    rdi,rax
    12ba:	call   1040 <fread@plt>
    12bf:	mov    QWORD PTR [rbp-0x10],rax
    printf("%lu read", byte_count);
    12c3:	mov    rax,QWORD PTR [rbp-0x10]
    12c7:	lea    rdx,[rip+0x2d45]        # 4013 <_IO_stdin_used+0x13>
    12ce:	mov    rsi,rax
    12d1:	mov    rdi,rdx
    12d4:	mov    eax,0x0
    12d9:	call   1070 <printf@plt>
    fclose(file);
    12de:	mov    rax,QWORD PTR [rbp-0x8]
    12e2:	mov    rdi,rax
    12e5:	call   1050 <fclose@plt>
    12ea:	jmp    131b <read_file_to_memory+0xb2>
  }
  else
  {
    LOG_ERROR("Unable to open file: %s", name);
    12ec:	mov    rcx,QWORD PTR [rbp-0x18]
    12f0:	lea    rdx,[rip+0x2d25]        # 401c <_IO_stdin_used+0x1c>
    12f7:	lea    rax,[rip+0x2d36]        # 4034 <_IO_stdin_used+0x34>
    12fe:	mov    r8,rcx
    1301:	mov    rcx,rdx
    1304:	mov    edx,0x183
    1309:	mov    rsi,rax
    130c:	mov    edi,0x1
    1311:	mov    eax,0x0
    1316:	call   14da <log_message>
  }

  return byte_count;
    131b:	mov    rax,QWORD PTR [rbp-0x10]
}
    131f:	leave
    1320:	ret

0000000000001321 <file_size>:

usize file_size(const char *name)
{
    1321:	push   rbp
    1322:	mov    rbp,rsp
    1325:	sub    rsp,0xb0
    132c:	mov    QWORD PTR [rbp-0xa8],rdi
    1333:	mov    rax,QWORD PTR fs:0x28
    133c:	mov    QWORD PTR [rbp-0x8],rax
    1340:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1342:	lea    rdx,[rbp-0xa0]
    1349:	mov    rax,QWORD PTR [rbp-0xa8]
    1350:	mov    rsi,rdx
    1353:	mov    rdi,rax
    1356:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    135b:	mov    rax,QWORD PTR [rbp-0x70]
}
    135f:	mov    rdx,QWORD PTR [rbp-0x8]
    1363:	sub    rdx,QWORD PTR fs:0x28
    136c:	je     1373 <file_size+0x52>
    136e:	call   1060 <__stack_chk_fail@plt>
    1373:	leave
    1374:	ret

0000000000001375 <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    1375:	push   rbp
    1376:	mov    rbp,rsp
    1379:	sub    rsp,0x50
    137d:	mov    QWORD PTR [rbp-0x48],rdi
    1381:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    1385:	mov    rax,QWORD PTR [rbp-0x50]
    1389:	mov    rdi,rax
    138c:	call   1321 <file_size>
    1391:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    1395:	mov    rcx,QWORD PTR [rbp-0x48]
    1399:	mov    rax,QWORD PTR [rcx]
    139c:	mov    rdx,QWORD PTR [rcx+0x8]
    13a0:	mov    QWORD PTR [rbp-0x20],rax
    13a4:	mov    QWORD PTR [rbp-0x18],rdx
    13a8:	mov    rax,QWORD PTR [rcx+0x10]
    13ac:	mov    rdx,QWORD PTR [rcx+0x18]
    13b0:	mov    QWORD PTR [rbp-0x10],rax
    13b4:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    13b8:	mov    rcx,QWORD PTR [rbp-0x40]
    13bc:	mov    rax,QWORD PTR [rbp-0x48]
    13c0:	mov    edx,0x1
    13c5:	mov    rsi,rcx
    13c8:	mov    rdi,rax
    13cb:	call   180c <arena_alloc>
    13d0:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13d4:	mov    rdx,QWORD PTR [rbp-0x40]
    13d8:	mov    rcx,QWORD PTR [rbp-0x38]
    13dc:	mov    rax,QWORD PTR [rbp-0x50]
    13e0:	mov    rsi,rcx
    13e3:	mov    rdi,rax
    13e6:	call   1269 <read_file_to_memory>
    13eb:	cmp    QWORD PTR [rbp-0x40],rax
    13ef:	je     145e <read_file_to_arena+0xe9>
  {
    printf("%lu buffer size\n", buffer_size);
    13f1:	mov    rax,QWORD PTR [rbp-0x40]
    13f5:	lea    rdx,[rip+0x2c45]        # 4041 <_IO_stdin_used+0x41>
    13fc:	mov    rsi,rax
    13ff:	mov    rdi,rdx
    1402:	mov    eax,0x0
    1407:	call   1070 <printf@plt>
    LOG_ERROR("Unable to read file: %s", name);
    140c:	mov    rcx,QWORD PTR [rbp-0x50]
    1410:	lea    rdx,[rip+0x2c3b]        # 4052 <_IO_stdin_used+0x52>
    1417:	lea    rax,[rip+0x2c16]        # 4034 <_IO_stdin_used+0x34>
    141e:	mov    r8,rcx
    1421:	mov    rcx,rdx
    1424:	mov    edx,0x1a2
    1429:	mov    rsi,rax
    142c:	mov    edi,0x1
    1431:	mov    eax,0x0
    1436:	call   14da <log_message>
    *arena = save; // Rollback allocation
    143b:	mov    rcx,QWORD PTR [rbp-0x48]
    143f:	mov    rax,QWORD PTR [rbp-0x20]
    1443:	mov    rdx,QWORD PTR [rbp-0x18]
    1447:	mov    QWORD PTR [rcx],rax
    144a:	mov    QWORD PTR [rcx+0x8],rdx
    144e:	mov    rax,QWORD PTR [rbp-0x10]
    1452:	mov    rdx,QWORD PTR [rbp-0x8]
    1456:	mov    QWORD PTR [rcx+0x10],rax
    145a:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    145e:	mov    rax,QWORD PTR [rbp-0x38]
    1462:	mov    QWORD PTR [rbp-0x30],rax
    1466:	mov    rax,QWORD PTR [rbp-0x40]
    146a:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    146e:	mov    rax,QWORD PTR [rbp-0x30]
    1472:	mov    rdx,QWORD PTR [rbp-0x28]
}
    1476:	leave
    1477:	ret

0000000000001478 <strings_equal>:

b8 strings_equal(String a, String b)
{
    1478:	push   rbp
    1479:	mov    rbp,rsp
    147c:	sub    rsp,0x20
    1480:	mov    rax,rdi
    1483:	mov    r8,rsi
    1486:	mov    rsi,rax
    1489:	mov    edi,0x0
    148e:	mov    rdi,r8
    1491:	mov    QWORD PTR [rbp-0x10],rsi
    1495:	mov    QWORD PTR [rbp-0x8],rdi
    1499:	mov    QWORD PTR [rbp-0x20],rdx
    149d:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    14a1:	mov    rdx,QWORD PTR [rbp-0x8]
    14a5:	mov    rax,QWORD PTR [rbp-0x18]
    14a9:	cmp    rdx,rax
    14ac:	jne    14d3 <strings_equal+0x5b>
    14ae:	mov    rax,QWORD PTR [rbp-0x8]
    14b2:	mov    rdx,rax
    14b5:	mov    rcx,QWORD PTR [rbp-0x20]
    14b9:	mov    rax,QWORD PTR [rbp-0x10]
    14bd:	mov    rsi,rcx
    14c0:	mov    rdi,rax
    14c3:	call   10d0 <memcmp@plt>
    14c8:	test   eax,eax
    14ca:	jne    14d3 <strings_equal+0x5b>
    14cc:	mov    eax,0x1
    14d1:	jmp    14d8 <strings_equal+0x60>
    14d3:	mov    eax,0x0
}
    14d8:	leave
    14d9:	ret

00000000000014da <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14da:	push   rbp
    14db:	mov    rbp,rsp
    14de:	sub    rsp,0x100
    14e5:	mov    DWORD PTR [rbp-0xe4],edi
    14eb:	mov    QWORD PTR [rbp-0xf0],rsi
    14f2:	mov    QWORD PTR [rbp-0xf8],rdx
    14f9:	mov    QWORD PTR [rbp-0x100],rcx
    1500:	mov    QWORD PTR [rbp-0x90],r8
    1507:	mov    QWORD PTR [rbp-0x88],r9
    150e:	test   al,al
    1510:	je     1532 <log_message+0x58>
    1512:	movaps XMMWORD PTR [rbp-0x80],xmm0
    1516:	movaps XMMWORD PTR [rbp-0x70],xmm1
    151a:	movaps XMMWORD PTR [rbp-0x60],xmm2
    151e:	movaps XMMWORD PTR [rbp-0x50],xmm3
    1522:	movaps XMMWORD PTR [rbp-0x40],xmm4
    1526:	movaps XMMWORD PTR [rbp-0x30],xmm5
    152a:	movaps XMMWORD PTR [rbp-0x20],xmm6
    152e:	movaps XMMWORD PTR [rbp-0x10],xmm7
    1532:	mov    rax,QWORD PTR fs:0x28
    153b:	mov    QWORD PTR [rbp-0xb8],rax
    1542:	xor    eax,eax
  FILE *stream = stderr;
    1544:	mov    rax,QWORD PTR [rip+0x5c35]        # 7180 <stderr@GLIBC_2.2.5>
    154b:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    1552:	cmp    DWORD PTR [rbp-0xe4],0x1
    1559:	ja     15a2 <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    155b:	mov    eax,DWORD PTR [rbp-0xe4]
    1561:	lea    rdx,[rax*8+0x0]
    1569:	lea    rax,[rip+0x5b50]        # 70c0 <level_strings>
    1570:	mov    rdx,QWORD PTR [rdx+rax*1]
    1574:	mov    rdi,QWORD PTR [rbp-0xf8]
    157b:	mov    rcx,QWORD PTR [rbp-0xf0]
    1582:	lea    rsi,[rip+0x2b08]        # 4091 <_IO_stdin_used+0x91>
    1589:	mov    rax,QWORD PTR [rbp-0xd8]
    1590:	mov    r8,rdi
    1593:	mov    rdi,rax
    1596:	mov    eax,0x0
    159b:	call   10f0 <fprintf@plt>
    15a0:	jmp    15f0 <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    15a2:	cmp    DWORD PTR [rbp-0xe4],0x3
    15a9:	jne    15b9 <log_message+0xdf>
    {
      stream = stdout;
    15ab:	mov    rax,QWORD PTR [rip+0x5bae]        # 7160 <stdout@GLIBC_2.2.5>
    15b2:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    15b9:	mov    eax,DWORD PTR [rbp-0xe4]
    15bf:	lea    rdx,[rax*8+0x0]
    15c7:	lea    rax,[rip+0x5af2]        # 70c0 <level_strings>
    15ce:	mov    rdx,QWORD PTR [rdx+rax*1]
    15d2:	lea    rcx,[rip+0x2acf]        # 40a8 <_IO_stdin_used+0xa8>
    15d9:	mov    rax,QWORD PTR [rbp-0xd8]
    15e0:	mov    rsi,rcx
    15e3:	mov    rdi,rax
    15e6:	mov    eax,0x0
    15eb:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15f0:	mov    DWORD PTR [rbp-0xd0],0x20
    15fa:	mov    DWORD PTR [rbp-0xcc],0x30
    1604:	lea    rax,[rbp+0x10]
    1608:	mov    QWORD PTR [rbp-0xc8],rax
    160f:	lea    rax,[rbp-0xb0]
    1616:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    161d:	lea    rdx,[rbp-0xd0]
    1624:	mov    rcx,QWORD PTR [rbp-0x100]
    162b:	mov    rax,QWORD PTR [rbp-0xd8]
    1632:	mov    rsi,rcx
    1635:	mov    rdi,rax
    1638:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    163d:	mov    rax,QWORD PTR [rbp-0xd8]
    1644:	mov    rsi,rax
    1647:	mov    edi,0xa
    164c:	call   10c0 <fputc@plt>
}
    1651:	nop
    1652:	mov    rax,QWORD PTR [rbp-0xb8]
    1659:	sub    rax,QWORD PTR fs:0x28
    1662:	je     1669 <log_message+0x18f>
    1664:	call   1060 <__stack_chk_fail@plt>
    1669:	leave
    166a:	ret

000000000000166b <arena_make>:

Arena arena_make(isize reserve_size)
{
    166b:	push   rbp
    166c:	mov    rbp,rsp
    166f:	sub    rsp,0x30
    1673:	mov    QWORD PTR [rbp-0x28],rdi
    1677:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    167b:	pxor   xmm0,xmm0
    167f:	movaps XMMWORD PTR [rbp-0x20],xmm0
    1683:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    1687:	mov    rax,QWORD PTR [rbp-0x30]
    168b:	mov    esi,0x1
    1690:	mov    rdi,rax
    1693:	call   10e0 <calloc@plt>
    1698:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    169c:	mov    rax,QWORD PTR [rbp-0x20]
    16a0:	test   rax,rax
    16a3:	jne    16d7 <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    16a5:	lea    rdx,[rip+0x2a0c]        # 40b8 <_IO_stdin_used+0xb8>
    16ac:	lea    rax,[rip+0x2981]        # 4034 <_IO_stdin_used+0x34>
    16b3:	mov    rcx,rdx
    16b6:	mov    edx,0x1de
    16bb:	mov    rsi,rax
    16be:	mov    edi,0x0
    16c3:	mov    eax,0x0
    16c8:	call   14da <log_message>
    16cd:	mov    edi,0xffffffff
    16d2:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    16d7:	mov    rax,QWORD PTR [rbp-0x30]
    16db:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16df:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16e7:	mov    rcx,QWORD PTR [rbp-0x28]
    16eb:	mov    rax,QWORD PTR [rbp-0x20]
    16ef:	mov    rdx,QWORD PTR [rbp-0x18]
    16f3:	mov    QWORD PTR [rcx],rax
    16f6:	mov    QWORD PTR [rcx+0x8],rdx
    16fa:	mov    rax,QWORD PTR [rbp-0x10]
    16fe:	mov    rdx,QWORD PTR [rbp-0x8]
    1702:	mov    QWORD PTR [rcx+0x10],rax
    1706:	mov    QWORD PTR [rcx+0x18],rdx
}
    170a:	mov    rax,QWORD PTR [rbp-0x28]
    170e:	leave
    170f:	ret

0000000000001710 <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    1710:	push   rbp
    1711:	mov    rbp,rsp
    1714:	sub    rsp,0x40
    1718:	mov    QWORD PTR [rbp-0x28],rdi
    171c:	mov    QWORD PTR [rbp-0x30],rsi
    1720:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    1724:	cmp    QWORD PTR [rbp-0x30],0x0
    1729:	jne    1750 <arena_make_backed+0x40>
    172b:	lea    rdx,[rip+0x307e]        # 47b0 <__PRETTY_FUNCTION__.9>
    1732:	lea    rsi,[rip+0x28fb]        # 4034 <_IO_stdin_used+0x34>
    1739:	lea    rax,[rip+0x2998]        # 40d8 <_IO_stdin_used+0xd8>
    1740:	mov    rcx,rdx
    1743:	mov    edx,0x1ea
    1748:	mov    rdi,rax
    174b:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    1750:	cmp    QWORD PTR [rbp-0x38],0x0
    1755:	jne    177c <arena_make_backed+0x6c>
    1757:	lea    rdx,[rip+0x3052]        # 47b0 <__PRETTY_FUNCTION__.9>
    175e:	lea    rsi,[rip+0x28cf]        # 4034 <_IO_stdin_used+0x34>
    1765:	lea    rax,[rip+0x29bc]        # 4128 <_IO_stdin_used+0x128>
    176c:	mov    rcx,rdx
    176f:	mov    edx,0x1eb
    1774:	mov    rdi,rax
    1777:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    177c:	pxor   xmm0,xmm0
    1780:	movaps XMMWORD PTR [rbp-0x20],xmm0
    1784:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    1788:	mov    rax,QWORD PTR [rbp-0x30]
    178c:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    1790:	mov    rax,QWORD PTR [rbp-0x38]
    1794:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    1798:	mov    eax,DWORD PTR [rbp-0x8]
    179b:	or     eax,0x1
    179e:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    17a1:	mov    rcx,QWORD PTR [rbp-0x28]
    17a5:	mov    rax,QWORD PTR [rbp-0x20]
    17a9:	mov    rdx,QWORD PTR [rbp-0x18]
    17ad:	mov    QWORD PTR [rcx],rax
    17b0:	mov    QWORD PTR [rcx+0x8],rdx
    17b4:	mov    rax,QWORD PTR [rbp-0x10]
    17b8:	mov    rdx,QWORD PTR [rbp-0x8]
    17bc:	mov    QWORD PTR [rcx+0x10],rax
    17c0:	mov    QWORD PTR [rcx+0x18],rdx
}
    17c4:	mov    rax,QWORD PTR [rbp-0x28]
    17c8:	leave
    17c9:	ret

00000000000017ca <arena_free>:

void arena_free(Arena *arena)
{
    17ca:	push   rbp
    17cb:	mov    rbp,rsp
    17ce:	sub    rsp,0x10
    17d2:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    17d6:	mov    rax,QWORD PTR [rbp-0x8]
    17da:	mov    eax,DWORD PTR [rax+0x18]
    17dd:	and    eax,0x1
    17e0:	test   eax,eax
    17e2:	jne    17f3 <arena_free+0x29>
  {
    free(arena->base);
    17e4:	mov    rax,QWORD PTR [rbp-0x8]
    17e8:	mov    rax,QWORD PTR [rax]
    17eb:	mov    rdi,rax
    17ee:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17f3:	mov    rax,QWORD PTR [rbp-0x8]
    17f7:	mov    edx,0x20
    17fc:	mov    esi,0x0
    1801:	mov    rdi,rax
    1804:	call   10a0 <memset@plt>
}
    1809:	nop
    180a:	leave
    180b:	ret

000000000000180c <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    180c:	push   rbp
    180d:	mov    rbp,rsp
    1810:	sub    rsp,0x40
    1814:	mov    QWORD PTR [rbp-0x28],rdi
    1818:	mov    QWORD PTR [rbp-0x30],rsi
    181c:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    1820:	mov    rax,QWORD PTR [rbp-0x28]
    1824:	mov    rax,QWORD PTR [rax]
    1827:	test   rax,rax
    182a:	jne    1851 <arena_alloc+0x45>
    182c:	lea    rdx,[rip+0x2f95]        # 47c8 <__PRETTY_FUNCTION__.8>
    1833:	lea    rsi,[rip+0x27fa]        # 4034 <_IO_stdin_used+0x34>
    183a:	lea    rax,[rip+0x292f]        # 4170 <_IO_stdin_used+0x170>
    1841:	mov    rcx,rdx
    1844:	mov    edx,0x203
    1849:	mov    rdi,rax
    184c:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    1851:	mov    rax,QWORD PTR [rbp-0x28]
    1855:	mov    rdx,QWORD PTR [rax+0x10]
    1859:	mov    rax,QWORD PTR [rbp-0x38]
    185d:	add    rax,rdx
    1860:	lea    rdx,[rax-0x1]
    1864:	mov    rax,QWORD PTR [rbp-0x38]
    1868:	neg    rax
    186b:	and    rax,rdx
    186e:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    1872:	mov    rdx,QWORD PTR [rbp-0x18]
    1876:	mov    rax,QWORD PTR [rbp-0x30]
    187a:	add    rdx,rax
    187d:	mov    rax,QWORD PTR [rbp-0x28]
    1881:	mov    rax,QWORD PTR [rax+0x8]
    1885:	cmp    rdx,rax
    1888:	jle    18dd <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    188a:	mov    rdx,QWORD PTR [rbp-0x18]
    188e:	mov    rax,QWORD PTR [rbp-0x30]
    1892:	add    rax,rdx
    1895:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1899:	mov    rax,QWORD PTR [rbp-0x28]
    189d:	mov    rsi,QWORD PTR [rax+0x8]
    18a1:	mov    rcx,QWORD PTR [rbp-0x8]
    18a5:	lea    rdx,[rip+0x28fc]        # 41a8 <_IO_stdin_used+0x1a8>
    18ac:	lea    rax,[rip+0x2781]        # 4034 <_IO_stdin_used+0x34>
    18b3:	mov    r9,rsi
    18b6:	mov    r8,rcx
    18b9:	mov    rcx,rdx
    18bc:	mov    edx,0x20c
    18c1:	mov    rsi,rax
    18c4:	mov    edi,0x0
    18c9:	mov    eax,0x0
    18ce:	call   14da <log_message>
    18d3:	mov    edi,0xffffffff
    18d8:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18dd:	mov    rax,QWORD PTR [rbp-0x28]
    18e1:	mov    rdx,QWORD PTR [rax]
    18e4:	mov    rax,QWORD PTR [rbp-0x18]
    18e8:	add    rax,rdx
    18eb:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18ef:	mov    rdx,QWORD PTR [rbp-0x30]
    18f3:	mov    rax,QWORD PTR [rbp-0x10]
    18f7:	mov    esi,0x0
    18fc:	mov    rdi,rax
    18ff:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    1904:	mov    rdx,QWORD PTR [rbp-0x18]
    1908:	mov    rax,QWORD PTR [rbp-0x30]
    190c:	add    rdx,rax
    190f:	mov    rax,QWORD PTR [rbp-0x28]
    1913:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    1917:	mov    rax,QWORD PTR [rbp-0x10]
}
    191b:	leave
    191c:	ret

000000000000191d <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    191d:	push   rbp
    191e:	mov    rbp,rsp
    1921:	sub    rsp,0x10
    1925:	mov    QWORD PTR [rbp-0x8],rdi
    1929:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    192d:	mov    rax,QWORD PTR [rbp-0x8]
    1931:	mov    rax,QWORD PTR [rax+0x10]
    1935:	cmp    QWORD PTR [rbp-0x10],rax
    1939:	jl     1960 <arena_pop_to+0x43>
    193b:	lea    rdx,[rip+0x2e96]        # 47d8 <__PRETTY_FUNCTION__.7>
    1942:	lea    rsi,[rip+0x26eb]        # 4034 <_IO_stdin_used+0x34>
    1949:	lea    rax,[rip+0x2898]        # 41e8 <_IO_stdin_used+0x1e8>
    1950:	mov    rcx,rdx
    1953:	mov    edx,0x21c
    1958:	mov    rdi,rax
    195b:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    1960:	mov    rax,QWORD PTR [rbp-0x8]
    1964:	mov    rdx,QWORD PTR [rbp-0x10]
    1968:	mov    QWORD PTR [rax+0x10],rdx
}
    196c:	nop
    196d:	leave
    196e:	ret

000000000000196f <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    196f:	push   rbp
    1970:	mov    rbp,rsp
    1973:	sub    rsp,0x10
    1977:	mov    QWORD PTR [rbp-0x8],rdi
    197b:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    197f:	mov    rax,QWORD PTR [rbp-0x8]
    1983:	mov    rax,QWORD PTR [rax+0x10]
    1987:	sub    rax,QWORD PTR [rbp-0x10]
    198b:	mov    rdx,rax
    198e:	mov    rax,QWORD PTR [rbp-0x8]
    1992:	mov    rsi,rdx
    1995:	mov    rdi,rax
    1998:	call   191d <arena_pop_to>
}
    199d:	nop
    199e:	leave
    199f:	ret

00000000000019a0 <arena_clear>:

void arena_clear(Arena *arena)
{
    19a0:	push   rbp
    19a1:	mov    rbp,rsp
    19a4:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    19a8:	mov    rax,QWORD PTR [rbp-0x8]
    19ac:	mov    QWORD PTR [rax+0x10],0x0
}
    19b4:	nop
    19b5:	pop    rbp
    19b6:	ret

00000000000019b7 <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    19b7:	push   rbp
    19b8:	mov    rbp,rsp
    19bb:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    19bf:	mov    rax,QWORD PTR [rbp-0x18]
    19c3:	mov    QWORD PTR [rbp-0x10],rax
    19c7:	mov    rax,QWORD PTR [rbp-0x18]
    19cb:	mov    rax,QWORD PTR [rax+0x10]
    19cf:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    19d3:	mov    rax,QWORD PTR [rbp-0x10]
    19d7:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19db:	pop    rbp
    19dc:	ret

00000000000019dd <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19dd:	push   rbp
    19de:	mov    rbp,rsp
    19e1:	sub    rsp,0x10
    19e5:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19e9:	mov    rax,QWORD PTR [rbp-0x8]
    19ed:	mov    rdx,QWORD PTR [rax+0x8]
    19f1:	mov    rax,QWORD PTR [rbp-0x8]
    19f5:	mov    rax,QWORD PTR [rax]
    19f8:	mov    rsi,rdx
    19fb:	mov    rdi,rax
    19fe:	call   191d <arena_pop_to>
  ZERO_STRUCT(scratch);
    1a03:	mov    rax,QWORD PTR [rbp-0x8]
    1a07:	mov    edx,0x10
    1a0c:	mov    esi,0x0
    1a11:	mov    rdi,rax
    1a14:	call   10a0 <memset@plt>
}
    1a19:	nop
    1a1a:	leave
    1a1b:	ret

0000000000001a1c <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    1a1c:	push   rbp
    1a1d:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    1a20:	mov    eax,0xf4240
}
    1a25:	pop    rbp
    1a26:	ret

0000000000001a27 <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    1a27:	push   rbp
    1a28:	mov    rbp,rsp
    1a2b:	sub    rsp,0x30
    1a2f:	mov    rax,QWORD PTR fs:0x28
    1a38:	mov    QWORD PTR [rbp-0x8],rax
    1a3c:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a3e:	lea    rax,[rbp-0x20]
    1a42:	mov    esi,0x0
    1a47:	mov    rdi,rax
    1a4a:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a4f:	call   1a1c <get_os_timer_freq>
    1a54:	mov    rdx,QWORD PTR [rbp-0x20]
    1a58:	imul   rax,rdx
    1a5c:	mov    rdx,QWORD PTR [rbp-0x18]
    1a60:	add    rax,rdx
    1a63:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a67:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a6b:	mov    rdx,QWORD PTR [rbp-0x8]
    1a6f:	sub    rdx,QWORD PTR fs:0x28
    1a78:	je     1a7f <read_os_timer+0x58>
    1a7a:	call   1060 <__stack_chk_fail@plt>
    1a7f:	leave
    1a80:	ret

0000000000001a81 <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a81:	push   rbp
    1a82:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a85:	rdtsc
    1a87:	shl    rdx,0x20
    1a8b:	or     rax,rdx
  return __rdtsc();
}
    1a8e:	pop    rbp
    1a8f:	ret

0000000000001a90 <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a90:	push   rbp
    1a91:	mov    rbp,rsp
    1a94:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a98:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1aa0:	call   1a1c <get_os_timer_freq>
    1aa5:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1aa9:	call   1a81 <read_cpu_timer>
    1aae:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1ab2:	call   1a27 <read_os_timer>
    1ab7:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1abb:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1ac3:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1acb:	mov    rax,QWORD PTR [rbp-0x40]
    1acf:	imul   rax,QWORD PTR [rbp-0x48]
    1ad4:	shr    rax,0x3
    1ad8:	movabs rdx,0x20c49ba5e353f7cf
    1ae2:	mul    rdx
    1ae5:	mov    rax,rdx
    1ae8:	shr    rax,0x4
    1aec:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1af0:	jmp    1b07 <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1af2:	call   1a27 <read_os_timer>
    1af7:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1afb:	mov    rax,QWORD PTR [rbp-0x28]
    1aff:	sub    rax,QWORD PTR [rbp-0x30]
    1b03:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1b07:	mov    rax,QWORD PTR [rbp-0x50]
    1b0b:	cmp    rax,QWORD PTR [rbp-0x20]
    1b0f:	jb     1af2 <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1b11:	call   1a81 <read_cpu_timer>
    1b16:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1b1a:	mov    rax,QWORD PTR [rbp-0x18]
    1b1e:	sub    rax,QWORD PTR [rbp-0x38]
    1b22:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1b26:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1b2e:	cmp    QWORD PTR [rbp-0x50],0x0
    1b33:	jne    1b5a <estimate_cpu_freq+0xca>
    1b35:	lea    rdx,[rip+0x2cb4]        # 47f0 <__PRETTY_FUNCTION__.6>
    1b3c:	lea    rsi,[rip+0x2704]        # 4247 <_IO_stdin_used+0x247>
    1b43:	lea    rax,[rip+0x2716]        # 4260 <_IO_stdin_used+0x260>
    1b4a:	mov    rcx,rdx
    1b4d:	mov    edx,0x3a
    1b52:	mov    rdi,rax
    1b55:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b5a:	mov    rax,QWORD PTR [rbp-0x40]
    1b5e:	imul   rax,QWORD PTR [rbp-0x10]
    1b63:	mov    edx,0x0
    1b68:	div    QWORD PTR [rbp-0x50]
    1b6c:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b70:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b74:	leave
    1b75:	ret

0000000000001b76 <cpu_time_in_seconds>:

static
f64 cpu_time_in_seconds(u64 cpu_time, u64 cpu_timer_frequency)
{
    1b76:	push   rbp
    1b77:	mov    rbp,rsp
    1b7a:	mov    QWORD PTR [rbp-0x18],rdi
    1b7e:	mov    QWORD PTR [rbp-0x20],rsi
  f64 result = 0.0;
    1b82:	pxor   xmm0,xmm0
    1b86:	movsd  QWORD PTR [rbp-0x8],xmm0
  if (cpu_timer_frequency)
    1b8b:	cmp    QWORD PTR [rbp-0x20],0x0
    1b90:	je     1bf5 <cpu_time_in_seconds+0x7f>
  {
    result = (f64)cpu_time / (f64)cpu_timer_frequency;
    1b92:	mov    rax,QWORD PTR [rbp-0x18]
    1b96:	test   rax,rax
    1b99:	js     1ba6 <cpu_time_in_seconds+0x30>
    1b9b:	pxor   xmm0,xmm0
    1b9f:	cvtsi2sd xmm0,rax
    1ba4:	jmp    1bbf <cpu_time_in_seconds+0x49>
    1ba6:	mov    rdx,rax
    1ba9:	shr    rdx,1
    1bac:	and    eax,0x1
    1baf:	or     rdx,rax
    1bb2:	pxor   xmm0,xmm0
    1bb6:	cvtsi2sd xmm0,rdx
    1bbb:	addsd  xmm0,xmm0
    1bbf:	mov    rax,QWORD PTR [rbp-0x20]
    1bc3:	test   rax,rax
    1bc6:	js     1bd3 <cpu_time_in_seconds+0x5d>
    1bc8:	pxor   xmm1,xmm1
    1bcc:	cvtsi2sd xmm1,rax
    1bd1:	jmp    1bec <cpu_time_in_seconds+0x76>
    1bd3:	mov    rdx,rax
    1bd6:	shr    rdx,1
    1bd9:	and    eax,0x1
    1bdc:	or     rdx,rax
    1bdf:	pxor   xmm1,xmm1
    1be3:	cvtsi2sd xmm1,rdx
    1be8:	addsd  xmm1,xmm1
    1bec:	divsd  xmm0,xmm1
    1bf0:	movsd  QWORD PTR [rbp-0x8],xmm0
  }

  return result;
    1bf5:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    1bfa:	pop    rbp
    1bfb:	ret

0000000000001bfc <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1bfc:	push   rbp
    1bfd:	mov    rbp,rsp
    1c00:	push   rbx
    1c01:	sub    rsp,0x30028
    1c08:	mov    rax,QWORD PTR fs:0x28
    1c11:	mov    QWORD PTR [rbp-0x18],rax
    1c15:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1c17:	call   1a81 <read_cpu_timer>
    1c1c:	mov    rbx,rax
  g_profiler = (Profiler)
    1c1f:	lea    rax,[rip+0x557a]        # 71a0 <g_profiler>
    1c26:	mov    edx,0x30010
    1c2b:	mov    esi,0x0
    1c30:	mov    rdi,rax
    1c33:	call   10a0 <memset@plt>
    1c38:	mov    QWORD PTR [rip+0x5561],rbx        # 71a0 <g_profiler>
  };
}
    1c3f:	nop
    1c40:	mov    rax,QWORD PTR [rbp-0x18]
    1c44:	sub    rax,QWORD PTR fs:0x28
    1c4d:	je     1c54 <begin_profiling+0x58>
    1c4f:	call   1060 <__stack_chk_fail@plt>
    1c54:	mov    rbx,QWORD PTR [rbp-0x8]
    1c58:	leave
    1c59:	ret

0000000000001c5a <end_profiling>:

static
void end_profiling()
{
    1c5a:	push   rbp
    1c5b:	mov    rbp,rsp
    1c5e:	sub    rsp,0x50
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1c62:	call   1a81 <read_cpu_timer>
    1c67:	mov    rdx,rax
    1c6a:	mov    rax,QWORD PTR [rip+0x552f]        # 71a0 <g_profiler>
    1c71:	sub    rdx,rax
    1c74:	mov    QWORD PTR [rbp-0x38],rdx

  if (total_delta)
    1c78:	cmp    QWORD PTR [rbp-0x38],0x0
    1c7d:	je     2024 <end_profiling+0x3ca>
  {
    u64 freq = estimate_cpu_freq();
    1c83:	call   1a90 <estimate_cpu_freq>
    1c88:	mov    QWORD PTR [rbp-0x30],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1c8c:	mov    rax,QWORD PTR [rbp-0x38]
    1c90:	test   rax,rax
    1c93:	js     1ca0 <end_profiling+0x46>
    1c95:	pxor   xmm0,xmm0
    1c99:	cvtsi2sd xmm0,rax
    1c9e:	jmp    1cb9 <end_profiling+0x5f>
    1ca0:	mov    rdx,rax
    1ca3:	shr    rdx,1
    1ca6:	and    eax,0x1
    1ca9:	or     rdx,rax
    1cac:	pxor   xmm0,xmm0
    1cb0:	cvtsi2sd xmm0,rdx
    1cb5:	addsd  xmm0,xmm0
    1cb9:	mov    rax,QWORD PTR [rbp-0x30]
    1cbd:	test   rax,rax
    1cc0:	js     1ccd <end_profiling+0x73>
    1cc2:	pxor   xmm1,xmm1
    1cc6:	cvtsi2sd xmm1,rax
    1ccb:	jmp    1ce6 <end_profiling+0x8c>
    1ccd:	mov    rdx,rax
    1cd0:	shr    rdx,1
    1cd3:	and    eax,0x1
    1cd6:	or     rdx,rax
    1cd9:	pxor   xmm1,xmm1
    1cdd:	cvtsi2sd xmm1,rdx
    1ce2:	addsd  xmm1,xmm1
    1ce6:	movapd xmm2,xmm0
    1cea:	divsd  xmm2,xmm1
    1cee:	movsd  xmm0,QWORD PTR [rip+0x2bb2]        # 48a8 <__PRETTY_FUNCTION__.0+0x18>
    1cf6:	mulsd  xmm2,xmm0
    1cfa:	movq   rcx,xmm2
    1cff:	mov    rdx,QWORD PTR [rbp-0x30]
    1d03:	mov    rax,QWORD PTR [rbp-0x38]
    1d07:	lea    rdi,[rip+0x25a2]        # 42b0 <_IO_stdin_used+0x2b0>
    1d0e:	movq   xmm0,rcx
    1d13:	mov    rsi,rax
    1d16:	mov    eax,0x1
    1d1b:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1d20:	pxor   xmm0,xmm0
    1d24:	movsd  QWORD PTR [rbp-0x48],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1d29:	mov    QWORD PTR [rbp-0x40],0x0
    1d31:	jmp    2016 <end_profiling+0x3bc>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1d36:	mov    rdx,QWORD PTR [rbp-0x40]
    1d3a:	mov    rax,rdx
    1d3d:	add    rax,rax
    1d40:	add    rax,rdx
    1d43:	shl    rax,0x4
    1d47:	lea    rdx,[rax+0x10]
    1d4b:	lea    rax,[rip+0x544e]        # 71a0 <g_profiler>
    1d52:	add    rax,rdx
    1d55:	mov    QWORD PTR [rbp-0x28],rax

      if (zone->elapsed_inclusive)
    1d59:	mov    rax,QWORD PTR [rbp-0x28]
    1d5d:	mov    rax,QWORD PTR [rax+0x18]
    1d61:	test   rax,rax
    1d64:	je     2011 <end_profiling+0x3b7>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1d6a:	mov    rax,QWORD PTR [rbp-0x28]
    1d6e:	mov    rax,QWORD PTR [rax+0x10]
    1d72:	test   rax,rax
    1d75:	js     1d82 <end_profiling+0x128>
    1d77:	pxor   xmm0,xmm0
    1d7b:	cvtsi2sd xmm0,rax
    1d80:	jmp    1d9b <end_profiling+0x141>
    1d82:	mov    rdx,rax
    1d85:	shr    rdx,1
    1d88:	and    eax,0x1
    1d8b:	or     rdx,rax
    1d8e:	pxor   xmm0,xmm0
    1d92:	cvtsi2sd xmm0,rdx
    1d97:	addsd  xmm0,xmm0
    1d9b:	mov    rax,QWORD PTR [rbp-0x38]
    1d9f:	test   rax,rax
    1da2:	js     1daf <end_profiling+0x155>
    1da4:	pxor   xmm1,xmm1
    1da8:	cvtsi2sd xmm1,rax
    1dad:	jmp    1dc8 <end_profiling+0x16e>
    1daf:	mov    rdx,rax
    1db2:	shr    rdx,1
    1db5:	and    eax,0x1
    1db8:	or     rdx,rax
    1dbb:	pxor   xmm1,xmm1
    1dbf:	cvtsi2sd xmm1,rdx
    1dc4:	addsd  xmm1,xmm1
    1dc8:	movapd xmm2,xmm0
    1dcc:	divsd  xmm2,xmm1
    1dd0:	movsd  xmm0,QWORD PTR [rip+0x2ad8]        # 48b0 <__PRETTY_FUNCTION__.0+0x20>
    1dd8:	mulsd  xmm0,xmm2
    1ddc:	movsd  QWORD PTR [rbp-0x20],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1de1:	mov    rax,QWORD PTR [rbp-0x28]
    1de5:	mov    rsi,QWORD PTR [rax+0x10]
    1de9:	mov    rax,QWORD PTR [rbp-0x28]
    1ded:	mov    rdx,QWORD PTR [rax+0x20]
    1df1:	mov    rax,QWORD PTR [rbp-0x28]
    1df5:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1df8:	mov    rcx,QWORD PTR [rbp-0x28]
    1dfc:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1e00:	mov    r9d,ecx
    1e03:	mov    rcx,QWORD PTR [rbp-0x20]
    1e07:	lea    rdi,[rip+0x24d2]        # 42e0 <_IO_stdin_used+0x2e0>
    1e0e:	movq   xmm0,rcx
    1e13:	mov    r8,rsi
    1e16:	mov    rcx,rdx
    1e19:	mov    rdx,rax
    1e1c:	mov    esi,r9d
    1e1f:	mov    eax,0x1
    1e24:	call   1070 <printf@plt>

        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1e29:	mov    rax,QWORD PTR [rbp-0x28]
    1e2d:	mov    rdx,QWORD PTR [rax+0x10]
    1e31:	mov    rax,QWORD PTR [rbp-0x28]
    1e35:	mov    rax,QWORD PTR [rax+0x18]
    1e39:	cmp    rdx,rax
    1e3c:	je     1ee1 <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1e42:	mov    rax,QWORD PTR [rbp-0x28]
    1e46:	mov    rax,QWORD PTR [rax+0x18]
    1e4a:	test   rax,rax
    1e4d:	js     1e5a <end_profiling+0x200>
    1e4f:	pxor   xmm0,xmm0
    1e53:	cvtsi2sd xmm0,rax
    1e58:	jmp    1e73 <end_profiling+0x219>
    1e5a:	mov    rdx,rax
    1e5d:	shr    rdx,1
    1e60:	and    eax,0x1
    1e63:	or     rdx,rax
    1e66:	pxor   xmm0,xmm0
    1e6a:	cvtsi2sd xmm0,rdx
    1e6f:	addsd  xmm0,xmm0
    1e73:	mov    rax,QWORD PTR [rbp-0x38]
    1e77:	test   rax,rax
    1e7a:	js     1e87 <end_profiling+0x22d>
    1e7c:	pxor   xmm1,xmm1
    1e80:	cvtsi2sd xmm1,rax
    1e85:	jmp    1ea0 <end_profiling+0x246>
    1e87:	mov    rdx,rax
    1e8a:	shr    rdx,1
    1e8d:	and    eax,0x1
    1e90:	or     rdx,rax
    1e93:	pxor   xmm1,xmm1
    1e97:	cvtsi2sd xmm1,rdx
    1e9c:	addsd  xmm1,xmm1
    1ea0:	movapd xmm2,xmm0
    1ea4:	divsd  xmm2,xmm1
    1ea8:	movsd  xmm0,QWORD PTR [rip+0x2a00]        # 48b0 <__PRETTY_FUNCTION__.0+0x20>
    1eb0:	mulsd  xmm0,xmm2
    1eb4:	movsd  QWORD PTR [rbp-0x18],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1eb9:	mov    rax,QWORD PTR [rbp-0x28]
    1ebd:	mov    rax,QWORD PTR [rax+0x18]
    1ec1:	mov    rdx,QWORD PTR [rbp-0x18]
    1ec5:	lea    rcx,[rip+0x246c]        # 4338 <_IO_stdin_used+0x338>
    1ecc:	movq   xmm0,rdx
    1ed1:	mov    rsi,rax
    1ed4:	mov    rdi,rcx
    1ed7:	mov    eax,0x1
    1edc:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1ee1:	movsd  xmm0,QWORD PTR [rbp-0x48]
    1ee6:	addsd  xmm0,QWORD PTR [rbp-0x20]
    1eeb:	movsd  QWORD PTR [rbp-0x48],xmm0

        if (zone->bytes_processed)
    1ef0:	mov    rax,QWORD PTR [rbp-0x28]
    1ef4:	mov    rax,QWORD PTR [rax+0x28]
    1ef8:	test   rax,rax
    1efb:	je     2011 <end_profiling+0x3b7>
        {
          f64 megabytes = (f64)zone->bytes_processed / MB(1);
    1f01:	mov    rax,QWORD PTR [rbp-0x28]
    1f05:	mov    rax,QWORD PTR [rax+0x28]
    1f09:	test   rax,rax
    1f0c:	js     1f19 <end_profiling+0x2bf>
    1f0e:	pxor   xmm0,xmm0
    1f12:	cvtsi2sd xmm0,rax
    1f17:	jmp    1f32 <end_profiling+0x2d8>
    1f19:	mov    rdx,rax
    1f1c:	shr    rdx,1
    1f1f:	and    eax,0x1
    1f22:	or     rdx,rax
    1f25:	pxor   xmm0,xmm0
    1f29:	cvtsi2sd xmm0,rdx
    1f2e:	addsd  xmm0,xmm0
    1f32:	movsd  xmm1,QWORD PTR [rip+0x297e]        # 48b8 <__PRETTY_FUNCTION__.0+0x28>
    1f3a:	divsd  xmm0,xmm1
    1f3e:	movsd  QWORD PTR [rbp-0x10],xmm0

          f64 gb_per_s = (f64)zone->bytes_processed / ((f64)zone->elapsed_inclusive / (f64)freq) / (f64)GB(1.0);
    1f43:	mov    rax,QWORD PTR [rbp-0x28]
    1f47:	mov    rax,QWORD PTR [rax+0x28]
    1f4b:	test   rax,rax
    1f4e:	js     1f5b <end_profiling+0x301>
    1f50:	pxor   xmm0,xmm0
    1f54:	cvtsi2sd xmm0,rax
    1f59:	jmp    1f74 <end_profiling+0x31a>
    1f5b:	mov    rdx,rax
    1f5e:	shr    rdx,1
    1f61:	and    eax,0x1
    1f64:	or     rdx,rax
    1f67:	pxor   xmm0,xmm0
    1f6b:	cvtsi2sd xmm0,rdx
    1f70:	addsd  xmm0,xmm0
    1f74:	mov    rax,QWORD PTR [rbp-0x28]
    1f78:	mov    rax,QWORD PTR [rax+0x18]
    1f7c:	test   rax,rax
    1f7f:	js     1f8c <end_profiling+0x332>
    1f81:	pxor   xmm1,xmm1
    1f85:	cvtsi2sd xmm1,rax
    1f8a:	jmp    1fa5 <end_profiling+0x34b>
    1f8c:	mov    rdx,rax
    1f8f:	shr    rdx,1
    1f92:	and    eax,0x1
    1f95:	or     rdx,rax
    1f98:	pxor   xmm1,xmm1
    1f9c:	cvtsi2sd xmm1,rdx
    1fa1:	addsd  xmm1,xmm1
    1fa5:	mov    rax,QWORD PTR [rbp-0x30]
    1fa9:	test   rax,rax
    1fac:	js     1fb9 <end_profiling+0x35f>
    1fae:	pxor   xmm2,xmm2
    1fb2:	cvtsi2sd xmm2,rax
    1fb7:	jmp    1fd2 <end_profiling+0x378>
    1fb9:	mov    rdx,rax
    1fbc:	shr    rdx,1
    1fbf:	and    eax,0x1
    1fc2:	or     rdx,rax
    1fc5:	pxor   xmm2,xmm2
    1fc9:	cvtsi2sd xmm2,rdx
    1fce:	addsd  xmm2,xmm2
    1fd2:	divsd  xmm1,xmm2
    1fd6:	divsd  xmm0,xmm1
    1fda:	movsd  xmm1,QWORD PTR [rip+0x28de]        # 48c0 <__PRETTY_FUNCTION__.0+0x30>
    1fe2:	divsd  xmm0,xmm1
    1fe6:	movsd  QWORD PTR [rbp-0x8],xmm0

          printf("  Megabytes Processed: %fMB @ %f GB/s\n", megabytes, gb_per_s);
    1feb:	movsd  xmm0,QWORD PTR [rbp-0x8]
    1ff0:	mov    rax,QWORD PTR [rbp-0x10]
    1ff4:	lea    rdx,[rip+0x236d]        # 4368 <_IO_stdin_used+0x368>
    1ffb:	movapd xmm1,xmm0
    1fff:	movq   xmm0,rax
    2004:	mov    rdi,rdx
    2007:	mov    eax,0x2
    200c:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    2011:	add    QWORD PTR [rbp-0x40],0x1
    2016:	cmp    QWORD PTR [rbp-0x40],0xfff
    201e:	jbe    1d36 <end_profiling+0xdc>
        }
      }
    }
  }
}
    2024:	nop
    2025:	leave
    2026:	ret

0000000000002027 <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    2027:	push   rbp
    2028:	mov    rbp,rsp
    202b:	push   rbx
    202c:	sub    rsp,0x78
    2030:	mov    QWORD PTR [rbp-0x58],rdi
    2034:	mov    rax,rsi
    2037:	mov    rsi,rdx
    203a:	mov    rax,rax
    203d:	mov    edx,0x0
    2042:	mov    rdx,rsi
    2045:	mov    QWORD PTR [rbp-0x70],rax
    2049:	mov    QWORD PTR [rbp-0x68],rdx
    204d:	mov    QWORD PTR [rbp-0x60],rcx
    2051:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    2055:	pxor   xmm0,xmm0
    2059:	movaps XMMWORD PTR [rbp-0x50],xmm0
    205d:	movaps XMMWORD PTR [rbp-0x40],xmm0
    2061:	movaps XMMWORD PTR [rbp-0x30],xmm0
    2065:	movq   QWORD PTR [rbp-0x20],xmm0
    206a:	mov    rax,QWORD PTR [rbp-0x70]
    206e:	mov    rdx,QWORD PTR [rbp-0x68]
    2072:	mov    QWORD PTR [rbp-0x50],rax
    2076:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    207a:	mov    rdx,QWORD PTR [rbp-0x60]
    207e:	mov    rax,rdx
    2081:	add    rax,rax
    2084:	add    rax,rdx
    2087:	shl    rax,0x4
    208b:	mov    rdx,rax
    208e:	lea    rax,[rip+0x5133]        # 71c8 <g_profiler+0x28>
    2095:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    2099:	mov    QWORD PTR [rbp-0x38],rax
    209d:	mov    rax,QWORD PTR [rbp-0x60]
    20a1:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    20a5:	mov    rax,QWORD PTR [rip+0x50fc]        # 71a8 <g_profiler+0x8>
  Profile_Pass pass =
    20ac:	mov    QWORD PTR [rbp-0x28],rax
    20b0:	mov    rax,QWORD PTR [rbp-0x78]
    20b4:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    20b8:	mov    rax,QWORD PTR [rbp-0x60]
    20bc:	mov    QWORD PTR [rip+0x50e5],rax        # 71a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    20c3:	call   1a81 <read_cpu_timer>
    20c8:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    20cc:	mov    rax,QWORD PTR [rbp-0x58]
    20d0:	mov    rcx,QWORD PTR [rbp-0x50]
    20d4:	mov    rbx,QWORD PTR [rbp-0x48]
    20d8:	mov    QWORD PTR [rax],rcx
    20db:	mov    QWORD PTR [rax+0x8],rbx
    20df:	mov    rcx,QWORD PTR [rbp-0x40]
    20e3:	mov    rbx,QWORD PTR [rbp-0x38]
    20e7:	mov    QWORD PTR [rax+0x10],rcx
    20eb:	mov    QWORD PTR [rax+0x18],rbx
    20ef:	mov    rcx,QWORD PTR [rbp-0x30]
    20f3:	mov    rbx,QWORD PTR [rbp-0x28]
    20f7:	mov    QWORD PTR [rax+0x20],rcx
    20fb:	mov    QWORD PTR [rax+0x28],rbx
    20ff:	mov    rdx,QWORD PTR [rbp-0x20]
    2103:	mov    QWORD PTR [rax+0x30],rdx
}
    2107:	mov    rax,QWORD PTR [rbp-0x58]
    210b:	mov    rbx,QWORD PTR [rbp-0x8]
    210f:	leave
    2110:	ret

0000000000002111 <__profile_close_pass>:

static
void __profile_close_pass(Profile_Pass pass)
{
    2111:	push   rbp
    2112:	mov    rbp,rsp
    2115:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    2119:	call   1a81 <read_cpu_timer>
    211e:	mov    rdx,rax
    2121:	mov    rax,QWORD PTR [rbp+0x20]
    2125:	sub    rdx,rax
    2128:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    212c:	mov    rax,QWORD PTR [rbp+0x38]
    2130:	mov    QWORD PTR [rip+0x5071],rax        # 71a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    2137:	mov    rdx,QWORD PTR [rbp+0x30]
    213b:	mov    rax,rdx
    213e:	add    rax,rax
    2141:	add    rax,rdx
    2144:	shl    rax,0x4
    2148:	lea    rdx,[rax+0x10]
    214c:	lea    rax,[rip+0x504d]        # 71a0 <g_profiler>
    2153:	add    rax,rdx
    2156:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    215a:	mov    rax,QWORD PTR [rbp-0x10]
    215e:	mov    rdx,QWORD PTR [rax+0x10]
    2162:	mov    rax,QWORD PTR [rbp-0x18]
    2166:	add    rdx,rax
    2169:	mov    rax,QWORD PTR [rbp-0x10]
    216d:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    2171:	mov    rax,QWORD PTR [rbp-0x10]
    2175:	mov    rax,QWORD PTR [rax+0x20]
    2179:	lea    rdx,[rax+0x1]
    217d:	mov    rax,QWORD PTR [rbp-0x10]
    2181:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    2185:	mov    rcx,QWORD PTR [rbp-0x10]
    2189:	mov    rax,QWORD PTR [rbp+0x10]
    218d:	mov    rdx,QWORD PTR [rbp+0x18]
    2191:	mov    QWORD PTR [rcx],rax
    2194:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    2198:	mov    rdx,QWORD PTR [rbp+0x28]
    219c:	mov    rax,QWORD PTR [rbp-0x18]
    21a0:	add    rdx,rax
    21a3:	mov    rax,QWORD PTR [rbp-0x10]
    21a7:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    21ab:	mov    rax,QWORD PTR [rbp-0x10]
    21af:	mov    rdx,QWORD PTR [rax+0x28]
    21b3:	mov    rax,QWORD PTR [rbp+0x40]
    21b7:	add    rdx,rax
    21ba:	mov    rax,QWORD PTR [rbp-0x10]
    21be:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    21c2:	mov    rdx,QWORD PTR [rbp+0x38]
    21c6:	mov    rax,rdx
    21c9:	add    rax,rax
    21cc:	add    rax,rdx
    21cf:	shl    rax,0x4
    21d3:	lea    rdx,[rax+0x10]
    21d7:	lea    rax,[rip+0x4fc2]        # 71a0 <g_profiler>
    21de:	add    rax,rdx
    21e1:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    21e5:	mov    rax,QWORD PTR [rbp-0x8]
    21e9:	mov    rax,QWORD PTR [rax+0x10]
    21ed:	sub    rax,QWORD PTR [rbp-0x18]
    21f1:	mov    rdx,rax
    21f4:	mov    rax,QWORD PTR [rbp-0x8]
    21f8:	mov    QWORD PTR [rax+0x10],rdx
}
    21fc:	nop
    21fd:	leave
    21fe:	ret

00000000000021ff <parser_at>:
  b32    had_error;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    21ff:	push   rbp
    2200:	mov    rbp,rsp
    2203:	sub    rsp,0x10
    2207:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    220b:	mov    rax,QWORD PTR [rbp-0x8]
    220f:	mov    rdx,QWORD PTR [rax+0x10]
    2213:	mov    rax,QWORD PTR [rbp-0x8]
    2217:	mov    rax,QWORD PTR [rax+0x8]
    221b:	cmp    rdx,rax
    221e:	jb     2245 <parser_at+0x46>
    2220:	lea    rdx,[rip+0x25e1]        # 4808 <__PRETTY_FUNCTION__.5>
    2227:	lea    rsi,[rip+0x226c]        # 449a <_IO_stdin_used+0x49a>
    222e:	lea    rax,[rip+0x227b]        # 44b0 <_IO_stdin_used+0x4b0>
    2235:	mov    rcx,rdx
    2238:	mov    edx,0x30
    223d:	mov    rdi,rax
    2240:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    2245:	mov    rax,QWORD PTR [rbp-0x8]
    2249:	mov    rdx,QWORD PTR [rax]
    224c:	mov    rax,QWORD PTR [rbp-0x8]
    2250:	mov    rax,QWORD PTR [rax+0x10]
    2254:	add    rax,rdx
}
    2257:	leave
    2258:	ret

0000000000002259 <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    2259:	push   rbp
    225a:	mov    rbp,rsp
    225d:	sub    rsp,0x10
    2261:	mov    QWORD PTR [rbp-0x8],rdi
    2265:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    2269:	mov    rax,QWORD PTR [rbp-0x8]
    226d:	mov    rdi,rax
    2270:	call   21ff <parser_at>
    2275:	mov    rdx,QWORD PTR [rbp-0x10]
    2279:	add    rax,rdx
}
    227c:	leave
    227d:	ret

000000000000227e <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    227e:	push   rbp
    227f:	mov    rbp,rsp
    2282:	mov    QWORD PTR [rbp-0x8],rdi
    2286:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    228a:	mov    rax,QWORD PTR [rbp-0x8]
    228e:	mov    rdx,QWORD PTR [rax+0x10]
    2292:	mov    rax,QWORD PTR [rbp-0x10]
    2296:	add    rdx,rax
    2299:	mov    rax,QWORD PTR [rbp-0x8]
    229d:	mov    QWORD PTR [rax+0x10],rdx
}
    22a1:	nop
    22a2:	pop    rbp
    22a3:	ret

00000000000022a4 <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    22a4:	push   rbp
    22a5:	mov    rbp,rsp
    22a8:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count && !parser->had_error;
    22ac:	mov    rax,QWORD PTR [rbp-0x8]
    22b0:	mov    rdx,QWORD PTR [rax+0x10]
    22b4:	mov    rax,QWORD PTR [rbp-0x8]
    22b8:	mov    rax,QWORD PTR [rax+0x8]
    22bc:	cmp    rdx,rax
    22bf:	jae    22d3 <parser_incomplete+0x2f>
    22c1:	mov    rax,QWORD PTR [rbp-0x8]
    22c5:	mov    eax,DWORD PTR [rax+0x18]
    22c8:	test   eax,eax
    22ca:	jne    22d3 <parser_incomplete+0x2f>
    22cc:	mov    eax,0x1
    22d1:	jmp    22d8 <parser_incomplete+0x34>
    22d3:	mov    eax,0x0
}
    22d8:	pop    rbp
    22d9:	ret

00000000000022da <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    22da:	push   rbp
    22db:	mov    rbp,rsp
    22de:	push   r12
    22e0:	push   rbx
    22e1:	sub    rsp,0x20
    22e5:	mov    QWORD PTR [rbp-0x18],rdi
    22e9:	mov    rax,rsi
    22ec:	mov    rcx,rdx
    22ef:	mov    rax,rax
    22f2:	mov    edx,0x0
    22f7:	mov    rdx,rcx
    22fa:	mov    QWORD PTR [rbp-0x30],rax
    22fe:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    2302:	mov    rax,QWORD PTR [rbp-0x28]
    2306:	mov    r12,rax
    2309:	mov    rbx,QWORD PTR [rbp-0x30]
    230d:	mov    rax,QWORD PTR [rbp-0x18]
    2311:	mov    rdi,rax
    2314:	call   21ff <parser_at>
    2319:	mov    rdx,r12
    231c:	mov    rsi,rbx
    231f:	mov    rdi,rax
    2322:	call   10d0 <memcmp@plt>
    2327:	test   eax,eax
    2329:	sete   al
}
    232c:	add    rsp,0x20
    2330:	pop    rbx
    2331:	pop    r12
    2333:	pop    rbp
    2334:	ret

0000000000002335 <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    2335:	push   rbp
    2336:	mov    rbp,rsp
    2339:	mov    eax,edi
    233b:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    233e:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    2342:	movzx  eax,BYTE PTR [rbp-0x14]
    2346:	cmp    eax,0x2e
    2349:	jg     2352 <is_numeric+0x1d>
    234b:	cmp    eax,0x2d
    234e:	jge    235a <is_numeric+0x25>
    2350:	jmp    235f <is_numeric+0x2a>
    2352:	sub    eax,0x30
    2355:	cmp    eax,0x9
    2358:	ja     235f <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    235a:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    235e:	nop
  }


  return result;
    235f:	movzx  eax,BYTE PTR [rbp-0x1]
}
    2363:	pop    rbp
    2364:	ret

0000000000002365 <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    2365:	push   rbp
    2366:	mov    rbp,rsp
    2369:	sub    rsp,0x50
    236d:	mov    QWORD PTR [rbp-0x48],rdi
    2371:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    2375:	pxor   xmm0,xmm0
    2379:	movaps XMMWORD PTR [rbp-0x20],xmm0
    237d:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    2382:	jmp    2395 <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    2384:	mov    rax,QWORD PTR [rbp-0x50]
    2388:	mov    esi,0x1
    238d:	mov    rdi,rax
    2390:	call   227e <parser_advance>
  while (parser_incomplete(parser)  &&
    2395:	mov    rax,QWORD PTR [rbp-0x50]
    2399:	mov    rdi,rax
    239c:	call   22a4 <parser_incomplete>
    23a1:	test   al,al
    23a3:	je     23f1 <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    23a5:	mov    rax,QWORD PTR [rbp-0x50]
    23a9:	mov    rdi,rax
    23ac:	call   21ff <parser_at>
    23b1:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    23b4:	cmp    al,0x20
    23b6:	je     2384 <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    23b8:	mov    rax,QWORD PTR [rbp-0x50]
    23bc:	mov    rdi,rax
    23bf:	call   21ff <parser_at>
    23c4:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    23c7:	cmp    al,0xa
    23c9:	je     2384 <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    23cb:	mov    rax,QWORD PTR [rbp-0x50]
    23cf:	mov    rdi,rax
    23d2:	call   21ff <parser_at>
    23d7:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    23da:	cmp    al,0xd
    23dc:	je     2384 <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    23de:	mov    rax,QWORD PTR [rbp-0x50]
    23e2:	mov    rdi,rax
    23e5:	call   21ff <parser_at>
    23ea:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    23ed:	cmp    al,0x9
    23ef:	je     2384 <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    23f1:	mov    rax,QWORD PTR [rbp-0x50]
    23f5:	mov    rdi,rax
    23f8:	call   22a4 <parser_incomplete>
    23fd:	test   al,al
    23ff:	je     284d <get_json_token+0x4e8>
  {
    token.value.data = parser_at(parser);
    2405:	mov    rax,QWORD PTR [rbp-0x50]
    2409:	mov    rdi,rax
    240c:	call   21ff <parser_at>
    2411:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    2415:	mov    rax,QWORD PTR [rbp-0x50]
    2419:	mov    rdi,rax
    241c:	call   21ff <parser_at>
    2421:	movzx  eax,BYTE PTR [rax]
    2424:	movzx  eax,al
    2427:	cmp    eax,0x7d
    242a:	je     2517 <get_json_token+0x1b2>
    2430:	cmp    eax,0x7d
    2433:	jg     285e <get_json_token+0x4f9>
    2439:	cmp    eax,0x7b
    243c:	je     24f2 <get_json_token+0x18d>
    2442:	cmp    eax,0x7b
    2445:	jg     285e <get_json_token+0x4f9>
    244b:	cmp    eax,0x74
    244e:	je     269a <get_json_token+0x335>
    2454:	cmp    eax,0x74
    2457:	jg     285e <get_json_token+0x4f9>
    245d:	cmp    eax,0x6e
    2460:	je     27c0 <get_json_token+0x45b>
    2466:	cmp    eax,0x6e
    2469:	jg     285e <get_json_token+0x4f9>
    246f:	cmp    eax,0x66
    2472:	je     272d <get_json_token+0x3c8>
    2478:	cmp    eax,0x66
    247b:	jg     285e <get_json_token+0x4f9>
    2481:	cmp    eax,0x5d
    2484:	je     2561 <get_json_token+0x1fc>
    248a:	cmp    eax,0x5d
    248d:	jg     285e <get_json_token+0x4f9>
    2493:	cmp    eax,0x5b
    2496:	je     253c <get_json_token+0x1d7>
    249c:	cmp    eax,0x5b
    249f:	jg     285e <get_json_token+0x4f9>
    24a5:	cmp    eax,0x3a
    24a8:	je     25ab <get_json_token+0x246>
    24ae:	cmp    eax,0x3a
    24b1:	jg     285e <get_json_token+0x4f9>
    24b7:	cmp    eax,0x39
    24ba:	jg     285e <get_json_token+0x4f9>
    24c0:	cmp    eax,0x30
    24c3:	jge    2649 <get_json_token+0x2e4>
    24c9:	cmp    eax,0x2e
    24cc:	jg     285e <get_json_token+0x4f9>
    24d2:	cmp    eax,0x2d
    24d5:	jge    2649 <get_json_token+0x2e4>
    24db:	cmp    eax,0x22
    24de:	je     25d0 <get_json_token+0x26b>
    24e4:	cmp    eax,0x2c
    24e7:	je     2586 <get_json_token+0x221>
    24ed:	jmp    285e <get_json_token+0x4f9>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    24f2:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    24f9:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2501:	mov    rax,QWORD PTR [rbp-0x50]
    2505:	mov    esi,0x1
    250a:	mov    rdi,rax
    250d:	call   227e <parser_advance>
      }
      break;
    2512:	jmp    285e <get_json_token+0x4f9>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    2517:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    251e:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2526:	mov    rax,QWORD PTR [rbp-0x50]
    252a:	mov    esi,0x1
    252f:	mov    rdi,rax
    2532:	call   227e <parser_advance>
      }
      break;
    2537:	jmp    285e <get_json_token+0x4f9>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    253c:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    2543:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    254b:	mov    rax,QWORD PTR [rbp-0x50]
    254f:	mov    esi,0x1
    2554:	mov    rdi,rax
    2557:	call   227e <parser_advance>
      }
      break;
    255c:	jmp    285e <get_json_token+0x4f9>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    2561:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    2568:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2570:	mov    rax,QWORD PTR [rbp-0x50]
    2574:	mov    esi,0x1
    2579:	mov    rdi,rax
    257c:	call   227e <parser_advance>
      }
      break;
    2581:	jmp    285e <get_json_token+0x4f9>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    2586:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    258d:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2595:	mov    rax,QWORD PTR [rbp-0x50]
    2599:	mov    esi,0x1
    259e:	mov    rdi,rax
    25a1:	call   227e <parser_advance>
      }
      break;
    25a6:	jmp    285e <get_json_token+0x4f9>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    25ab:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    25b2:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    25ba:	mov    rax,QWORD PTR [rbp-0x50]
    25be:	mov    esi,0x1
    25c3:	mov    rdi,rax
    25c6:	call   227e <parser_advance>
      }
      break;
    25cb:	jmp    285e <get_json_token+0x4f9>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    25d0:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    25d7:	mov    rax,QWORD PTR [rbp-0x50]
    25db:	mov    esi,0x1
    25e0:	mov    rdi,rax
    25e3:	call   227e <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    25e8:	mov    rax,QWORD PTR [rbp-0x50]
    25ec:	mov    rdi,rax
    25ef:	call   21ff <parser_at>
    25f4:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    25f8:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    2600:	jmp    2618 <get_json_token+0x2b3>
        {
          string_count += 1;
    2602:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    2607:	mov    rax,QWORD PTR [rbp-0x50]
    260b:	mov    esi,0x1
    2610:	mov    rdi,rax
    2613:	call   227e <parser_advance>
        while (*parser_at(parser) != '"')
    2618:	mov    rax,QWORD PTR [rbp-0x50]
    261c:	mov    rdi,rax
    261f:	call   21ff <parser_at>
    2624:	movzx  eax,BYTE PTR [rax]
    2627:	cmp    al,0x22
    2629:	jne    2602 <get_json_token+0x29d>
        }
        token.value.count = string_count;
    262b:	mov    rax,QWORD PTR [rbp-0x40]
    262f:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    2633:	mov    rax,QWORD PTR [rbp-0x50]
    2637:	mov    esi,0x1
    263c:	mov    rdi,rax
    263f:	call   227e <parser_advance>
      }
      break;
    2644:	jmp    285e <get_json_token+0x4f9>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2649:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    2650:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2658:	jmp    2670 <get_json_token+0x30b>
        {
          digit_count += 1;
    265a:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    265f:	mov    rax,QWORD PTR [rbp-0x50]
    2663:	mov    esi,0x1
    2668:	mov    rdi,rax
    266b:	call   227e <parser_advance>
        while (is_numeric(*parser_at(parser)))
    2670:	mov    rax,QWORD PTR [rbp-0x50]
    2674:	mov    rdi,rax
    2677:	call   21ff <parser_at>
    267c:	movzx  eax,BYTE PTR [rax]
    267f:	movzx  eax,al
    2682:	mov    edi,eax
    2684:	call   2335 <is_numeric>
    2689:	test   al,al
    268b:	jne    265a <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    268d:	mov    rax,QWORD PTR [rbp-0x38]
    2691:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    2695:	jmp    285e <get_json_token+0x4f9>
      case 't':
      {
        String string = String("true");
    269a:	lea    rax,[rip+0x1e5b]        # 44fc <_IO_stdin_used+0x4fc>
    26a1:	mov    QWORD PTR [rbp-0x30],rax
    26a5:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    26ad:	mov    rcx,QWORD PTR [rbp-0x30]
    26b1:	mov    rdx,QWORD PTR [rbp-0x28]
    26b5:	mov    rax,QWORD PTR [rbp-0x50]
    26b9:	mov    rsi,rcx
    26bc:	mov    rdi,rax
    26bf:	call   22da <parser_token_is_literal>
    26c4:	test   al,al
    26c6:	je     26ea <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    26c8:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    26cf:	mov    rax,QWORD PTR [rbp-0x28]
    26d3:	mov    rdx,rax
    26d6:	mov    rax,QWORD PTR [rbp-0x50]
    26da:	mov    rsi,rdx
    26dd:	mov    rdi,rax
    26e0:	call   227e <parser_advance>
    26e5:	jmp    285e <get_json_token+0x4f9>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    26ea:	mov    rax,QWORD PTR [rbp-0x50]
    26ee:	mov    rcx,QWORD PTR [rax+0x10]
    26f2:	lea    rdx,[rip+0x1e0f]        # 4508 <_IO_stdin_used+0x508>
    26f9:	lea    rax,[rip+0x1d9a]        # 449a <_IO_stdin_used+0x49a>
    2700:	mov    r8,rcx
    2703:	mov    rcx,rdx
    2706:	mov    edx,0xe0
    270b:	mov    rsi,rax
    270e:	mov    edi,0x1
    2713:	mov    eax,0x0
    2718:	call   14da <log_message>
          parser->had_error = true;
    271d:	mov    rax,QWORD PTR [rbp-0x50]
    2721:	mov    DWORD PTR [rax+0x18],0x1
        }
      }
      break;
    2728:	jmp    285e <get_json_token+0x4f9>
      case 'f':
      {
        String string = String("false");
    272d:	lea    rax,[rip+0x1e01]        # 4535 <_IO_stdin_used+0x535>
    2734:	mov    QWORD PTR [rbp-0x30],rax
    2738:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    2740:	mov    rcx,QWORD PTR [rbp-0x30]
    2744:	mov    rdx,QWORD PTR [rbp-0x28]
    2748:	mov    rax,QWORD PTR [rbp-0x50]
    274c:	mov    rsi,rcx
    274f:	mov    rdi,rax
    2752:	call   22da <parser_token_is_literal>
    2757:	test   al,al
    2759:	je     277d <get_json_token+0x418>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    275b:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    2762:	mov    rax,QWORD PTR [rbp-0x28]
    2766:	mov    rdx,rax
    2769:	mov    rax,QWORD PTR [rbp-0x50]
    276d:	mov    rsi,rdx
    2770:	mov    rdi,rax
    2773:	call   227e <parser_advance>
    2778:	jmp    285e <get_json_token+0x4f9>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    277d:	mov    rax,QWORD PTR [rbp-0x50]
    2781:	mov    rcx,QWORD PTR [rax+0x10]
    2785:	lea    rdx,[rip+0x1d7c]        # 4508 <_IO_stdin_used+0x508>
    278c:	lea    rax,[rip+0x1d07]        # 449a <_IO_stdin_used+0x49a>
    2793:	mov    r8,rcx
    2796:	mov    rcx,rdx
    2799:	mov    edx,0xf0
    279e:	mov    rsi,rax
    27a1:	mov    edi,0x1
    27a6:	mov    eax,0x0
    27ab:	call   14da <log_message>
          parser->had_error = true;
    27b0:	mov    rax,QWORD PTR [rbp-0x50]
    27b4:	mov    DWORD PTR [rax+0x18],0x1
        }
      }
      break;
    27bb:	jmp    285e <get_json_token+0x4f9>
      case 'n':
      {
        String string = String("null");
    27c0:	lea    rax,[rip+0x1d74]        # 453b <_IO_stdin_used+0x53b>
    27c7:	mov    QWORD PTR [rbp-0x30],rax
    27cb:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    27d3:	mov    rcx,QWORD PTR [rbp-0x30]
    27d7:	mov    rdx,QWORD PTR [rbp-0x28]
    27db:	mov    rax,QWORD PTR [rbp-0x50]
    27df:	mov    rsi,rcx
    27e2:	mov    rdi,rax
    27e5:	call   22da <parser_token_is_literal>
    27ea:	test   al,al
    27ec:	je     280d <get_json_token+0x4a8>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    27ee:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    27f5:	mov    rax,QWORD PTR [rbp-0x28]
    27f9:	mov    rdx,rax
    27fc:	mov    rax,QWORD PTR [rbp-0x50]
    2800:	mov    rsi,rdx
    2803:	mov    rdi,rax
    2806:	call   227e <parser_advance>
    280b:	jmp    285e <get_json_token+0x4f9>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    280d:	mov    rax,QWORD PTR [rbp-0x50]
    2811:	mov    rcx,QWORD PTR [rax+0x10]
    2815:	lea    rdx,[rip+0x1cec]        # 4508 <_IO_stdin_used+0x508>
    281c:	lea    rax,[rip+0x1c77]        # 449a <_IO_stdin_used+0x49a>
    2823:	mov    r8,rcx
    2826:	mov    rcx,rdx
    2829:	mov    edx,0x100
    282e:	mov    rsi,rax
    2831:	mov    edi,0x1
    2836:	mov    eax,0x0
    283b:	call   14da <log_message>
          parser->had_error = true;
    2840:	mov    rax,QWORD PTR [rbp-0x50]
    2844:	mov    DWORD PTR [rax+0x18],0x1
        }
      }
      break;
    284b:	jmp    285e <get_json_token+0x4f9>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    284d:	mov    rax,QWORD PTR [rbp-0x50]
    2851:	mov    esi,0x1
    2856:	mov    rdi,rax
    2859:	call   227e <parser_advance>
  }

  return token;
    285e:	mov    rcx,QWORD PTR [rbp-0x48]
    2862:	mov    rax,QWORD PTR [rbp-0x20]
    2866:	mov    rdx,QWORD PTR [rbp-0x18]
    286a:	mov    QWORD PTR [rcx],rax
    286d:	mov    QWORD PTR [rcx+0x8],rdx
    2871:	mov    rax,QWORD PTR [rbp-0x10]
    2875:	mov    QWORD PTR [rcx+0x10],rax
}
    2879:	mov    rax,QWORD PTR [rbp-0x48]
    287d:	leave
    287e:	ret

000000000000287f <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    287f:	push   rbp
    2880:	mov    rbp,rsp
    2883:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    2886:	cmp    DWORD PTR [rbp-0x14],0x7
    288a:	je     28a4 <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    288c:	cmp    DWORD PTR [rbp-0x14],0x9
    2890:	je     28a4 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    2892:	cmp    DWORD PTR [rbp-0x14],0xa
    2896:	je     28a4 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    2898:	cmp    DWORD PTR [rbp-0x14],0xb
    289c:	je     28a4 <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    289e:	cmp    DWORD PTR [rbp-0x14],0x8
    28a2:	jne    28ab <json_token_type_is_value_type+0x2c>
    28a4:	mov    eax,0x1
    28a9:	jmp    28b0 <json_token_type_is_value_type+0x31>
    28ab:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    28b0:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    28b3:	mov    eax,DWORD PTR [rbp-0x4]
}
    28b6:	pop    rbp
    28b7:	ret

00000000000028b8 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    28b8:	push   rbp
    28b9:	mov    rbp,rsp
    28bc:	push   rbx
    28bd:	sub    rsp,0x88
    28c4:	mov    QWORD PTR [rbp-0x78],rdi
    28c8:	mov    QWORD PTR [rbp-0x80],rsi
    28cc:	mov    QWORD PTR [rbp-0x90],rdx
    28d3:	mov    QWORD PTR [rbp-0x88],rcx
    28da:	mov    rax,QWORD PTR fs:0x28
    28e3:	mov    QWORD PTR [rbp-0x18],rax
    28e7:	xor    eax,eax
  profile_begin_func();
    28e9:	lea    r8,[rip+0x1f30]        # 4820 <__func__.4>
    28f0:	mov    r9d,0x11
    28f6:	lea    rax,[rbp-0x50]
    28fa:	mov    rsi,r8
    28fd:	mov    rdx,r9
    2900:	mov    r8d,0x0
    2906:	mov    ecx,0x1
    290b:	mov    rdi,rax
    290e:	call   2027 <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    2913:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    291b:	mov    eax,DWORD PTR [rbp+0x10]
    291e:	cmp    eax,0x1
    2921:	jne    294d <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    2923:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    292a:	mov    edx,DWORD PTR [rbp-0x64]
    292d:	mov    rsi,QWORD PTR [rbp-0x80]
    2931:	mov    rax,QWORD PTR [rbp-0x78]
    2935:	mov    ecx,edx
    2937:	mov    edx,0x2
    293c:	mov    rdi,rax
    293f:	call   2aaa <parse_json_children>
    2944:	mov    QWORD PTR [rbp-0x60],rax
    2948:	jmp    29e2 <parse_json_object+0x12a>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    294d:	mov    eax,DWORD PTR [rbp+0x10]
    2950:	cmp    eax,0x3
    2953:	jne    297c <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    2955:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    295c:	mov    edx,DWORD PTR [rbp-0x68]
    295f:	mov    rsi,QWORD PTR [rbp-0x80]
    2963:	mov    rax,QWORD PTR [rbp-0x78]
    2967:	mov    ecx,edx
    2969:	mov    edx,0x4
    296e:	mov    rdi,rax
    2971:	call   2aaa <parse_json_children>
    2976:	mov    QWORD PTR [rbp-0x60],rax
    297a:	jmp    29e2 <parse_json_object+0x12a>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    297c:	mov    eax,DWORD PTR [rbp+0x10]
    297f:	mov    edi,eax
    2981:	call   287f <json_token_type_is_value_type>
    2986:	test   eax,eax
    2988:	jne    29e2 <parse_json_object+0x12a>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    298a:	mov    eax,DWORD PTR [rbp+0x10]
    298d:	mov    eax,eax
    298f:	lea    rdx,[rax*8+0x0]
    2997:	lea    rax,[rip+0x4742]        # 70e0 <JSON_Token_Type_strings>
    299e:	mov    rcx,QWORD PTR [rdx+rax*1]
    29a2:	lea    rdx,[rip+0x1b97]        # 4540 <_IO_stdin_used+0x540>
    29a9:	lea    rax,[rip+0x1aea]        # 449a <_IO_stdin_used+0x49a>
    29b0:	push   QWORD PTR [rbp+0x20]
    29b3:	push   QWORD PTR [rbp+0x18]
    29b6:	mov    r8,rcx
    29b9:	mov    rcx,rdx
    29bc:	mov    edx,0x138
    29c1:	mov    rsi,rax
    29c4:	mov    edi,0x1
    29c9:	mov    eax,0x0
    29ce:	call   14da <log_message>
    29d3:	add    rsp,0x10
          parser->had_error = true;
    29d7:	mov    rax,QWORD PTR [rbp-0x80]
    29db:	mov    DWORD PTR [rax+0x18],0x1
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    29e2:	mov    rax,QWORD PTR [rbp-0x78]
    29e6:	mov    edx,0x8
    29eb:	mov    esi,0x30
    29f0:	mov    rdi,rax
    29f3:	call   180c <arena_alloc>
    29f8:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    29fc:	mov    rcx,QWORD PTR [rbp-0x58]
    2a00:	mov    rax,QWORD PTR [rbp-0x90]
    2a07:	mov    rdx,QWORD PTR [rbp-0x88]
    2a0e:	mov    QWORD PTR [rcx],rax
    2a11:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    2a15:	mov    rax,QWORD PTR [rbp-0x58]
    2a19:	mov    rdx,QWORD PTR [rbp-0x60]
    2a1d:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    2a21:	mov    rax,QWORD PTR [rbp-0x58]
    2a25:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    2a2d:	mov    rcx,QWORD PTR [rbp-0x58]
    2a31:	mov    rax,QWORD PTR [rbp+0x18]
    2a35:	mov    rdx,QWORD PTR [rbp+0x20]
    2a39:	mov    QWORD PTR [rcx+0x10],rax
    2a3d:	mov    QWORD PTR [rcx+0x18],rdx

  profile_close_func();
    2a41:	sub    rsp,0x8
    2a45:	sub    rsp,0x38
    2a49:	mov    rax,rsp
    2a4c:	mov    rcx,QWORD PTR [rbp-0x50]
    2a50:	mov    rbx,QWORD PTR [rbp-0x48]
    2a54:	mov    QWORD PTR [rax],rcx
    2a57:	mov    QWORD PTR [rax+0x8],rbx
    2a5b:	mov    rcx,QWORD PTR [rbp-0x40]
    2a5f:	mov    rbx,QWORD PTR [rbp-0x38]
    2a63:	mov    QWORD PTR [rax+0x10],rcx
    2a67:	mov    QWORD PTR [rax+0x18],rbx
    2a6b:	mov    rcx,QWORD PTR [rbp-0x30]
    2a6f:	mov    rbx,QWORD PTR [rbp-0x28]
    2a73:	mov    QWORD PTR [rax+0x20],rcx
    2a77:	mov    QWORD PTR [rax+0x28],rbx
    2a7b:	mov    rdx,QWORD PTR [rbp-0x20]
    2a7f:	mov    QWORD PTR [rax+0x30],rdx
    2a83:	call   2111 <__profile_close_pass>
    2a88:	add    rsp,0x40

  return result;
    2a8c:	mov    rax,QWORD PTR [rbp-0x58]
}
    2a90:	mov    rdx,QWORD PTR [rbp-0x18]
    2a94:	sub    rdx,QWORD PTR fs:0x28
    2a9d:	je     2aa4 <parse_json_object+0x1ec>
    2a9f:	call   1060 <__stack_chk_fail@plt>
    2aa4:	mov    rbx,QWORD PTR [rbp-0x8]
    2aa8:	leave
    2aa9:	ret

0000000000002aaa <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    2aaa:	push   rbp
    2aab:	mov    rbp,rsp
    2aae:	push   rbx
    2aaf:	sub    rsp,0x108
    2ab6:	mov    QWORD PTR [rbp-0xd8],rdi
    2abd:	mov    QWORD PTR [rbp-0xe0],rsi
    2ac4:	mov    DWORD PTR [rbp-0xe4],edx
    2aca:	mov    DWORD PTR [rbp-0xe8],ecx
    2ad0:	mov    rax,QWORD PTR fs:0x28
    2ad9:	mov    QWORD PTR [rbp-0x18],rax
    2add:	xor    eax,eax
  profile_begin_func();
    2adf:	lea    r8,[rip+0x1d5a]        # 4840 <__func__.3>
    2ae6:	mov    r9d,0x13
    2aec:	lea    rax,[rbp-0x50]
    2af0:	mov    rsi,r8
    2af3:	mov    rdx,r9
    2af6:	mov    r8d,0x0
    2afc:	mov    ecx,0x2
    2b01:	mov    rdi,rax
    2b04:	call   2027 <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2b09:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    2b14:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2b1f:	jmp    2e26 <parse_json_children+0x37c>
  {
    JSON_Token key_token = {0};
    2b24:	pxor   xmm0,xmm0
    2b28:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2b2f:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2b37:	pxor   xmm0,xmm0
    2b3b:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2b42:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2b47:	cmp    DWORD PTR [rbp-0xe8],0x0
    2b4e:	je     2c7b <parse_json_children+0x1d1>
    {
      key_token = get_json_token(parser);
    2b54:	lea    rax,[rbp-0xb0]
    2b5b:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b62:	mov    rsi,rdx
    2b65:	mov    rdi,rax
    2b68:	call   2365 <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2b6d:	mov    eax,DWORD PTR [rbp-0xb0]
    2b73:	cmp    eax,0x7
    2b76:	jne    2c09 <parse_json_children+0x15f>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2b7c:	lea    rax,[rbp-0x70]
    2b80:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b87:	mov    rsi,rdx
    2b8a:	mov    rdi,rax
    2b8d:	call   2365 <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2b92:	mov    eax,DWORD PTR [rbp-0x70]
    2b95:	cmp    eax,0x6
    2b98:	jne    2bb8 <parse_json_children+0x10e>
        {
          value_token = get_json_token(parser);
    2b9a:	lea    rax,[rbp-0x90]
    2ba1:	mov    rdx,QWORD PTR [rbp-0xe0]
    2ba8:	mov    rsi,rdx
    2bab:	mov    rdi,rax
    2bae:	call   2365 <get_json_token>
    2bb3:	jmp    2cbb <parse_json_children+0x211>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2bb8:	mov    rcx,QWORD PTR [rbp-0xa8]
    2bbf:	mov    rax,QWORD PTR [rbp-0xa0]
    2bc6:	mov    esi,eax
    2bc8:	lea    rdx,[rip+0x19c1]        # 4590 <_IO_stdin_used+0x590>
    2bcf:	lea    rax,[rip+0x18c4]        # 449a <_IO_stdin_used+0x49a>
    2bd6:	mov    r9,rcx
    2bd9:	mov    r8d,esi
    2bdc:	mov    rcx,rdx
    2bdf:	mov    edx,0x164
    2be4:	mov    rsi,rax
    2be7:	mov    edi,0x1
    2bec:	mov    eax,0x0
    2bf1:	call   14da <log_message>
          parser->had_error = true;
    2bf6:	mov    rax,QWORD PTR [rbp-0xe0]
    2bfd:	mov    DWORD PTR [rax+0x18],0x1
    2c04:	jmp    2cbb <parse_json_children+0x211>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2c09:	mov    rcx,QWORD PTR [rbp-0xa8]
    2c10:	mov    rax,QWORD PTR [rbp-0xa0]
    2c17:	mov    edi,eax
    2c19:	mov    eax,DWORD PTR [rbp-0xb0]
    2c1f:	mov    eax,eax
    2c21:	lea    rdx,[rax*8+0x0]
    2c29:	lea    rax,[rip+0x44b0]        # 70e0 <JSON_Token_Type_strings>
    2c30:	mov    rsi,QWORD PTR [rdx+rax*1]
    2c34:	lea    rdx,[rip+0x1975]        # 45b0 <_IO_stdin_used+0x5b0>
    2c3b:	lea    rax,[rip+0x1858]        # 449a <_IO_stdin_used+0x49a>
    2c42:	sub    rsp,0x8
    2c46:	push   rcx
    2c47:	mov    r9d,edi
    2c4a:	mov    r8,rsi
    2c4d:	mov    rcx,rdx
    2c50:	mov    edx,0x16a
    2c55:	mov    rsi,rax
    2c58:	mov    edi,0x1
    2c5d:	mov    eax,0x0
    2c62:	call   14da <log_message>
    2c67:	add    rsp,0x10
        parser->had_error = true;
    2c6b:	mov    rax,QWORD PTR [rbp-0xe0]
    2c72:	mov    DWORD PTR [rax+0x18],0x1
    2c79:	jmp    2cbb <parse_json_children+0x211>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2c7b:	lea    rax,[rbp-0x110]
    2c82:	mov    rdx,QWORD PTR [rbp-0xe0]
    2c89:	mov    rsi,rdx
    2c8c:	mov    rdi,rax
    2c8f:	call   2365 <get_json_token>
    2c94:	mov    rax,QWORD PTR [rbp-0x110]
    2c9b:	mov    rdx,QWORD PTR [rbp-0x108]
    2ca2:	mov    QWORD PTR [rbp-0x90],rax
    2ca9:	mov    QWORD PTR [rbp-0x88],rdx
    2cb0:	mov    rax,QWORD PTR [rbp-0x100]
    2cb7:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2cbb:	mov    eax,DWORD PTR [rbp-0x90]
    2cc1:	cmp    DWORD PTR [rbp-0xe4],eax
    2cc7:	je     2e3f <parse_json_children+0x395>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2ccd:	mov    rax,QWORD PTR [rbp-0xa8]
    2cd4:	mov    rdx,QWORD PTR [rbp-0xa0]
    2cdb:	mov    r8,QWORD PTR [rbp-0xe0]
    2ce2:	mov    rdi,QWORD PTR [rbp-0xd8]
    2ce9:	sub    rsp,0x8
    2ced:	sub    rsp,0x18
    2cf1:	mov    rsi,rsp
    2cf4:	mov    rcx,QWORD PTR [rbp-0x90]
    2cfb:	mov    rbx,QWORD PTR [rbp-0x88]
    2d02:	mov    QWORD PTR [rsi],rcx
    2d05:	mov    QWORD PTR [rsi+0x8],rbx
    2d09:	mov    rcx,QWORD PTR [rbp-0x80]
    2d0d:	mov    QWORD PTR [rsi+0x10],rcx
    2d11:	mov    rcx,rdx
    2d14:	mov    rdx,rax
    2d17:	mov    rsi,r8
    2d1a:	call   28b8 <parse_json_object>
    2d1f:	add    rsp,0x20
    2d23:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2d2a:	cmp    QWORD PTR [rbp-0xb8],0x0
    2d32:	je     2d7c <parse_json_children+0x2d2>
    {
      // Create links
      if (!first_child)
    2d34:	cmp    QWORD PTR [rbp-0xc8],0x0
    2d3c:	jne    2d5c <parse_json_children+0x2b2>
      {
        first_child        = object;
    2d3e:	mov    rax,QWORD PTR [rbp-0xb8]
    2d45:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2d4c:	mov    rax,QWORD PTR [rbp-0xb8]
    2d53:	mov    QWORD PTR [rbp-0xc0],rax
    2d5a:	jmp    2d7c <parse_json_children+0x2d2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2d5c:	mov    rax,QWORD PTR [rbp-0xc0]
    2d63:	mov    rdx,QWORD PTR [rbp-0xb8]
    2d6a:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2d6e:	mov    rax,QWORD PTR [rbp-0xb8]
    2d75:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2d7c:	lea    rax,[rbp-0x70]
    2d80:	mov    rdx,QWORD PTR [rbp-0xe0]
    2d87:	mov    rsi,rdx
    2d8a:	mov    rdi,rax
    2d8d:	call   2365 <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2d92:	mov    eax,DWORD PTR [rbp-0x70]
    2d95:	cmp    DWORD PTR [rbp-0xe4],eax
    2d9b:	je     2e42 <parse_json_children+0x398>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2da1:	mov    eax,DWORD PTR [rbp-0x70]
    2da4:	cmp    eax,0x5
    2da7:	je     2e26 <parse_json_children+0x37c>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2da9:	mov    r8,QWORD PTR [rbp-0x68]
    2dad:	mov    rax,QWORD PTR [rbp-0x60]
    2db1:	mov    r9d,eax
    2db4:	mov    eax,DWORD PTR [rbp-0x70]
    2db7:	mov    eax,eax
    2db9:	lea    rdx,[rax*8+0x0]
    2dc1:	lea    rax,[rip+0x4318]        # 70e0 <JSON_Token_Type_strings>
    2dc8:	mov    r10,QWORD PTR [rdx+rax*1]
    2dcc:	lea    rdi,[rip+0x1805]        # 45d8 <_IO_stdin_used+0x5d8>
    2dd3:	lea    rsi,[rip+0x16c0]        # 449a <_IO_stdin_used+0x49a>
    2dda:	sub    rsp,0x18
    2dde:	mov    rcx,rsp
    2de1:	mov    rax,QWORD PTR [rbp-0x70]
    2de5:	mov    rdx,QWORD PTR [rbp-0x68]
    2de9:	mov    QWORD PTR [rcx],rax
    2dec:	mov    QWORD PTR [rcx+0x8],rdx
    2df0:	mov    rax,QWORD PTR [rbp-0x60]
    2df4:	mov    QWORD PTR [rcx+0x10],rax
    2df8:	push   r8
    2dfa:	mov    r8,r10
    2dfd:	mov    rcx,rdi
    2e00:	mov    edx,0x192
    2e05:	mov    edi,0x1
    2e0a:	mov    eax,0x0
    2e0f:	call   14da <log_message>
    2e14:	add    rsp,0x20
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
        parser->had_error = true;
    2e18:	mov    rax,QWORD PTR [rbp-0xe0]
    2e1f:	mov    DWORD PTR [rax+0x18],0x1
  while (parser_incomplete(parser))
    2e26:	mov    rax,QWORD PTR [rbp-0xe0]
    2e2d:	mov    rdi,rax
    2e30:	call   22a4 <parser_incomplete>
    2e35:	test   al,al
    2e37:	jne    2b24 <parse_json_children+0x7a>
    2e3d:	jmp    2e43 <parse_json_children+0x399>
      break;
    2e3f:	nop
    2e40:	jmp    2e43 <parse_json_children+0x399>
      break;
    2e42:	nop
    }
  }

  profile_close_func();
    2e43:	sub    rsp,0x8
    2e47:	sub    rsp,0x38
    2e4b:	mov    rax,rsp
    2e4e:	mov    rcx,QWORD PTR [rbp-0x50]
    2e52:	mov    rbx,QWORD PTR [rbp-0x48]
    2e56:	mov    QWORD PTR [rax],rcx
    2e59:	mov    QWORD PTR [rax+0x8],rbx
    2e5d:	mov    rcx,QWORD PTR [rbp-0x40]
    2e61:	mov    rbx,QWORD PTR [rbp-0x38]
    2e65:	mov    QWORD PTR [rax+0x10],rcx
    2e69:	mov    QWORD PTR [rax+0x18],rbx
    2e6d:	mov    rcx,QWORD PTR [rbp-0x30]
    2e71:	mov    rbx,QWORD PTR [rbp-0x28]
    2e75:	mov    QWORD PTR [rax+0x20],rcx
    2e79:	mov    QWORD PTR [rax+0x28],rbx
    2e7d:	mov    rdx,QWORD PTR [rbp-0x20]
    2e81:	mov    QWORD PTR [rax+0x30],rdx
    2e85:	call   2111 <__profile_close_pass>
    2e8a:	add    rsp,0x40

  return first_child;
    2e8e:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2e95:	mov    rdx,QWORD PTR [rbp-0x18]
    2e99:	sub    rdx,QWORD PTR fs:0x28
    2ea2:	je     2ea9 <parse_json_children+0x3ff>
    2ea4:	call   1060 <__stack_chk_fail@plt>
    2ea9:	mov    rbx,QWORD PTR [rbp-0x8]
    2ead:	leave
    2eae:	ret

0000000000002eaf <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2eaf:	push   rbp
    2eb0:	mov    rbp,rsp
    2eb3:	push   rbx
    2eb4:	sub    rsp,0xb8
    2ebb:	mov    QWORD PTR [rbp-0xa8],rdi
    2ec2:	mov    rax,rsi
    2ec5:	mov    rsi,rdx
    2ec8:	mov    rax,rax
    2ecb:	mov    edx,0x0
    2ed0:	mov    rdx,rsi
    2ed3:	mov    QWORD PTR [rbp-0xc0],rax
    2eda:	mov    QWORD PTR [rbp-0xb8],rdx
    2ee1:	mov    rax,QWORD PTR fs:0x28
    2eea:	mov    QWORD PTR [rbp-0x18],rax
    2eee:	xor    eax,eax
  profile_begin_func();
    2ef0:	lea    rcx,[rip+0x1961]        # 4858 <__func__.2>
    2ef7:	mov    ebx,0xa
    2efc:	lea    rax,[rbp-0x50]
    2f00:	mov    rsi,rcx
    2f03:	mov    rdx,rbx
    2f06:	mov    r8d,0x0
    2f0c:	mov    ecx,0x3
    2f11:	mov    rdi,rax
    2f14:	call   2027 <__profile_begin_pass>

  JSON_Parser parser =
    2f19:	pxor   xmm0,xmm0
    2f1d:	movaps XMMWORD PTR [rbp-0x70],xmm0
    2f21:	movaps XMMWORD PTR [rbp-0x60],xmm0
    2f25:	mov    rax,QWORD PTR [rbp-0xc0]
    2f2c:	mov    rdx,QWORD PTR [rbp-0xb8]
    2f33:	mov    QWORD PTR [rbp-0x70],rax
    2f37:	mov    QWORD PTR [rbp-0x68],rdx
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2f3b:	lea    rax,[rbp-0x90]
    2f42:	lea    rdx,[rbp-0x70]
    2f46:	mov    rsi,rdx
    2f49:	mov    rdi,rax
    2f4c:	call   2365 <get_json_token>
    2f51:	mov    ecx,0x0
    2f56:	mov    ebx,0x0
    2f5b:	lea    r8,[rbp-0x70]
    2f5f:	mov    rdi,QWORD PTR [rbp-0xa8]
    2f66:	sub    rsp,0x8
    2f6a:	sub    rsp,0x18
    2f6e:	mov    rsi,rsp
    2f71:	mov    rax,QWORD PTR [rbp-0x90]
    2f78:	mov    rdx,QWORD PTR [rbp-0x88]
    2f7f:	mov    QWORD PTR [rsi],rax
    2f82:	mov    QWORD PTR [rsi+0x8],rdx
    2f86:	mov    rax,QWORD PTR [rbp-0x80]
    2f8a:	mov    QWORD PTR [rsi+0x10],rax
    2f8e:	mov    rdx,rcx
    2f91:	mov    rcx,rbx
    2f94:	mov    rsi,r8
    2f97:	call   28b8 <parse_json_object>
    2f9c:	add    rsp,0x20
    2fa0:	mov    QWORD PTR [rbp-0x98],rax

  profile_close_func();
    2fa7:	sub    rsp,0x8
    2fab:	sub    rsp,0x38
    2faf:	mov    rax,rsp
    2fb2:	mov    rcx,QWORD PTR [rbp-0x50]
    2fb6:	mov    rbx,QWORD PTR [rbp-0x48]
    2fba:	mov    QWORD PTR [rax],rcx
    2fbd:	mov    QWORD PTR [rax+0x8],rbx
    2fc1:	mov    rcx,QWORD PTR [rbp-0x40]
    2fc5:	mov    rbx,QWORD PTR [rbp-0x38]
    2fc9:	mov    QWORD PTR [rax+0x10],rcx
    2fcd:	mov    QWORD PTR [rax+0x18],rbx
    2fd1:	mov    rcx,QWORD PTR [rbp-0x30]
    2fd5:	mov    rbx,QWORD PTR [rbp-0x28]
    2fd9:	mov    QWORD PTR [rax+0x20],rcx
    2fdd:	mov    QWORD PTR [rax+0x28],rbx
    2fe1:	mov    rdx,QWORD PTR [rbp-0x20]
    2fe5:	mov    QWORD PTR [rax+0x30],rdx
    2fe9:	call   2111 <__profile_close_pass>
    2fee:	add    rsp,0x40

  return outer;
    2ff2:	mov    rax,QWORD PTR [rbp-0x98]
}
    2ff9:	mov    rdx,QWORD PTR [rbp-0x18]
    2ffd:	sub    rdx,QWORD PTR fs:0x28
    3006:	je     300d <parse_json+0x15e>
    3008:	call   1060 <__stack_chk_fail@plt>
    300d:	mov    rbx,QWORD PTR [rbp-0x8]
    3011:	leave
    3012:	ret

0000000000003013 <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    3013:	push   rbp
    3014:	mov    rbp,rsp
    3017:	push   rbx
    3018:	sub    rsp,0x78
    301c:	mov    QWORD PTR [rbp-0x68],rdi
    3020:	mov    rax,rsi
    3023:	mov    rsi,rdx
    3026:	mov    rax,rax
    3029:	mov    edx,0x0
    302e:	mov    rdx,rsi
    3031:	mov    QWORD PTR [rbp-0x80],rax
    3035:	mov    QWORD PTR [rbp-0x78],rdx
    3039:	mov    rax,QWORD PTR fs:0x28
    3042:	mov    QWORD PTR [rbp-0x18],rax
    3046:	xor    eax,eax
  profile_begin_func();
    3048:	lea    rcx,[rip+0x1821]        # 4870 <__func__.1>
    304f:	mov    ebx,0x12
    3054:	lea    rax,[rbp-0x50]
    3058:	mov    rsi,rcx
    305b:	mov    rdx,rbx
    305e:	mov    r8d,0x0
    3064:	mov    ecx,0x4
    3069:	mov    rdi,rax
    306c:	call   2027 <__profile_begin_pass>

  JSON_Object *result = NULL;
    3071:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    3079:	cmp    QWORD PTR [rbp-0x68],0x0
    307e:	je     30cd <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    3080:	mov    rax,QWORD PTR [rbp-0x68]
    3084:	mov    rax,QWORD PTR [rax+0x20]
    3088:	mov    QWORD PTR [rbp-0x58],rax
    308c:	jmp    30c6 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    308e:	mov    rax,QWORD PTR [rbp-0x58]
    3092:	mov    rdx,QWORD PTR [rax+0x8]
    3096:	mov    rax,QWORD PTR [rax]
    3099:	mov    rdi,QWORD PTR [rbp-0x80]
    309d:	mov    rsi,QWORD PTR [rbp-0x78]
    30a1:	mov    rcx,rdx
    30a4:	mov    rdx,rax
    30a7:	call   1478 <strings_equal>
    30ac:	test   al,al
    30ae:	je     30ba <lookup_json_object+0xa7>
      {
        result = cursor;
    30b0:	mov    rax,QWORD PTR [rbp-0x58]
    30b4:	mov    QWORD PTR [rbp-0x60],rax
        break;
    30b8:	jmp    30cd <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    30ba:	mov    rax,QWORD PTR [rbp-0x58]
    30be:	mov    rax,QWORD PTR [rax+0x28]
    30c2:	mov    QWORD PTR [rbp-0x58],rax
    30c6:	cmp    QWORD PTR [rbp-0x58],0x0
    30cb:	jne    308e <lookup_json_object+0x7b>
      }
    }
  }

  profile_close_func();
    30cd:	sub    rsp,0x8
    30d1:	sub    rsp,0x38
    30d5:	mov    rax,rsp
    30d8:	mov    rcx,QWORD PTR [rbp-0x50]
    30dc:	mov    rbx,QWORD PTR [rbp-0x48]
    30e0:	mov    QWORD PTR [rax],rcx
    30e3:	mov    QWORD PTR [rax+0x8],rbx
    30e7:	mov    rcx,QWORD PTR [rbp-0x40]
    30eb:	mov    rbx,QWORD PTR [rbp-0x38]
    30ef:	mov    QWORD PTR [rax+0x10],rcx
    30f3:	mov    QWORD PTR [rax+0x18],rbx
    30f7:	mov    rcx,QWORD PTR [rbp-0x30]
    30fb:	mov    rbx,QWORD PTR [rbp-0x28]
    30ff:	mov    QWORD PTR [rax+0x20],rcx
    3103:	mov    QWORD PTR [rax+0x28],rbx
    3107:	mov    rdx,QWORD PTR [rbp-0x20]
    310b:	mov    QWORD PTR [rax+0x30],rdx
    310f:	call   2111 <__profile_close_pass>
    3114:	add    rsp,0x40

  return result;
    3118:	mov    rax,QWORD PTR [rbp-0x60]
}
    311c:	mov    rdx,QWORD PTR [rbp-0x18]
    3120:	sub    rdx,QWORD PTR fs:0x28
    3129:	je     3130 <lookup_json_object+0x11d>
    312b:	call   1060 <__stack_chk_fail@plt>
    3130:	mov    rbx,QWORD PTR [rbp-0x8]
    3134:	leave
    3135:	ret

0000000000003136 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    3136:	push   rbp
    3137:	mov    rbp,rsp
    313a:	sub    rsp,0x50
    313e:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    3142:	cmp    QWORD PTR [rbp-0x48],0x0
    3147:	jne    316e <json_object_to_f64+0x38>
    3149:	lea    rdx,[rip+0x1740]        # 4890 <__PRETTY_FUNCTION__.0>
    3150:	lea    rsi,[rip+0x1343]        # 449a <_IO_stdin_used+0x49a>
    3157:	lea    rax,[rip+0x14ba]        # 4618 <_IO_stdin_used+0x618>
    315e:	mov    rcx,rdx
    3161:	mov    edx,0x1ca
    3166:	mov    rdi,rax
    3169:	call   1090 <__assert_fail@plt>

  String val = object->value;
    316e:	mov    rax,QWORD PTR [rbp-0x48]
    3172:	mov    rdx,QWORD PTR [rax+0x18]
    3176:	mov    rax,QWORD PTR [rax+0x10]
    317a:	mov    QWORD PTR [rbp-0x10],rax
    317e:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    3182:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    318a:	movsd  xmm0,QWORD PTR [rip+0x1736]        # 48c8 <__PRETTY_FUNCTION__.0+0x38>
    3192:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    3197:	mov    rax,QWORD PTR [rbp-0x8]
    319b:	cmp    QWORD PTR [rbp-0x30],rax
    319f:	jae    31c5 <json_object_to_f64+0x8f>
    31a1:	mov    rdx,QWORD PTR [rbp-0x10]
    31a5:	mov    rax,QWORD PTR [rbp-0x30]
    31a9:	add    rax,rdx
    31ac:	movzx  eax,BYTE PTR [rax]
    31af:	cmp    al,0x2d
    31b1:	jne    31c5 <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    31b3:	movsd  xmm0,QWORD PTR [rip+0x1715]        # 48d0 <__PRETTY_FUNCTION__.0+0x40>
    31bb:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    31c0:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    31c5:	pxor   xmm0,xmm0
    31c9:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    31ce:	jmp    3215 <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    31d0:	mov    rdx,QWORD PTR [rbp-0x10]
    31d4:	mov    rax,QWORD PTR [rbp-0x30]
    31d8:	add    rax,rdx
    31db:	movzx  eax,BYTE PTR [rax]
    31de:	sub    eax,0x30
    31e1:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    31e4:	cmp    BYTE PTR [rbp-0x32],0x9
    31e8:	ja     3221 <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    31ea:	movsd  xmm1,QWORD PTR [rbp-0x20]
    31ef:	movsd  xmm0,QWORD PTR [rip+0x16e1]        # 48d8 <__PRETTY_FUNCTION__.0+0x48>
    31f7:	mulsd  xmm1,xmm0
    31fb:	movzx  eax,BYTE PTR [rbp-0x32]
    31ff:	pxor   xmm0,xmm0
    3203:	cvtsi2sd xmm0,eax
    3207:	addsd  xmm0,xmm1
    320b:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    3210:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    3215:	mov    rax,QWORD PTR [rbp-0x8]
    3219:	cmp    QWORD PTR [rbp-0x30],rax
    321d:	jb     31d0 <json_object_to_f64+0x9a>
    321f:	jmp    3222 <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    3221:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    3222:	mov    rax,QWORD PTR [rbp-0x8]
    3226:	cmp    QWORD PTR [rbp-0x30],rax
    322a:	jae    32b7 <json_object_to_f64+0x181>
    3230:	mov    rdx,QWORD PTR [rbp-0x10]
    3234:	mov    rax,QWORD PTR [rbp-0x30]
    3238:	add    rax,rdx
    323b:	movzx  eax,BYTE PTR [rax]
    323e:	cmp    al,0x2e
    3240:	jne    32b7 <json_object_to_f64+0x181>
  {
    at += 1;
    3242:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    3247:	movsd  xmm0,QWORD PTR [rip+0x1691]        # 48e0 <__PRETTY_FUNCTION__.0+0x50>
    324f:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    3254:	jmp    32aa <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3256:	mov    rdx,QWORD PTR [rbp-0x10]
    325a:	mov    rax,QWORD PTR [rbp-0x30]
    325e:	add    rax,rdx
    3261:	movzx  eax,BYTE PTR [rax]
    3264:	sub    eax,0x30
    3267:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    326a:	cmp    BYTE PTR [rbp-0x31],0x9
    326e:	ja     32b6 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    3270:	movzx  eax,BYTE PTR [rbp-0x31]
    3274:	pxor   xmm0,xmm0
    3278:	cvtsi2sd xmm0,eax
    327c:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    3281:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3286:	addsd  xmm0,xmm1
    328a:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    328f:	movsd  xmm1,QWORD PTR [rbp-0x18]
    3294:	movsd  xmm0,QWORD PTR [rip+0x1644]        # 48e0 <__PRETTY_FUNCTION__.0+0x50>
    329c:	mulsd  xmm0,xmm1
    32a0:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    32a5:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    32aa:	mov    rax,QWORD PTR [rbp-0x8]
    32ae:	cmp    QWORD PTR [rbp-0x30],rax
    32b2:	jb     3256 <json_object_to_f64+0x120>
    32b4:	jmp    32b7 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    32b6:	nop
      }
    }
  }

  return sign * result;
    32b7:	movsd  xmm0,QWORD PTR [rbp-0x28]
    32bc:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    32c1:	leave
    32c2:	ret

00000000000032c3 <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    32c3:	push   rbp
    32c4:	mov    rbp,rsp
    32c7:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    32cc:	movsd  xmm0,QWORD PTR [rbp-0x8]
    32d1:	movsd  xmm1,QWORD PTR [rip+0x160f]        # 48e8 <__PRETTY_FUNCTION__.0+0x58>
    32d9:	divsd  xmm0,xmm1
}
    32dd:	pop    rbp
    32de:	ret

00000000000032df <square>:

static
f64 square(f64 x)
{
    32df:	push   rbp
    32e0:	mov    rbp,rsp
    32e3:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    32e8:	movsd  xmm0,QWORD PTR [rbp-0x8]
    32ed:	mulsd  xmm0,xmm0
}
    32f1:	pop    rbp
    32f2:	ret

00000000000032f3 <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    32f3:	push   rbp
    32f4:	mov    rbp,rsp
    32f7:	sub    rsp,0x90
    32fe:	movsd  QWORD PTR [rbp-0x58],xmm0
    3303:	movsd  QWORD PTR [rbp-0x60],xmm1
    3308:	movsd  QWORD PTR [rbp-0x68],xmm2
    330d:	movsd  QWORD PTR [rbp-0x70],xmm3
    3312:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    3317:	movsd  xmm0,QWORD PTR [rbp-0x60]
    331c:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    3321:	movsd  xmm0,QWORD PTR [rbp-0x70]
    3326:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    332b:	movsd  xmm0,QWORD PTR [rbp-0x58]
    3330:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    3335:	movsd  xmm0,QWORD PTR [rbp-0x68]
    333a:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    333f:	movsd  xmm0,QWORD PTR [rbp-0x40]
    3344:	subsd  xmm0,QWORD PTR [rbp-0x48]
    3349:	movq   rax,xmm0
    334e:	movq   xmm0,rax
    3353:	call   32c3 <to_radians>
    3358:	movq   rax,xmm0
    335d:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    3361:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3366:	subsd  xmm0,QWORD PTR [rbp-0x38]
    336b:	movq   rax,xmm0
    3370:	movq   xmm0,rax
    3375:	call   32c3 <to_radians>
    337a:	movq   rax,xmm0
    337f:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    3383:	mov    rax,QWORD PTR [rbp-0x48]
    3387:	movq   xmm0,rax
    338c:	call   32c3 <to_radians>
    3391:	movq   rax,xmm0
    3396:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    339a:	mov    rax,QWORD PTR [rbp-0x40]
    339e:	movq   xmm0,rax
    33a3:	call   32c3 <to_radians>
    33a8:	movq   rax,xmm0
    33ad:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    33b1:	movsd  xmm0,QWORD PTR [rbp-0x28]
    33b6:	movsd  xmm1,QWORD PTR [rip+0x1532]        # 48f0 <__PRETTY_FUNCTION__.0+0x60>
    33be:	divsd  xmm0,xmm1
    33c2:	movq   rax,xmm0
    33c7:	movq   xmm0,rax
    33cc:	call   1130 <sin@plt>
    33d1:	movq   rax,xmm0
    33d6:	movq   xmm0,rax
    33db:	call   32df <square>
    33e0:	movsd  QWORD PTR [rbp-0x80],xmm0
    33e5:	mov    rax,QWORD PTR [rbp-0x48]
    33e9:	movq   xmm0,rax
    33ee:	call   10b0 <cos@plt>
    33f3:	movsd  QWORD PTR [rbp-0x88],xmm0
    33fb:	mov    rax,QWORD PTR [rbp-0x40]
    33ff:	movq   xmm0,rax
    3404:	call   10b0 <cos@plt>
    3409:	movapd xmm5,xmm0
    340d:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    3415:	movsd  QWORD PTR [rbp-0x88],xmm5
    341d:	movsd  xmm0,QWORD PTR [rbp-0x20]
    3422:	movsd  xmm1,QWORD PTR [rip+0x14c6]        # 48f0 <__PRETTY_FUNCTION__.0+0x60>
    342a:	movapd xmm6,xmm0
    342e:	divsd  xmm6,xmm1
    3432:	movq   rax,xmm6
    3437:	movq   xmm0,rax
    343c:	call   1130 <sin@plt>
    3441:	movq   rax,xmm0
    3446:	movq   xmm0,rax
    344b:	call   32df <square>
    3450:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    3458:	addsd  xmm0,QWORD PTR [rbp-0x80]
    345d:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    3462:	mov    rax,QWORD PTR [rbp-0x18]
    3466:	movq   xmm0,rax
    346b:	call   1160 <sqrt@plt>
    3470:	movq   rax,xmm0
    3475:	movq   xmm0,rax
    347a:	call   1140 <asin@plt>
    347f:	addsd  xmm0,xmm0
    3483:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    3488:	movsd  xmm0,QWORD PTR [rbp-0x78]
    348d:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    3492:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3497:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    349c:	leave
    349d:	ret

000000000000349e <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    349e:	push   rbp
    349f:	mov    rbp,rsp
    34a2:	movsd  QWORD PTR [rbp-0x18],xmm0
    34a7:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    34ac:	movsd  xmm0,QWORD PTR [rip+0x1444]        # 48f8 <__PRETTY_FUNCTION__.0+0x68>
    34b4:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    34b9:	movsd  xmm0,QWORD PTR [rbp-0x18]
    34be:	movq   xmm1,QWORD PTR [rip+0x143a]        # 4900 <__PRETTY_FUNCTION__.0+0x70>
    34c6:	andpd  xmm0,xmm1
    34ca:	movsd  xmm1,QWORD PTR [rbp-0x20]
    34cf:	movq   xmm2,QWORD PTR [rip+0x1429]        # 4900 <__PRETTY_FUNCTION__.0+0x70>
    34d7:	andpd  xmm2,xmm1
    34db:	movapd xmm1,xmm0
    34df:	subsd  xmm1,xmm2
    34e3:	movsd  xmm0,QWORD PTR [rbp-0x8]
    34e8:	comisd xmm0,xmm1
    34ec:	setae  al
    34ef:	movzx  eax,al
}
    34f2:	pop    rbp
    34f3:	ret

00000000000034f4 <main>:

int main(int args_count, char **args)
{
    34f4:	push   rbp
    34f5:	mov    rbp,rsp
    34f8:	push   r15
    34fa:	push   r14
    34fc:	push   r13
    34fe:	push   r12
    3500:	push   rbx
    3501:	sub    rsp,0x268
    3508:	mov    DWORD PTR [rbp-0x1f4],edi
    350e:	mov    QWORD PTR [rbp-0x200],rsi
    3515:	mov    rax,QWORD PTR fs:0x28
    351e:	mov    QWORD PTR [rbp-0x38],rax
    3522:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    3524:	cmp    DWORD PTR [rbp-0x1f4],0x3
    352b:	je     3558 <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    352d:	mov    rax,QWORD PTR [rbp-0x200]
    3534:	mov    rax,QWORD PTR [rax]
    3537:	lea    rdx,[rip+0x1112]        # 4650 <_IO_stdin_used+0x650>
    353e:	mov    rsi,rax
    3541:	mov    rdi,rdx
    3544:	mov    eax,0x0
    3549:	call   1070 <printf@plt>
    return 1;
    354e:	mov    eax,0x1
    3553:	jmp    3e5e <main+0x96a>
  }

  begin_profiling();
    3558:	call   1bfc <begin_profiling>

  Arena arena = {0};
    355d:	pxor   xmm0,xmm0
    3561:	movaps XMMWORD PTR [rbp-0x150],xmm0
    3568:	movaps XMMWORD PTR [rbp-0x140],xmm0
  arena = arena_make(GB(4));
    356f:	lea    rdx,[rbp-0x220]
    3576:	movabs rax,0x100000000
    3580:	mov    rsi,rax
    3583:	mov    rdi,rdx
    3586:	call   166b <arena_make>
    358b:	mov    rax,QWORD PTR [rbp-0x220]
    3592:	mov    rdx,QWORD PTR [rbp-0x218]
    3599:	mov    QWORD PTR [rbp-0x150],rax
    35a0:	mov    QWORD PTR [rbp-0x148],rdx
    35a7:	mov    rax,QWORD PTR [rbp-0x210]
    35ae:	mov    rdx,QWORD PTR [rbp-0x208]
    35b5:	mov    QWORD PTR [rbp-0x140],rax
    35bc:	mov    QWORD PTR [rbp-0x138],rdx

  String source = {0};
    35c3:	mov    QWORD PTR [rbp-0x160],0x0
    35ce:	mov    QWORD PTR [rbp-0x158],0x0
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    35d9:	mov    rax,QWORD PTR [rbp-0x200]
    35e0:	add    rax,0x8
    35e4:	mov    rax,QWORD PTR [rax]
    35e7:	mov    rdi,rax
    35ea:	call   1321 <file_size>
    35ef:	mov    rcx,rax
    35f2:	lea    r12,[rip+0x1083]        # 467c <_IO_stdin_used+0x67c>
    35f9:	mov    r13d,0x4
    35ff:	lea    rdi,[rbp-0x130]
    3606:	mov    rdx,r12
    3609:	mov    rax,r13
    360c:	mov    r8,rcx
    360f:	mov    ecx,0x5
    3614:	mov    rsi,rdx
    3617:	mov    rdx,rax
    361a:	call   2027 <__profile_begin_pass>
    361f:	mov    QWORD PTR [rbp-0x1e0],0x0
    362a:	jmp    36c5 <main+0x1d1>
  {
    source = read_file_to_arena(&arena, args[1]);
    362f:	mov    rax,QWORD PTR [rbp-0x200]
    3636:	add    rax,0x8
    363a:	mov    rdx,QWORD PTR [rax]
    363d:	lea    rax,[rbp-0x150]
    3644:	mov    rsi,rdx
    3647:	mov    rdi,rax
    364a:	call   1375 <read_file_to_arena>
    364f:	mov    QWORD PTR [rbp-0x160],rax
    3656:	mov    QWORD PTR [rbp-0x158],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    365d:	add    QWORD PTR [rbp-0x1e0],0x1
    3665:	sub    rsp,0x8
    3669:	sub    rsp,0x38
    366d:	mov    rcx,rsp
    3670:	mov    rax,QWORD PTR [rbp-0x130]
    3677:	mov    rdx,QWORD PTR [rbp-0x128]
    367e:	mov    QWORD PTR [rcx],rax
    3681:	mov    QWORD PTR [rcx+0x8],rdx
    3685:	mov    rax,QWORD PTR [rbp-0x120]
    368c:	mov    rdx,QWORD PTR [rbp-0x118]
    3693:	mov    QWORD PTR [rcx+0x10],rax
    3697:	mov    QWORD PTR [rcx+0x18],rdx
    369b:	mov    rax,QWORD PTR [rbp-0x110]
    36a2:	mov    rdx,QWORD PTR [rbp-0x108]
    36a9:	mov    QWORD PTR [rcx+0x20],rax
    36ad:	mov    QWORD PTR [rcx+0x28],rdx
    36b1:	mov    rax,QWORD PTR [rbp-0x100]
    36b8:	mov    QWORD PTR [rcx+0x30],rax
    36bc:	call   2111 <__profile_close_pass>
    36c1:	add    rsp,0x40
    36c5:	cmp    QWORD PTR [rbp-0x1e0],0x0
    36cd:	je     362f <main+0x13b>
  }

  usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    36d3:	mov    QWORD PTR [rbp-0x1a8],0x18
  usize max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    36de:	mov    rax,QWORD PTR [rbp-0x158]
    36e5:	mov    edx,0x0
    36ea:	div    QWORD PTR [rbp-0x1a8]
    36f1:	mov    QWORD PTR [rbp-0x1a0],rax
  Haversine_Pair * pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    36f8:	mov    rax,QWORD PTR [rbp-0x1a0]
    36ff:	shl    rax,0x5
    3703:	mov    rcx,rax
    3706:	lea    rax,[rbp-0x150]
    370d:	mov    edx,0x8
    3712:	mov    rsi,rcx
    3715:	mov    rdi,rax
    3718:	call   180c <arena_alloc>
    371d:	mov    QWORD PTR [rbp-0x198],rax
  i32 pair_count = 0;
    3724:	mov    DWORD PTR [rbp-0x1e8],0x0

  JSON_Object *root = NULL;
    372e:	mov    QWORD PTR [rbp-0x190],0x0
  root = parse_json(&arena, source);
    3739:	mov    rcx,QWORD PTR [rbp-0x160]
    3740:	mov    rdx,QWORD PTR [rbp-0x158]
    3747:	lea    rax,[rbp-0x150]
    374e:	mov    rsi,rcx
    3751:	mov    rdi,rax
    3754:	call   2eaf <parse_json>
    3759:	mov    QWORD PTR [rbp-0x190],rax

  f64 haversine_sum = 0.0;
    3760:	pxor   xmm0,xmm0
    3764:	movsd  QWORD PTR [rbp-0x188],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    376c:	lea    r14,[rip+0xf0e]        # 4681 <_IO_stdin_used+0x681>
    3773:	mov    r15d,0x5
    3779:	mov    rcx,r14
    377c:	mov    rdx,r15
    377f:	mov    rax,QWORD PTR [rbp-0x190]
    3786:	mov    rsi,rcx
    3789:	mov    rdi,rax
    378c:	call   3013 <lookup_json_object>
    3791:	mov    QWORD PTR [rbp-0x180],rax
  if (pairs)
    3798:	cmp    QWORD PTR [rbp-0x198],0x0
    37a0:	je     3965 <main+0x471>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    37a6:	mov    rax,QWORD PTR [rbp-0x180]
    37ad:	mov    rax,QWORD PTR [rax+0x20]
    37b1:	mov    QWORD PTR [rbp-0x1d8],rax
    37b8:	jmp    3946 <main+0x452>
    {
      Haversine_Pair pair =
      {
        .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    37bd:	lea    rax,[rip+0xec3]        # 4687 <_IO_stdin_used+0x687>
    37c4:	mov    QWORD PTR [rbp-0x260],rax
    37cb:	mov    QWORD PTR [rbp-0x258],0x2
    37d6:	mov    rbx,QWORD PTR [rbp-0x260]
    37dd:	mov    rsi,QWORD PTR [rbp-0x258]
    37e4:	mov    rax,rbx
    37e7:	mov    rdx,rsi
    37ea:	mov    rcx,QWORD PTR [rbp-0x1d8]
    37f1:	mov    rsi,rax
    37f4:	mov    rdi,rcx
    37f7:	call   3013 <lookup_json_object>
    37fc:	mov    rdi,rax
    37ff:	call   3136 <json_object_to_f64>
    3804:	movq   rax,xmm0
      Haversine_Pair pair =
    3809:	mov    QWORD PTR [rbp-0x70],rax
        .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    380d:	lea    rax,[rip+0xe76]        # 468a <_IO_stdin_used+0x68a>
    3814:	mov    QWORD PTR [rbp-0x270],rax
    381b:	mov    QWORD PTR [rbp-0x268],0x2
    3826:	mov    rax,QWORD PTR [rbp-0x270]
    382d:	mov    rdx,QWORD PTR [rbp-0x268]
    3834:	mov    rcx,rax
    3837:	mov    rax,QWORD PTR [rbp-0x1d8]
    383e:	mov    rsi,rcx
    3841:	mov    rdi,rax
    3844:	call   3013 <lookup_json_object>
    3849:	mov    rdi,rax
    384c:	call   3136 <json_object_to_f64>
    3851:	movq   rax,xmm0
      Haversine_Pair pair =
    3856:	mov    QWORD PTR [rbp-0x68],rax
        .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    385a:	lea    rax,[rip+0xe2c]        # 468d <_IO_stdin_used+0x68d>
    3861:	mov    QWORD PTR [rbp-0x280],rax
    3868:	mov    QWORD PTR [rbp-0x278],0x2
    3873:	mov    rax,QWORD PTR [rbp-0x280]
    387a:	mov    rdx,QWORD PTR [rbp-0x278]
    3881:	mov    rcx,rax
    3884:	mov    rax,QWORD PTR [rbp-0x1d8]
    388b:	mov    rsi,rcx
    388e:	mov    rdi,rax
    3891:	call   3013 <lookup_json_object>
    3896:	mov    rdi,rax
    3899:	call   3136 <json_object_to_f64>
    389e:	movq   rax,xmm0
      Haversine_Pair pair =
    38a3:	mov    QWORD PTR [rbp-0x60],rax
        .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    38a7:	lea    rax,[rip+0xde2]        # 4690 <_IO_stdin_used+0x690>
    38ae:	mov    QWORD PTR [rbp-0x290],rax
    38b5:	mov    QWORD PTR [rbp-0x288],0x2
    38c0:	mov    rax,QWORD PTR [rbp-0x290]
    38c7:	mov    rdx,QWORD PTR [rbp-0x288]
    38ce:	mov    rcx,rax
    38d1:	mov    rax,QWORD PTR [rbp-0x1d8]
    38d8:	mov    rsi,rcx
    38db:	mov    rdi,rax
    38de:	call   3013 <lookup_json_object>
    38e3:	mov    rdi,rax
    38e6:	call   3136 <json_object_to_f64>
    38eb:	movq   rax,xmm0
      Haversine_Pair pair =
    38f0:	mov    QWORD PTR [rbp-0x58],rax
      };

      pairs[pair_count] = pair;
    38f4:	mov    eax,DWORD PTR [rbp-0x1e8]
    38fa:	cdqe
    38fc:	shl    rax,0x5
    3900:	mov    rdx,rax
    3903:	mov    rax,QWORD PTR [rbp-0x198]
    390a:	lea    rcx,[rdx+rax*1]
    390e:	mov    rax,QWORD PTR [rbp-0x70]
    3912:	mov    rdx,QWORD PTR [rbp-0x68]
    3916:	mov    QWORD PTR [rcx],rax
    3919:	mov    QWORD PTR [rcx+0x8],rdx
    391d:	mov    rax,QWORD PTR [rbp-0x60]
    3921:	mov    rdx,QWORD PTR [rbp-0x58]
    3925:	mov    QWORD PTR [rcx+0x10],rax
    3929:	mov    QWORD PTR [rcx+0x18],rdx
      pair_count += 1;
    392d:	add    DWORD PTR [rbp-0x1e8],0x1
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    3934:	mov    rax,QWORD PTR [rbp-0x1d8]
    393b:	mov    rax,QWORD PTR [rax+0x28]
    393f:	mov    QWORD PTR [rbp-0x1d8],rax
    3946:	cmp    QWORD PTR [rbp-0x1d8],0x0
    394e:	je     3965 <main+0x471>
    3950:	mov    eax,DWORD PTR [rbp-0x1e8]
    3956:	cdqe
    3958:	cmp    rax,QWORD PTR [rbp-0x1a0]
    395f:	jb     37bd <main+0x2c9>
    }
  }

  f64 sum = 0.0;
    3965:	pxor   xmm0,xmm0
    3969:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    3971:	mov    eax,DWORD PTR [rbp-0x1e8]
    3977:	cdqe
    3979:	shl    rax,0x5
    397d:	mov    rdx,rax
    3980:	lea    rax,[rip+0xd0c]        # 4693 <_IO_stdin_used+0x693>
    3987:	mov    QWORD PTR [rbp-0x230],rax
    398e:	mov    QWORD PTR [rbp-0x228],0x3
    3999:	lea    rax,[rbp-0xf0]
    39a0:	mov    rcx,QWORD PTR [rbp-0x230]
    39a7:	mov    rbx,QWORD PTR [rbp-0x228]
    39ae:	mov    rsi,rcx
    39b1:	mov    rdi,rbx
    39b4:	mov    r8,rdx
    39b7:	mov    ecx,0x6
    39bc:	mov    rdx,rdi
    39bf:	mov    rdi,rax
    39c2:	call   2027 <__profile_begin_pass>
    39c7:	mov    QWORD PTR [rbp-0x1c8],0x0
    39d2:	jmp    3b54 <main+0x660>
  {
    for (usize i = 0; i < pair_count; i++)
    39d7:	mov    QWORD PTR [rbp-0x1c0],0x0
    39e2:	jmp    3ab7 <main+0x5c3>
    {
      f64 earth_radius = 6372.8;
    39e7:	movsd  xmm0,QWORD PTR [rip+0xf21]        # 4910 <__PRETTY_FUNCTION__.0+0x80>
    39ef:	movsd  QWORD PTR [rbp-0x170],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    39f7:	mov    rax,QWORD PTR [rbp-0x1c0]
    39fe:	shl    rax,0x5
    3a02:	mov    rdx,rax
    3a05:	mov    rax,QWORD PTR [rbp-0x198]
    3a0c:	add    rax,rdx
    3a0f:	movsd  xmm2,QWORD PTR [rax+0x18]
    3a14:	mov    rax,QWORD PTR [rbp-0x1c0]
    3a1b:	shl    rax,0x5
    3a1f:	mov    rdx,rax
    3a22:	mov    rax,QWORD PTR [rbp-0x198]
    3a29:	add    rax,rdx
    3a2c:	movsd  xmm1,QWORD PTR [rax+0x10]
    3a31:	mov    rax,QWORD PTR [rbp-0x1c0]
    3a38:	shl    rax,0x5
    3a3c:	mov    rdx,rax
    3a3f:	mov    rax,QWORD PTR [rbp-0x198]
    3a46:	add    rax,rdx
    3a49:	movsd  xmm0,QWORD PTR [rax+0x8]
    3a4e:	mov    rax,QWORD PTR [rbp-0x1c0]
    3a55:	shl    rax,0x5
    3a59:	mov    rdx,rax
    3a5c:	mov    rax,QWORD PTR [rbp-0x198]
    3a63:	add    rax,rdx
    3a66:	mov    rax,QWORD PTR [rax]
    3a69:	movsd  xmm3,QWORD PTR [rbp-0x170]
    3a71:	movapd xmm4,xmm3
    3a75:	movapd xmm3,xmm2
    3a79:	movapd xmm2,xmm1
    3a7d:	movapd xmm1,xmm0
    3a81:	movq   xmm0,rax
    3a86:	call   32f3 <reference_haversine>
    3a8b:	movq   rax,xmm0
    3a90:	mov    QWORD PTR [rbp-0x168],rax
      sum += result;
    3a97:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3a9f:	addsd  xmm0,QWORD PTR [rbp-0x168]
    3aa7:	movsd  QWORD PTR [rbp-0x1d0],xmm0
    for (usize i = 0; i < pair_count; i++)
    3aaf:	add    QWORD PTR [rbp-0x1c0],0x1
    3ab7:	mov    eax,DWORD PTR [rbp-0x1e8]
    3abd:	cdqe
    3abf:	cmp    QWORD PTR [rbp-0x1c0],rax
    3ac6:	jb     39e7 <main+0x4f3>
    }
    sum /= pair_count;
    3acc:	pxor   xmm1,xmm1
    3ad0:	cvtsi2sd xmm1,DWORD PTR [rbp-0x1e8]
    3ad8:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3ae0:	divsd  xmm0,xmm1
    3ae4:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    3aec:	add    QWORD PTR [rbp-0x1c8],0x1
    3af4:	sub    rsp,0x8
    3af8:	sub    rsp,0x38
    3afc:	mov    rax,rsp
    3aff:	mov    rcx,QWORD PTR [rbp-0xf0]
    3b06:	mov    rbx,QWORD PTR [rbp-0xe8]
    3b0d:	mov    QWORD PTR [rax],rcx
    3b10:	mov    QWORD PTR [rax+0x8],rbx
    3b14:	mov    rcx,QWORD PTR [rbp-0xe0]
    3b1b:	mov    rbx,QWORD PTR [rbp-0xd8]
    3b22:	mov    QWORD PTR [rax+0x10],rcx
    3b26:	mov    QWORD PTR [rax+0x18],rbx
    3b2a:	mov    rcx,QWORD PTR [rbp-0xd0]
    3b31:	mov    rbx,QWORD PTR [rbp-0xc8]
    3b38:	mov    QWORD PTR [rax+0x20],rcx
    3b3c:	mov    QWORD PTR [rax+0x28],rbx
    3b40:	mov    rdx,QWORD PTR [rbp-0xc0]
    3b47:	mov    QWORD PTR [rax+0x30],rdx
    3b4b:	call   2111 <__profile_close_pass>
    3b50:	add    rsp,0x40
    3b54:	cmp    QWORD PTR [rbp-0x1c8],0x0
    3b5c:	je     39d7 <main+0x4e3>
  }

  PROFILE_SCOPE("check")
    3b62:	lea    rax,[rip+0xb2e]        # 4697 <_IO_stdin_used+0x697>
    3b69:	mov    QWORD PTR [rbp-0x240],rax
    3b70:	mov    QWORD PTR [rbp-0x238],0x5
    3b7b:	lea    rax,[rbp-0xb0]
    3b82:	mov    rcx,QWORD PTR [rbp-0x240]
    3b89:	mov    rbx,QWORD PTR [rbp-0x238]
    3b90:	mov    rsi,rcx
    3b93:	mov    rdx,rbx
    3b96:	mov    r8d,0x0
    3b9c:	mov    ecx,0x7
    3ba1:	mov    rdi,rax
    3ba4:	call   2027 <__profile_begin_pass>
    3ba9:	mov    QWORD PTR [rbp-0x1b8],0x0
    3bb4:	jmp    3d89 <main+0x895>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3bb9:	mov    rax,QWORD PTR [rbp-0x200]
    3bc0:	add    rax,0x10
    3bc4:	mov    rdx,QWORD PTR [rax]
    3bc7:	lea    rax,[rbp-0x150]
    3bce:	mov    rsi,rdx
    3bd1:	mov    rdi,rax
    3bd4:	call   1375 <read_file_to_arena>
    3bd9:	mov    QWORD PTR [rbp-0x70],rax
    3bdd:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3be1:	mov    rax,QWORD PTR [rbp-0x68]
    3be5:	cmp    rax,0xb
    3be9:	jbe    3cfc <main+0x808>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3bef:	mov    rax,QWORD PTR [rbp-0x70]
    3bf3:	movsd  xmm0,QWORD PTR [rax]
    3bf7:	movsd  QWORD PTR [rbp-0x178],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3bff:	mov    rax,QWORD PTR [rbp-0x70]
    3c03:	mov    eax,DWORD PTR [rax+0x8]
    3c06:	mov    DWORD PTR [rbp-0x1e4],eax

      if (solution_pairs == pair_count)
    3c0c:	mov    eax,DWORD PTR [rbp-0x1e4]
    3c12:	cmp    eax,DWORD PTR [rbp-0x1e8]
    3c18:	jne    3cc0 <main+0x7cc>
      {
        if (epsilon_equal(solution_sum, sum))
    3c1e:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3c26:	mov    rax,QWORD PTR [rbp-0x178]
    3c2d:	movapd xmm1,xmm0
    3c31:	movq   xmm0,rax
    3c36:	call   349e <epsilon_equal>
    3c3b:	test   eax,eax
    3c3d:	je     3c81 <main+0x78d>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3c3f:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3c47:	mov    rax,QWORD PTR [rbp-0x178]
    3c4e:	lea    rdx,[rip+0xa4b]        # 46a0 <_IO_stdin_used+0x6a0>
    3c55:	lea    rsi,[rip+0xa77]        # 46d3 <_IO_stdin_used+0x6d3>
    3c5c:	movapd xmm1,xmm0
    3c60:	movq   xmm0,rax
    3c65:	mov    rcx,rdx
    3c68:	mov    edx,0x5b
    3c6d:	mov    edi,0x3
    3c72:	mov    eax,0x2
    3c77:	call   14da <log_message>
    3c7c:	jmp    3d24 <main+0x830>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3c81:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3c89:	mov    rax,QWORD PTR [rbp-0x178]
    3c90:	lea    rdx,[rip+0xa51]        # 46e8 <_IO_stdin_used+0x6e8>
    3c97:	lea    rsi,[rip+0xa35]        # 46d3 <_IO_stdin_used+0x6d3>
    3c9e:	movapd xmm1,xmm0
    3ca2:	movq   xmm0,rax
    3ca7:	mov    rcx,rdx
    3caa:	mov    edx,0x5f
    3caf:	mov    edi,0x1
    3cb4:	mov    eax,0x2
    3cb9:	call   14da <log_message>
    3cbe:	jmp    3d24 <main+0x830>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3cc0:	mov    esi,DWORD PTR [rbp-0x1e8]
    3cc6:	mov    ecx,DWORD PTR [rbp-0x1e4]
    3ccc:	lea    rdx,[rip+0xa4d]        # 4720 <_IO_stdin_used+0x720>
    3cd3:	lea    rax,[rip+0x9f9]        # 46d3 <_IO_stdin_used+0x6d3>
    3cda:	mov    r9d,esi
    3cdd:	mov    r8d,ecx
    3ce0:	mov    rcx,rdx
    3ce3:	mov    edx,0x64
    3ce8:	mov    rsi,rax
    3ceb:	mov    edi,0x1
    3cf0:	mov    eax,0x0
    3cf5:	call   14da <log_message>
    3cfa:	jmp    3d24 <main+0x830>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3cfc:	lea    rdx,[rip+0xa65]        # 4768 <_IO_stdin_used+0x768>
    3d03:	lea    rax,[rip+0x9c9]        # 46d3 <_IO_stdin_used+0x6d3>
    3d0a:	mov    rcx,rdx
    3d0d:	mov    edx,0x69
    3d12:	mov    rsi,rax
    3d15:	mov    edi,0x1
    3d1a:	mov    eax,0x0
    3d1f:	call   14da <log_message>
  PROFILE_SCOPE("check")
    3d24:	add    QWORD PTR [rbp-0x1b8],0x1
    3d2c:	sub    rsp,0x8
    3d30:	sub    rsp,0x38
    3d34:	mov    rax,rsp
    3d37:	mov    rcx,QWORD PTR [rbp-0xb0]
    3d3e:	mov    rbx,QWORD PTR [rbp-0xa8]
    3d45:	mov    QWORD PTR [rax],rcx
    3d48:	mov    QWORD PTR [rax+0x8],rbx
    3d4c:	mov    rcx,QWORD PTR [rbp-0xa0]
    3d53:	mov    rbx,QWORD PTR [rbp-0x98]
    3d5a:	mov    QWORD PTR [rax+0x10],rcx
    3d5e:	mov    QWORD PTR [rax+0x18],rbx
    3d62:	mov    rcx,QWORD PTR [rbp-0x90]
    3d69:	mov    rbx,QWORD PTR [rbp-0x88]
    3d70:	mov    QWORD PTR [rax+0x20],rcx
    3d74:	mov    QWORD PTR [rax+0x28],rbx
    3d78:	mov    rdx,QWORD PTR [rbp-0x80]
    3d7c:	mov    QWORD PTR [rax+0x30],rdx
    3d80:	call   2111 <__profile_close_pass>
    3d85:	add    rsp,0x40
    3d89:	cmp    QWORD PTR [rbp-0x1b8],0x0
    3d91:	je     3bb9 <main+0x6c5>
    }
  }

  PROFILE_SCOPE("free")
    3d97:	lea    rax,[rip+0xa05]        # 47a3 <_IO_stdin_used+0x7a3>
    3d9e:	mov    QWORD PTR [rbp-0x250],rax
    3da5:	mov    QWORD PTR [rbp-0x248],0x4
    3db0:	lea    rax,[rbp-0x70]
    3db4:	mov    rcx,QWORD PTR [rbp-0x250]
    3dbb:	mov    rbx,QWORD PTR [rbp-0x248]
    3dc2:	mov    rsi,rcx
    3dc5:	mov    rdx,rbx
    3dc8:	mov    r8d,0x0
    3dce:	mov    ecx,0x8
    3dd3:	mov    rdi,rax
    3dd6:	call   2027 <__profile_begin_pass>
    3ddb:	mov    QWORD PTR [rbp-0x1b0],0x0
    3de6:	jmp    3e4a <main+0x956>
  {
    arena_free(&arena);
    3de8:	lea    rax,[rbp-0x150]
    3def:	mov    rdi,rax
    3df2:	call   17ca <arena_free>
  PROFILE_SCOPE("free")
    3df7:	add    QWORD PTR [rbp-0x1b0],0x1
    3dff:	sub    rsp,0x8
    3e03:	sub    rsp,0x38
    3e07:	mov    rax,rsp
    3e0a:	mov    rcx,QWORD PTR [rbp-0x70]
    3e0e:	mov    rbx,QWORD PTR [rbp-0x68]
    3e12:	mov    QWORD PTR [rax],rcx
    3e15:	mov    QWORD PTR [rax+0x8],rbx
    3e19:	mov    rcx,QWORD PTR [rbp-0x60]
    3e1d:	mov    rbx,QWORD PTR [rbp-0x58]
    3e21:	mov    QWORD PTR [rax+0x10],rcx
    3e25:	mov    QWORD PTR [rax+0x18],rbx
    3e29:	mov    rcx,QWORD PTR [rbp-0x50]
    3e2d:	mov    rbx,QWORD PTR [rbp-0x48]
    3e31:	mov    QWORD PTR [rax+0x20],rcx
    3e35:	mov    QWORD PTR [rax+0x28],rbx
    3e39:	mov    rdx,QWORD PTR [rbp-0x40]
    3e3d:	mov    QWORD PTR [rax+0x30],rdx
    3e41:	call   2111 <__profile_close_pass>
    3e46:	add    rsp,0x40
    3e4a:	cmp    QWORD PTR [rbp-0x1b0],0x0
    3e52:	je     3de8 <main+0x8f4>
  }

  end_profiling();
    3e54:	call   1c5a <end_profiling>
    3e59:	mov    eax,0x0
}
    3e5e:	mov    rdx,QWORD PTR [rbp-0x38]
    3e62:	sub    rdx,QWORD PTR fs:0x28
    3e6b:	je     3e72 <main+0x97e>
    3e6d:	call   1060 <__stack_chk_fail@plt>
    3e72:	lea    rsp,[rbp-0x28]
    3e76:	pop    rbx
    3e77:	pop    r12
    3e79:	pop    r13
    3e7b:	pop    r14
    3e7d:	pop    r15
    3e7f:	pop    rbp
    3e80:	ret

Disassembly of section .fini:

0000000000003e84 <_fini>:
    3e84:	endbr64
    3e88:	sub    rsp,0x8
    3e8c:	add    rsp,0x8
    3e90:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x5fc1]        # 6fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x5fca]        # 6ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x5fcc]        # 6ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x5fca]        # 7000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x5fc2]        # 7008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x5fba]        # 7010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x5fb2]        # 7018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x5faa]        # 7020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x5fa2]        # 7028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x5f9a]        # 7030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x5f92]        # 7038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x5f8a]        # 7040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x5f82]        # 7048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x5f7a]        # 7050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x5f72]        # 7058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x5f6a]        # 7060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x5f62]        # 7068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x5f5a]        # 7070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x5f52]        # 7078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x5f4a]        # 7080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x5f42]        # 7088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x5f3a]        # 7090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x5f32]        # 7098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x232f]        # 34be <main>
    118f:	call   QWORD PTR [rip+0x5e2b]        # 6fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x5fa1]        # 7148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x5f9a]        # 7148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x5e0e]        # 6fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x5f71]        # 7148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x5f6a]        # 7148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x5ddd]        # 6fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x5f6d],0x0        # 7188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x5dba],0x0        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x5e76]        # 70a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x5da8]        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x5f44],0x1        # 7188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  usize byte_count = 0;
    127d:	mov    QWORD PTR [rbp-0x10],0x0

  FILE *file = fopen(name, "rb");
    1285:	lea    rdx,[rip+0x2d84]        # 4010 <_IO_stdin_used+0x10>
    128c:	mov    rax,QWORD PTR [rbp-0x18]
    1290:	mov    rsi,rdx
    1293:	mov    rdi,rax
    1296:	call   1110 <fopen@plt>
    129b:	mov    QWORD PTR [rbp-0x8],rax
  if (file)
    129f:	cmp    QWORD PTR [rbp-0x8],0x0
    12a4:	je     12d1 <read_file_to_memory+0x68>
  {
    byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12a6:	mov    rcx,QWORD PTR [rbp-0x8]
    12aa:	mov    rdx,QWORD PTR [rbp-0x28]
    12ae:	mov    rax,QWORD PTR [rbp-0x20]
    12b2:	mov    esi,0x1
    12b7:	mov    rdi,rax
    12ba:	call   1040 <fread@plt>
    12bf:	mov    QWORD PTR [rbp-0x10],rax
    fclose(file);
    12c3:	mov    rax,QWORD PTR [rbp-0x8]
    12c7:	mov    rdi,rax
    12ca:	call   1050 <fclose@plt>
    12cf:	jmp    1300 <read_file_to_memory+0x97>
  }
  else
  {
    LOG_ERROR("Unable to open file: %s", name);
    12d1:	mov    rcx,QWORD PTR [rbp-0x18]
    12d5:	lea    rdx,[rip+0x2d37]        # 4013 <_IO_stdin_used+0x13>
    12dc:	lea    rax,[rip+0x2d48]        # 402b <_IO_stdin_used+0x2b>
    12e3:	mov    r8,rcx
    12e6:	mov    rcx,rdx
    12e9:	mov    edx,0x182
    12ee:	mov    rsi,rax
    12f1:	mov    edi,0x1
    12f6:	mov    eax,0x0
    12fb:	call   14a4 <log_message>
  }

  return byte_count;
    1300:	mov    rax,QWORD PTR [rbp-0x10]
}
    1304:	leave
    1305:	ret

0000000000001306 <file_size>:

usize file_size(const char *name)
{
    1306:	push   rbp
    1307:	mov    rbp,rsp
    130a:	sub    rsp,0xb0
    1311:	mov    QWORD PTR [rbp-0xa8],rdi
    1318:	mov    rax,QWORD PTR fs:0x28
    1321:	mov    QWORD PTR [rbp-0x8],rax
    1325:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1327:	lea    rdx,[rbp-0xa0]
    132e:	mov    rax,QWORD PTR [rbp-0xa8]
    1335:	mov    rsi,rdx
    1338:	mov    rdi,rax
    133b:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    1340:	mov    rax,QWORD PTR [rbp-0x70]
}
    1344:	mov    rdx,QWORD PTR [rbp-0x8]
    1348:	sub    rdx,QWORD PTR fs:0x28
    1351:	je     1358 <file_size+0x52>
    1353:	call   1060 <__stack_chk_fail@plt>
    1358:	leave
    1359:	ret

000000000000135a <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    135a:	push   rbp
    135b:	mov    rbp,rsp
    135e:	sub    rsp,0x50
    1362:	mov    QWORD PTR [rbp-0x48],rdi
    1366:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    136a:	mov    rax,QWORD PTR [rbp-0x50]
    136e:	mov    rdi,rax
    1371:	call   1306 <file_size>
    1376:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    137a:	mov    rcx,QWORD PTR [rbp-0x48]
    137e:	mov    rax,QWORD PTR [rcx]
    1381:	mov    rdx,QWORD PTR [rcx+0x8]
    1385:	mov    QWORD PTR [rbp-0x20],rax
    1389:	mov    QWORD PTR [rbp-0x18],rdx
    138d:	mov    rax,QWORD PTR [rcx+0x10]
    1391:	mov    rdx,QWORD PTR [rcx+0x18]
    1395:	mov    QWORD PTR [rbp-0x10],rax
    1399:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139d:	mov    rcx,QWORD PTR [rbp-0x40]
    13a1:	mov    rax,QWORD PTR [rbp-0x48]
    13a5:	mov    edx,0x1
    13aa:	mov    rsi,rcx
    13ad:	mov    rdi,rax
    13b0:	call   17d6 <arena_alloc>
    13b5:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b9:	mov    rdx,QWORD PTR [rbp-0x40]
    13bd:	mov    rcx,QWORD PTR [rbp-0x38]
    13c1:	mov    rax,QWORD PTR [rbp-0x50]
    13c5:	mov    rsi,rcx
    13c8:	mov    rdi,rax
    13cb:	call   1269 <read_file_to_memory>
    13d0:	cmp    QWORD PTR [rbp-0x40],rax
    13d4:	je     1428 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d6:	mov    rcx,QWORD PTR [rbp-0x50]
    13da:	lea    rdx,[rip+0x2c57]        # 4038 <_IO_stdin_used+0x38>
    13e1:	lea    rax,[rip+0x2c43]        # 402b <_IO_stdin_used+0x2b>
    13e8:	mov    r8,rcx
    13eb:	mov    rcx,rdx
    13ee:	mov    edx,0x1a0
    13f3:	mov    rsi,rax
    13f6:	mov    edi,0x1
    13fb:	mov    eax,0x0
    1400:	call   14a4 <log_message>
    *arena = save; // Rollback allocation
    1405:	mov    rcx,QWORD PTR [rbp-0x48]
    1409:	mov    rax,QWORD PTR [rbp-0x20]
    140d:	mov    rdx,QWORD PTR [rbp-0x18]
    1411:	mov    QWORD PTR [rcx],rax
    1414:	mov    QWORD PTR [rcx+0x8],rdx
    1418:	mov    rax,QWORD PTR [rbp-0x10]
    141c:	mov    rdx,QWORD PTR [rbp-0x8]
    1420:	mov    QWORD PTR [rcx+0x10],rax
    1424:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1428:	mov    rax,QWORD PTR [rbp-0x38]
    142c:	mov    QWORD PTR [rbp-0x30],rax
    1430:	mov    rax,QWORD PTR [rbp-0x40]
    1434:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1438:	mov    rax,QWORD PTR [rbp-0x30]
    143c:	mov    rdx,QWORD PTR [rbp-0x28]
}
    1440:	leave
    1441:	ret

0000000000001442 <strings_equal>:

b8 strings_equal(String a, String b)
{
    1442:	push   rbp
    1443:	mov    rbp,rsp
    1446:	sub    rsp,0x20
    144a:	mov    rax,rdi
    144d:	mov    r8,rsi
    1450:	mov    rsi,rax
    1453:	mov    edi,0x0
    1458:	mov    rdi,r8
    145b:	mov    QWORD PTR [rbp-0x10],rsi
    145f:	mov    QWORD PTR [rbp-0x8],rdi
    1463:	mov    QWORD PTR [rbp-0x20],rdx
    1467:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    146b:	mov    rdx,QWORD PTR [rbp-0x8]
    146f:	mov    rax,QWORD PTR [rbp-0x18]
    1473:	cmp    rdx,rax
    1476:	jne    149d <strings_equal+0x5b>
    1478:	mov    rax,QWORD PTR [rbp-0x8]
    147c:	mov    rdx,rax
    147f:	mov    rcx,QWORD PTR [rbp-0x20]
    1483:	mov    rax,QWORD PTR [rbp-0x10]
    1487:	mov    rsi,rcx
    148a:	mov    rdi,rax
    148d:	call   10d0 <memcmp@plt>
    1492:	test   eax,eax
    1494:	jne    149d <strings_equal+0x5b>
    1496:	mov    eax,0x1
    149b:	jmp    14a2 <strings_equal+0x60>
    149d:	mov    eax,0x0
}
    14a2:	leave
    14a3:	ret

00000000000014a4 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a4:	push   rbp
    14a5:	mov    rbp,rsp
    14a8:	sub    rsp,0x100
    14af:	mov    DWORD PTR [rbp-0xe4],edi
    14b5:	mov    QWORD PTR [rbp-0xf0],rsi
    14bc:	mov    QWORD PTR [rbp-0xf8],rdx
    14c3:	mov    QWORD PTR [rbp-0x100],rcx
    14ca:	mov    QWORD PTR [rbp-0x90],r8
    14d1:	mov    QWORD PTR [rbp-0x88],r9
    14d8:	test   al,al
    14da:	je     14fc <log_message+0x58>
    14dc:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14e0:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e4:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e8:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14ec:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14f0:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f4:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f8:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14fc:	mov    rax,QWORD PTR fs:0x28
    1505:	mov    QWORD PTR [rbp-0xb8],rax
    150c:	xor    eax,eax
  FILE *stream = stderr;
    150e:	mov    rax,QWORD PTR [rip+0x5c6b]        # 7180 <stderr@GLIBC_2.2.5>
    1515:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    151c:	cmp    DWORD PTR [rbp-0xe4],0x1
    1523:	ja     156c <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1525:	mov    eax,DWORD PTR [rbp-0xe4]
    152b:	lea    rdx,[rax*8+0x0]
    1533:	lea    rax,[rip+0x5b86]        # 70c0 <level_strings>
    153a:	mov    rdx,QWORD PTR [rdx+rax*1]
    153e:	mov    rdi,QWORD PTR [rbp-0xf8]
    1545:	mov    rcx,QWORD PTR [rbp-0xf0]
    154c:	lea    rsi,[rip+0x2b24]        # 4077 <_IO_stdin_used+0x77>
    1553:	mov    rax,QWORD PTR [rbp-0xd8]
    155a:	mov    r8,rdi
    155d:	mov    rdi,rax
    1560:	mov    eax,0x0
    1565:	call   10f0 <fprintf@plt>
    156a:	jmp    15ba <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    156c:	cmp    DWORD PTR [rbp-0xe4],0x3
    1573:	jne    1583 <log_message+0xdf>
    {
      stream = stdout;
    1575:	mov    rax,QWORD PTR [rip+0x5be4]        # 7160 <stdout@GLIBC_2.2.5>
    157c:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1583:	mov    eax,DWORD PTR [rbp-0xe4]
    1589:	lea    rdx,[rax*8+0x0]
    1591:	lea    rax,[rip+0x5b28]        # 70c0 <level_strings>
    1598:	mov    rdx,QWORD PTR [rdx+rax*1]
    159c:	lea    rcx,[rip+0x2aeb]        # 408e <_IO_stdin_used+0x8e>
    15a3:	mov    rax,QWORD PTR [rbp-0xd8]
    15aa:	mov    rsi,rcx
    15ad:	mov    rdi,rax
    15b0:	mov    eax,0x0
    15b5:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15ba:	mov    DWORD PTR [rbp-0xd0],0x20
    15c4:	mov    DWORD PTR [rbp-0xcc],0x30
    15ce:	lea    rax,[rbp+0x10]
    15d2:	mov    QWORD PTR [rbp-0xc8],rax
    15d9:	lea    rax,[rbp-0xb0]
    15e0:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e7:	lea    rdx,[rbp-0xd0]
    15ee:	mov    rcx,QWORD PTR [rbp-0x100]
    15f5:	mov    rax,QWORD PTR [rbp-0xd8]
    15fc:	mov    rsi,rcx
    15ff:	mov    rdi,rax
    1602:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1607:	mov    rax,QWORD PTR [rbp-0xd8]
    160e:	mov    rsi,rax
    1611:	mov    edi,0xa
    1616:	call   10c0 <fputc@plt>
}
    161b:	nop
    161c:	mov    rax,QWORD PTR [rbp-0xb8]
    1623:	sub    rax,QWORD PTR fs:0x28
    162c:	je     1633 <log_message+0x18f>
    162e:	call   1060 <__stack_chk_fail@plt>
    1633:	leave
    1634:	ret

0000000000001635 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1635:	push   rbp
    1636:	mov    rbp,rsp
    1639:	sub    rsp,0x30
    163d:	mov    QWORD PTR [rbp-0x28],rdi
    1641:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1645:	pxor   xmm0,xmm0
    1649:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164d:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    1651:	mov    rax,QWORD PTR [rbp-0x30]
    1655:	mov    esi,0x1
    165a:	mov    rdi,rax
    165d:	call   10e0 <calloc@plt>
    1662:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1666:	mov    rax,QWORD PTR [rbp-0x20]
    166a:	test   rax,rax
    166d:	jne    16a1 <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166f:	lea    rdx,[rip+0x2a2a]        # 40a0 <_IO_stdin_used+0xa0>
    1676:	lea    rax,[rip+0x29ae]        # 402b <_IO_stdin_used+0x2b>
    167d:	mov    rcx,rdx
    1680:	mov    edx,0x1dc
    1685:	mov    rsi,rax
    1688:	mov    edi,0x0
    168d:	mov    eax,0x0
    1692:	call   14a4 <log_message>
    1697:	mov    edi,0xffffffff
    169c:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    16a1:	mov    rax,QWORD PTR [rbp-0x30]
    16a5:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a9:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16b1:	mov    rcx,QWORD PTR [rbp-0x28]
    16b5:	mov    rax,QWORD PTR [rbp-0x20]
    16b9:	mov    rdx,QWORD PTR [rbp-0x18]
    16bd:	mov    QWORD PTR [rcx],rax
    16c0:	mov    QWORD PTR [rcx+0x8],rdx
    16c4:	mov    rax,QWORD PTR [rbp-0x10]
    16c8:	mov    rdx,QWORD PTR [rbp-0x8]
    16cc:	mov    QWORD PTR [rcx+0x10],rax
    16d0:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d4:	mov    rax,QWORD PTR [rbp-0x28]
    16d8:	leave
    16d9:	ret

00000000000016da <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16da:	push   rbp
    16db:	mov    rbp,rsp
    16de:	sub    rsp,0x40
    16e2:	mov    QWORD PTR [rbp-0x28],rdi
    16e6:	mov    QWORD PTR [rbp-0x30],rsi
    16ea:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16ee:	cmp    QWORD PTR [rbp-0x30],0x0
    16f3:	jne    171a <arena_make_backed+0x40>
    16f5:	lea    rdx,[rip+0x3094]        # 4790 <__PRETTY_FUNCTION__.9>
    16fc:	lea    rsi,[rip+0x2928]        # 402b <_IO_stdin_used+0x2b>
    1703:	lea    rax,[rip+0x29b6]        # 40c0 <_IO_stdin_used+0xc0>
    170a:	mov    rcx,rdx
    170d:	mov    edx,0x1e8
    1712:	mov    rdi,rax
    1715:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    171a:	cmp    QWORD PTR [rbp-0x38],0x0
    171f:	jne    1746 <arena_make_backed+0x6c>
    1721:	lea    rdx,[rip+0x3068]        # 4790 <__PRETTY_FUNCTION__.9>
    1728:	lea    rsi,[rip+0x28fc]        # 402b <_IO_stdin_used+0x2b>
    172f:	lea    rax,[rip+0x29da]        # 4110 <_IO_stdin_used+0x110>
    1736:	mov    rcx,rdx
    1739:	mov    edx,0x1e9
    173e:	mov    rdi,rax
    1741:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1746:	pxor   xmm0,xmm0
    174a:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174e:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    1752:	mov    rax,QWORD PTR [rbp-0x30]
    1756:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    175a:	mov    rax,QWORD PTR [rbp-0x38]
    175e:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    1762:	mov    eax,DWORD PTR [rbp-0x8]
    1765:	or     eax,0x1
    1768:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    176b:	mov    rcx,QWORD PTR [rbp-0x28]
    176f:	mov    rax,QWORD PTR [rbp-0x20]
    1773:	mov    rdx,QWORD PTR [rbp-0x18]
    1777:	mov    QWORD PTR [rcx],rax
    177a:	mov    QWORD PTR [rcx+0x8],rdx
    177e:	mov    rax,QWORD PTR [rbp-0x10]
    1782:	mov    rdx,QWORD PTR [rbp-0x8]
    1786:	mov    QWORD PTR [rcx+0x10],rax
    178a:	mov    QWORD PTR [rcx+0x18],rdx
}
    178e:	mov    rax,QWORD PTR [rbp-0x28]
    1792:	leave
    1793:	ret

0000000000001794 <arena_free>:

void arena_free(Arena *arena)
{
    1794:	push   rbp
    1795:	mov    rbp,rsp
    1798:	sub    rsp,0x10
    179c:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    17a0:	mov    rax,QWORD PTR [rbp-0x8]
    17a4:	mov    eax,DWORD PTR [rax+0x18]
    17a7:	and    eax,0x1
    17aa:	test   eax,eax
    17ac:	jne    17bd <arena_free+0x29>
  {
    free(arena->base);
    17ae:	mov    rax,QWORD PTR [rbp-0x8]
    17b2:	mov    rax,QWORD PTR [rax]
    17b5:	mov    rdi,rax
    17b8:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17bd:	mov    rax,QWORD PTR [rbp-0x8]
    17c1:	mov    edx,0x20
    17c6:	mov    esi,0x0
    17cb:	mov    rdi,rax
    17ce:	call   10a0 <memset@plt>
}
    17d3:	nop
    17d4:	leave
    17d5:	ret

00000000000017d6 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d6:	push   rbp
    17d7:	mov    rbp,rsp
    17da:	sub    rsp,0x40
    17de:	mov    QWORD PTR [rbp-0x28],rdi
    17e2:	mov    QWORD PTR [rbp-0x30],rsi
    17e6:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17ea:	mov    rax,QWORD PTR [rbp-0x28]
    17ee:	mov    rax,QWORD PTR [rax]
    17f1:	test   rax,rax
    17f4:	jne    181b <arena_alloc+0x45>
    17f6:	lea    rdx,[rip+0x2fab]        # 47a8 <__PRETTY_FUNCTION__.8>
    17fd:	lea    rsi,[rip+0x2827]        # 402b <_IO_stdin_used+0x2b>
    1804:	lea    rax,[rip+0x294d]        # 4158 <_IO_stdin_used+0x158>
    180b:	mov    rcx,rdx
    180e:	mov    edx,0x201
    1813:	mov    rdi,rax
    1816:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    181b:	mov    rax,QWORD PTR [rbp-0x28]
    181f:	mov    rdx,QWORD PTR [rax+0x10]
    1823:	mov    rax,QWORD PTR [rbp-0x38]
    1827:	add    rax,rdx
    182a:	lea    rdx,[rax-0x1]
    182e:	mov    rax,QWORD PTR [rbp-0x38]
    1832:	neg    rax
    1835:	and    rax,rdx
    1838:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    183c:	mov    rdx,QWORD PTR [rbp-0x18]
    1840:	mov    rax,QWORD PTR [rbp-0x30]
    1844:	add    rdx,rax
    1847:	mov    rax,QWORD PTR [rbp-0x28]
    184b:	mov    rax,QWORD PTR [rax+0x8]
    184f:	cmp    rdx,rax
    1852:	jle    18a7 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1854:	mov    rdx,QWORD PTR [rbp-0x18]
    1858:	mov    rax,QWORD PTR [rbp-0x30]
    185c:	add    rax,rdx
    185f:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1863:	mov    rax,QWORD PTR [rbp-0x28]
    1867:	mov    rsi,QWORD PTR [rax+0x8]
    186b:	mov    rcx,QWORD PTR [rbp-0x8]
    186f:	lea    rdx,[rip+0x291a]        # 4190 <_IO_stdin_used+0x190>
    1876:	lea    rax,[rip+0x27ae]        # 402b <_IO_stdin_used+0x2b>
    187d:	mov    r9,rsi
    1880:	mov    r8,rcx
    1883:	mov    rcx,rdx
    1886:	mov    edx,0x20a
    188b:	mov    rsi,rax
    188e:	mov    edi,0x0
    1893:	mov    eax,0x0
    1898:	call   14a4 <log_message>
    189d:	mov    edi,0xffffffff
    18a2:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a7:	mov    rax,QWORD PTR [rbp-0x28]
    18ab:	mov    rdx,QWORD PTR [rax]
    18ae:	mov    rax,QWORD PTR [rbp-0x18]
    18b2:	add    rax,rdx
    18b5:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b9:	mov    rdx,QWORD PTR [rbp-0x30]
    18bd:	mov    rax,QWORD PTR [rbp-0x10]
    18c1:	mov    esi,0x0
    18c6:	mov    rdi,rax
    18c9:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18ce:	mov    rdx,QWORD PTR [rbp-0x18]
    18d2:	mov    rax,QWORD PTR [rbp-0x30]
    18d6:	add    rdx,rax
    18d9:	mov    rax,QWORD PTR [rbp-0x28]
    18dd:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18e1:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e5:	leave
    18e6:	ret

00000000000018e7 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e7:	push   rbp
    18e8:	mov    rbp,rsp
    18eb:	sub    rsp,0x10
    18ef:	mov    QWORD PTR [rbp-0x8],rdi
    18f3:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f7:	mov    rax,QWORD PTR [rbp-0x8]
    18fb:	mov    rax,QWORD PTR [rax+0x10]
    18ff:	cmp    QWORD PTR [rbp-0x10],rax
    1903:	jl     192a <arena_pop_to+0x43>
    1905:	lea    rdx,[rip+0x2eac]        # 47b8 <__PRETTY_FUNCTION__.7>
    190c:	lea    rsi,[rip+0x2718]        # 402b <_IO_stdin_used+0x2b>
    1913:	lea    rax,[rip+0x28b6]        # 41d0 <_IO_stdin_used+0x1d0>
    191a:	mov    rcx,rdx
    191d:	mov    edx,0x21a
    1922:	mov    rdi,rax
    1925:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    192a:	mov    rax,QWORD PTR [rbp-0x8]
    192e:	mov    rdx,QWORD PTR [rbp-0x10]
    1932:	mov    QWORD PTR [rax+0x10],rdx
}
    1936:	nop
    1937:	leave
    1938:	ret

0000000000001939 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1939:	push   rbp
    193a:	mov    rbp,rsp
    193d:	sub    rsp,0x10
    1941:	mov    QWORD PTR [rbp-0x8],rdi
    1945:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1949:	mov    rax,QWORD PTR [rbp-0x8]
    194d:	mov    rax,QWORD PTR [rax+0x10]
    1951:	sub    rax,QWORD PTR [rbp-0x10]
    1955:	mov    rdx,rax
    1958:	mov    rax,QWORD PTR [rbp-0x8]
    195c:	mov    rsi,rdx
    195f:	mov    rdi,rax
    1962:	call   18e7 <arena_pop_to>
}
    1967:	nop
    1968:	leave
    1969:	ret

000000000000196a <arena_clear>:

void arena_clear(Arena *arena)
{
    196a:	push   rbp
    196b:	mov    rbp,rsp
    196e:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    1972:	mov    rax,QWORD PTR [rbp-0x8]
    1976:	mov    QWORD PTR [rax+0x10],0x0
}
    197e:	nop
    197f:	pop    rbp
    1980:	ret

0000000000001981 <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    1981:	push   rbp
    1982:	mov    rbp,rsp
    1985:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1989:	mov    rax,QWORD PTR [rbp-0x18]
    198d:	mov    QWORD PTR [rbp-0x10],rax
    1991:	mov    rax,QWORD PTR [rbp-0x18]
    1995:	mov    rax,QWORD PTR [rax+0x10]
    1999:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199d:	mov    rax,QWORD PTR [rbp-0x10]
    19a1:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a5:	pop    rbp
    19a6:	ret

00000000000019a7 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a7:	push   rbp
    19a8:	mov    rbp,rsp
    19ab:	sub    rsp,0x10
    19af:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b3:	mov    rax,QWORD PTR [rbp-0x8]
    19b7:	mov    rdx,QWORD PTR [rax+0x8]
    19bb:	mov    rax,QWORD PTR [rbp-0x8]
    19bf:	mov    rax,QWORD PTR [rax]
    19c2:	mov    rsi,rdx
    19c5:	mov    rdi,rax
    19c8:	call   18e7 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19cd:	mov    rax,QWORD PTR [rbp-0x8]
    19d1:	mov    edx,0x10
    19d6:	mov    esi,0x0
    19db:	mov    rdi,rax
    19de:	call   10a0 <memset@plt>
}
    19e3:	nop
    19e4:	leave
    19e5:	ret

00000000000019e6 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e6:	push   rbp
    19e7:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19ea:	mov    eax,0xf4240
}
    19ef:	pop    rbp
    19f0:	ret

00000000000019f1 <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19f1:	push   rbp
    19f2:	mov    rbp,rsp
    19f5:	sub    rsp,0x30
    19f9:	mov    rax,QWORD PTR fs:0x28
    1a02:	mov    QWORD PTR [rbp-0x8],rax
    1a06:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a08:	lea    rax,[rbp-0x20]
    1a0c:	mov    esi,0x0
    1a11:	mov    rdi,rax
    1a14:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a19:	call   19e6 <get_os_timer_freq>
    1a1e:	mov    rdx,QWORD PTR [rbp-0x20]
    1a22:	imul   rax,rdx
    1a26:	mov    rdx,QWORD PTR [rbp-0x18]
    1a2a:	add    rax,rdx
    1a2d:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a31:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a35:	mov    rdx,QWORD PTR [rbp-0x8]
    1a39:	sub    rdx,QWORD PTR fs:0x28
    1a42:	je     1a49 <read_os_timer+0x58>
    1a44:	call   1060 <__stack_chk_fail@plt>
    1a49:	leave
    1a4a:	ret

0000000000001a4b <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a4b:	push   rbp
    1a4c:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4f:	rdtsc
    1a51:	shl    rdx,0x20
    1a55:	or     rax,rdx
  return __rdtsc();
}
    1a58:	pop    rbp
    1a59:	ret

0000000000001a5a <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a5a:	push   rbp
    1a5b:	mov    rbp,rsp
    1a5e:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a62:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a6a:	call   19e6 <get_os_timer_freq>
    1a6f:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a73:	call   1a4b <read_cpu_timer>
    1a78:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a7c:	call   19f1 <read_os_timer>
    1a81:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a85:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8d:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a95:	mov    rax,QWORD PTR [rbp-0x40]
    1a99:	imul   rax,QWORD PTR [rbp-0x48]
    1a9e:	shr    rax,0x3
    1aa2:	movabs rdx,0x20c49ba5e353f7cf
    1aac:	mul    rdx
    1aaf:	mov    rax,rdx
    1ab2:	shr    rax,0x4
    1ab6:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1aba:	jmp    1ad1 <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1abc:	call   19f1 <read_os_timer>
    1ac1:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac5:	mov    rax,QWORD PTR [rbp-0x28]
    1ac9:	sub    rax,QWORD PTR [rbp-0x30]
    1acd:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ad1:	mov    rax,QWORD PTR [rbp-0x50]
    1ad5:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad9:	jb     1abc <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1adb:	call   1a4b <read_cpu_timer>
    1ae0:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae4:	mov    rax,QWORD PTR [rbp-0x18]
    1ae8:	sub    rax,QWORD PTR [rbp-0x38]
    1aec:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1af0:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af8:	cmp    QWORD PTR [rbp-0x50],0x0
    1afd:	jne    1b24 <estimate_cpu_freq+0xca>
    1aff:	lea    rdx,[rip+0x2cca]        # 47d0 <__PRETTY_FUNCTION__.6>
    1b06:	lea    rsi,[rip+0x2722]        # 422f <_IO_stdin_used+0x22f>
    1b0d:	lea    rax,[rip+0x2734]        # 4248 <_IO_stdin_used+0x248>
    1b14:	mov    rcx,rdx
    1b17:	mov    edx,0x3a
    1b1c:	mov    rdi,rax
    1b1f:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b24:	mov    rax,QWORD PTR [rbp-0x40]
    1b28:	imul   rax,QWORD PTR [rbp-0x10]
    1b2d:	mov    edx,0x0
    1b32:	div    QWORD PTR [rbp-0x50]
    1b36:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b3a:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3e:	leave
    1b3f:	ret

0000000000001b40 <cpu_time_in_seconds>:

static
f64 cpu_time_in_seconds(u64 cpu_time, u64 cpu_timer_frequency)
{
    1b40:	push   rbp
    1b41:	mov    rbp,rsp
    1b44:	mov    QWORD PTR [rbp-0x18],rdi
    1b48:	mov    QWORD PTR [rbp-0x20],rsi
  f64 result = 0.0;
    1b4c:	pxor   xmm0,xmm0
    1b50:	movsd  QWORD PTR [rbp-0x8],xmm0
  if (cpu_timer_frequency)
    1b55:	cmp    QWORD PTR [rbp-0x20],0x0
    1b5a:	je     1bbf <cpu_time_in_seconds+0x7f>
  {
    result = (f64)cpu_time / (f64)cpu_timer_frequency;
    1b5c:	mov    rax,QWORD PTR [rbp-0x18]
    1b60:	test   rax,rax
    1b63:	js     1b70 <cpu_time_in_seconds+0x30>
    1b65:	pxor   xmm0,xmm0
    1b69:	cvtsi2sd xmm0,rax
    1b6e:	jmp    1b89 <cpu_time_in_seconds+0x49>
    1b70:	mov    rdx,rax
    1b73:	shr    rdx,1
    1b76:	and    eax,0x1
    1b79:	or     rdx,rax
    1b7c:	pxor   xmm0,xmm0
    1b80:	cvtsi2sd xmm0,rdx
    1b85:	addsd  xmm0,xmm0
    1b89:	mov    rax,QWORD PTR [rbp-0x20]
    1b8d:	test   rax,rax
    1b90:	js     1b9d <cpu_time_in_seconds+0x5d>
    1b92:	pxor   xmm1,xmm1
    1b96:	cvtsi2sd xmm1,rax
    1b9b:	jmp    1bb6 <cpu_time_in_seconds+0x76>
    1b9d:	mov    rdx,rax
    1ba0:	shr    rdx,1
    1ba3:	and    eax,0x1
    1ba6:	or     rdx,rax
    1ba9:	pxor   xmm1,xmm1
    1bad:	cvtsi2sd xmm1,rdx
    1bb2:	addsd  xmm1,xmm1
    1bb6:	divsd  xmm0,xmm1
    1bba:	movsd  QWORD PTR [rbp-0x8],xmm0
  }

  return result;
    1bbf:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    1bc4:	pop    rbp
    1bc5:	ret

0000000000001bc6 <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1bc6:	push   rbp
    1bc7:	mov    rbp,rsp
    1bca:	push   rbx
    1bcb:	sub    rsp,0x30028
    1bd2:	mov    rax,QWORD PTR fs:0x28
    1bdb:	mov    QWORD PTR [rbp-0x18],rax
    1bdf:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1be1:	call   1a4b <read_cpu_timer>
    1be6:	mov    rbx,rax
  g_profiler = (Profiler)
    1be9:	lea    rax,[rip+0x55b0]        # 71a0 <g_profiler>
    1bf0:	mov    edx,0x30010
    1bf5:	mov    esi,0x0
    1bfa:	mov    rdi,rax
    1bfd:	call   10a0 <memset@plt>
    1c02:	mov    QWORD PTR [rip+0x5597],rbx        # 71a0 <g_profiler>
  };
}
    1c09:	nop
    1c0a:	mov    rax,QWORD PTR [rbp-0x18]
    1c0e:	sub    rax,QWORD PTR fs:0x28
    1c17:	je     1c1e <begin_profiling+0x58>
    1c19:	call   1060 <__stack_chk_fail@plt>
    1c1e:	mov    rbx,QWORD PTR [rbp-0x8]
    1c22:	leave
    1c23:	ret

0000000000001c24 <end_profiling>:

static
void end_profiling()
{
    1c24:	push   rbp
    1c25:	mov    rbp,rsp
    1c28:	sub    rsp,0x50
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1c2c:	call   1a4b <read_cpu_timer>
    1c31:	mov    rdx,rax
    1c34:	mov    rax,QWORD PTR [rip+0x5565]        # 71a0 <g_profiler>
    1c3b:	sub    rdx,rax
    1c3e:	mov    QWORD PTR [rbp-0x38],rdx

  if (total_delta)
    1c42:	cmp    QWORD PTR [rbp-0x38],0x0
    1c47:	je     1fee <end_profiling+0x3ca>
  {
    u64 freq = estimate_cpu_freq();
    1c4d:	call   1a5a <estimate_cpu_freq>
    1c52:	mov    QWORD PTR [rbp-0x30],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1c56:	mov    rax,QWORD PTR [rbp-0x38]
    1c5a:	test   rax,rax
    1c5d:	js     1c6a <end_profiling+0x46>
    1c5f:	pxor   xmm0,xmm0
    1c63:	cvtsi2sd xmm0,rax
    1c68:	jmp    1c83 <end_profiling+0x5f>
    1c6a:	mov    rdx,rax
    1c6d:	shr    rdx,1
    1c70:	and    eax,0x1
    1c73:	or     rdx,rax
    1c76:	pxor   xmm0,xmm0
    1c7a:	cvtsi2sd xmm0,rdx
    1c7f:	addsd  xmm0,xmm0
    1c83:	mov    rax,QWORD PTR [rbp-0x30]
    1c87:	test   rax,rax
    1c8a:	js     1c97 <end_profiling+0x73>
    1c8c:	pxor   xmm1,xmm1
    1c90:	cvtsi2sd xmm1,rax
    1c95:	jmp    1cb0 <end_profiling+0x8c>
    1c97:	mov    rdx,rax
    1c9a:	shr    rdx,1
    1c9d:	and    eax,0x1
    1ca0:	or     rdx,rax
    1ca3:	pxor   xmm1,xmm1
    1ca7:	cvtsi2sd xmm1,rdx
    1cac:	addsd  xmm1,xmm1
    1cb0:	movapd xmm2,xmm0
    1cb4:	divsd  xmm2,xmm1
    1cb8:	movsd  xmm0,QWORD PTR [rip+0x2bc8]        # 4888 <__PRETTY_FUNCTION__.0+0x18>
    1cc0:	mulsd  xmm2,xmm0
    1cc4:	movq   rcx,xmm2
    1cc9:	mov    rdx,QWORD PTR [rbp-0x30]
    1ccd:	mov    rax,QWORD PTR [rbp-0x38]
    1cd1:	lea    rdi,[rip+0x25c0]        # 4298 <_IO_stdin_used+0x298>
    1cd8:	movq   xmm0,rcx
    1cdd:	mov    rsi,rax
    1ce0:	mov    eax,0x1
    1ce5:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1cea:	pxor   xmm0,xmm0
    1cee:	movsd  QWORD PTR [rbp-0x48],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1cf3:	mov    QWORD PTR [rbp-0x40],0x0
    1cfb:	jmp    1fe0 <end_profiling+0x3bc>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1d00:	mov    rdx,QWORD PTR [rbp-0x40]
    1d04:	mov    rax,rdx
    1d07:	add    rax,rax
    1d0a:	add    rax,rdx
    1d0d:	shl    rax,0x4
    1d11:	lea    rdx,[rax+0x10]
    1d15:	lea    rax,[rip+0x5484]        # 71a0 <g_profiler>
    1d1c:	add    rax,rdx
    1d1f:	mov    QWORD PTR [rbp-0x28],rax

      if (zone->elapsed_inclusive)
    1d23:	mov    rax,QWORD PTR [rbp-0x28]
    1d27:	mov    rax,QWORD PTR [rax+0x18]
    1d2b:	test   rax,rax
    1d2e:	je     1fdb <end_profiling+0x3b7>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1d34:	mov    rax,QWORD PTR [rbp-0x28]
    1d38:	mov    rax,QWORD PTR [rax+0x10]
    1d3c:	test   rax,rax
    1d3f:	js     1d4c <end_profiling+0x128>
    1d41:	pxor   xmm0,xmm0
    1d45:	cvtsi2sd xmm0,rax
    1d4a:	jmp    1d65 <end_profiling+0x141>
    1d4c:	mov    rdx,rax
    1d4f:	shr    rdx,1
    1d52:	and    eax,0x1
    1d55:	or     rdx,rax
    1d58:	pxor   xmm0,xmm0
    1d5c:	cvtsi2sd xmm0,rdx
    1d61:	addsd  xmm0,xmm0
    1d65:	mov    rax,QWORD PTR [rbp-0x38]
    1d69:	test   rax,rax
    1d6c:	js     1d79 <end_profiling+0x155>
    1d6e:	pxor   xmm1,xmm1
    1d72:	cvtsi2sd xmm1,rax
    1d77:	jmp    1d92 <end_profiling+0x16e>
    1d79:	mov    rdx,rax
    1d7c:	shr    rdx,1
    1d7f:	and    eax,0x1
    1d82:	or     rdx,rax
    1d85:	pxor   xmm1,xmm1
    1d89:	cvtsi2sd xmm1,rdx
    1d8e:	addsd  xmm1,xmm1
    1d92:	movapd xmm2,xmm0
    1d96:	divsd  xmm2,xmm1
    1d9a:	movsd  xmm0,QWORD PTR [rip+0x2aee]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1da2:	mulsd  xmm0,xmm2
    1da6:	movsd  QWORD PTR [rbp-0x20],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1dab:	mov    rax,QWORD PTR [rbp-0x28]
    1daf:	mov    rsi,QWORD PTR [rax+0x10]
    1db3:	mov    rax,QWORD PTR [rbp-0x28]
    1db7:	mov    rdx,QWORD PTR [rax+0x20]
    1dbb:	mov    rax,QWORD PTR [rbp-0x28]
    1dbf:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1dc2:	mov    rcx,QWORD PTR [rbp-0x28]
    1dc6:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1dca:	mov    r9d,ecx
    1dcd:	mov    rcx,QWORD PTR [rbp-0x20]
    1dd1:	lea    rdi,[rip+0x24f0]        # 42c8 <_IO_stdin_used+0x2c8>
    1dd8:	movq   xmm0,rcx
    1ddd:	mov    r8,rsi
    1de0:	mov    rcx,rdx
    1de3:	mov    rdx,rax
    1de6:	mov    esi,r9d
    1de9:	mov    eax,0x1
    1dee:	call   1070 <printf@plt>

        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1df3:	mov    rax,QWORD PTR [rbp-0x28]
    1df7:	mov    rdx,QWORD PTR [rax+0x10]
    1dfb:	mov    rax,QWORD PTR [rbp-0x28]
    1dff:	mov    rax,QWORD PTR [rax+0x18]
    1e03:	cmp    rdx,rax
    1e06:	je     1eab <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1e0c:	mov    rax,QWORD PTR [rbp-0x28]
    1e10:	mov    rax,QWORD PTR [rax+0x18]
    1e14:	test   rax,rax
    1e17:	js     1e24 <end_profiling+0x200>
    1e19:	pxor   xmm0,xmm0
    1e1d:	cvtsi2sd xmm0,rax
    1e22:	jmp    1e3d <end_profiling+0x219>
    1e24:	mov    rdx,rax
    1e27:	shr    rdx,1
    1e2a:	and    eax,0x1
    1e2d:	or     rdx,rax
    1e30:	pxor   xmm0,xmm0
    1e34:	cvtsi2sd xmm0,rdx
    1e39:	addsd  xmm0,xmm0
    1e3d:	mov    rax,QWORD PTR [rbp-0x38]
    1e41:	test   rax,rax
    1e44:	js     1e51 <end_profiling+0x22d>
    1e46:	pxor   xmm1,xmm1
    1e4a:	cvtsi2sd xmm1,rax
    1e4f:	jmp    1e6a <end_profiling+0x246>
    1e51:	mov    rdx,rax
    1e54:	shr    rdx,1
    1e57:	and    eax,0x1
    1e5a:	or     rdx,rax
    1e5d:	pxor   xmm1,xmm1
    1e61:	cvtsi2sd xmm1,rdx
    1e66:	addsd  xmm1,xmm1
    1e6a:	movapd xmm2,xmm0
    1e6e:	divsd  xmm2,xmm1
    1e72:	movsd  xmm0,QWORD PTR [rip+0x2a16]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1e7a:	mulsd  xmm0,xmm2
    1e7e:	movsd  QWORD PTR [rbp-0x18],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1e83:	mov    rax,QWORD PTR [rbp-0x28]
    1e87:	mov    rax,QWORD PTR [rax+0x18]
    1e8b:	mov    rdx,QWORD PTR [rbp-0x18]
    1e8f:	lea    rcx,[rip+0x248a]        # 4320 <_IO_stdin_used+0x320>
    1e96:	movq   xmm0,rdx
    1e9b:	mov    rsi,rax
    1e9e:	mov    rdi,rcx
    1ea1:	mov    eax,0x1
    1ea6:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1eab:	movsd  xmm0,QWORD PTR [rbp-0x48]
    1eb0:	addsd  xmm0,QWORD PTR [rbp-0x20]
    1eb5:	movsd  QWORD PTR [rbp-0x48],xmm0

        if (zone->bytes_processed)
    1eba:	mov    rax,QWORD PTR [rbp-0x28]
    1ebe:	mov    rax,QWORD PTR [rax+0x28]
    1ec2:	test   rax,rax
    1ec5:	je     1fdb <end_profiling+0x3b7>
        {
          f64 megabytes = (f64)zone->bytes_processed / MB(1);
    1ecb:	mov    rax,QWORD PTR [rbp-0x28]
    1ecf:	mov    rax,QWORD PTR [rax+0x28]
    1ed3:	test   rax,rax
    1ed6:	js     1ee3 <end_profiling+0x2bf>
    1ed8:	pxor   xmm0,xmm0
    1edc:	cvtsi2sd xmm0,rax
    1ee1:	jmp    1efc <end_profiling+0x2d8>
    1ee3:	mov    rdx,rax
    1ee6:	shr    rdx,1
    1ee9:	and    eax,0x1
    1eec:	or     rdx,rax
    1eef:	pxor   xmm0,xmm0
    1ef3:	cvtsi2sd xmm0,rdx
    1ef8:	addsd  xmm0,xmm0
    1efc:	movsd  xmm1,QWORD PTR [rip+0x2994]        # 4898 <__PRETTY_FUNCTION__.0+0x28>
    1f04:	divsd  xmm0,xmm1
    1f08:	movsd  QWORD PTR [rbp-0x10],xmm0

          f64 gb_per_s = (f64)zone->bytes_processed / ((f64)zone->elapsed_inclusive / (f64)freq) / (f64)GB(1.0);
    1f0d:	mov    rax,QWORD PTR [rbp-0x28]
    1f11:	mov    rax,QWORD PTR [rax+0x28]
    1f15:	test   rax,rax
    1f18:	js     1f25 <end_profiling+0x301>
    1f1a:	pxor   xmm0,xmm0
    1f1e:	cvtsi2sd xmm0,rax
    1f23:	jmp    1f3e <end_profiling+0x31a>
    1f25:	mov    rdx,rax
    1f28:	shr    rdx,1
    1f2b:	and    eax,0x1
    1f2e:	or     rdx,rax
    1f31:	pxor   xmm0,xmm0
    1f35:	cvtsi2sd xmm0,rdx
    1f3a:	addsd  xmm0,xmm0
    1f3e:	mov    rax,QWORD PTR [rbp-0x28]
    1f42:	mov    rax,QWORD PTR [rax+0x18]
    1f46:	test   rax,rax
    1f49:	js     1f56 <end_profiling+0x332>
    1f4b:	pxor   xmm1,xmm1
    1f4f:	cvtsi2sd xmm1,rax
    1f54:	jmp    1f6f <end_profiling+0x34b>
    1f56:	mov    rdx,rax
    1f59:	shr    rdx,1
    1f5c:	and    eax,0x1
    1f5f:	or     rdx,rax
    1f62:	pxor   xmm1,xmm1
    1f66:	cvtsi2sd xmm1,rdx
    1f6b:	addsd  xmm1,xmm1
    1f6f:	mov    rax,QWORD PTR [rbp-0x30]
    1f73:	test   rax,rax
    1f76:	js     1f83 <end_profiling+0x35f>
    1f78:	pxor   xmm2,xmm2
    1f7c:	cvtsi2sd xmm2,rax
    1f81:	jmp    1f9c <end_profiling+0x378>
    1f83:	mov    rdx,rax
    1f86:	shr    rdx,1
    1f89:	and    eax,0x1
    1f8c:	or     rdx,rax
    1f8f:	pxor   xmm2,xmm2
    1f93:	cvtsi2sd xmm2,rdx
    1f98:	addsd  xmm2,xmm2
    1f9c:	divsd  xmm1,xmm2
    1fa0:	divsd  xmm0,xmm1
    1fa4:	movsd  xmm1,QWORD PTR [rip+0x28f4]        # 48a0 <__PRETTY_FUNCTION__.0+0x30>
    1fac:	divsd  xmm0,xmm1
    1fb0:	movsd  QWORD PTR [rbp-0x8],xmm0

          printf("  Megabytes Processed: %fMB @ %f GB/s\n", megabytes, gb_per_s);
    1fb5:	movsd  xmm0,QWORD PTR [rbp-0x8]
    1fba:	mov    rax,QWORD PTR [rbp-0x10]
    1fbe:	lea    rdx,[rip+0x238b]        # 4350 <_IO_stdin_used+0x350>
    1fc5:	movapd xmm1,xmm0
    1fc9:	movq   xmm0,rax
    1fce:	mov    rdi,rdx
    1fd1:	mov    eax,0x2
    1fd6:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1fdb:	add    QWORD PTR [rbp-0x40],0x1
    1fe0:	cmp    QWORD PTR [rbp-0x40],0xfff
    1fe8:	jbe    1d00 <end_profiling+0xdc>
        }
      }
    }
  }
}
    1fee:	nop
    1fef:	leave
    1ff0:	ret

0000000000001ff1 <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1ff1:	push   rbp
    1ff2:	mov    rbp,rsp
    1ff5:	push   rbx
    1ff6:	sub    rsp,0x78
    1ffa:	mov    QWORD PTR [rbp-0x58],rdi
    1ffe:	mov    rax,rsi
    2001:	mov    rsi,rdx
    2004:	mov    rax,rax
    2007:	mov    edx,0x0
    200c:	mov    rdx,rsi
    200f:	mov    QWORD PTR [rbp-0x70],rax
    2013:	mov    QWORD PTR [rbp-0x68],rdx
    2017:	mov    QWORD PTR [rbp-0x60],rcx
    201b:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    201f:	pxor   xmm0,xmm0
    2023:	movaps XMMWORD PTR [rbp-0x50],xmm0
    2027:	movaps XMMWORD PTR [rbp-0x40],xmm0
    202b:	movaps XMMWORD PTR [rbp-0x30],xmm0
    202f:	movq   QWORD PTR [rbp-0x20],xmm0
    2034:	mov    rax,QWORD PTR [rbp-0x70]
    2038:	mov    rdx,QWORD PTR [rbp-0x68]
    203c:	mov    QWORD PTR [rbp-0x50],rax
    2040:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    2044:	mov    rdx,QWORD PTR [rbp-0x60]
    2048:	mov    rax,rdx
    204b:	add    rax,rax
    204e:	add    rax,rdx
    2051:	shl    rax,0x4
    2055:	mov    rdx,rax
    2058:	lea    rax,[rip+0x5169]        # 71c8 <g_profiler+0x28>
    205f:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    2063:	mov    QWORD PTR [rbp-0x38],rax
    2067:	mov    rax,QWORD PTR [rbp-0x60]
    206b:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    206f:	mov    rax,QWORD PTR [rip+0x5132]        # 71a8 <g_profiler+0x8>
  Profile_Pass pass =
    2076:	mov    QWORD PTR [rbp-0x28],rax
    207a:	mov    rax,QWORD PTR [rbp-0x78]
    207e:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    2082:	mov    rax,QWORD PTR [rbp-0x60]
    2086:	mov    QWORD PTR [rip+0x511b],rax        # 71a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    208d:	call   1a4b <read_cpu_timer>
    2092:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    2096:	mov    rax,QWORD PTR [rbp-0x58]
    209a:	mov    rcx,QWORD PTR [rbp-0x50]
    209e:	mov    rbx,QWORD PTR [rbp-0x48]
    20a2:	mov    QWORD PTR [rax],rcx
    20a5:	mov    QWORD PTR [rax+0x8],rbx
    20a9:	mov    rcx,QWORD PTR [rbp-0x40]
    20ad:	mov    rbx,QWORD PTR [rbp-0x38]
    20b1:	mov    QWORD PTR [rax+0x10],rcx
    20b5:	mov    QWORD PTR [rax+0x18],rbx
    20b9:	mov    rcx,QWORD PTR [rbp-0x30]
    20bd:	mov    rbx,QWORD PTR [rbp-0x28]
    20c1:	mov    QWORD PTR [rax+0x20],rcx
    20c5:	mov    QWORD PTR [rax+0x28],rbx
    20c9:	mov    rdx,QWORD PTR [rbp-0x20]
    20cd:	mov    QWORD PTR [rax+0x30],rdx
}
    20d1:	mov    rax,QWORD PTR [rbp-0x58]
    20d5:	mov    rbx,QWORD PTR [rbp-0x8]
    20d9:	leave
    20da:	ret

00000000000020db <__profile_close_pass>:

static
void __profile_close_pass(Profile_Pass pass)
{
    20db:	push   rbp
    20dc:	mov    rbp,rsp
    20df:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    20e3:	call   1a4b <read_cpu_timer>
    20e8:	mov    rdx,rax
    20eb:	mov    rax,QWORD PTR [rbp+0x20]
    20ef:	sub    rdx,rax
    20f2:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    20f6:	mov    rax,QWORD PTR [rbp+0x38]
    20fa:	mov    QWORD PTR [rip+0x50a7],rax        # 71a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    2101:	mov    rdx,QWORD PTR [rbp+0x30]
    2105:	mov    rax,rdx
    2108:	add    rax,rax
    210b:	add    rax,rdx
    210e:	shl    rax,0x4
    2112:	lea    rdx,[rax+0x10]
    2116:	lea    rax,[rip+0x5083]        # 71a0 <g_profiler>
    211d:	add    rax,rdx
    2120:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    2124:	mov    rax,QWORD PTR [rbp-0x10]
    2128:	mov    rdx,QWORD PTR [rax+0x10]
    212c:	mov    rax,QWORD PTR [rbp-0x18]
    2130:	add    rdx,rax
    2133:	mov    rax,QWORD PTR [rbp-0x10]
    2137:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    213b:	mov    rax,QWORD PTR [rbp-0x10]
    213f:	mov    rax,QWORD PTR [rax+0x20]
    2143:	lea    rdx,[rax+0x1]
    2147:	mov    rax,QWORD PTR [rbp-0x10]
    214b:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    214f:	mov    rcx,QWORD PTR [rbp-0x10]
    2153:	mov    rax,QWORD PTR [rbp+0x10]
    2157:	mov    rdx,QWORD PTR [rbp+0x18]
    215b:	mov    QWORD PTR [rcx],rax
    215e:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    2162:	mov    rdx,QWORD PTR [rbp+0x28]
    2166:	mov    rax,QWORD PTR [rbp-0x18]
    216a:	add    rdx,rax
    216d:	mov    rax,QWORD PTR [rbp-0x10]
    2171:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    2175:	mov    rax,QWORD PTR [rbp-0x10]
    2179:	mov    rdx,QWORD PTR [rax+0x28]
    217d:	mov    rax,QWORD PTR [rbp+0x40]
    2181:	add    rdx,rax
    2184:	mov    rax,QWORD PTR [rbp-0x10]
    2188:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    218c:	mov    rdx,QWORD PTR [rbp+0x38]
    2190:	mov    rax,rdx
    2193:	add    rax,rax
    2196:	add    rax,rdx
    2199:	shl    rax,0x4
    219d:	lea    rdx,[rax+0x10]
    21a1:	lea    rax,[rip+0x4ff8]        # 71a0 <g_profiler>
    21a8:	add    rax,rdx
    21ab:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    21af:	mov    rax,QWORD PTR [rbp-0x8]
    21b3:	mov    rax,QWORD PTR [rax+0x10]
    21b7:	sub    rax,QWORD PTR [rbp-0x18]
    21bb:	mov    rdx,rax
    21be:	mov    rax,QWORD PTR [rbp-0x8]
    21c2:	mov    QWORD PTR [rax+0x10],rdx
}
    21c6:	nop
    21c7:	leave
    21c8:	ret

00000000000021c9 <parser_at>:
  b32    had_error;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    21c9:	push   rbp
    21ca:	mov    rbp,rsp
    21cd:	sub    rsp,0x10
    21d1:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    21d5:	mov    rax,QWORD PTR [rbp-0x8]
    21d9:	mov    rdx,QWORD PTR [rax+0x10]
    21dd:	mov    rax,QWORD PTR [rbp-0x8]
    21e1:	mov    rax,QWORD PTR [rax+0x8]
    21e5:	cmp    rdx,rax
    21e8:	jb     220f <parser_at+0x46>
    21ea:	lea    rdx,[rip+0x25f7]        # 47e8 <__PRETTY_FUNCTION__.5>
    21f1:	lea    rsi,[rip+0x228a]        # 4482 <_IO_stdin_used+0x482>
    21f8:	lea    rax,[rip+0x2299]        # 4498 <_IO_stdin_used+0x498>
    21ff:	mov    rcx,rdx
    2202:	mov    edx,0x30
    2207:	mov    rdi,rax
    220a:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    220f:	mov    rax,QWORD PTR [rbp-0x8]
    2213:	mov    rdx,QWORD PTR [rax]
    2216:	mov    rax,QWORD PTR [rbp-0x8]
    221a:	mov    rax,QWORD PTR [rax+0x10]
    221e:	add    rax,rdx
}
    2221:	leave
    2222:	ret

0000000000002223 <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    2223:	push   rbp
    2224:	mov    rbp,rsp
    2227:	sub    rsp,0x10
    222b:	mov    QWORD PTR [rbp-0x8],rdi
    222f:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    2233:	mov    rax,QWORD PTR [rbp-0x8]
    2237:	mov    rdi,rax
    223a:	call   21c9 <parser_at>
    223f:	mov    rdx,QWORD PTR [rbp-0x10]
    2243:	add    rax,rdx
}
    2246:	leave
    2247:	ret

0000000000002248 <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    2248:	push   rbp
    2249:	mov    rbp,rsp
    224c:	mov    QWORD PTR [rbp-0x8],rdi
    2250:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    2254:	mov    rax,QWORD PTR [rbp-0x8]
    2258:	mov    rdx,QWORD PTR [rax+0x10]
    225c:	mov    rax,QWORD PTR [rbp-0x10]
    2260:	add    rdx,rax
    2263:	mov    rax,QWORD PTR [rbp-0x8]
    2267:	mov    QWORD PTR [rax+0x10],rdx
}
    226b:	nop
    226c:	pop    rbp
    226d:	ret

000000000000226e <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    226e:	push   rbp
    226f:	mov    rbp,rsp
    2272:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count && !parser->had_error;
    2276:	mov    rax,QWORD PTR [rbp-0x8]
    227a:	mov    rdx,QWORD PTR [rax+0x10]
    227e:	mov    rax,QWORD PTR [rbp-0x8]
    2282:	mov    rax,QWORD PTR [rax+0x8]
    2286:	cmp    rdx,rax
    2289:	jae    229d <parser_incomplete+0x2f>
    228b:	mov    rax,QWORD PTR [rbp-0x8]
    228f:	mov    eax,DWORD PTR [rax+0x18]
    2292:	test   eax,eax
    2294:	jne    229d <parser_incomplete+0x2f>
    2296:	mov    eax,0x1
    229b:	jmp    22a2 <parser_incomplete+0x34>
    229d:	mov    eax,0x0
}
    22a2:	pop    rbp
    22a3:	ret

00000000000022a4 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    22a4:	push   rbp
    22a5:	mov    rbp,rsp
    22a8:	push   r12
    22aa:	push   rbx
    22ab:	sub    rsp,0x20
    22af:	mov    QWORD PTR [rbp-0x18],rdi
    22b3:	mov    rax,rsi
    22b6:	mov    rcx,rdx
    22b9:	mov    rax,rax
    22bc:	mov    edx,0x0
    22c1:	mov    rdx,rcx
    22c4:	mov    QWORD PTR [rbp-0x30],rax
    22c8:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    22cc:	mov    rax,QWORD PTR [rbp-0x28]
    22d0:	mov    r12,rax
    22d3:	mov    rbx,QWORD PTR [rbp-0x30]
    22d7:	mov    rax,QWORD PTR [rbp-0x18]
    22db:	mov    rdi,rax
    22de:	call   21c9 <parser_at>
    22e3:	mov    rdx,r12
    22e6:	mov    rsi,rbx
    22e9:	mov    rdi,rax
    22ec:	call   10d0 <memcmp@plt>
    22f1:	test   eax,eax
    22f3:	sete   al
}
    22f6:	add    rsp,0x20
    22fa:	pop    rbx
    22fb:	pop    r12
    22fd:	pop    rbp
    22fe:	ret

00000000000022ff <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    22ff:	push   rbp
    2300:	mov    rbp,rsp
    2303:	mov    eax,edi
    2305:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    2308:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    230c:	movzx  eax,BYTE PTR [rbp-0x14]
    2310:	cmp    eax,0x2e
    2313:	jg     231c <is_numeric+0x1d>
    2315:	cmp    eax,0x2d
    2318:	jge    2324 <is_numeric+0x25>
    231a:	jmp    2329 <is_numeric+0x2a>
    231c:	sub    eax,0x30
    231f:	cmp    eax,0x9
    2322:	ja     2329 <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2324:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    2328:	nop
  }


  return result;
    2329:	movzx  eax,BYTE PTR [rbp-0x1]
}
    232d:	pop    rbp
    232e:	ret

000000000000232f <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    232f:	push   rbp
    2330:	mov    rbp,rsp
    2333:	sub    rsp,0x50
    2337:	mov    QWORD PTR [rbp-0x48],rdi
    233b:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    233f:	pxor   xmm0,xmm0
    2343:	movaps XMMWORD PTR [rbp-0x20],xmm0
    2347:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    234c:	jmp    235f <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    234e:	mov    rax,QWORD PTR [rbp-0x50]
    2352:	mov    esi,0x1
    2357:	mov    rdi,rax
    235a:	call   2248 <parser_advance>
  while (parser_incomplete(parser)  &&
    235f:	mov    rax,QWORD PTR [rbp-0x50]
    2363:	mov    rdi,rax
    2366:	call   226e <parser_incomplete>
    236b:	test   al,al
    236d:	je     23bb <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    236f:	mov    rax,QWORD PTR [rbp-0x50]
    2373:	mov    rdi,rax
    2376:	call   21c9 <parser_at>
    237b:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    237e:	cmp    al,0x20
    2380:	je     234e <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    2382:	mov    rax,QWORD PTR [rbp-0x50]
    2386:	mov    rdi,rax
    2389:	call   21c9 <parser_at>
    238e:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    2391:	cmp    al,0xa
    2393:	je     234e <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    2395:	mov    rax,QWORD PTR [rbp-0x50]
    2399:	mov    rdi,rax
    239c:	call   21c9 <parser_at>
    23a1:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    23a4:	cmp    al,0xd
    23a6:	je     234e <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    23a8:	mov    rax,QWORD PTR [rbp-0x50]
    23ac:	mov    rdi,rax
    23af:	call   21c9 <parser_at>
    23b4:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    23b7:	cmp    al,0x9
    23b9:	je     234e <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    23bb:	mov    rax,QWORD PTR [rbp-0x50]
    23bf:	mov    rdi,rax
    23c2:	call   226e <parser_incomplete>
    23c7:	test   al,al
    23c9:	je     2817 <get_json_token+0x4e8>
  {
    token.value.data = parser_at(parser);
    23cf:	mov    rax,QWORD PTR [rbp-0x50]
    23d3:	mov    rdi,rax
    23d6:	call   21c9 <parser_at>
    23db:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    23df:	mov    rax,QWORD PTR [rbp-0x50]
    23e3:	mov    rdi,rax
    23e6:	call   21c9 <parser_at>
    23eb:	movzx  eax,BYTE PTR [rax]
    23ee:	movzx  eax,al
    23f1:	cmp    eax,0x7d
    23f4:	je     24e1 <get_json_token+0x1b2>
    23fa:	cmp    eax,0x7d
    23fd:	jg     2828 <get_json_token+0x4f9>
    2403:	cmp    eax,0x7b
    2406:	je     24bc <get_json_token+0x18d>
    240c:	cmp    eax,0x7b
    240f:	jg     2828 <get_json_token+0x4f9>
    2415:	cmp    eax,0x74
    2418:	je     2664 <get_json_token+0x335>
    241e:	cmp    eax,0x74
    2421:	jg     2828 <get_json_token+0x4f9>
    2427:	cmp    eax,0x6e
    242a:	je     278a <get_json_token+0x45b>
    2430:	cmp    eax,0x6e
    2433:	jg     2828 <get_json_token+0x4f9>
    2439:	cmp    eax,0x66
    243c:	je     26f7 <get_json_token+0x3c8>
    2442:	cmp    eax,0x66
    2445:	jg     2828 <get_json_token+0x4f9>
    244b:	cmp    eax,0x5d
    244e:	je     252b <get_json_token+0x1fc>
    2454:	cmp    eax,0x5d
    2457:	jg     2828 <get_json_token+0x4f9>
    245d:	cmp    eax,0x5b
    2460:	je     2506 <get_json_token+0x1d7>
    2466:	cmp    eax,0x5b
    2469:	jg     2828 <get_json_token+0x4f9>
    246f:	cmp    eax,0x3a
    2472:	je     2575 <get_json_token+0x246>
    2478:	cmp    eax,0x3a
    247b:	jg     2828 <get_json_token+0x4f9>
    2481:	cmp    eax,0x39
    2484:	jg     2828 <get_json_token+0x4f9>
    248a:	cmp    eax,0x30
    248d:	jge    2613 <get_json_token+0x2e4>
    2493:	cmp    eax,0x2e
    2496:	jg     2828 <get_json_token+0x4f9>
    249c:	cmp    eax,0x2d
    249f:	jge    2613 <get_json_token+0x2e4>
    24a5:	cmp    eax,0x22
    24a8:	je     259a <get_json_token+0x26b>
    24ae:	cmp    eax,0x2c
    24b1:	je     2550 <get_json_token+0x221>
    24b7:	jmp    2828 <get_json_token+0x4f9>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    24bc:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    24c3:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24cb:	mov    rax,QWORD PTR [rbp-0x50]
    24cf:	mov    esi,0x1
    24d4:	mov    rdi,rax
    24d7:	call   2248 <parser_advance>
      }
      break;
    24dc:	jmp    2828 <get_json_token+0x4f9>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    24e1:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    24e8:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24f0:	mov    rax,QWORD PTR [rbp-0x50]
    24f4:	mov    esi,0x1
    24f9:	mov    rdi,rax
    24fc:	call   2248 <parser_advance>
      }
      break;
    2501:	jmp    2828 <get_json_token+0x4f9>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2506:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    250d:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2515:	mov    rax,QWORD PTR [rbp-0x50]
    2519:	mov    esi,0x1
    251e:	mov    rdi,rax
    2521:	call   2248 <parser_advance>
      }
      break;
    2526:	jmp    2828 <get_json_token+0x4f9>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    252b:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    2532:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    253a:	mov    rax,QWORD PTR [rbp-0x50]
    253e:	mov    esi,0x1
    2543:	mov    rdi,rax
    2546:	call   2248 <parser_advance>
      }
      break;
    254b:	jmp    2828 <get_json_token+0x4f9>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    2550:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    2557:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    255f:	mov    rax,QWORD PTR [rbp-0x50]
    2563:	mov    esi,0x1
    2568:	mov    rdi,rax
    256b:	call   2248 <parser_advance>
      }
      break;
    2570:	jmp    2828 <get_json_token+0x4f9>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    2575:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    257c:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2584:	mov    rax,QWORD PTR [rbp-0x50]
    2588:	mov    esi,0x1
    258d:	mov    rdi,rax
    2590:	call   2248 <parser_advance>
      }
      break;
    2595:	jmp    2828 <get_json_token+0x4f9>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    259a:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    25a1:	mov    rax,QWORD PTR [rbp-0x50]
    25a5:	mov    esi,0x1
    25aa:	mov    rdi,rax
    25ad:	call   2248 <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    25b2:	mov    rax,QWORD PTR [rbp-0x50]
    25b6:	mov    rdi,rax
    25b9:	call   21c9 <parser_at>
    25be:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    25c2:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    25ca:	jmp    25e2 <get_json_token+0x2b3>
        {
          string_count += 1;
    25cc:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    25d1:	mov    rax,QWORD PTR [rbp-0x50]
    25d5:	mov    esi,0x1
    25da:	mov    rdi,rax
    25dd:	call   2248 <parser_advance>
        while (*parser_at(parser) != '"')
    25e2:	mov    rax,QWORD PTR [rbp-0x50]
    25e6:	mov    rdi,rax
    25e9:	call   21c9 <parser_at>
    25ee:	movzx  eax,BYTE PTR [rax]
    25f1:	cmp    al,0x22
    25f3:	jne    25cc <get_json_token+0x29d>
        }
        token.value.count = string_count;
    25f5:	mov    rax,QWORD PTR [rbp-0x40]
    25f9:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    25fd:	mov    rax,QWORD PTR [rbp-0x50]
    2601:	mov    esi,0x1
    2606:	mov    rdi,rax
    2609:	call   2248 <parser_advance>
      }
      break;
    260e:	jmp    2828 <get_json_token+0x4f9>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2613:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    261a:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2622:	jmp    263a <get_json_token+0x30b>
        {
          digit_count += 1;
    2624:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    2629:	mov    rax,QWORD PTR [rbp-0x50]
    262d:	mov    esi,0x1
    2632:	mov    rdi,rax
    2635:	call   2248 <parser_advance>
        while (is_numeric(*parser_at(parser)))
    263a:	mov    rax,QWORD PTR [rbp-0x50]
    263e:	mov    rdi,rax
    2641:	call   21c9 <parser_at>
    2646:	movzx  eax,BYTE PTR [rax]
    2649:	movzx  eax,al
    264c:	mov    edi,eax
    264e:	call   22ff <is_numeric>
    2653:	test   al,al
    2655:	jne    2624 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    2657:	mov    rax,QWORD PTR [rbp-0x38]
    265b:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    265f:	jmp    2828 <get_json_token+0x4f9>
      case 't':
      {
        String string = String("true");
    2664:	lea    rax,[rip+0x1e79]        # 44e4 <_IO_stdin_used+0x4e4>
    266b:	mov    QWORD PTR [rbp-0x30],rax
    266f:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    2677:	mov    rcx,QWORD PTR [rbp-0x30]
    267b:	mov    rdx,QWORD PTR [rbp-0x28]
    267f:	mov    rax,QWORD PTR [rbp-0x50]
    2683:	mov    rsi,rcx
    2686:	mov    rdi,rax
    2689:	call   22a4 <parser_token_is_literal>
    268e:	test   al,al
    2690:	je     26b4 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    2692:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    2699:	mov    rax,QWORD PTR [rbp-0x28]
    269d:	mov    rdx,rax
    26a0:	mov    rax,QWORD PTR [rbp-0x50]
    26a4:	mov    rsi,rdx
    26a7:	mov    rdi,rax
    26aa:	call   2248 <parser_advance>
    26af:	jmp    2828 <get_json_token+0x4f9>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    26b4:	mov    rax,QWORD PTR [rbp-0x50]
    26b8:	mov    rcx,QWORD PTR [rax+0x10]
    26bc:	lea    rdx,[rip+0x1e2d]        # 44f0 <_IO_stdin_used+0x4f0>
    26c3:	lea    rax,[rip+0x1db8]        # 4482 <_IO_stdin_used+0x482>
    26ca:	mov    r8,rcx
    26cd:	mov    rcx,rdx
    26d0:	mov    edx,0xe0
    26d5:	mov    rsi,rax
    26d8:	mov    edi,0x1
    26dd:	mov    eax,0x0
    26e2:	call   14a4 <log_message>
          parser->had_error = true;
    26e7:	mov    rax,QWORD PTR [rbp-0x50]
    26eb:	mov    DWORD PTR [rax+0x18],0x1
        }
      }
      break;
    26f2:	jmp    2828 <get_json_token+0x4f9>
      case 'f':
      {
        String string = String("false");
    26f7:	lea    rax,[rip+0x1e1f]        # 451d <_IO_stdin_used+0x51d>
    26fe:	mov    QWORD PTR [rbp-0x30],rax
    2702:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    270a:	mov    rcx,QWORD PTR [rbp-0x30]
    270e:	mov    rdx,QWORD PTR [rbp-0x28]
    2712:	mov    rax,QWORD PTR [rbp-0x50]
    2716:	mov    rsi,rcx
    2719:	mov    rdi,rax
    271c:	call   22a4 <parser_token_is_literal>
    2721:	test   al,al
    2723:	je     2747 <get_json_token+0x418>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    2725:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    272c:	mov    rax,QWORD PTR [rbp-0x28]
    2730:	mov    rdx,rax
    2733:	mov    rax,QWORD PTR [rbp-0x50]
    2737:	mov    rsi,rdx
    273a:	mov    rdi,rax
    273d:	call   2248 <parser_advance>
    2742:	jmp    2828 <get_json_token+0x4f9>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2747:	mov    rax,QWORD PTR [rbp-0x50]
    274b:	mov    rcx,QWORD PTR [rax+0x10]
    274f:	lea    rdx,[rip+0x1d9a]        # 44f0 <_IO_stdin_used+0x4f0>
    2756:	lea    rax,[rip+0x1d25]        # 4482 <_IO_stdin_used+0x482>
    275d:	mov    r8,rcx
    2760:	mov    rcx,rdx
    2763:	mov    edx,0xf0
    2768:	mov    rsi,rax
    276b:	mov    edi,0x1
    2770:	mov    eax,0x0
    2775:	call   14a4 <log_message>
          parser->had_error = true;
    277a:	mov    rax,QWORD PTR [rbp-0x50]
    277e:	mov    DWORD PTR [rax+0x18],0x1
        }
      }
      break;
    2785:	jmp    2828 <get_json_token+0x4f9>
      case 'n':
      {
        String string = String("null");
    278a:	lea    rax,[rip+0x1d92]        # 4523 <_IO_stdin_used+0x523>
    2791:	mov    QWORD PTR [rbp-0x30],rax
    2795:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    279d:	mov    rcx,QWORD PTR [rbp-0x30]
    27a1:	mov    rdx,QWORD PTR [rbp-0x28]
    27a5:	mov    rax,QWORD PTR [rbp-0x50]
    27a9:	mov    rsi,rcx
    27ac:	mov    rdi,rax
    27af:	call   22a4 <parser_token_is_literal>
    27b4:	test   al,al
    27b6:	je     27d7 <get_json_token+0x4a8>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    27b8:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    27bf:	mov    rax,QWORD PTR [rbp-0x28]
    27c3:	mov    rdx,rax
    27c6:	mov    rax,QWORD PTR [rbp-0x50]
    27ca:	mov    rsi,rdx
    27cd:	mov    rdi,rax
    27d0:	call   2248 <parser_advance>
    27d5:	jmp    2828 <get_json_token+0x4f9>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    27d7:	mov    rax,QWORD PTR [rbp-0x50]
    27db:	mov    rcx,QWORD PTR [rax+0x10]
    27df:	lea    rdx,[rip+0x1d0a]        # 44f0 <_IO_stdin_used+0x4f0>
    27e6:	lea    rax,[rip+0x1c95]        # 4482 <_IO_stdin_used+0x482>
    27ed:	mov    r8,rcx
    27f0:	mov    rcx,rdx
    27f3:	mov    edx,0x100
    27f8:	mov    rsi,rax
    27fb:	mov    edi,0x1
    2800:	mov    eax,0x0
    2805:	call   14a4 <log_message>
          parser->had_error = true;
    280a:	mov    rax,QWORD PTR [rbp-0x50]
    280e:	mov    DWORD PTR [rax+0x18],0x1
        }
      }
      break;
    2815:	jmp    2828 <get_json_token+0x4f9>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    2817:	mov    rax,QWORD PTR [rbp-0x50]
    281b:	mov    esi,0x1
    2820:	mov    rdi,rax
    2823:	call   2248 <parser_advance>
  }

  return token;
    2828:	mov    rcx,QWORD PTR [rbp-0x48]
    282c:	mov    rax,QWORD PTR [rbp-0x20]
    2830:	mov    rdx,QWORD PTR [rbp-0x18]
    2834:	mov    QWORD PTR [rcx],rax
    2837:	mov    QWORD PTR [rcx+0x8],rdx
    283b:	mov    rax,QWORD PTR [rbp-0x10]
    283f:	mov    QWORD PTR [rcx+0x10],rax
}
    2843:	mov    rax,QWORD PTR [rbp-0x48]
    2847:	leave
    2848:	ret

0000000000002849 <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    2849:	push   rbp
    284a:	mov    rbp,rsp
    284d:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    2850:	cmp    DWORD PTR [rbp-0x14],0x7
    2854:	je     286e <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2856:	cmp    DWORD PTR [rbp-0x14],0x9
    285a:	je     286e <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    285c:	cmp    DWORD PTR [rbp-0x14],0xa
    2860:	je     286e <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    2862:	cmp    DWORD PTR [rbp-0x14],0xb
    2866:	je     286e <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    2868:	cmp    DWORD PTR [rbp-0x14],0x8
    286c:	jne    2875 <json_token_type_is_value_type+0x2c>
    286e:	mov    eax,0x1
    2873:	jmp    287a <json_token_type_is_value_type+0x31>
    2875:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    287a:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    287d:	mov    eax,DWORD PTR [rbp-0x4]
}
    2880:	pop    rbp
    2881:	ret

0000000000002882 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    2882:	push   rbp
    2883:	mov    rbp,rsp
    2886:	push   rbx
    2887:	sub    rsp,0x88
    288e:	mov    QWORD PTR [rbp-0x78],rdi
    2892:	mov    QWORD PTR [rbp-0x80],rsi
    2896:	mov    QWORD PTR [rbp-0x90],rdx
    289d:	mov    QWORD PTR [rbp-0x88],rcx
    28a4:	mov    rax,QWORD PTR fs:0x28
    28ad:	mov    QWORD PTR [rbp-0x18],rax
    28b1:	xor    eax,eax
  profile_begin_func();
    28b3:	lea    r8,[rip+0x1f46]        # 4800 <__func__.4>
    28ba:	mov    r9d,0x11
    28c0:	lea    rax,[rbp-0x50]
    28c4:	mov    rsi,r8
    28c7:	mov    rdx,r9
    28ca:	mov    r8d,0x0
    28d0:	mov    ecx,0x1
    28d5:	mov    rdi,rax
    28d8:	call   1ff1 <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    28dd:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    28e5:	mov    eax,DWORD PTR [rbp+0x10]
    28e8:	cmp    eax,0x1
    28eb:	jne    2917 <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    28ed:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    28f4:	mov    edx,DWORD PTR [rbp-0x64]
    28f7:	mov    rsi,QWORD PTR [rbp-0x80]
    28fb:	mov    rax,QWORD PTR [rbp-0x78]
    28ff:	mov    ecx,edx
    2901:	mov    edx,0x2
    2906:	mov    rdi,rax
    2909:	call   2a74 <parse_json_children>
    290e:	mov    QWORD PTR [rbp-0x60],rax
    2912:	jmp    29ac <parse_json_object+0x12a>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2917:	mov    eax,DWORD PTR [rbp+0x10]
    291a:	cmp    eax,0x3
    291d:	jne    2946 <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    291f:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2926:	mov    edx,DWORD PTR [rbp-0x68]
    2929:	mov    rsi,QWORD PTR [rbp-0x80]
    292d:	mov    rax,QWORD PTR [rbp-0x78]
    2931:	mov    ecx,edx
    2933:	mov    edx,0x4
    2938:	mov    rdi,rax
    293b:	call   2a74 <parse_json_children>
    2940:	mov    QWORD PTR [rbp-0x60],rax
    2944:	jmp    29ac <parse_json_object+0x12a>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    2946:	mov    eax,DWORD PTR [rbp+0x10]
    2949:	mov    edi,eax
    294b:	call   2849 <json_token_type_is_value_type>
    2950:	test   eax,eax
    2952:	jne    29ac <parse_json_object+0x12a>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2954:	mov    eax,DWORD PTR [rbp+0x10]
    2957:	mov    eax,eax
    2959:	lea    rdx,[rax*8+0x0]
    2961:	lea    rax,[rip+0x4778]        # 70e0 <JSON_Token_Type_strings>
    2968:	mov    rcx,QWORD PTR [rdx+rax*1]
    296c:	lea    rdx,[rip+0x1bb5]        # 4528 <_IO_stdin_used+0x528>
    2973:	lea    rax,[rip+0x1b08]        # 4482 <_IO_stdin_used+0x482>
    297a:	push   QWORD PTR [rbp+0x20]
    297d:	push   QWORD PTR [rbp+0x18]
    2980:	mov    r8,rcx
    2983:	mov    rcx,rdx
    2986:	mov    edx,0x138
    298b:	mov    rsi,rax
    298e:	mov    edi,0x1
    2993:	mov    eax,0x0
    2998:	call   14a4 <log_message>
    299d:	add    rsp,0x10
          parser->had_error = true;
    29a1:	mov    rax,QWORD PTR [rbp-0x80]
    29a5:	mov    DWORD PTR [rax+0x18],0x1
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    29ac:	mov    rax,QWORD PTR [rbp-0x78]
    29b0:	mov    edx,0x8
    29b5:	mov    esi,0x30
    29ba:	mov    rdi,rax
    29bd:	call   17d6 <arena_alloc>
    29c2:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    29c6:	mov    rcx,QWORD PTR [rbp-0x58]
    29ca:	mov    rax,QWORD PTR [rbp-0x90]
    29d1:	mov    rdx,QWORD PTR [rbp-0x88]
    29d8:	mov    QWORD PTR [rcx],rax
    29db:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    29df:	mov    rax,QWORD PTR [rbp-0x58]
    29e3:	mov    rdx,QWORD PTR [rbp-0x60]
    29e7:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    29eb:	mov    rax,QWORD PTR [rbp-0x58]
    29ef:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    29f7:	mov    rcx,QWORD PTR [rbp-0x58]
    29fb:	mov    rax,QWORD PTR [rbp+0x18]
    29ff:	mov    rdx,QWORD PTR [rbp+0x20]
    2a03:	mov    QWORD PTR [rcx+0x10],rax
    2a07:	mov    QWORD PTR [rcx+0x18],rdx

  profile_close_func();
    2a0b:	sub    rsp,0x8
    2a0f:	sub    rsp,0x38
    2a13:	mov    rax,rsp
    2a16:	mov    rcx,QWORD PTR [rbp-0x50]
    2a1a:	mov    rbx,QWORD PTR [rbp-0x48]
    2a1e:	mov    QWORD PTR [rax],rcx
    2a21:	mov    QWORD PTR [rax+0x8],rbx
    2a25:	mov    rcx,QWORD PTR [rbp-0x40]
    2a29:	mov    rbx,QWORD PTR [rbp-0x38]
    2a2d:	mov    QWORD PTR [rax+0x10],rcx
    2a31:	mov    QWORD PTR [rax+0x18],rbx
    2a35:	mov    rcx,QWORD PTR [rbp-0x30]
    2a39:	mov    rbx,QWORD PTR [rbp-0x28]
    2a3d:	mov    QWORD PTR [rax+0x20],rcx
    2a41:	mov    QWORD PTR [rax+0x28],rbx
    2a45:	mov    rdx,QWORD PTR [rbp-0x20]
    2a49:	mov    QWORD PTR [rax+0x30],rdx
    2a4d:	call   20db <__profile_close_pass>
    2a52:	add    rsp,0x40

  return result;
    2a56:	mov    rax,QWORD PTR [rbp-0x58]
}
    2a5a:	mov    rdx,QWORD PTR [rbp-0x18]
    2a5e:	sub    rdx,QWORD PTR fs:0x28
    2a67:	je     2a6e <parse_json_object+0x1ec>
    2a69:	call   1060 <__stack_chk_fail@plt>
    2a6e:	mov    rbx,QWORD PTR [rbp-0x8]
    2a72:	leave
    2a73:	ret

0000000000002a74 <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    2a74:	push   rbp
    2a75:	mov    rbp,rsp
    2a78:	push   rbx
    2a79:	sub    rsp,0x108
    2a80:	mov    QWORD PTR [rbp-0xd8],rdi
    2a87:	mov    QWORD PTR [rbp-0xe0],rsi
    2a8e:	mov    DWORD PTR [rbp-0xe4],edx
    2a94:	mov    DWORD PTR [rbp-0xe8],ecx
    2a9a:	mov    rax,QWORD PTR fs:0x28
    2aa3:	mov    QWORD PTR [rbp-0x18],rax
    2aa7:	xor    eax,eax
  profile_begin_func();
    2aa9:	lea    r8,[rip+0x1d70]        # 4820 <__func__.3>
    2ab0:	mov    r9d,0x13
    2ab6:	lea    rax,[rbp-0x50]
    2aba:	mov    rsi,r8
    2abd:	mov    rdx,r9
    2ac0:	mov    r8d,0x0
    2ac6:	mov    ecx,0x2
    2acb:	mov    rdi,rax
    2ace:	call   1ff1 <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2ad3:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    2ade:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2ae9:	jmp    2df0 <parse_json_children+0x37c>
  {
    JSON_Token key_token = {0};
    2aee:	pxor   xmm0,xmm0
    2af2:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2af9:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2b01:	pxor   xmm0,xmm0
    2b05:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2b0c:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2b11:	cmp    DWORD PTR [rbp-0xe8],0x0
    2b18:	je     2c45 <parse_json_children+0x1d1>
    {
      key_token = get_json_token(parser);
    2b1e:	lea    rax,[rbp-0xb0]
    2b25:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b2c:	mov    rsi,rdx
    2b2f:	mov    rdi,rax
    2b32:	call   232f <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2b37:	mov    eax,DWORD PTR [rbp-0xb0]
    2b3d:	cmp    eax,0x7
    2b40:	jne    2bd3 <parse_json_children+0x15f>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2b46:	lea    rax,[rbp-0x70]
    2b4a:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b51:	mov    rsi,rdx
    2b54:	mov    rdi,rax
    2b57:	call   232f <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2b5c:	mov    eax,DWORD PTR [rbp-0x70]
    2b5f:	cmp    eax,0x6
    2b62:	jne    2b82 <parse_json_children+0x10e>
        {
          value_token = get_json_token(parser);
    2b64:	lea    rax,[rbp-0x90]
    2b6b:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b72:	mov    rsi,rdx
    2b75:	mov    rdi,rax
    2b78:	call   232f <get_json_token>
    2b7d:	jmp    2c85 <parse_json_children+0x211>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2b82:	mov    rcx,QWORD PTR [rbp-0xa8]
    2b89:	mov    rax,QWORD PTR [rbp-0xa0]
    2b90:	mov    esi,eax
    2b92:	lea    rdx,[rip+0x19df]        # 4578 <_IO_stdin_used+0x578>
    2b99:	lea    rax,[rip+0x18e2]        # 4482 <_IO_stdin_used+0x482>
    2ba0:	mov    r9,rcx
    2ba3:	mov    r8d,esi
    2ba6:	mov    rcx,rdx
    2ba9:	mov    edx,0x164
    2bae:	mov    rsi,rax
    2bb1:	mov    edi,0x1
    2bb6:	mov    eax,0x0
    2bbb:	call   14a4 <log_message>
          parser->had_error = true;
    2bc0:	mov    rax,QWORD PTR [rbp-0xe0]
    2bc7:	mov    DWORD PTR [rax+0x18],0x1
    2bce:	jmp    2c85 <parse_json_children+0x211>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2bd3:	mov    rcx,QWORD PTR [rbp-0xa8]
    2bda:	mov    rax,QWORD PTR [rbp-0xa0]
    2be1:	mov    edi,eax
    2be3:	mov    eax,DWORD PTR [rbp-0xb0]
    2be9:	mov    eax,eax
    2beb:	lea    rdx,[rax*8+0x0]
    2bf3:	lea    rax,[rip+0x44e6]        # 70e0 <JSON_Token_Type_strings>
    2bfa:	mov    rsi,QWORD PTR [rdx+rax*1]
    2bfe:	lea    rdx,[rip+0x1993]        # 4598 <_IO_stdin_used+0x598>
    2c05:	lea    rax,[rip+0x1876]        # 4482 <_IO_stdin_used+0x482>
    2c0c:	sub    rsp,0x8
    2c10:	push   rcx
    2c11:	mov    r9d,edi
    2c14:	mov    r8,rsi
    2c17:	mov    rcx,rdx
    2c1a:	mov    edx,0x16a
    2c1f:	mov    rsi,rax
    2c22:	mov    edi,0x1
    2c27:	mov    eax,0x0
    2c2c:	call   14a4 <log_message>
    2c31:	add    rsp,0x10
        parser->had_error = true;
    2c35:	mov    rax,QWORD PTR [rbp-0xe0]
    2c3c:	mov    DWORD PTR [rax+0x18],0x1
    2c43:	jmp    2c85 <parse_json_children+0x211>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2c45:	lea    rax,[rbp-0x110]
    2c4c:	mov    rdx,QWORD PTR [rbp-0xe0]
    2c53:	mov    rsi,rdx
    2c56:	mov    rdi,rax
    2c59:	call   232f <get_json_token>
    2c5e:	mov    rax,QWORD PTR [rbp-0x110]
    2c65:	mov    rdx,QWORD PTR [rbp-0x108]
    2c6c:	mov    QWORD PTR [rbp-0x90],rax
    2c73:	mov    QWORD PTR [rbp-0x88],rdx
    2c7a:	mov    rax,QWORD PTR [rbp-0x100]
    2c81:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2c85:	mov    eax,DWORD PTR [rbp-0x90]
    2c8b:	cmp    DWORD PTR [rbp-0xe4],eax
    2c91:	je     2e09 <parse_json_children+0x395>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2c97:	mov    rax,QWORD PTR [rbp-0xa8]
    2c9e:	mov    rdx,QWORD PTR [rbp-0xa0]
    2ca5:	mov    r8,QWORD PTR [rbp-0xe0]
    2cac:	mov    rdi,QWORD PTR [rbp-0xd8]
    2cb3:	sub    rsp,0x8
    2cb7:	sub    rsp,0x18
    2cbb:	mov    rsi,rsp
    2cbe:	mov    rcx,QWORD PTR [rbp-0x90]
    2cc5:	mov    rbx,QWORD PTR [rbp-0x88]
    2ccc:	mov    QWORD PTR [rsi],rcx
    2ccf:	mov    QWORD PTR [rsi+0x8],rbx
    2cd3:	mov    rcx,QWORD PTR [rbp-0x80]
    2cd7:	mov    QWORD PTR [rsi+0x10],rcx
    2cdb:	mov    rcx,rdx
    2cde:	mov    rdx,rax
    2ce1:	mov    rsi,r8
    2ce4:	call   2882 <parse_json_object>
    2ce9:	add    rsp,0x20
    2ced:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2cf4:	cmp    QWORD PTR [rbp-0xb8],0x0
    2cfc:	je     2d46 <parse_json_children+0x2d2>
    {
      // Create links
      if (!first_child)
    2cfe:	cmp    QWORD PTR [rbp-0xc8],0x0
    2d06:	jne    2d26 <parse_json_children+0x2b2>
      {
        first_child        = object;
    2d08:	mov    rax,QWORD PTR [rbp-0xb8]
    2d0f:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2d16:	mov    rax,QWORD PTR [rbp-0xb8]
    2d1d:	mov    QWORD PTR [rbp-0xc0],rax
    2d24:	jmp    2d46 <parse_json_children+0x2d2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2d26:	mov    rax,QWORD PTR [rbp-0xc0]
    2d2d:	mov    rdx,QWORD PTR [rbp-0xb8]
    2d34:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2d38:	mov    rax,QWORD PTR [rbp-0xb8]
    2d3f:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2d46:	lea    rax,[rbp-0x70]
    2d4a:	mov    rdx,QWORD PTR [rbp-0xe0]
    2d51:	mov    rsi,rdx
    2d54:	mov    rdi,rax
    2d57:	call   232f <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2d5c:	mov    eax,DWORD PTR [rbp-0x70]
    2d5f:	cmp    DWORD PTR [rbp-0xe4],eax
    2d65:	je     2e0c <parse_json_children+0x398>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2d6b:	mov    eax,DWORD PTR [rbp-0x70]
    2d6e:	cmp    eax,0x5
    2d71:	je     2df0 <parse_json_children+0x37c>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2d73:	mov    r8,QWORD PTR [rbp-0x68]
    2d77:	mov    rax,QWORD PTR [rbp-0x60]
    2d7b:	mov    r9d,eax
    2d7e:	mov    eax,DWORD PTR [rbp-0x70]
    2d81:	mov    eax,eax
    2d83:	lea    rdx,[rax*8+0x0]
    2d8b:	lea    rax,[rip+0x434e]        # 70e0 <JSON_Token_Type_strings>
    2d92:	mov    r10,QWORD PTR [rdx+rax*1]
    2d96:	lea    rdi,[rip+0x1823]        # 45c0 <_IO_stdin_used+0x5c0>
    2d9d:	lea    rsi,[rip+0x16de]        # 4482 <_IO_stdin_used+0x482>
    2da4:	sub    rsp,0x18
    2da8:	mov    rcx,rsp
    2dab:	mov    rax,QWORD PTR [rbp-0x70]
    2daf:	mov    rdx,QWORD PTR [rbp-0x68]
    2db3:	mov    QWORD PTR [rcx],rax
    2db6:	mov    QWORD PTR [rcx+0x8],rdx
    2dba:	mov    rax,QWORD PTR [rbp-0x60]
    2dbe:	mov    QWORD PTR [rcx+0x10],rax
    2dc2:	push   r8
    2dc4:	mov    r8,r10
    2dc7:	mov    rcx,rdi
    2dca:	mov    edx,0x192
    2dcf:	mov    edi,0x1
    2dd4:	mov    eax,0x0
    2dd9:	call   14a4 <log_message>
    2dde:	add    rsp,0x20
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
        parser->had_error = true;
    2de2:	mov    rax,QWORD PTR [rbp-0xe0]
    2de9:	mov    DWORD PTR [rax+0x18],0x1
  while (parser_incomplete(parser))
    2df0:	mov    rax,QWORD PTR [rbp-0xe0]
    2df7:	mov    rdi,rax
    2dfa:	call   226e <parser_incomplete>
    2dff:	test   al,al
    2e01:	jne    2aee <parse_json_children+0x7a>
    2e07:	jmp    2e0d <parse_json_children+0x399>
      break;
    2e09:	nop
    2e0a:	jmp    2e0d <parse_json_children+0x399>
      break;
    2e0c:	nop
    }
  }

  profile_close_func();
    2e0d:	sub    rsp,0x8
    2e11:	sub    rsp,0x38
    2e15:	mov    rax,rsp
    2e18:	mov    rcx,QWORD PTR [rbp-0x50]
    2e1c:	mov    rbx,QWORD PTR [rbp-0x48]
    2e20:	mov    QWORD PTR [rax],rcx
    2e23:	mov    QWORD PTR [rax+0x8],rbx
    2e27:	mov    rcx,QWORD PTR [rbp-0x40]
    2e2b:	mov    rbx,QWORD PTR [rbp-0x38]
    2e2f:	mov    QWORD PTR [rax+0x10],rcx
    2e33:	mov    QWORD PTR [rax+0x18],rbx
    2e37:	mov    rcx,QWORD PTR [rbp-0x30]
    2e3b:	mov    rbx,QWORD PTR [rbp-0x28]
    2e3f:	mov    QWORD PTR [rax+0x20],rcx
    2e43:	mov    QWORD PTR [rax+0x28],rbx
    2e47:	mov    rdx,QWORD PTR [rbp-0x20]
    2e4b:	mov    QWORD PTR [rax+0x30],rdx
    2e4f:	call   20db <__profile_close_pass>
    2e54:	add    rsp,0x40

  return first_child;
    2e58:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2e5f:	mov    rdx,QWORD PTR [rbp-0x18]
    2e63:	sub    rdx,QWORD PTR fs:0x28
    2e6c:	je     2e73 <parse_json_children+0x3ff>
    2e6e:	call   1060 <__stack_chk_fail@plt>
    2e73:	mov    rbx,QWORD PTR [rbp-0x8]
    2e77:	leave
    2e78:	ret

0000000000002e79 <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2e79:	push   rbp
    2e7a:	mov    rbp,rsp
    2e7d:	push   rbx
    2e7e:	sub    rsp,0xb8
    2e85:	mov    QWORD PTR [rbp-0xa8],rdi
    2e8c:	mov    rax,rsi
    2e8f:	mov    rsi,rdx
    2e92:	mov    rax,rax
    2e95:	mov    edx,0x0
    2e9a:	mov    rdx,rsi
    2e9d:	mov    QWORD PTR [rbp-0xc0],rax
    2ea4:	mov    QWORD PTR [rbp-0xb8],rdx
    2eab:	mov    rax,QWORD PTR fs:0x28
    2eb4:	mov    QWORD PTR [rbp-0x18],rax
    2eb8:	xor    eax,eax
  profile_begin_func();
    2eba:	lea    rcx,[rip+0x1977]        # 4838 <__func__.2>
    2ec1:	mov    ebx,0xa
    2ec6:	lea    rax,[rbp-0x50]
    2eca:	mov    rsi,rcx
    2ecd:	mov    rdx,rbx
    2ed0:	mov    r8d,0x0
    2ed6:	mov    ecx,0x3
    2edb:	mov    rdi,rax
    2ede:	call   1ff1 <__profile_begin_pass>

  JSON_Parser parser =
    2ee3:	pxor   xmm0,xmm0
    2ee7:	movaps XMMWORD PTR [rbp-0x70],xmm0
    2eeb:	movaps XMMWORD PTR [rbp-0x60],xmm0
    2eef:	mov    rax,QWORD PTR [rbp-0xc0]
    2ef6:	mov    rdx,QWORD PTR [rbp-0xb8]
    2efd:	mov    QWORD PTR [rbp-0x70],rax
    2f01:	mov    QWORD PTR [rbp-0x68],rdx
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2f05:	lea    rax,[rbp-0x90]
    2f0c:	lea    rdx,[rbp-0x70]
    2f10:	mov    rsi,rdx
    2f13:	mov    rdi,rax
    2f16:	call   232f <get_json_token>
    2f1b:	mov    ecx,0x0
    2f20:	mov    ebx,0x0
    2f25:	lea    r8,[rbp-0x70]
    2f29:	mov    rdi,QWORD PTR [rbp-0xa8]
    2f30:	sub    rsp,0x8
    2f34:	sub    rsp,0x18
    2f38:	mov    rsi,rsp
    2f3b:	mov    rax,QWORD PTR [rbp-0x90]
    2f42:	mov    rdx,QWORD PTR [rbp-0x88]
    2f49:	mov    QWORD PTR [rsi],rax
    2f4c:	mov    QWORD PTR [rsi+0x8],rdx
    2f50:	mov    rax,QWORD PTR [rbp-0x80]
    2f54:	mov    QWORD PTR [rsi+0x10],rax
    2f58:	mov    rdx,rcx
    2f5b:	mov    rcx,rbx
    2f5e:	mov    rsi,r8
    2f61:	call   2882 <parse_json_object>
    2f66:	add    rsp,0x20
    2f6a:	mov    QWORD PTR [rbp-0x98],rax

  profile_close_func();
    2f71:	sub    rsp,0x8
    2f75:	sub    rsp,0x38
    2f79:	mov    rax,rsp
    2f7c:	mov    rcx,QWORD PTR [rbp-0x50]
    2f80:	mov    rbx,QWORD PTR [rbp-0x48]
    2f84:	mov    QWORD PTR [rax],rcx
    2f87:	mov    QWORD PTR [rax+0x8],rbx
    2f8b:	mov    rcx,QWORD PTR [rbp-0x40]
    2f8f:	mov    rbx,QWORD PTR [rbp-0x38]
    2f93:	mov    QWORD PTR [rax+0x10],rcx
    2f97:	mov    QWORD PTR [rax+0x18],rbx
    2f9b:	mov    rcx,QWORD PTR [rbp-0x30]
    2f9f:	mov    rbx,QWORD PTR [rbp-0x28]
    2fa3:	mov    QWORD PTR [rax+0x20],rcx
    2fa7:	mov    QWORD PTR [rax+0x28],rbx
    2fab:	mov    rdx,QWORD PTR [rbp-0x20]
    2faf:	mov    QWORD PTR [rax+0x30],rdx
    2fb3:	call   20db <__profile_close_pass>
    2fb8:	add    rsp,0x40

  return outer;
    2fbc:	mov    rax,QWORD PTR [rbp-0x98]
}
    2fc3:	mov    rdx,QWORD PTR [rbp-0x18]
    2fc7:	sub    rdx,QWORD PTR fs:0x28
    2fd0:	je     2fd7 <parse_json+0x15e>
    2fd2:	call   1060 <__stack_chk_fail@plt>
    2fd7:	mov    rbx,QWORD PTR [rbp-0x8]
    2fdb:	leave
    2fdc:	ret

0000000000002fdd <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2fdd:	push   rbp
    2fde:	mov    rbp,rsp
    2fe1:	push   rbx
    2fe2:	sub    rsp,0x78
    2fe6:	mov    QWORD PTR [rbp-0x68],rdi
    2fea:	mov    rax,rsi
    2fed:	mov    rsi,rdx
    2ff0:	mov    rax,rax
    2ff3:	mov    edx,0x0
    2ff8:	mov    rdx,rsi
    2ffb:	mov    QWORD PTR [rbp-0x80],rax
    2fff:	mov    QWORD PTR [rbp-0x78],rdx
    3003:	mov    rax,QWORD PTR fs:0x28
    300c:	mov    QWORD PTR [rbp-0x18],rax
    3010:	xor    eax,eax
  profile_begin_func();
    3012:	lea    rcx,[rip+0x1837]        # 4850 <__func__.1>
    3019:	mov    ebx,0x12
    301e:	lea    rax,[rbp-0x50]
    3022:	mov    rsi,rcx
    3025:	mov    rdx,rbx
    3028:	mov    r8d,0x0
    302e:	mov    ecx,0x4
    3033:	mov    rdi,rax
    3036:	call   1ff1 <__profile_begin_pass>

  JSON_Object *result = NULL;
    303b:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    3043:	cmp    QWORD PTR [rbp-0x68],0x0
    3048:	je     3097 <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    304a:	mov    rax,QWORD PTR [rbp-0x68]
    304e:	mov    rax,QWORD PTR [rax+0x20]
    3052:	mov    QWORD PTR [rbp-0x58],rax
    3056:	jmp    3090 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    3058:	mov    rax,QWORD PTR [rbp-0x58]
    305c:	mov    rdx,QWORD PTR [rax+0x8]
    3060:	mov    rax,QWORD PTR [rax]
    3063:	mov    rdi,QWORD PTR [rbp-0x80]
    3067:	mov    rsi,QWORD PTR [rbp-0x78]
    306b:	mov    rcx,rdx
    306e:	mov    rdx,rax
    3071:	call   1442 <strings_equal>
    3076:	test   al,al
    3078:	je     3084 <lookup_json_object+0xa7>
      {
        result = cursor;
    307a:	mov    rax,QWORD PTR [rbp-0x58]
    307e:	mov    QWORD PTR [rbp-0x60],rax
        break;
    3082:	jmp    3097 <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    3084:	mov    rax,QWORD PTR [rbp-0x58]
    3088:	mov    rax,QWORD PTR [rax+0x28]
    308c:	mov    QWORD PTR [rbp-0x58],rax
    3090:	cmp    QWORD PTR [rbp-0x58],0x0
    3095:	jne    3058 <lookup_json_object+0x7b>
      }
    }
  }

  profile_close_func();
    3097:	sub    rsp,0x8
    309b:	sub    rsp,0x38
    309f:	mov    rax,rsp
    30a2:	mov    rcx,QWORD PTR [rbp-0x50]
    30a6:	mov    rbx,QWORD PTR [rbp-0x48]
    30aa:	mov    QWORD PTR [rax],rcx
    30ad:	mov    QWORD PTR [rax+0x8],rbx
    30b1:	mov    rcx,QWORD PTR [rbp-0x40]
    30b5:	mov    rbx,QWORD PTR [rbp-0x38]
    30b9:	mov    QWORD PTR [rax+0x10],rcx
    30bd:	mov    QWORD PTR [rax+0x18],rbx
    30c1:	mov    rcx,QWORD PTR [rbp-0x30]
    30c5:	mov    rbx,QWORD PTR [rbp-0x28]
    30c9:	mov    QWORD PTR [rax+0x20],rcx
    30cd:	mov    QWORD PTR [rax+0x28],rbx
    30d1:	mov    rdx,QWORD PTR [rbp-0x20]
    30d5:	mov    QWORD PTR [rax+0x30],rdx
    30d9:	call   20db <__profile_close_pass>
    30de:	add    rsp,0x40

  return result;
    30e2:	mov    rax,QWORD PTR [rbp-0x60]
}
    30e6:	mov    rdx,QWORD PTR [rbp-0x18]
    30ea:	sub    rdx,QWORD PTR fs:0x28
    30f3:	je     30fa <lookup_json_object+0x11d>
    30f5:	call   1060 <__stack_chk_fail@plt>
    30fa:	mov    rbx,QWORD PTR [rbp-0x8]
    30fe:	leave
    30ff:	ret

0000000000003100 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    3100:	push   rbp
    3101:	mov    rbp,rsp
    3104:	sub    rsp,0x50
    3108:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    310c:	cmp    QWORD PTR [rbp-0x48],0x0
    3111:	jne    3138 <json_object_to_f64+0x38>
    3113:	lea    rdx,[rip+0x1756]        # 4870 <__PRETTY_FUNCTION__.0>
    311a:	lea    rsi,[rip+0x1361]        # 4482 <_IO_stdin_used+0x482>
    3121:	lea    rax,[rip+0x14d8]        # 4600 <_IO_stdin_used+0x600>
    3128:	mov    rcx,rdx
    312b:	mov    edx,0x1ca
    3130:	mov    rdi,rax
    3133:	call   1090 <__assert_fail@plt>

  String val = object->value;
    3138:	mov    rax,QWORD PTR [rbp-0x48]
    313c:	mov    rdx,QWORD PTR [rax+0x18]
    3140:	mov    rax,QWORD PTR [rax+0x10]
    3144:	mov    QWORD PTR [rbp-0x10],rax
    3148:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    314c:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    3154:	movsd  xmm0,QWORD PTR [rip+0x174c]        # 48a8 <__PRETTY_FUNCTION__.0+0x38>
    315c:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    3161:	mov    rax,QWORD PTR [rbp-0x8]
    3165:	cmp    QWORD PTR [rbp-0x30],rax
    3169:	jae    318f <json_object_to_f64+0x8f>
    316b:	mov    rdx,QWORD PTR [rbp-0x10]
    316f:	mov    rax,QWORD PTR [rbp-0x30]
    3173:	add    rax,rdx
    3176:	movzx  eax,BYTE PTR [rax]
    3179:	cmp    al,0x2d
    317b:	jne    318f <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    317d:	movsd  xmm0,QWORD PTR [rip+0x172b]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    3185:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    318a:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    318f:	pxor   xmm0,xmm0
    3193:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    3198:	jmp    31df <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    319a:	mov    rdx,QWORD PTR [rbp-0x10]
    319e:	mov    rax,QWORD PTR [rbp-0x30]
    31a2:	add    rax,rdx
    31a5:	movzx  eax,BYTE PTR [rax]
    31a8:	sub    eax,0x30
    31ab:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    31ae:	cmp    BYTE PTR [rbp-0x32],0x9
    31b2:	ja     31eb <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    31b4:	movsd  xmm1,QWORD PTR [rbp-0x20]
    31b9:	movsd  xmm0,QWORD PTR [rip+0x16f7]        # 48b8 <__PRETTY_FUNCTION__.0+0x48>
    31c1:	mulsd  xmm1,xmm0
    31c5:	movzx  eax,BYTE PTR [rbp-0x32]
    31c9:	pxor   xmm0,xmm0
    31cd:	cvtsi2sd xmm0,eax
    31d1:	addsd  xmm0,xmm1
    31d5:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    31da:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    31df:	mov    rax,QWORD PTR [rbp-0x8]
    31e3:	cmp    QWORD PTR [rbp-0x30],rax
    31e7:	jb     319a <json_object_to_f64+0x9a>
    31e9:	jmp    31ec <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    31eb:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    31ec:	mov    rax,QWORD PTR [rbp-0x8]
    31f0:	cmp    QWORD PTR [rbp-0x30],rax
    31f4:	jae    3281 <json_object_to_f64+0x181>
    31fa:	mov    rdx,QWORD PTR [rbp-0x10]
    31fe:	mov    rax,QWORD PTR [rbp-0x30]
    3202:	add    rax,rdx
    3205:	movzx  eax,BYTE PTR [rax]
    3208:	cmp    al,0x2e
    320a:	jne    3281 <json_object_to_f64+0x181>
  {
    at += 1;
    320c:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    3211:	movsd  xmm0,QWORD PTR [rip+0x16a7]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    3219:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    321e:	jmp    3274 <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3220:	mov    rdx,QWORD PTR [rbp-0x10]
    3224:	mov    rax,QWORD PTR [rbp-0x30]
    3228:	add    rax,rdx
    322b:	movzx  eax,BYTE PTR [rax]
    322e:	sub    eax,0x30
    3231:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    3234:	cmp    BYTE PTR [rbp-0x31],0x9
    3238:	ja     3280 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    323a:	movzx  eax,BYTE PTR [rbp-0x31]
    323e:	pxor   xmm0,xmm0
    3242:	cvtsi2sd xmm0,eax
    3246:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    324b:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3250:	addsd  xmm0,xmm1
    3254:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    3259:	movsd  xmm1,QWORD PTR [rbp-0x18]
    325e:	movsd  xmm0,QWORD PTR [rip+0x165a]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    3266:	mulsd  xmm0,xmm1
    326a:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    326f:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    3274:	mov    rax,QWORD PTR [rbp-0x8]
    3278:	cmp    QWORD PTR [rbp-0x30],rax
    327c:	jb     3220 <json_object_to_f64+0x120>
    327e:	jmp    3281 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    3280:	nop
      }
    }
  }

  return sign * result;
    3281:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3286:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    328b:	leave
    328c:	ret

000000000000328d <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    328d:	push   rbp
    328e:	mov    rbp,rsp
    3291:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    3296:	movsd  xmm0,QWORD PTR [rbp-0x8]
    329b:	movsd  xmm1,QWORD PTR [rip+0x1625]        # 48c8 <__PRETTY_FUNCTION__.0+0x58>
    32a3:	divsd  xmm0,xmm1
}
    32a7:	pop    rbp
    32a8:	ret

00000000000032a9 <square>:

static
f64 square(f64 x)
{
    32a9:	push   rbp
    32aa:	mov    rbp,rsp
    32ad:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    32b2:	movsd  xmm0,QWORD PTR [rbp-0x8]
    32b7:	mulsd  xmm0,xmm0
}
    32bb:	pop    rbp
    32bc:	ret

00000000000032bd <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    32bd:	push   rbp
    32be:	mov    rbp,rsp
    32c1:	sub    rsp,0x90
    32c8:	movsd  QWORD PTR [rbp-0x58],xmm0
    32cd:	movsd  QWORD PTR [rbp-0x60],xmm1
    32d2:	movsd  QWORD PTR [rbp-0x68],xmm2
    32d7:	movsd  QWORD PTR [rbp-0x70],xmm3
    32dc:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    32e1:	movsd  xmm0,QWORD PTR [rbp-0x60]
    32e6:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    32eb:	movsd  xmm0,QWORD PTR [rbp-0x70]
    32f0:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    32f5:	movsd  xmm0,QWORD PTR [rbp-0x58]
    32fa:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    32ff:	movsd  xmm0,QWORD PTR [rbp-0x68]
    3304:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    3309:	movsd  xmm0,QWORD PTR [rbp-0x40]
    330e:	subsd  xmm0,QWORD PTR [rbp-0x48]
    3313:	movq   rax,xmm0
    3318:	movq   xmm0,rax
    331d:	call   328d <to_radians>
    3322:	movq   rax,xmm0
    3327:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    332b:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3330:	subsd  xmm0,QWORD PTR [rbp-0x38]
    3335:	movq   rax,xmm0
    333a:	movq   xmm0,rax
    333f:	call   328d <to_radians>
    3344:	movq   rax,xmm0
    3349:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    334d:	mov    rax,QWORD PTR [rbp-0x48]
    3351:	movq   xmm0,rax
    3356:	call   328d <to_radians>
    335b:	movq   rax,xmm0
    3360:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    3364:	mov    rax,QWORD PTR [rbp-0x40]
    3368:	movq   xmm0,rax
    336d:	call   328d <to_radians>
    3372:	movq   rax,xmm0
    3377:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    337b:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3380:	movsd  xmm1,QWORD PTR [rip+0x1548]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    3388:	divsd  xmm0,xmm1
    338c:	movq   rax,xmm0
    3391:	movq   xmm0,rax
    3396:	call   1130 <sin@plt>
    339b:	movq   rax,xmm0
    33a0:	movq   xmm0,rax
    33a5:	call   32a9 <square>
    33aa:	movsd  QWORD PTR [rbp-0x80],xmm0
    33af:	mov    rax,QWORD PTR [rbp-0x48]
    33b3:	movq   xmm0,rax
    33b8:	call   10b0 <cos@plt>
    33bd:	movsd  QWORD PTR [rbp-0x88],xmm0
    33c5:	mov    rax,QWORD PTR [rbp-0x40]
    33c9:	movq   xmm0,rax
    33ce:	call   10b0 <cos@plt>
    33d3:	movapd xmm5,xmm0
    33d7:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    33df:	movsd  QWORD PTR [rbp-0x88],xmm5
    33e7:	movsd  xmm0,QWORD PTR [rbp-0x20]
    33ec:	movsd  xmm1,QWORD PTR [rip+0x14dc]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    33f4:	movapd xmm6,xmm0
    33f8:	divsd  xmm6,xmm1
    33fc:	movq   rax,xmm6
    3401:	movq   xmm0,rax
    3406:	call   1130 <sin@plt>
    340b:	movq   rax,xmm0
    3410:	movq   xmm0,rax
    3415:	call   32a9 <square>
    341a:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    3422:	addsd  xmm0,QWORD PTR [rbp-0x80]
    3427:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    342c:	mov    rax,QWORD PTR [rbp-0x18]
    3430:	movq   xmm0,rax
    3435:	call   1160 <sqrt@plt>
    343a:	movq   rax,xmm0
    343f:	movq   xmm0,rax
    3444:	call   1140 <asin@plt>
    3449:	addsd  xmm0,xmm0
    344d:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    3452:	movsd  xmm0,QWORD PTR [rbp-0x78]
    3457:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    345c:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3461:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    3466:	leave
    3467:	ret

0000000000003468 <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    3468:	push   rbp
    3469:	mov    rbp,rsp
    346c:	movsd  QWORD PTR [rbp-0x18],xmm0
    3471:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    3476:	movsd  xmm0,QWORD PTR [rip+0x145a]        # 48d8 <__PRETTY_FUNCTION__.0+0x68>
    347e:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    3483:	movsd  xmm0,QWORD PTR [rbp-0x18]
    3488:	movq   xmm1,QWORD PTR [rip+0x1450]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    3490:	andpd  xmm0,xmm1
    3494:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3499:	movq   xmm2,QWORD PTR [rip+0x143f]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    34a1:	andpd  xmm2,xmm1
    34a5:	movapd xmm1,xmm0
    34a9:	subsd  xmm1,xmm2
    34ad:	movsd  xmm0,QWORD PTR [rbp-0x8]
    34b2:	comisd xmm0,xmm1
    34b6:	setae  al
    34b9:	movzx  eax,al
}
    34bc:	pop    rbp
    34bd:	ret

00000000000034be <main>:

int main(int args_count, char **args)
{
    34be:	push   rbp
    34bf:	mov    rbp,rsp
    34c2:	push   r15
    34c4:	push   r14
    34c6:	push   r13
    34c8:	push   r12
    34ca:	push   rbx
    34cb:	sub    rsp,0x268
    34d2:	mov    DWORD PTR [rbp-0x1f4],edi
    34d8:	mov    QWORD PTR [rbp-0x200],rsi
    34df:	mov    rax,QWORD PTR fs:0x28
    34e8:	mov    QWORD PTR [rbp-0x38],rax
    34ec:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    34ee:	cmp    DWORD PTR [rbp-0x1f4],0x3
    34f5:	je     3522 <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    34f7:	mov    rax,QWORD PTR [rbp-0x200]
    34fe:	mov    rax,QWORD PTR [rax]
    3501:	lea    rdx,[rip+0x1130]        # 4638 <_IO_stdin_used+0x638>
    3508:	mov    rsi,rax
    350b:	mov    rdi,rdx
    350e:	mov    eax,0x0
    3513:	call   1070 <printf@plt>
    return 1;
    3518:	mov    eax,0x1
    351d:	jmp    3e28 <main+0x96a>
  }

  begin_profiling();
    3522:	call   1bc6 <begin_profiling>

  Arena arena = {0};
    3527:	pxor   xmm0,xmm0
    352b:	movaps XMMWORD PTR [rbp-0x150],xmm0
    3532:	movaps XMMWORD PTR [rbp-0x140],xmm0
  arena = arena_make(GB(4));
    3539:	lea    rdx,[rbp-0x220]
    3540:	movabs rax,0x100000000
    354a:	mov    rsi,rax
    354d:	mov    rdi,rdx
    3550:	call   1635 <arena_make>
    3555:	mov    rax,QWORD PTR [rbp-0x220]
    355c:	mov    rdx,QWORD PTR [rbp-0x218]
    3563:	mov    QWORD PTR [rbp-0x150],rax
    356a:	mov    QWORD PTR [rbp-0x148],rdx
    3571:	mov    rax,QWORD PTR [rbp-0x210]
    3578:	mov    rdx,QWORD PTR [rbp-0x208]
    357f:	mov    QWORD PTR [rbp-0x140],rax
    3586:	mov    QWORD PTR [rbp-0x138],rdx

  String source = {0};
    358d:	mov    QWORD PTR [rbp-0x160],0x0
    3598:	mov    QWORD PTR [rbp-0x158],0x0
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    35a3:	mov    rax,QWORD PTR [rbp-0x200]
    35aa:	add    rax,0x8
    35ae:	mov    rax,QWORD PTR [rax]
    35b1:	mov    rdi,rax
    35b4:	call   1306 <file_size>
    35b9:	mov    rcx,rax
    35bc:	lea    r12,[rip+0x10a1]        # 4664 <_IO_stdin_used+0x664>
    35c3:	mov    r13d,0x4
    35c9:	lea    rdi,[rbp-0x130]
    35d0:	mov    rdx,r12
    35d3:	mov    rax,r13
    35d6:	mov    r8,rcx
    35d9:	mov    ecx,0x5
    35de:	mov    rsi,rdx
    35e1:	mov    rdx,rax
    35e4:	call   1ff1 <__profile_begin_pass>
    35e9:	mov    QWORD PTR [rbp-0x1e0],0x0
    35f4:	jmp    368f <main+0x1d1>
  {
    source = read_file_to_arena(&arena, args[1]);
    35f9:	mov    rax,QWORD PTR [rbp-0x200]
    3600:	add    rax,0x8
    3604:	mov    rdx,QWORD PTR [rax]
    3607:	lea    rax,[rbp-0x150]
    360e:	mov    rsi,rdx
    3611:	mov    rdi,rax
    3614:	call   135a <read_file_to_arena>
    3619:	mov    QWORD PTR [rbp-0x160],rax
    3620:	mov    QWORD PTR [rbp-0x158],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    3627:	add    QWORD PTR [rbp-0x1e0],0x1
    362f:	sub    rsp,0x8
    3633:	sub    rsp,0x38
    3637:	mov    rcx,rsp
    363a:	mov    rax,QWORD PTR [rbp-0x130]
    3641:	mov    rdx,QWORD PTR [rbp-0x128]
    3648:	mov    QWORD PTR [rcx],rax
    364b:	mov    QWORD PTR [rcx+0x8],rdx
    364f:	mov    rax,QWORD PTR [rbp-0x120]
    3656:	mov    rdx,QWORD PTR [rbp-0x118]
    365d:	mov    QWORD PTR [rcx+0x10],rax
    3661:	mov    QWORD PTR [rcx+0x18],rdx
    3665:	mov    rax,QWORD PTR [rbp-0x110]
    366c:	mov    rdx,QWORD PTR [rbp-0x108]
    3673:	mov    QWORD PTR [rcx+0x20],rax
    3677:	mov    QWORD PTR [rcx+0x28],rdx
    367b:	mov    rax,QWORD PTR [rbp-0x100]
    3682:	mov    QWORD PTR [rcx+0x30],rax
    3686:	call   20db <__profile_close_pass>
    368b:	add    rsp,0x40
    368f:	cmp    QWORD PTR [rbp-0x1e0],0x0
    3697:	je     35f9 <main+0x13b>
  }

  usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    369d:	mov    QWORD PTR [rbp-0x1a8],0x18
  usize max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    36a8:	mov    rax,QWORD PTR [rbp-0x158]
    36af:	mov    edx,0x0
    36b4:	div    QWORD PTR [rbp-0x1a8]
    36bb:	mov    QWORD PTR [rbp-0x1a0],rax
  Haversine_Pair * pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    36c2:	mov    rax,QWORD PTR [rbp-0x1a0]
    36c9:	shl    rax,0x5
    36cd:	mov    rcx,rax
    36d0:	lea    rax,[rbp-0x150]
    36d7:	mov    edx,0x8
    36dc:	mov    rsi,rcx
    36df:	mov    rdi,rax
    36e2:	call   17d6 <arena_alloc>
    36e7:	mov    QWORD PTR [rbp-0x198],rax
  i32 pair_count = 0;
    36ee:	mov    DWORD PTR [rbp-0x1e8],0x0

  JSON_Object *root = NULL;
    36f8:	mov    QWORD PTR [rbp-0x190],0x0
  root = parse_json(&arena, source);
    3703:	mov    rcx,QWORD PTR [rbp-0x160]
    370a:	mov    rdx,QWORD PTR [rbp-0x158]
    3711:	lea    rax,[rbp-0x150]
    3718:	mov    rsi,rcx
    371b:	mov    rdi,rax
    371e:	call   2e79 <parse_json>
    3723:	mov    QWORD PTR [rbp-0x190],rax

  f64 haversine_sum = 0.0;
    372a:	pxor   xmm0,xmm0
    372e:	movsd  QWORD PTR [rbp-0x188],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    3736:	lea    r14,[rip+0xf2c]        # 4669 <_IO_stdin_used+0x669>
    373d:	mov    r15d,0x5
    3743:	mov    rcx,r14
    3746:	mov    rdx,r15
    3749:	mov    rax,QWORD PTR [rbp-0x190]
    3750:	mov    rsi,rcx
    3753:	mov    rdi,rax
    3756:	call   2fdd <lookup_json_object>
    375b:	mov    QWORD PTR [rbp-0x180],rax
  if (pairs)
    3762:	cmp    QWORD PTR [rbp-0x198],0x0
    376a:	je     392f <main+0x471>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    3770:	mov    rax,QWORD PTR [rbp-0x180]
    3777:	mov    rax,QWORD PTR [rax+0x20]
    377b:	mov    QWORD PTR [rbp-0x1d8],rax
    3782:	jmp    3910 <main+0x452>
    {
      Haversine_Pair pair =
      {
        .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    3787:	lea    rax,[rip+0xee1]        # 466f <_IO_stdin_used+0x66f>
    378e:	mov    QWORD PTR [rbp-0x260],rax
    3795:	mov    QWORD PTR [rbp-0x258],0x2
    37a0:	mov    rbx,QWORD PTR [rbp-0x260]
    37a7:	mov    rsi,QWORD PTR [rbp-0x258]
    37ae:	mov    rax,rbx
    37b1:	mov    rdx,rsi
    37b4:	mov    rcx,QWORD PTR [rbp-0x1d8]
    37bb:	mov    rsi,rax
    37be:	mov    rdi,rcx
    37c1:	call   2fdd <lookup_json_object>
    37c6:	mov    rdi,rax
    37c9:	call   3100 <json_object_to_f64>
    37ce:	movq   rax,xmm0
      Haversine_Pair pair =
    37d3:	mov    QWORD PTR [rbp-0x70],rax
        .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    37d7:	lea    rax,[rip+0xe94]        # 4672 <_IO_stdin_used+0x672>
    37de:	mov    QWORD PTR [rbp-0x270],rax
    37e5:	mov    QWORD PTR [rbp-0x268],0x2
    37f0:	mov    rax,QWORD PTR [rbp-0x270]
    37f7:	mov    rdx,QWORD PTR [rbp-0x268]
    37fe:	mov    rcx,rax
    3801:	mov    rax,QWORD PTR [rbp-0x1d8]
    3808:	mov    rsi,rcx
    380b:	mov    rdi,rax
    380e:	call   2fdd <lookup_json_object>
    3813:	mov    rdi,rax
    3816:	call   3100 <json_object_to_f64>
    381b:	movq   rax,xmm0
      Haversine_Pair pair =
    3820:	mov    QWORD PTR [rbp-0x68],rax
        .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    3824:	lea    rax,[rip+0xe4a]        # 4675 <_IO_stdin_used+0x675>
    382b:	mov    QWORD PTR [rbp-0x280],rax
    3832:	mov    QWORD PTR [rbp-0x278],0x2
    383d:	mov    rax,QWORD PTR [rbp-0x280]
    3844:	mov    rdx,QWORD PTR [rbp-0x278]
    384b:	mov    rcx,rax
    384e:	mov    rax,QWORD PTR [rbp-0x1d8]
    3855:	mov    rsi,rcx
    3858:	mov    rdi,rax
    385b:	call   2fdd <lookup_json_object>
    3860:	mov    rdi,rax
    3863:	call   3100 <json_object_to_f64>
    3868:	movq   rax,xmm0
      Haversine_Pair pair =
    386d:	mov    QWORD PTR [rbp-0x60],rax
        .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    3871:	lea    rax,[rip+0xe00]        # 4678 <_IO_stdin_used+0x678>
    3878:	mov    QWORD PTR [rbp-0x290],rax
    387f:	mov    QWORD PTR [rbp-0x288],0x2
    388a:	mov    rax,QWORD PTR [rbp-0x290]
    3891:	mov    rdx,QWORD PTR [rbp-0x288]
    3898:	mov    rcx,rax
    389b:	mov    rax,QWORD PTR [rbp-0x1d8]
    38a2:	mov    rsi,rcx
    38a5:	mov    rdi,rax
    38a8:	call   2fdd <lookup_json_object>
    38ad:	mov    rdi,rax
    38b0:	call   3100 <json_object_to_f64>
    38b5:	movq   rax,xmm0
      Haversine_Pair pair =
    38ba:	mov    QWORD PTR [rbp-0x58],rax
      };

      pairs[pair_count] = pair;
    38be:	mov    eax,DWORD PTR [rbp-0x1e8]
    38c4:	cdqe
    38c6:	shl    rax,0x5
    38ca:	mov    rdx,rax
    38cd:	mov    rax,QWORD PTR [rbp-0x198]
    38d4:	lea    rcx,[rdx+rax*1]
    38d8:	mov    rax,QWORD PTR [rbp-0x70]
    38dc:	mov    rdx,QWORD PTR [rbp-0x68]
    38e0:	mov    QWORD PTR [rcx],rax
    38e3:	mov    QWORD PTR [rcx+0x8],rdx
    38e7:	mov    rax,QWORD PTR [rbp-0x60]
    38eb:	mov    rdx,QWORD PTR [rbp-0x58]
    38ef:	mov    QWORD PTR [rcx+0x10],rax
    38f3:	mov    QWORD PTR [rcx+0x18],rdx
      pair_count += 1;
    38f7:	add    DWORD PTR [rbp-0x1e8],0x1
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    38fe:	mov    rax,QWORD PTR [rbp-0x1d8]
    3905:	mov    rax,QWORD PTR [rax+0x28]
    3909:	mov    QWORD PTR [rbp-0x1d8],rax
    3910:	cmp    QWORD PTR [rbp-0x1d8],0x0
    3918:	je     392f <main+0x471>
    391a:	mov    eax,DWORD PTR [rbp-0x1e8]
    3920:	cdqe
    3922:	cmp    rax,QWORD PTR [rbp-0x1a0]
    3929:	jb     3787 <main+0x2c9>
    }
  }

  f64 sum = 0.0;
    392f:	pxor   xmm0,xmm0
    3933:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    393b:	mov    eax,DWORD PTR [rbp-0x1e8]
    3941:	cdqe
    3943:	shl    rax,0x5
    3947:	mov    rdx,rax
    394a:	lea    rax,[rip+0xd2a]        # 467b <_IO_stdin_used+0x67b>
    3951:	mov    QWORD PTR [rbp-0x230],rax
    3958:	mov    QWORD PTR [rbp-0x228],0x3
    3963:	lea    rax,[rbp-0xf0]
    396a:	mov    rcx,QWORD PTR [rbp-0x230]
    3971:	mov    rbx,QWORD PTR [rbp-0x228]
    3978:	mov    rsi,rcx
    397b:	mov    rdi,rbx
    397e:	mov    r8,rdx
    3981:	mov    ecx,0x6
    3986:	mov    rdx,rdi
    3989:	mov    rdi,rax
    398c:	call   1ff1 <__profile_begin_pass>
    3991:	mov    QWORD PTR [rbp-0x1c8],0x0
    399c:	jmp    3b1e <main+0x660>
  {
    for (usize i = 0; i < pair_count; i++)
    39a1:	mov    QWORD PTR [rbp-0x1c0],0x0
    39ac:	jmp    3a81 <main+0x5c3>
    {
      f64 earth_radius = 6372.8;
    39b1:	movsd  xmm0,QWORD PTR [rip+0xf37]        # 48f0 <__PRETTY_FUNCTION__.0+0x80>
    39b9:	movsd  QWORD PTR [rbp-0x170],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    39c1:	mov    rax,QWORD PTR [rbp-0x1c0]
    39c8:	shl    rax,0x5
    39cc:	mov    rdx,rax
    39cf:	mov    rax,QWORD PTR [rbp-0x198]
    39d6:	add    rax,rdx
    39d9:	movsd  xmm2,QWORD PTR [rax+0x18]
    39de:	mov    rax,QWORD PTR [rbp-0x1c0]
    39e5:	shl    rax,0x5
    39e9:	mov    rdx,rax
    39ec:	mov    rax,QWORD PTR [rbp-0x198]
    39f3:	add    rax,rdx
    39f6:	movsd  xmm1,QWORD PTR [rax+0x10]
    39fb:	mov    rax,QWORD PTR [rbp-0x1c0]
    3a02:	shl    rax,0x5
    3a06:	mov    rdx,rax
    3a09:	mov    rax,QWORD PTR [rbp-0x198]
    3a10:	add    rax,rdx
    3a13:	movsd  xmm0,QWORD PTR [rax+0x8]
    3a18:	mov    rax,QWORD PTR [rbp-0x1c0]
    3a1f:	shl    rax,0x5
    3a23:	mov    rdx,rax
    3a26:	mov    rax,QWORD PTR [rbp-0x198]
    3a2d:	add    rax,rdx
    3a30:	mov    rax,QWORD PTR [rax]
    3a33:	movsd  xmm3,QWORD PTR [rbp-0x170]
    3a3b:	movapd xmm4,xmm3
    3a3f:	movapd xmm3,xmm2
    3a43:	movapd xmm2,xmm1
    3a47:	movapd xmm1,xmm0
    3a4b:	movq   xmm0,rax
    3a50:	call   32bd <reference_haversine>
    3a55:	movq   rax,xmm0
    3a5a:	mov    QWORD PTR [rbp-0x168],rax
      sum += result;
    3a61:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3a69:	addsd  xmm0,QWORD PTR [rbp-0x168]
    3a71:	movsd  QWORD PTR [rbp-0x1d0],xmm0
    for (usize i = 0; i < pair_count; i++)
    3a79:	add    QWORD PTR [rbp-0x1c0],0x1
    3a81:	mov    eax,DWORD PTR [rbp-0x1e8]
    3a87:	cdqe
    3a89:	cmp    QWORD PTR [rbp-0x1c0],rax
    3a90:	jb     39b1 <main+0x4f3>
    }
    sum /= pair_count;
    3a96:	pxor   xmm1,xmm1
    3a9a:	cvtsi2sd xmm1,DWORD PTR [rbp-0x1e8]
    3aa2:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3aaa:	divsd  xmm0,xmm1
    3aae:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    3ab6:	add    QWORD PTR [rbp-0x1c8],0x1
    3abe:	sub    rsp,0x8
    3ac2:	sub    rsp,0x38
    3ac6:	mov    rax,rsp
    3ac9:	mov    rcx,QWORD PTR [rbp-0xf0]
    3ad0:	mov    rbx,QWORD PTR [rbp-0xe8]
    3ad7:	mov    QWORD PTR [rax],rcx
    3ada:	mov    QWORD PTR [rax+0x8],rbx
    3ade:	mov    rcx,QWORD PTR [rbp-0xe0]
    3ae5:	mov    rbx,QWORD PTR [rbp-0xd8]
    3aec:	mov    QWORD PTR [rax+0x10],rcx
    3af0:	mov    QWORD PTR [rax+0x18],rbx
    3af4:	mov    rcx,QWORD PTR [rbp-0xd0]
    3afb:	mov    rbx,QWORD PTR [rbp-0xc8]
    3b02:	mov    QWORD PTR [rax+0x20],rcx
    3b06:	mov    QWORD PTR [rax+0x28],rbx
    3b0a:	mov    rdx,QWORD PTR [rbp-0xc0]
    3b11:	mov    QWORD PTR [rax+0x30],rdx
    3b15:	call   20db <__profile_close_pass>
    3b1a:	add    rsp,0x40
    3b1e:	cmp    QWORD PTR [rbp-0x1c8],0x0
    3b26:	je     39a1 <main+0x4e3>
  }

  PROFILE_SCOPE("check")
    3b2c:	lea    rax,[rip+0xb4c]        # 467f <_IO_stdin_used+0x67f>
    3b33:	mov    QWORD PTR [rbp-0x240],rax
    3b3a:	mov    QWORD PTR [rbp-0x238],0x5
    3b45:	lea    rax,[rbp-0xb0]
    3b4c:	mov    rcx,QWORD PTR [rbp-0x240]
    3b53:	mov    rbx,QWORD PTR [rbp-0x238]
    3b5a:	mov    rsi,rcx
    3b5d:	mov    rdx,rbx
    3b60:	mov    r8d,0x0
    3b66:	mov    ecx,0x7
    3b6b:	mov    rdi,rax
    3b6e:	call   1ff1 <__profile_begin_pass>
    3b73:	mov    QWORD PTR [rbp-0x1b8],0x0
    3b7e:	jmp    3d53 <main+0x895>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3b83:	mov    rax,QWORD PTR [rbp-0x200]
    3b8a:	add    rax,0x10
    3b8e:	mov    rdx,QWORD PTR [rax]
    3b91:	lea    rax,[rbp-0x150]
    3b98:	mov    rsi,rdx
    3b9b:	mov    rdi,rax
    3b9e:	call   135a <read_file_to_arena>
    3ba3:	mov    QWORD PTR [rbp-0x70],rax
    3ba7:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3bab:	mov    rax,QWORD PTR [rbp-0x68]
    3baf:	cmp    rax,0xb
    3bb3:	jbe    3cc6 <main+0x808>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3bb9:	mov    rax,QWORD PTR [rbp-0x70]
    3bbd:	movsd  xmm0,QWORD PTR [rax]
    3bc1:	movsd  QWORD PTR [rbp-0x178],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3bc9:	mov    rax,QWORD PTR [rbp-0x70]
    3bcd:	mov    eax,DWORD PTR [rax+0x8]
    3bd0:	mov    DWORD PTR [rbp-0x1e4],eax

      if (solution_pairs == pair_count)
    3bd6:	mov    eax,DWORD PTR [rbp-0x1e4]
    3bdc:	cmp    eax,DWORD PTR [rbp-0x1e8]
    3be2:	jne    3c8a <main+0x7cc>
      {
        if (epsilon_equal(solution_sum, sum))
    3be8:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3bf0:	mov    rax,QWORD PTR [rbp-0x178]
    3bf7:	movapd xmm1,xmm0
    3bfb:	movq   xmm0,rax
    3c00:	call   3468 <epsilon_equal>
    3c05:	test   eax,eax
    3c07:	je     3c4b <main+0x78d>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3c09:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3c11:	mov    rax,QWORD PTR [rbp-0x178]
    3c18:	lea    rdx,[rip+0xa69]        # 4688 <_IO_stdin_used+0x688>
    3c1f:	lea    rsi,[rip+0xa95]        # 46bb <_IO_stdin_used+0x6bb>
    3c26:	movapd xmm1,xmm0
    3c2a:	movq   xmm0,rax
    3c2f:	mov    rcx,rdx
    3c32:	mov    edx,0x5b
    3c37:	mov    edi,0x3
    3c3c:	mov    eax,0x2
    3c41:	call   14a4 <log_message>
    3c46:	jmp    3cee <main+0x830>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3c4b:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3c53:	mov    rax,QWORD PTR [rbp-0x178]
    3c5a:	lea    rdx,[rip+0xa6f]        # 46d0 <_IO_stdin_used+0x6d0>
    3c61:	lea    rsi,[rip+0xa53]        # 46bb <_IO_stdin_used+0x6bb>
    3c68:	movapd xmm1,xmm0
    3c6c:	movq   xmm0,rax
    3c71:	mov    rcx,rdx
    3c74:	mov    edx,0x5f
    3c79:	mov    edi,0x1
    3c7e:	mov    eax,0x2
    3c83:	call   14a4 <log_message>
    3c88:	jmp    3cee <main+0x830>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3c8a:	mov    esi,DWORD PTR [rbp-0x1e8]
    3c90:	mov    ecx,DWORD PTR [rbp-0x1e4]
    3c96:	lea    rdx,[rip+0xa6b]        # 4708 <_IO_stdin_used+0x708>
    3c9d:	lea    rax,[rip+0xa17]        # 46bb <_IO_stdin_used+0x6bb>
    3ca4:	mov    r9d,esi
    3ca7:	mov    r8d,ecx
    3caa:	mov    rcx,rdx
    3cad:	mov    edx,0x64
    3cb2:	mov    rsi,rax
    3cb5:	mov    edi,0x1
    3cba:	mov    eax,0x0
    3cbf:	call   14a4 <log_message>
    3cc4:	jmp    3cee <main+0x830>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3cc6:	lea    rdx,[rip+0xa83]        # 4750 <_IO_stdin_used+0x750>
    3ccd:	lea    rax,[rip+0x9e7]        # 46bb <_IO_stdin_used+0x6bb>
    3cd4:	mov    rcx,rdx
    3cd7:	mov    edx,0x69
    3cdc:	mov    rsi,rax
    3cdf:	mov    edi,0x1
    3ce4:	mov    eax,0x0
    3ce9:	call   14a4 <log_message>
  PROFILE_SCOPE("check")
    3cee:	add    QWORD PTR [rbp-0x1b8],0x1
    3cf6:	sub    rsp,0x8
    3cfa:	sub    rsp,0x38
    3cfe:	mov    rax,rsp
    3d01:	mov    rcx,QWORD PTR [rbp-0xb0]
    3d08:	mov    rbx,QWORD PTR [rbp-0xa8]
    3d0f:	mov    QWORD PTR [rax],rcx
    3d12:	mov    QWORD PTR [rax+0x8],rbx
    3d16:	mov    rcx,QWORD PTR [rbp-0xa0]
    3d1d:	mov    rbx,QWORD PTR [rbp-0x98]
    3d24:	mov    QWORD PTR [rax+0x10],rcx
    3d28:	mov    QWORD PTR [rax+0x18],rbx
    3d2c:	mov    rcx,QWORD PTR [rbp-0x90]
    3d33:	mov    rbx,QWORD PTR [rbp-0x88]
    3d3a:	mov    QWORD PTR [rax+0x20],rcx
    3d3e:	mov    QWORD PTR [rax+0x28],rbx
    3d42:	mov    rdx,QWORD PTR [rbp-0x80]
    3d46:	mov    QWORD PTR [rax+0x30],rdx
    3d4a:	call   20db <__profile_close_pass>
    3d4f:	add    rsp,0x40
    3d53:	cmp    QWORD PTR [rbp-0x1b8],0x0
    3d5b:	je     3b83 <main+0x6c5>
    }
  }

  PROFILE_SCOPE("free")
    3d61:	lea    rax,[rip+0xa23]        # 478b <_IO_stdin_used+0x78b>
    3d68:	mov    QWORD PTR [rbp-0x250],rax
    3d6f:	mov    QWORD PTR [rbp-0x248],0x4
    3d7a:	lea    rax,[rbp-0x70]
    3d7e:	mov    rcx,QWORD PTR [rbp-0x250]
    3d85:	mov    rbx,QWORD PTR [rbp-0x248]
    3d8c:	mov    rsi,rcx
    3d8f:	mov    rdx,rbx
    3d92:	mov    r8d,0x0
    3d98:	mov    ecx,0x8
    3d9d:	mov    rdi,rax
    3da0:	call   1ff1 <__profile_begin_pass>
    3da5:	mov    QWORD PTR [rbp-0x1b0],0x0
    3db0:	jmp    3e14 <main+0x956>
  {
    arena_free(&arena);
    3db2:	lea    rax,[rbp-0x150]
    3db9:	mov    rdi,rax
    3dbc:	call   1794 <arena_free>
  PROFILE_SCOPE("free")
    3dc1:	add    QWORD PTR [rbp-0x1b0],0x1
    3dc9:	sub    rsp,0x8
    3dcd:	sub    rsp,0x38
    3dd1:	mov    rax,rsp
    3dd4:	mov    rcx,QWORD PTR [rbp-0x70]
    3dd8:	mov    rbx,QWORD PTR [rbp-0x68]
    3ddc:	mov    QWORD PTR [rax],rcx
    3ddf:	mov    QWORD PTR [rax+0x8],rbx
    3de3:	mov    rcx,QWORD PTR [rbp-0x60]
    3de7:	mov    rbx,QWORD PTR [rbp-0x58]
    3deb:	mov    QWORD PTR [rax+0x10],rcx
    3def:	mov    QWORD PTR [rax+0x18],rbx
    3df3:	mov    rcx,QWORD PTR [rbp-0x50]
    3df7:	mov    rbx,QWORD PTR [rbp-0x48]
    3dfb:	mov    QWORD PTR [rax+0x20],rcx
    3dff:	mov    QWORD PTR [rax+0x28],rbx
    3e03:	mov    rdx,QWORD PTR [rbp-0x40]
    3e07:	mov    QWORD PTR [rax+0x30],rdx
    3e0b:	call   20db <__profile_close_pass>
    3e10:	add    rsp,0x40
    3e14:	cmp    QWORD PTR [rbp-0x1b0],0x0
    3e1c:	je     3db2 <main+0x8f4>
  }

  end_profiling();
    3e1e:	call   1c24 <end_profiling>
    3e23:	mov    eax,0x0
}
    3e28:	mov    rdx,QWORD PTR [rbp-0x38]
    3e2c:	sub    rdx,QWORD PTR fs:0x28
    3e35:	je     3e3c <main+0x97e>
    3e37:	call   1060 <__stack_chk_fail@plt>
    3e3c:	lea    rsp,[rbp-0x28]
    3e40:	pop    rbx
    3e41:	pop    r12
    3e43:	pop    r13
    3e45:	pop    r14
    3e47:	pop    r15
    3e49:	pop    rbp
    3e4a:	ret

Disassembly of section .fini:

0000000000003e4c <_fini>:
    3e4c:	endbr64
    3e50:	sub    rsp,0x8
    3e54:	add    rsp,0x8
    3e58:	ret

calc.x:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	endbr64
    1004:	sub    rsp,0x8
    1008:	mov    rax,QWORD PTR [rip+0x5fc1]        # 6fd0 <__gmon_start__@Base>
    100f:	test   rax,rax
    1012:	je     1016 <_init+0x16>
    1014:	call   rax
    1016:	add    rsp,0x8
    101a:	ret

Disassembly of section .plt:

0000000000001020 <free@plt-0x10>:
    1020:	push   QWORD PTR [rip+0x5fca]        # 6ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	jmp    QWORD PTR [rip+0x5fcc]        # 6ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:	nop    DWORD PTR [rax+0x0]

0000000000001030 <free@plt>:
    1030:	jmp    QWORD PTR [rip+0x5fca]        # 7000 <free@GLIBC_2.2.5>
    1036:	push   0x0
    103b:	jmp    1020 <_init+0x20>

0000000000001040 <fread@plt>:
    1040:	jmp    QWORD PTR [rip+0x5fc2]        # 7008 <fread@GLIBC_2.2.5>
    1046:	push   0x1
    104b:	jmp    1020 <_init+0x20>

0000000000001050 <fclose@plt>:
    1050:	jmp    QWORD PTR [rip+0x5fba]        # 7010 <fclose@GLIBC_2.2.5>
    1056:	push   0x2
    105b:	jmp    1020 <_init+0x20>

0000000000001060 <__stack_chk_fail@plt>:
    1060:	jmp    QWORD PTR [rip+0x5fb2]        # 7018 <__stack_chk_fail@GLIBC_2.4>
    1066:	push   0x3
    106b:	jmp    1020 <_init+0x20>

0000000000001070 <printf@plt>:
    1070:	jmp    QWORD PTR [rip+0x5faa]        # 7020 <printf@GLIBC_2.2.5>
    1076:	push   0x4
    107b:	jmp    1020 <_init+0x20>

0000000000001080 <gettimeofday@plt>:
    1080:	jmp    QWORD PTR [rip+0x5fa2]        # 7028 <gettimeofday@GLIBC_2.2.5>
    1086:	push   0x5
    108b:	jmp    1020 <_init+0x20>

0000000000001090 <__assert_fail@plt>:
    1090:	jmp    QWORD PTR [rip+0x5f9a]        # 7030 <__assert_fail@GLIBC_2.2.5>
    1096:	push   0x6
    109b:	jmp    1020 <_init+0x20>

00000000000010a0 <memset@plt>:
    10a0:	jmp    QWORD PTR [rip+0x5f92]        # 7038 <memset@GLIBC_2.2.5>
    10a6:	push   0x7
    10ab:	jmp    1020 <_init+0x20>

00000000000010b0 <cos@plt>:
    10b0:	jmp    QWORD PTR [rip+0x5f8a]        # 7040 <cos@GLIBC_2.2.5>
    10b6:	push   0x8
    10bb:	jmp    1020 <_init+0x20>

00000000000010c0 <fputc@plt>:
    10c0:	jmp    QWORD PTR [rip+0x5f82]        # 7048 <fputc@GLIBC_2.2.5>
    10c6:	push   0x9
    10cb:	jmp    1020 <_init+0x20>

00000000000010d0 <memcmp@plt>:
    10d0:	jmp    QWORD PTR [rip+0x5f7a]        # 7050 <memcmp@GLIBC_2.2.5>
    10d6:	push   0xa
    10db:	jmp    1020 <_init+0x20>

00000000000010e0 <calloc@plt>:
    10e0:	jmp    QWORD PTR [rip+0x5f72]        # 7058 <calloc@GLIBC_2.2.5>
    10e6:	push   0xb
    10eb:	jmp    1020 <_init+0x20>

00000000000010f0 <fprintf@plt>:
    10f0:	jmp    QWORD PTR [rip+0x5f6a]        # 7060 <fprintf@GLIBC_2.2.5>
    10f6:	push   0xc
    10fb:	jmp    1020 <_init+0x20>

0000000000001100 <stat@plt>:
    1100:	jmp    QWORD PTR [rip+0x5f62]        # 7068 <stat@GLIBC_2.33>
    1106:	push   0xd
    110b:	jmp    1020 <_init+0x20>

0000000000001110 <fopen@plt>:
    1110:	jmp    QWORD PTR [rip+0x5f5a]        # 7070 <fopen@GLIBC_2.2.5>
    1116:	push   0xe
    111b:	jmp    1020 <_init+0x20>

0000000000001120 <vfprintf@plt>:
    1120:	jmp    QWORD PTR [rip+0x5f52]        # 7078 <vfprintf@GLIBC_2.2.5>
    1126:	push   0xf
    112b:	jmp    1020 <_init+0x20>

0000000000001130 <sin@plt>:
    1130:	jmp    QWORD PTR [rip+0x5f4a]        # 7080 <sin@GLIBC_2.2.5>
    1136:	push   0x10
    113b:	jmp    1020 <_init+0x20>

0000000000001140 <asin@plt>:
    1140:	jmp    QWORD PTR [rip+0x5f42]        # 7088 <asin@GLIBC_2.2.5>
    1146:	push   0x11
    114b:	jmp    1020 <_init+0x20>

0000000000001150 <exit@plt>:
    1150:	jmp    QWORD PTR [rip+0x5f3a]        # 7090 <exit@GLIBC_2.2.5>
    1156:	push   0x12
    115b:	jmp    1020 <_init+0x20>

0000000000001160 <sqrt@plt>:
    1160:	jmp    QWORD PTR [rip+0x5f32]        # 7098 <sqrt@GLIBC_2.2.5>
    1166:	push   0x13
    116b:	jmp    1020 <_init+0x20>

Disassembly of section .text:

0000000000001170 <_start>:
    1170:	endbr64
    1174:	xor    ebp,ebp
    1176:	mov    r9,rdx
    1179:	pop    rsi
    117a:	mov    rdx,rsp
    117d:	and    rsp,0xfffffffffffffff0
    1181:	push   rax
    1182:	push   rsp
    1183:	xor    r8d,r8d
    1186:	xor    ecx,ecx
    1188:	lea    rdi,[rip+0x232f]        # 34be <main>
    118f:	call   QWORD PTR [rip+0x5e2b]        # 6fc0 <__libc_start_main@GLIBC_2.34>
    1195:	hlt
    1196:	cs nop WORD PTR [rax+rax*1+0x0]
    11a0:	lea    rdi,[rip+0x5fa1]        # 7148 <__TMC_END__>
    11a7:	lea    rax,[rip+0x5f9a]        # 7148 <__TMC_END__>
    11ae:	cmp    rax,rdi
    11b1:	je     11c8 <_start+0x58>
    11b3:	mov    rax,QWORD PTR [rip+0x5e0e]        # 6fc8 <_ITM_deregisterTMCloneTable@Base>
    11ba:	test   rax,rax
    11bd:	je     11c8 <_start+0x58>
    11bf:	jmp    rax
    11c1:	nop    DWORD PTR [rax+0x0]
    11c8:	ret
    11c9:	nop    DWORD PTR [rax+0x0]
    11d0:	lea    rdi,[rip+0x5f71]        # 7148 <__TMC_END__>
    11d7:	lea    rsi,[rip+0x5f6a]        # 7148 <__TMC_END__>
    11de:	sub    rsi,rdi
    11e1:	mov    rax,rsi
    11e4:	shr    rsi,0x3f
    11e8:	sar    rax,0x3
    11ec:	add    rsi,rax
    11ef:	sar    rsi,1
    11f2:	je     1208 <_start+0x98>
    11f4:	mov    rax,QWORD PTR [rip+0x5ddd]        # 6fd8 <_ITM_registerTMCloneTable@Base>
    11fb:	test   rax,rax
    11fe:	je     1208 <_start+0x98>
    1200:	jmp    rax
    1202:	nop    WORD PTR [rax+rax*1+0x0]
    1208:	ret
    1209:	nop    DWORD PTR [rax+0x0]
    1210:	endbr64
    1214:	cmp    BYTE PTR [rip+0x5f6d],0x0        # 7188 <stderr@GLIBC_2.2.5+0x8>
    121b:	jne    1250 <_start+0xe0>
    121d:	push   rbp
    121e:	cmp    QWORD PTR [rip+0x5dba],0x0        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1226:	mov    rbp,rsp
    1229:	je     1238 <_start+0xc8>
    122b:	mov    rdi,QWORD PTR [rip+0x5e76]        # 70a8 <__dso_handle>
    1232:	call   QWORD PTR [rip+0x5da8]        # 6fe0 <__cxa_finalize@GLIBC_2.2.5>
    1238:	call   11a0 <_start+0x30>
    123d:	mov    BYTE PTR [rip+0x5f44],0x1        # 7188 <stderr@GLIBC_2.2.5+0x8>
    1244:	pop    rbp
    1245:	ret
    1246:	cs nop WORD PTR [rax+rax*1+0x0]
    1250:	ret
    1251:	nop    DWORD PTR [rax+0x0]
    1255:	data16 cs nop WORD PTR [rax+rax*1+0x0]
    1260:	endbr64
    1264:	jmp    11d0 <_start+0x60>

0000000000001269 <read_file_to_memory>:
////////////////
// #define COMMON_IMPLEMENTATION
#ifdef COMMON_IMPLEMENTATION
// Returns size of file, or 0 if it can't open the file
usize read_file_to_memory(const char *name, u8 *buffer, usize buffer_size)
{
    1269:	push   rbp
    126a:	mov    rbp,rsp
    126d:	sub    rsp,0x30
    1271:	mov    QWORD PTR [rbp-0x18],rdi
    1275:	mov    QWORD PTR [rbp-0x20],rsi
    1279:	mov    QWORD PTR [rbp-0x28],rdx
  usize byte_count = 0;
    127d:	mov    QWORD PTR [rbp-0x10],0x0

  FILE *file = fopen(name, "rb");
    1285:	lea    rdx,[rip+0x2d84]        # 4010 <_IO_stdin_used+0x10>
    128c:	mov    rax,QWORD PTR [rbp-0x18]
    1290:	mov    rsi,rdx
    1293:	mov    rdi,rax
    1296:	call   1110 <fopen@plt>
    129b:	mov    QWORD PTR [rbp-0x8],rax
  if (file)
    129f:	cmp    QWORD PTR [rbp-0x8],0x0
    12a4:	je     12d1 <read_file_to_memory+0x68>
  {
    byte_count = fread(buffer, sizeof(u8), buffer_size, file);
    12a6:	mov    rcx,QWORD PTR [rbp-0x8]
    12aa:	mov    rdx,QWORD PTR [rbp-0x28]
    12ae:	mov    rax,QWORD PTR [rbp-0x20]
    12b2:	mov    esi,0x1
    12b7:	mov    rdi,rax
    12ba:	call   1040 <fread@plt>
    12bf:	mov    QWORD PTR [rbp-0x10],rax
    fclose(file);
    12c3:	mov    rax,QWORD PTR [rbp-0x8]
    12c7:	mov    rdi,rax
    12ca:	call   1050 <fclose@plt>
    12cf:	jmp    1300 <read_file_to_memory+0x97>
  }
  else
  {
    LOG_ERROR("Unable to open file: %s", name);
    12d1:	mov    rcx,QWORD PTR [rbp-0x18]
    12d5:	lea    rdx,[rip+0x2d37]        # 4013 <_IO_stdin_used+0x13>
    12dc:	lea    rax,[rip+0x2d48]        # 402b <_IO_stdin_used+0x2b>
    12e3:	mov    r8,rcx
    12e6:	mov    rcx,rdx
    12e9:	mov    edx,0x182
    12ee:	mov    rsi,rax
    12f1:	mov    edi,0x1
    12f6:	mov    eax,0x0
    12fb:	call   14a4 <log_message>
  }

  return byte_count;
    1300:	mov    rax,QWORD PTR [rbp-0x10]
}
    1304:	leave
    1305:	ret

0000000000001306 <file_size>:

usize file_size(const char *name)
{
    1306:	push   rbp
    1307:	mov    rbp,rsp
    130a:	sub    rsp,0xb0
    1311:	mov    QWORD PTR [rbp-0xa8],rdi
    1318:	mov    rax,QWORD PTR fs:0x28
    1321:	mov    QWORD PTR [rbp-0x8],rax
    1325:	xor    eax,eax
#if _WIN32
  struct __stat64 stats;
  _stat64(name, &stats);
#else
  struct stat stats;
  stat(name, &stats);
    1327:	lea    rdx,[rbp-0xa0]
    132e:	mov    rax,QWORD PTR [rbp-0xa8]
    1335:	mov    rsi,rdx
    1338:	mov    rdi,rax
    133b:	call   1100 <stat@plt>
#endif

  return stats.st_size;
    1340:	mov    rax,QWORD PTR [rbp-0x70]
}
    1344:	mov    rdx,QWORD PTR [rbp-0x8]
    1348:	sub    rdx,QWORD PTR fs:0x28
    1351:	je     1358 <file_size+0x52>
    1353:	call   1060 <__stack_chk_fail@plt>
    1358:	leave
    1359:	ret

000000000000135a <read_file_to_arena>:

String read_file_to_arena(Arena *arena, const char *name)
{
    135a:	push   rbp
    135b:	mov    rbp,rsp
    135e:	sub    rsp,0x50
    1362:	mov    QWORD PTR [rbp-0x48],rdi
    1366:	mov    QWORD PTR [rbp-0x50],rsi
  usize buffer_size = file_size(name);
    136a:	mov    rax,QWORD PTR [rbp-0x50]
    136e:	mov    rdi,rax
    1371:	call   1306 <file_size>
    1376:	mov    QWORD PTR [rbp-0x40],rax

  // Just in case we fail reading we won't commit any allocations
  Arena save = *arena;
    137a:	mov    rcx,QWORD PTR [rbp-0x48]
    137e:	mov    rax,QWORD PTR [rcx]
    1381:	mov    rdx,QWORD PTR [rcx+0x8]
    1385:	mov    QWORD PTR [rbp-0x20],rax
    1389:	mov    QWORD PTR [rbp-0x18],rdx
    138d:	mov    rax,QWORD PTR [rcx+0x10]
    1391:	mov    rdx,QWORD PTR [rcx+0x18]
    1395:	mov    QWORD PTR [rbp-0x10],rax
    1399:	mov    QWORD PTR [rbp-0x8],rdx
  u8 *buffer = arena_calloc(arena, buffer_size, u8);
    139d:	mov    rcx,QWORD PTR [rbp-0x40]
    13a1:	mov    rax,QWORD PTR [rbp-0x48]
    13a5:	mov    edx,0x1
    13aa:	mov    rsi,rcx
    13ad:	mov    rdi,rax
    13b0:	call   17d6 <arena_alloc>
    13b5:	mov    QWORD PTR [rbp-0x38],rax

  if (read_file_to_memory(name, buffer, buffer_size) != buffer_size)
    13b9:	mov    rdx,QWORD PTR [rbp-0x40]
    13bd:	mov    rcx,QWORD PTR [rbp-0x38]
    13c1:	mov    rax,QWORD PTR [rbp-0x50]
    13c5:	mov    rsi,rcx
    13c8:	mov    rdi,rax
    13cb:	call   1269 <read_file_to_memory>
    13d0:	cmp    QWORD PTR [rbp-0x40],rax
    13d4:	je     1428 <read_file_to_arena+0xce>
  {
    LOG_ERROR("Unable to read file: %s", name);
    13d6:	mov    rcx,QWORD PTR [rbp-0x50]
    13da:	lea    rdx,[rip+0x2c57]        # 4038 <_IO_stdin_used+0x38>
    13e1:	lea    rax,[rip+0x2c43]        # 402b <_IO_stdin_used+0x2b>
    13e8:	mov    r8,rcx
    13eb:	mov    rcx,rdx
    13ee:	mov    edx,0x1a0
    13f3:	mov    rsi,rax
    13f6:	mov    edi,0x1
    13fb:	mov    eax,0x0
    1400:	call   14a4 <log_message>
    *arena = save; // Rollback allocation
    1405:	mov    rcx,QWORD PTR [rbp-0x48]
    1409:	mov    rax,QWORD PTR [rbp-0x20]
    140d:	mov    rdx,QWORD PTR [rbp-0x18]
    1411:	mov    QWORD PTR [rcx],rax
    1414:	mov    QWORD PTR [rcx+0x8],rdx
    1418:	mov    rax,QWORD PTR [rbp-0x10]
    141c:	mov    rdx,QWORD PTR [rbp-0x8]
    1420:	mov    QWORD PTR [rcx+0x10],rax
    1424:	mov    QWORD PTR [rcx+0x18],rdx
  }

  String result =
    1428:	mov    rax,QWORD PTR [rbp-0x38]
    142c:	mov    QWORD PTR [rbp-0x30],rax
    1430:	mov    rax,QWORD PTR [rbp-0x40]
    1434:	mov    QWORD PTR [rbp-0x28],rax
  {
    .data  = buffer,
    .count = buffer_size,
  };

  return result;
    1438:	mov    rax,QWORD PTR [rbp-0x30]
    143c:	mov    rdx,QWORD PTR [rbp-0x28]
}
    1440:	leave
    1441:	ret

0000000000001442 <strings_equal>:

b8 strings_equal(String a, String b)
{
    1442:	push   rbp
    1443:	mov    rbp,rsp
    1446:	sub    rsp,0x20
    144a:	mov    rax,rdi
    144d:	mov    r8,rsi
    1450:	mov    rsi,rax
    1453:	mov    edi,0x0
    1458:	mov    rdi,r8
    145b:	mov    QWORD PTR [rbp-0x10],rsi
    145f:	mov    QWORD PTR [rbp-0x8],rdi
    1463:	mov    QWORD PTR [rbp-0x20],rdx
    1467:	mov    QWORD PTR [rbp-0x18],rcx
  return a.count == b.count && memcmp(a.data, b.data, a.count) == 0;
    146b:	mov    rdx,QWORD PTR [rbp-0x8]
    146f:	mov    rax,QWORD PTR [rbp-0x18]
    1473:	cmp    rdx,rax
    1476:	jne    149d <strings_equal+0x5b>
    1478:	mov    rax,QWORD PTR [rbp-0x8]
    147c:	mov    rdx,rax
    147f:	mov    rcx,QWORD PTR [rbp-0x20]
    1483:	mov    rax,QWORD PTR [rbp-0x10]
    1487:	mov    rsi,rcx
    148a:	mov    rdi,rax
    148d:	call   10d0 <memcmp@plt>
    1492:	test   eax,eax
    1494:	jne    149d <strings_equal+0x5b>
    1496:	mov    eax,0x1
    149b:	jmp    14a2 <strings_equal+0x60>
    149d:	mov    eax,0x0
}
    14a2:	leave
    14a3:	ret

00000000000014a4 <log_message>:
{
  LOG_ENUM(ENUM_STRING)
};

void log_message(Log_Level level, const char *file, usize line, const char *message, ...)
{
    14a4:	push   rbp
    14a5:	mov    rbp,rsp
    14a8:	sub    rsp,0x100
    14af:	mov    DWORD PTR [rbp-0xe4],edi
    14b5:	mov    QWORD PTR [rbp-0xf0],rsi
    14bc:	mov    QWORD PTR [rbp-0xf8],rdx
    14c3:	mov    QWORD PTR [rbp-0x100],rcx
    14ca:	mov    QWORD PTR [rbp-0x90],r8
    14d1:	mov    QWORD PTR [rbp-0x88],r9
    14d8:	test   al,al
    14da:	je     14fc <log_message+0x58>
    14dc:	movaps XMMWORD PTR [rbp-0x80],xmm0
    14e0:	movaps XMMWORD PTR [rbp-0x70],xmm1
    14e4:	movaps XMMWORD PTR [rbp-0x60],xmm2
    14e8:	movaps XMMWORD PTR [rbp-0x50],xmm3
    14ec:	movaps XMMWORD PTR [rbp-0x40],xmm4
    14f0:	movaps XMMWORD PTR [rbp-0x30],xmm5
    14f4:	movaps XMMWORD PTR [rbp-0x20],xmm6
    14f8:	movaps XMMWORD PTR [rbp-0x10],xmm7
    14fc:	mov    rax,QWORD PTR fs:0x28
    1505:	mov    QWORD PTR [rbp-0xb8],rax
    150c:	xor    eax,eax
  FILE *stream = stderr;
    150e:	mov    rax,QWORD PTR [rip+0x5c6b]        # 7180 <stderr@GLIBC_2.2.5>
    1515:	mov    QWORD PTR [rbp-0xd8],rax
  if (level <= LOG_ERROR)
    151c:	cmp    DWORD PTR [rbp-0xe4],0x1
    1523:	ja     156c <log_message+0xc8>
  {
    fprintf(stream, "[" LOG_TITLE " %s]: (%s:%lu) ", level_strings[level], file, line);
    1525:	mov    eax,DWORD PTR [rbp-0xe4]
    152b:	lea    rdx,[rax*8+0x0]
    1533:	lea    rax,[rip+0x5b86]        # 70c0 <level_strings>
    153a:	mov    rdx,QWORD PTR [rdx+rax*1]
    153e:	mov    rdi,QWORD PTR [rbp-0xf8]
    1545:	mov    rcx,QWORD PTR [rbp-0xf0]
    154c:	lea    rsi,[rip+0x2b24]        # 4077 <_IO_stdin_used+0x77>
    1553:	mov    rax,QWORD PTR [rbp-0xd8]
    155a:	mov    r8,rdi
    155d:	mov    rdi,rax
    1560:	mov    eax,0x0
    1565:	call   10f0 <fprintf@plt>
    156a:	jmp    15ba <log_message+0x116>
  }
  else
  {
    if (level == LOG_INFO)
    156c:	cmp    DWORD PTR [rbp-0xe4],0x3
    1573:	jne    1583 <log_message+0xdf>
    {
      stream = stdout;
    1575:	mov    rax,QWORD PTR [rip+0x5be4]        # 7160 <stdout@GLIBC_2.2.5>
    157c:	mov    QWORD PTR [rbp-0xd8],rax
    }
    fprintf(stream, "[" LOG_TITLE " %s]: ", level_strings[level]);
    1583:	mov    eax,DWORD PTR [rbp-0xe4]
    1589:	lea    rdx,[rax*8+0x0]
    1591:	lea    rax,[rip+0x5b28]        # 70c0 <level_strings>
    1598:	mov    rdx,QWORD PTR [rdx+rax*1]
    159c:	lea    rcx,[rip+0x2aeb]        # 408e <_IO_stdin_used+0x8e>
    15a3:	mov    rax,QWORD PTR [rbp-0xd8]
    15aa:	mov    rsi,rcx
    15ad:	mov    rdi,rax
    15b0:	mov    eax,0x0
    15b5:	call   10f0 <fprintf@plt>
  }

  va_list args;
  va_start(args, message);
    15ba:	mov    DWORD PTR [rbp-0xd0],0x20
    15c4:	mov    DWORD PTR [rbp-0xcc],0x30
    15ce:	lea    rax,[rbp+0x10]
    15d2:	mov    QWORD PTR [rbp-0xc8],rax
    15d9:	lea    rax,[rbp-0xb0]
    15e0:	mov    QWORD PTR [rbp-0xc0],rax
  vfprintf(stream, message, args);
    15e7:	lea    rdx,[rbp-0xd0]
    15ee:	mov    rcx,QWORD PTR [rbp-0x100]
    15f5:	mov    rax,QWORD PTR [rbp-0xd8]
    15fc:	mov    rsi,rcx
    15ff:	mov    rdi,rax
    1602:	call   1120 <vfprintf@plt>
  va_end(args);

  fprintf(stream, "\n");
    1607:	mov    rax,QWORD PTR [rbp-0xd8]
    160e:	mov    rsi,rax
    1611:	mov    edi,0xa
    1616:	call   10c0 <fputc@plt>
}
    161b:	nop
    161c:	mov    rax,QWORD PTR [rbp-0xb8]
    1623:	sub    rax,QWORD PTR fs:0x28
    162c:	je     1633 <log_message+0x18f>
    162e:	call   1060 <__stack_chk_fail@plt>
    1633:	leave
    1634:	ret

0000000000001635 <arena_make>:

Arena arena_make(isize reserve_size)
{
    1635:	push   rbp
    1636:	mov    rbp,rsp
    1639:	sub    rsp,0x30
    163d:	mov    QWORD PTR [rbp-0x28],rdi
    1641:	mov    QWORD PTR [rbp-0x30],rsi
  Arena arena = {0};
    1645:	pxor   xmm0,xmm0
    1649:	movaps XMMWORD PTR [rbp-0x20],xmm0
    164d:	movaps XMMWORD PTR [rbp-0x10],xmm0

  // NOTE(ss): Calloc will return page-aligned memory so I don't think it is
  // necessary to make sure that the alignment suffices
  arena.base = (u8 *)calloc(reserve_size, 1);
    1651:	mov    rax,QWORD PTR [rbp-0x30]
    1655:	mov    esi,0x1
    165a:	mov    rdi,rax
    165d:	call   10e0 <calloc@plt>
    1662:	mov    QWORD PTR [rbp-0x20],rax

  if (arena.base == NULL)
    1666:	mov    rax,QWORD PTR [rbp-0x20]
    166a:	test   rax,rax
    166d:	jne    16a1 <arena_make+0x6c>
  {
    LOG_FATAL("Failed to allocate arena memory", EXT_ARENA_ALLOCATION);
    166f:	lea    rdx,[rip+0x2a2a]        # 40a0 <_IO_stdin_used+0xa0>
    1676:	lea    rax,[rip+0x29ae]        # 402b <_IO_stdin_used+0x2b>
    167d:	mov    rcx,rdx
    1680:	mov    edx,0x1dc
    1685:	mov    rsi,rax
    1688:	mov    edi,0x0
    168d:	mov    eax,0x0
    1692:	call   14a4 <log_message>
    1697:	mov    edi,0xffffffff
    169c:	call   1150 <exit@plt>
    return arena;
  }

  arena.capacity = reserve_size;
    16a1:	mov    rax,QWORD PTR [rbp-0x30]
    16a5:	mov    QWORD PTR [rbp-0x18],rax
  arena.next_offset = 0;
    16a9:	mov    QWORD PTR [rbp-0x10],0x0

  return arena;
    16b1:	mov    rcx,QWORD PTR [rbp-0x28]
    16b5:	mov    rax,QWORD PTR [rbp-0x20]
    16b9:	mov    rdx,QWORD PTR [rbp-0x18]
    16bd:	mov    QWORD PTR [rcx],rax
    16c0:	mov    QWORD PTR [rcx+0x8],rdx
    16c4:	mov    rax,QWORD PTR [rbp-0x10]
    16c8:	mov    rdx,QWORD PTR [rbp-0x8]
    16cc:	mov    QWORD PTR [rcx+0x10],rax
    16d0:	mov    QWORD PTR [rcx+0x18],rdx
}
    16d4:	mov    rax,QWORD PTR [rbp-0x28]
    16d8:	leave
    16d9:	ret

00000000000016da <arena_make_backed>:

Arena arena_make_backed(u8 *backing_buffer, isize backing_size)
{
    16da:	push   rbp
    16db:	mov    rbp,rsp
    16de:	sub    rsp,0x40
    16e2:	mov    QWORD PTR [rbp-0x28],rdi
    16e6:	mov    QWORD PTR [rbp-0x30],rsi
    16ea:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(backing_buffer != NULL, "Backing buffer for arena must not be NULL!");
    16ee:	cmp    QWORD PTR [rbp-0x30],0x0
    16f3:	jne    171a <arena_make_backed+0x40>
    16f5:	lea    rdx,[rip+0x3094]        # 4790 <__PRETTY_FUNCTION__.9>
    16fc:	lea    rsi,[rip+0x2928]        # 402b <_IO_stdin_used+0x2b>
    1703:	lea    rax,[rip+0x29b6]        # 40c0 <_IO_stdin_used+0xc0>
    170a:	mov    rcx,rdx
    170d:	mov    edx,0x1e8
    1712:	mov    rdi,rax
    1715:	call   1090 <__assert_fail@plt>
  ASSERT(backing_size   != 0,    "Backing buffer size for arena must not be 0!");
    171a:	cmp    QWORD PTR [rbp-0x38],0x0
    171f:	jne    1746 <arena_make_backed+0x6c>
    1721:	lea    rdx,[rip+0x3068]        # 4790 <__PRETTY_FUNCTION__.9>
    1728:	lea    rsi,[rip+0x28fc]        # 402b <_IO_stdin_used+0x2b>
    172f:	lea    rax,[rip+0x29da]        # 4110 <_IO_stdin_used+0x110>
    1736:	mov    rcx,rdx
    1739:	mov    edx,0x1e9
    173e:	mov    rdi,rax
    1741:	call   1090 <__assert_fail@plt>

  Arena arena = {0};
    1746:	pxor   xmm0,xmm0
    174a:	movaps XMMWORD PTR [rbp-0x20],xmm0
    174e:	movaps XMMWORD PTR [rbp-0x10],xmm0

  arena.base     = backing_buffer;
    1752:	mov    rax,QWORD PTR [rbp-0x30]
    1756:	mov    QWORD PTR [rbp-0x20],rax
  arena.capacity = backing_size;
    175a:	mov    rax,QWORD PTR [rbp-0x38]
    175e:	mov    QWORD PTR [rbp-0x18],rax

  // Shitty cpp compilers complain we don't do it like this
  arena.flags = (Arena_Flags)(arena.flags | ARENA_FLAG_BUFFER_BACKED);
    1762:	mov    eax,DWORD PTR [rbp-0x8]
    1765:	or     eax,0x1
    1768:	mov    DWORD PTR [rbp-0x8],eax

  return arena;
    176b:	mov    rcx,QWORD PTR [rbp-0x28]
    176f:	mov    rax,QWORD PTR [rbp-0x20]
    1773:	mov    rdx,QWORD PTR [rbp-0x18]
    1777:	mov    QWORD PTR [rcx],rax
    177a:	mov    QWORD PTR [rcx+0x8],rdx
    177e:	mov    rax,QWORD PTR [rbp-0x10]
    1782:	mov    rdx,QWORD PTR [rbp-0x8]
    1786:	mov    QWORD PTR [rcx+0x10],rax
    178a:	mov    QWORD PTR [rcx+0x18],rdx
}
    178e:	mov    rax,QWORD PTR [rbp-0x28]
    1792:	leave
    1793:	ret

0000000000001794 <arena_free>:

void arena_free(Arena *arena)
{
    1794:	push   rbp
    1795:	mov    rbp,rsp
    1798:	sub    rsp,0x10
    179c:	mov    QWORD PTR [rbp-0x8],rdi
  if (!(arena->flags & ARENA_FLAG_BUFFER_BACKED))
    17a0:	mov    rax,QWORD PTR [rbp-0x8]
    17a4:	mov    eax,DWORD PTR [rax+0x18]
    17a7:	and    eax,0x1
    17aa:	test   eax,eax
    17ac:	jne    17bd <arena_free+0x29>
  {
    free(arena->base);
    17ae:	mov    rax,QWORD PTR [rbp-0x8]
    17b2:	mov    rax,QWORD PTR [rax]
    17b5:	mov    rdi,rax
    17b8:	call   1030 <free@plt>
  }

  ZERO_STRUCT(arena);
    17bd:	mov    rax,QWORD PTR [rbp-0x8]
    17c1:	mov    edx,0x20
    17c6:	mov    esi,0x0
    17cb:	mov    rdi,rax
    17ce:	call   10a0 <memset@plt>
}
    17d3:	nop
    17d4:	leave
    17d5:	ret

00000000000017d6 <arena_alloc>:

void *arena_alloc(Arena *arena, isize size, isize alignment) {
    17d6:	push   rbp
    17d7:	mov    rbp,rsp
    17da:	sub    rsp,0x40
    17de:	mov    QWORD PTR [rbp-0x28],rdi
    17e2:	mov    QWORD PTR [rbp-0x30],rsi
    17e6:	mov    QWORD PTR [rbp-0x38],rdx
  ASSERT(arena->base != NULL, "Arena memory is null");
    17ea:	mov    rax,QWORD PTR [rbp-0x28]
    17ee:	mov    rax,QWORD PTR [rax]
    17f1:	test   rax,rax
    17f4:	jne    181b <arena_alloc+0x45>
    17f6:	lea    rdx,[rip+0x2fab]        # 47a8 <__PRETTY_FUNCTION__.8>
    17fd:	lea    rsi,[rip+0x2827]        # 402b <_IO_stdin_used+0x2b>
    1804:	lea    rax,[rip+0x294d]        # 4158 <_IO_stdin_used+0x158>
    180b:	mov    rcx,rdx
    180e:	mov    edx,0x201
    1813:	mov    rdi,rax
    1816:	call   1090 <__assert_fail@plt>

  isize aligned_offset = ALIGN_ROUND_UP(arena->next_offset, alignment);
    181b:	mov    rax,QWORD PTR [rbp-0x28]
    181f:	mov    rdx,QWORD PTR [rax+0x10]
    1823:	mov    rax,QWORD PTR [rbp-0x38]
    1827:	add    rax,rdx
    182a:	lea    rdx,[rax-0x1]
    182e:	mov    rax,QWORD PTR [rbp-0x38]
    1832:	neg    rax
    1835:	and    rax,rdx
    1838:	mov    QWORD PTR [rbp-0x18],rax

  // Do we need a bigger buffer?
  if ((aligned_offset + size) > arena->capacity)
    183c:	mov    rdx,QWORD PTR [rbp-0x18]
    1840:	mov    rax,QWORD PTR [rbp-0x30]
    1844:	add    rdx,rax
    1847:	mov    rax,QWORD PTR [rbp-0x28]
    184b:	mov    rax,QWORD PTR [rax+0x8]
    184f:	cmp    rdx,rax
    1852:	jle    18a7 <arena_alloc+0xd1>
  {
    u64 needed_capacity = aligned_offset + size;
    1854:	mov    rdx,QWORD PTR [rbp-0x18]
    1858:	mov    rax,QWORD PTR [rbp-0x30]
    185c:	add    rax,rdx
    185f:	mov    QWORD PTR [rbp-0x8],rax

    LOG_FATAL("Not enough memory in arena, NEED: %ld bytes HAVE: %ld bytes",
    1863:	mov    rax,QWORD PTR [rbp-0x28]
    1867:	mov    rsi,QWORD PTR [rax+0x8]
    186b:	mov    rcx,QWORD PTR [rbp-0x8]
    186f:	lea    rdx,[rip+0x291a]        # 4190 <_IO_stdin_used+0x190>
    1876:	lea    rax,[rip+0x27ae]        # 402b <_IO_stdin_used+0x2b>
    187d:	mov    r9,rsi
    1880:	mov    r8,rcx
    1883:	mov    rcx,rdx
    1886:	mov    edx,0x20a
    188b:	mov    rsi,rax
    188e:	mov    edi,0x0
    1893:	mov    eax,0x0
    1898:	call   14a4 <log_message>
    189d:	mov    edi,0xffffffff
    18a2:	call   1150 <exit@plt>
              EXT_ARENA_ALLOCATION, needed_capacity, arena->capacity);
    return NULL;
  }

  void *ptr = arena->base + aligned_offset;
    18a7:	mov    rax,QWORD PTR [rbp-0x28]
    18ab:	mov    rdx,QWORD PTR [rax]
    18ae:	mov    rax,QWORD PTR [rbp-0x18]
    18b2:	add    rax,rdx
    18b5:	mov    QWORD PTR [rbp-0x10],rax
  ZERO_SIZE(ptr, size); // make sure memory is zeroed out
    18b9:	mov    rdx,QWORD PTR [rbp-0x30]
    18bd:	mov    rax,QWORD PTR [rbp-0x10]
    18c1:	mov    esi,0x0
    18c6:	mov    rdi,rax
    18c9:	call   10a0 <memset@plt>

  // now move the offset
  arena->next_offset = aligned_offset + size;
    18ce:	mov    rdx,QWORD PTR [rbp-0x18]
    18d2:	mov    rax,QWORD PTR [rbp-0x30]
    18d6:	add    rdx,rax
    18d9:	mov    rax,QWORD PTR [rbp-0x28]
    18dd:	mov    QWORD PTR [rax+0x10],rdx

  return ptr;
    18e1:	mov    rax,QWORD PTR [rbp-0x10]
}
    18e5:	leave
    18e6:	ret

00000000000018e7 <arena_pop_to>:

void arena_pop_to(Arena *arena, isize offset)
{
    18e7:	push   rbp
    18e8:	mov    rbp,rsp
    18eb:	sub    rsp,0x10
    18ef:	mov    QWORD PTR [rbp-0x8],rdi
    18f3:	mov    QWORD PTR [rbp-0x10],rsi
  ASSERT(offset < arena->next_offset,
    18f7:	mov    rax,QWORD PTR [rbp-0x8]
    18fb:	mov    rax,QWORD PTR [rax+0x10]
    18ff:	cmp    QWORD PTR [rbp-0x10],rax
    1903:	jl     192a <arena_pop_to+0x43>
    1905:	lea    rdx,[rip+0x2eac]        # 47b8 <__PRETTY_FUNCTION__.7>
    190c:	lea    rsi,[rip+0x2718]        # 402b <_IO_stdin_used+0x2b>
    1913:	lea    rax,[rip+0x28b6]        # 41d0 <_IO_stdin_used+0x1d0>
    191a:	mov    rcx,rdx
    191d:	mov    edx,0x21a
    1922:	mov    rdi,rax
    1925:	call   1090 <__assert_fail@plt>
         "Failed to pop arena allocation, more than currently allocated");

  // Should we zero out the memory?
  arena->next_offset = offset;
    192a:	mov    rax,QWORD PTR [rbp-0x8]
    192e:	mov    rdx,QWORD PTR [rbp-0x10]
    1932:	mov    QWORD PTR [rax+0x10],rdx
}
    1936:	nop
    1937:	leave
    1938:	ret

0000000000001939 <arena_pop>:

void arena_pop(Arena *arena, isize size)
{
    1939:	push   rbp
    193a:	mov    rbp,rsp
    193d:	sub    rsp,0x10
    1941:	mov    QWORD PTR [rbp-0x8],rdi
    1945:	mov    QWORD PTR [rbp-0x10],rsi
  arena_pop_to(arena, arena->next_offset - size);
    1949:	mov    rax,QWORD PTR [rbp-0x8]
    194d:	mov    rax,QWORD PTR [rax+0x10]
    1951:	sub    rax,QWORD PTR [rbp-0x10]
    1955:	mov    rdx,rax
    1958:	mov    rax,QWORD PTR [rbp-0x8]
    195c:	mov    rsi,rdx
    195f:	mov    rdi,rax
    1962:	call   18e7 <arena_pop_to>
}
    1967:	nop
    1968:	leave
    1969:	ret

000000000000196a <arena_clear>:

void arena_clear(Arena *arena)
{
    196a:	push   rbp
    196b:	mov    rbp,rsp
    196e:	mov    QWORD PTR [rbp-0x8],rdi
  arena->next_offset = 0;
    1972:	mov    rax,QWORD PTR [rbp-0x8]
    1976:	mov    QWORD PTR [rax+0x10],0x0
}
    197e:	nop
    197f:	pop    rbp
    1980:	ret

0000000000001981 <scratch_begin>:

Scratch scratch_begin(Arena *arena)
{
    1981:	push   rbp
    1982:	mov    rbp,rsp
    1985:	mov    QWORD PTR [rbp-0x18],rdi
  Scratch scratch = {.arena = arena, .offset_save = arena->next_offset};
    1989:	mov    rax,QWORD PTR [rbp-0x18]
    198d:	mov    QWORD PTR [rbp-0x10],rax
    1991:	mov    rax,QWORD PTR [rbp-0x18]
    1995:	mov    rax,QWORD PTR [rax+0x10]
    1999:	mov    QWORD PTR [rbp-0x8],rax
  return scratch;
    199d:	mov    rax,QWORD PTR [rbp-0x10]
    19a1:	mov    rdx,QWORD PTR [rbp-0x8]
}
    19a5:	pop    rbp
    19a6:	ret

00000000000019a7 <scratch_end>:

void scratch_end(Scratch *scratch)
{
    19a7:	push   rbp
    19a8:	mov    rbp,rsp
    19ab:	sub    rsp,0x10
    19af:	mov    QWORD PTR [rbp-0x8],rdi
  arena_pop_to(scratch->arena, scratch->offset_save);
    19b3:	mov    rax,QWORD PTR [rbp-0x8]
    19b7:	mov    rdx,QWORD PTR [rax+0x8]
    19bb:	mov    rax,QWORD PTR [rbp-0x8]
    19bf:	mov    rax,QWORD PTR [rax]
    19c2:	mov    rsi,rdx
    19c5:	mov    rdi,rax
    19c8:	call   18e7 <arena_pop_to>
  ZERO_STRUCT(scratch);
    19cd:	mov    rax,QWORD PTR [rbp-0x8]
    19d1:	mov    edx,0x10
    19d6:	mov    esi,0x0
    19db:	mov    rdi,rax
    19de:	call   10a0 <memset@plt>
}
    19e3:	nop
    19e4:	leave
    19e5:	ret

00000000000019e6 <get_os_timer_freq>:
#include <sys/time.h>

// NOTE(ss): Will need to be defined per OS
static
u64 get_os_timer_freq(void)
{
    19e6:	push   rbp
    19e7:	mov    rbp,rsp
  // Posix gettimeofday is in microseconds
  return 1000000;
    19ea:	mov    eax,0xf4240
}
    19ef:	pop    rbp
    19f0:	ret

00000000000019f1 <read_os_timer>:

// NOTE(ss): Will need to be defined per OS
static
u64 read_os_timer(void)
{
    19f1:	push   rbp
    19f2:	mov    rbp,rsp
    19f5:	sub    rsp,0x30
    19f9:	mov    rax,QWORD PTR fs:0x28
    1a02:	mov    QWORD PTR [rbp-0x8],rax
    1a06:	xor    eax,eax
  struct timeval value;
  gettimeofday(&value, 0);
    1a08:	lea    rax,[rbp-0x20]
    1a0c:	mov    esi,0x0
    1a11:	mov    rdi,rax
    1a14:	call   1080 <gettimeofday@plt>
  u64 result = get_os_timer_freq() * value.tv_sec + value.tv_usec;
    1a19:	call   19e6 <get_os_timer_freq>
    1a1e:	mov    rdx,QWORD PTR [rbp-0x20]
    1a22:	imul   rax,rdx
    1a26:	mov    rdx,QWORD PTR [rbp-0x18]
    1a2a:	add    rax,rdx
    1a2d:	mov    QWORD PTR [rbp-0x28],rax

  return result;
    1a31:	mov    rax,QWORD PTR [rbp-0x28]
}
    1a35:	mov    rdx,QWORD PTR [rbp-0x8]
    1a39:	sub    rdx,QWORD PTR fs:0x28
    1a42:	je     1a49 <read_os_timer+0x58>
    1a44:	call   1060 <__stack_chk_fail@plt>
    1a49:	leave
    1a4a:	ret

0000000000001a4b <read_cpu_timer>:

// NOTE(ss): Will need to be defined per ISA
static
u64 read_cpu_timer(void)
{
    1a4b:	push   rbp
    1a4c:	mov    rbp,rsp
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
    1a4f:	rdtsc
    1a51:	shl    rdx,0x20
    1a55:	or     rax,rdx
  return __rdtsc();
}
    1a58:	pop    rbp
    1a59:	ret

0000000000001a5a <estimate_cpu_freq>:

// Just an estimation, in microseconds
static
u64 estimate_cpu_freq(void)
{
    1a5a:	push   rbp
    1a5b:	mov    rbp,rsp
    1a5e:	sub    rsp,0x50
  u64 wait_milliseconds = 100;
    1a62:	mov    QWORD PTR [rbp-0x48],0x64
  u64 os_frequency = get_os_timer_freq();
    1a6a:	call   19e6 <get_os_timer_freq>
    1a6f:	mov    QWORD PTR [rbp-0x40],rax

  u64 cpu_start = read_cpu_timer();
    1a73:	call   1a4b <read_cpu_timer>
    1a78:	mov    QWORD PTR [rbp-0x38],rax
  u64 os_start  = read_os_timer();
    1a7c:	call   19f1 <read_os_timer>
    1a81:	mov    QWORD PTR [rbp-0x30],rax

  u64 os_end   = 0;
    1a85:	mov    QWORD PTR [rbp-0x28],0x0
  u64 os_delta = 0;
    1a8d:	mov    QWORD PTR [rbp-0x50],0x0

  // In microseconds
  u64 os_wait_time = (os_frequency * wait_milliseconds) / 1000;
    1a95:	mov    rax,QWORD PTR [rbp-0x40]
    1a99:	imul   rax,QWORD PTR [rbp-0x48]
    1a9e:	shr    rax,0x3
    1aa2:	movabs rdx,0x20c49ba5e353f7cf
    1aac:	mul    rdx
    1aaf:	mov    rax,rdx
    1ab2:	shr    rax,0x4
    1ab6:	mov    QWORD PTR [rbp-0x20],rax
  while (os_delta < os_wait_time)
    1aba:	jmp    1ad1 <estimate_cpu_freq+0x77>
  {
    os_end   = read_os_timer();
    1abc:	call   19f1 <read_os_timer>
    1ac1:	mov    QWORD PTR [rbp-0x28],rax
    os_delta = os_end - os_start;
    1ac5:	mov    rax,QWORD PTR [rbp-0x28]
    1ac9:	sub    rax,QWORD PTR [rbp-0x30]
    1acd:	mov    QWORD PTR [rbp-0x50],rax
  while (os_delta < os_wait_time)
    1ad1:	mov    rax,QWORD PTR [rbp-0x50]
    1ad5:	cmp    rax,QWORD PTR [rbp-0x20]
    1ad9:	jb     1abc <estimate_cpu_freq+0x62>
  }

  u64 cpu_end   = read_cpu_timer();
    1adb:	call   1a4b <read_cpu_timer>
    1ae0:	mov    QWORD PTR [rbp-0x18],rax
  u64 cpu_delta = cpu_end - cpu_start;
    1ae4:	mov    rax,QWORD PTR [rbp-0x18]
    1ae8:	sub    rax,QWORD PTR [rbp-0x38]
    1aec:	mov    QWORD PTR [rbp-0x10],rax

  u64 cpu_frequency = 0;
    1af0:	mov    QWORD PTR [rbp-0x8],0x0

  assert(os_delta != 0 && "OS Time delta for cpu frequency estimation was somehow 0!");
    1af8:	cmp    QWORD PTR [rbp-0x50],0x0
    1afd:	jne    1b24 <estimate_cpu_freq+0xca>
    1aff:	lea    rdx,[rip+0x2cca]        # 47d0 <__PRETTY_FUNCTION__.6>
    1b06:	lea    rsi,[rip+0x2722]        # 422f <_IO_stdin_used+0x22f>
    1b0d:	lea    rax,[rip+0x2734]        # 4248 <_IO_stdin_used+0x248>
    1b14:	mov    rcx,rdx
    1b17:	mov    edx,0x3a
    1b1c:	mov    rdi,rax
    1b1f:	call   1090 <__assert_fail@plt>

  // CPU time in OS ticks, divide by OS delta gives estimate of cpu frequency
  cpu_frequency = os_frequency * cpu_delta / os_delta;
    1b24:	mov    rax,QWORD PTR [rbp-0x40]
    1b28:	imul   rax,QWORD PTR [rbp-0x10]
    1b2d:	mov    edx,0x0
    1b32:	div    QWORD PTR [rbp-0x50]
    1b36:	mov    QWORD PTR [rbp-0x8],rax

  return cpu_frequency;
    1b3a:	mov    rax,QWORD PTR [rbp-0x8]
}
    1b3e:	leave
    1b3f:	ret

0000000000001b40 <cpu_time_in_seconds>:

static
f64 cpu_time_in_seconds(u64 cpu_time, u64 cpu_timer_frequency)
{
    1b40:	push   rbp
    1b41:	mov    rbp,rsp
    1b44:	mov    QWORD PTR [rbp-0x18],rdi
    1b48:	mov    QWORD PTR [rbp-0x20],rsi
  f64 result = 0.0;
    1b4c:	pxor   xmm0,xmm0
    1b50:	movsd  QWORD PTR [rbp-0x8],xmm0
  if (cpu_timer_frequency)
    1b55:	cmp    QWORD PTR [rbp-0x20],0x0
    1b5a:	je     1bbf <cpu_time_in_seconds+0x7f>
  {
    result = (f64)cpu_time / (f64)cpu_timer_frequency;
    1b5c:	mov    rax,QWORD PTR [rbp-0x18]
    1b60:	test   rax,rax
    1b63:	js     1b70 <cpu_time_in_seconds+0x30>
    1b65:	pxor   xmm0,xmm0
    1b69:	cvtsi2sd xmm0,rax
    1b6e:	jmp    1b89 <cpu_time_in_seconds+0x49>
    1b70:	mov    rdx,rax
    1b73:	shr    rdx,1
    1b76:	and    eax,0x1
    1b79:	or     rdx,rax
    1b7c:	pxor   xmm0,xmm0
    1b80:	cvtsi2sd xmm0,rdx
    1b85:	addsd  xmm0,xmm0
    1b89:	mov    rax,QWORD PTR [rbp-0x20]
    1b8d:	test   rax,rax
    1b90:	js     1b9d <cpu_time_in_seconds+0x5d>
    1b92:	pxor   xmm1,xmm1
    1b96:	cvtsi2sd xmm1,rax
    1b9b:	jmp    1bb6 <cpu_time_in_seconds+0x76>
    1b9d:	mov    rdx,rax
    1ba0:	shr    rdx,1
    1ba3:	and    eax,0x1
    1ba6:	or     rdx,rax
    1ba9:	pxor   xmm1,xmm1
    1bad:	cvtsi2sd xmm1,rdx
    1bb2:	addsd  xmm1,xmm1
    1bb6:	divsd  xmm0,xmm1
    1bba:	movsd  QWORD PTR [rbp-0x8],xmm0
  }

  return result;
    1bbf:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    1bc4:	pop    rbp
    1bc5:	ret

0000000000001bc6 <begin_profiling>:

static Profiler g_profiler;

static
void begin_profiling()
{
    1bc6:	push   rbp
    1bc7:	mov    rbp,rsp
    1bca:	push   rbx
    1bcb:	sub    rsp,0x30028
    1bd2:	mov    rax,QWORD PTR fs:0x28
    1bdb:	mov    QWORD PTR [rbp-0x18],rax
    1bdf:	xor    eax,eax
  g_profiler = (Profiler)
  {
    .start = read_cpu_timer(),
    1be1:	call   1a4b <read_cpu_timer>
    1be6:	mov    rbx,rax
  g_profiler = (Profiler)
    1be9:	lea    rax,[rip+0x55b0]        # 71a0 <g_profiler>
    1bf0:	mov    edx,0x30010
    1bf5:	mov    esi,0x0
    1bfa:	mov    rdi,rax
    1bfd:	call   10a0 <memset@plt>
    1c02:	mov    QWORD PTR [rip+0x5597],rbx        # 71a0 <g_profiler>
  };
}
    1c09:	nop
    1c0a:	mov    rax,QWORD PTR [rbp-0x18]
    1c0e:	sub    rax,QWORD PTR fs:0x28
    1c17:	je     1c1e <begin_profiling+0x58>
    1c19:	call   1060 <__stack_chk_fail@plt>
    1c1e:	mov    rbx,QWORD PTR [rbp-0x8]
    1c22:	leave
    1c23:	ret

0000000000001c24 <end_profiling>:

static
void end_profiling()
{
    1c24:	push   rbp
    1c25:	mov    rbp,rsp
    1c28:	sub    rsp,0x50
  u64 total_delta = read_cpu_timer() - g_profiler.start;
    1c2c:	call   1a4b <read_cpu_timer>
    1c31:	mov    rdx,rax
    1c34:	mov    rax,QWORD PTR [rip+0x5565]        # 71a0 <g_profiler>
    1c3b:	sub    rdx,rax
    1c3e:	mov    QWORD PTR [rbp-0x38],rdx

  if (total_delta)
    1c42:	cmp    QWORD PTR [rbp-0x38],0x0
    1c47:	je     1fee <end_profiling+0x3ca>
  {
    u64 freq = estimate_cpu_freq();
    1c4d:	call   1a5a <estimate_cpu_freq>
    1c52:	mov    QWORD PTR [rbp-0x30],rax
    printf("[PROFILE] Total duration: %lu (%f ms @ %lu Hz)\n", total_delta, (f64)total_delta / (f64)freq * 1000.0, freq);
    1c56:	mov    rax,QWORD PTR [rbp-0x38]
    1c5a:	test   rax,rax
    1c5d:	js     1c6a <end_profiling+0x46>
    1c5f:	pxor   xmm0,xmm0
    1c63:	cvtsi2sd xmm0,rax
    1c68:	jmp    1c83 <end_profiling+0x5f>
    1c6a:	mov    rdx,rax
    1c6d:	shr    rdx,1
    1c70:	and    eax,0x1
    1c73:	or     rdx,rax
    1c76:	pxor   xmm0,xmm0
    1c7a:	cvtsi2sd xmm0,rdx
    1c7f:	addsd  xmm0,xmm0
    1c83:	mov    rax,QWORD PTR [rbp-0x30]
    1c87:	test   rax,rax
    1c8a:	js     1c97 <end_profiling+0x73>
    1c8c:	pxor   xmm1,xmm1
    1c90:	cvtsi2sd xmm1,rax
    1c95:	jmp    1cb0 <end_profiling+0x8c>
    1c97:	mov    rdx,rax
    1c9a:	shr    rdx,1
    1c9d:	and    eax,0x1
    1ca0:	or     rdx,rax
    1ca3:	pxor   xmm1,xmm1
    1ca7:	cvtsi2sd xmm1,rdx
    1cac:	addsd  xmm1,xmm1
    1cb0:	movapd xmm2,xmm0
    1cb4:	divsd  xmm2,xmm1
    1cb8:	movsd  xmm0,QWORD PTR [rip+0x2bc8]        # 4888 <__PRETTY_FUNCTION__.0+0x18>
    1cc0:	mulsd  xmm2,xmm0
    1cc4:	movq   rcx,xmm2
    1cc9:	mov    rdx,QWORD PTR [rbp-0x30]
    1ccd:	mov    rax,QWORD PTR [rbp-0x38]
    1cd1:	lea    rdi,[rip+0x25c0]        # 4298 <_IO_stdin_used+0x298>
    1cd8:	movq   xmm0,rcx
    1cdd:	mov    rsi,rax
    1ce0:	mov    eax,0x1
    1ce5:	call   1070 <printf@plt>

    f64 exclusive_percent = 0.0;
    1cea:	pxor   xmm0,xmm0
    1cee:	movsd  QWORD PTR [rbp-0x48],xmm0

    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1cf3:	mov    QWORD PTR [rbp-0x40],0x0
    1cfb:	jmp    1fe0 <end_profiling+0x3bc>
    {
      Profile_Zone *zone = &g_profiler.zones[i];
    1d00:	mov    rdx,QWORD PTR [rbp-0x40]
    1d04:	mov    rax,rdx
    1d07:	add    rax,rax
    1d0a:	add    rax,rdx
    1d0d:	shl    rax,0x4
    1d11:	lea    rdx,[rax+0x10]
    1d15:	lea    rax,[rip+0x5484]        # 71a0 <g_profiler>
    1d1c:	add    rax,rdx
    1d1f:	mov    QWORD PTR [rbp-0x28],rax

      if (zone->elapsed_inclusive)
    1d23:	mov    rax,QWORD PTR [rbp-0x28]
    1d27:	mov    rax,QWORD PTR [rax+0x18]
    1d2b:	test   rax,rax
    1d2e:	je     1fdb <end_profiling+0x3b7>
      {
        f64 percent = ((f64)zone->elapsed_exclusive / (f64)total_delta) * 100.0;
    1d34:	mov    rax,QWORD PTR [rbp-0x28]
    1d38:	mov    rax,QWORD PTR [rax+0x10]
    1d3c:	test   rax,rax
    1d3f:	js     1d4c <end_profiling+0x128>
    1d41:	pxor   xmm0,xmm0
    1d45:	cvtsi2sd xmm0,rax
    1d4a:	jmp    1d65 <end_profiling+0x141>
    1d4c:	mov    rdx,rax
    1d4f:	shr    rdx,1
    1d52:	and    eax,0x1
    1d55:	or     rdx,rax
    1d58:	pxor   xmm0,xmm0
    1d5c:	cvtsi2sd xmm0,rdx
    1d61:	addsd  xmm0,xmm0
    1d65:	mov    rax,QWORD PTR [rbp-0x38]
    1d69:	test   rax,rax
    1d6c:	js     1d79 <end_profiling+0x155>
    1d6e:	pxor   xmm1,xmm1
    1d72:	cvtsi2sd xmm1,rax
    1d77:	jmp    1d92 <end_profiling+0x16e>
    1d79:	mov    rdx,rax
    1d7c:	shr    rdx,1
    1d7f:	and    eax,0x1
    1d82:	or     rdx,rax
    1d85:	pxor   xmm1,xmm1
    1d89:	cvtsi2sd xmm1,rdx
    1d8e:	addsd  xmm1,xmm1
    1d92:	movapd xmm2,xmm0
    1d96:	divsd  xmm2,xmm1
    1d9a:	movsd  xmm0,QWORD PTR [rip+0x2aee]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1da2:	mulsd  xmm0,xmm2
    1da6:	movsd  QWORD PTR [rbp-0x20],xmm0

        printf("[PROFILE] Zone '%.*s':\n"
    1dab:	mov    rax,QWORD PTR [rbp-0x28]
    1daf:	mov    rsi,QWORD PTR [rax+0x10]
    1db3:	mov    rax,QWORD PTR [rbp-0x28]
    1db7:	mov    rdx,QWORD PTR [rax+0x20]
    1dbb:	mov    rax,QWORD PTR [rbp-0x28]
    1dbf:	mov    rax,QWORD PTR [rax]
               "  Hit Count: %lu\n"
               "  Exclusive Timestamp Cycles: %lu (%.4f%%)\n"
               , String_Format(zone->name), zone->hit_count, zone->elapsed_exclusive, percent);
    1dc2:	mov    rcx,QWORD PTR [rbp-0x28]
    1dc6:	mov    rcx,QWORD PTR [rcx+0x8]
        printf("[PROFILE] Zone '%.*s':\n"
    1dca:	mov    r9d,ecx
    1dcd:	mov    rcx,QWORD PTR [rbp-0x20]
    1dd1:	lea    rdi,[rip+0x24f0]        # 42c8 <_IO_stdin_used+0x2c8>
    1dd8:	movq   xmm0,rcx
    1ddd:	mov    r8,rsi
    1de0:	mov    rcx,rdx
    1de3:	mov    rdx,rax
    1de6:	mov    esi,r9d
    1de9:	mov    eax,0x1
    1dee:	call   1070 <printf@plt>

        if (zone->elapsed_exclusive != zone->elapsed_inclusive)
    1df3:	mov    rax,QWORD PTR [rbp-0x28]
    1df7:	mov    rdx,QWORD PTR [rax+0x10]
    1dfb:	mov    rax,QWORD PTR [rbp-0x28]
    1dff:	mov    rax,QWORD PTR [rax+0x18]
    1e03:	cmp    rdx,rax
    1e06:	je     1eab <end_profiling+0x287>
        {
          f64 with_children_percent = ((f64)zone->elapsed_inclusive / (f64)total_delta) * 100.0;
    1e0c:	mov    rax,QWORD PTR [rbp-0x28]
    1e10:	mov    rax,QWORD PTR [rax+0x18]
    1e14:	test   rax,rax
    1e17:	js     1e24 <end_profiling+0x200>
    1e19:	pxor   xmm0,xmm0
    1e1d:	cvtsi2sd xmm0,rax
    1e22:	jmp    1e3d <end_profiling+0x219>
    1e24:	mov    rdx,rax
    1e27:	shr    rdx,1
    1e2a:	and    eax,0x1
    1e2d:	or     rdx,rax
    1e30:	pxor   xmm0,xmm0
    1e34:	cvtsi2sd xmm0,rdx
    1e39:	addsd  xmm0,xmm0
    1e3d:	mov    rax,QWORD PTR [rbp-0x38]
    1e41:	test   rax,rax
    1e44:	js     1e51 <end_profiling+0x22d>
    1e46:	pxor   xmm1,xmm1
    1e4a:	cvtsi2sd xmm1,rax
    1e4f:	jmp    1e6a <end_profiling+0x246>
    1e51:	mov    rdx,rax
    1e54:	shr    rdx,1
    1e57:	and    eax,0x1
    1e5a:	or     rdx,rax
    1e5d:	pxor   xmm1,xmm1
    1e61:	cvtsi2sd xmm1,rdx
    1e66:	addsd  xmm1,xmm1
    1e6a:	movapd xmm2,xmm0
    1e6e:	divsd  xmm2,xmm1
    1e72:	movsd  xmm0,QWORD PTR [rip+0x2a16]        # 4890 <__PRETTY_FUNCTION__.0+0x20>
    1e7a:	mulsd  xmm0,xmm2
    1e7e:	movsd  QWORD PTR [rbp-0x18],xmm0
          printf("  Inclusive Timestamp Cycles: %lu (%.4f%%)\n", zone->elapsed_inclusive, with_children_percent);
    1e83:	mov    rax,QWORD PTR [rbp-0x28]
    1e87:	mov    rax,QWORD PTR [rax+0x18]
    1e8b:	mov    rdx,QWORD PTR [rbp-0x18]
    1e8f:	lea    rcx,[rip+0x248a]        # 4320 <_IO_stdin_used+0x320>
    1e96:	movq   xmm0,rdx
    1e9b:	mov    rsi,rax
    1e9e:	mov    rdi,rcx
    1ea1:	mov    eax,0x1
    1ea6:	call   1070 <printf@plt>
        }

        exclusive_percent += percent;
    1eab:	movsd  xmm0,QWORD PTR [rbp-0x48]
    1eb0:	addsd  xmm0,QWORD PTR [rbp-0x20]
    1eb5:	movsd  QWORD PTR [rbp-0x48],xmm0

        if (zone->bytes_processed)
    1eba:	mov    rax,QWORD PTR [rbp-0x28]
    1ebe:	mov    rax,QWORD PTR [rax+0x28]
    1ec2:	test   rax,rax
    1ec5:	je     1fdb <end_profiling+0x3b7>
        {
          f64 megabytes = (f64)zone->bytes_processed / MB(1);
    1ecb:	mov    rax,QWORD PTR [rbp-0x28]
    1ecf:	mov    rax,QWORD PTR [rax+0x28]
    1ed3:	test   rax,rax
    1ed6:	js     1ee3 <end_profiling+0x2bf>
    1ed8:	pxor   xmm0,xmm0
    1edc:	cvtsi2sd xmm0,rax
    1ee1:	jmp    1efc <end_profiling+0x2d8>
    1ee3:	mov    rdx,rax
    1ee6:	shr    rdx,1
    1ee9:	and    eax,0x1
    1eec:	or     rdx,rax
    1eef:	pxor   xmm0,xmm0
    1ef3:	cvtsi2sd xmm0,rdx
    1ef8:	addsd  xmm0,xmm0
    1efc:	movsd  xmm1,QWORD PTR [rip+0x2994]        # 4898 <__PRETTY_FUNCTION__.0+0x28>
    1f04:	divsd  xmm0,xmm1
    1f08:	movsd  QWORD PTR [rbp-0x10],xmm0

          f64 gb_per_s = (f64)zone->bytes_processed / ((f64)zone->elapsed_inclusive / (f64)freq) / (f64)GB(1.0);
    1f0d:	mov    rax,QWORD PTR [rbp-0x28]
    1f11:	mov    rax,QWORD PTR [rax+0x28]
    1f15:	test   rax,rax
    1f18:	js     1f25 <end_profiling+0x301>
    1f1a:	pxor   xmm0,xmm0
    1f1e:	cvtsi2sd xmm0,rax
    1f23:	jmp    1f3e <end_profiling+0x31a>
    1f25:	mov    rdx,rax
    1f28:	shr    rdx,1
    1f2b:	and    eax,0x1
    1f2e:	or     rdx,rax
    1f31:	pxor   xmm0,xmm0
    1f35:	cvtsi2sd xmm0,rdx
    1f3a:	addsd  xmm0,xmm0
    1f3e:	mov    rax,QWORD PTR [rbp-0x28]
    1f42:	mov    rax,QWORD PTR [rax+0x18]
    1f46:	test   rax,rax
    1f49:	js     1f56 <end_profiling+0x332>
    1f4b:	pxor   xmm1,xmm1
    1f4f:	cvtsi2sd xmm1,rax
    1f54:	jmp    1f6f <end_profiling+0x34b>
    1f56:	mov    rdx,rax
    1f59:	shr    rdx,1
    1f5c:	and    eax,0x1
    1f5f:	or     rdx,rax
    1f62:	pxor   xmm1,xmm1
    1f66:	cvtsi2sd xmm1,rdx
    1f6b:	addsd  xmm1,xmm1
    1f6f:	mov    rax,QWORD PTR [rbp-0x30]
    1f73:	test   rax,rax
    1f76:	js     1f83 <end_profiling+0x35f>
    1f78:	pxor   xmm2,xmm2
    1f7c:	cvtsi2sd xmm2,rax
    1f81:	jmp    1f9c <end_profiling+0x378>
    1f83:	mov    rdx,rax
    1f86:	shr    rdx,1
    1f89:	and    eax,0x1
    1f8c:	or     rdx,rax
    1f8f:	pxor   xmm2,xmm2
    1f93:	cvtsi2sd xmm2,rdx
    1f98:	addsd  xmm2,xmm2
    1f9c:	divsd  xmm1,xmm2
    1fa0:	divsd  xmm0,xmm1
    1fa4:	movsd  xmm1,QWORD PTR [rip+0x28f4]        # 48a0 <__PRETTY_FUNCTION__.0+0x30>
    1fac:	divsd  xmm0,xmm1
    1fb0:	movsd  QWORD PTR [rbp-0x8],xmm0

          printf("  Megabytes Processed: %fMB @ %f GB/s\n", megabytes, gb_per_s);
    1fb5:	movsd  xmm0,QWORD PTR [rbp-0x8]
    1fba:	mov    rax,QWORD PTR [rbp-0x10]
    1fbe:	lea    rdx,[rip+0x238b]        # 4350 <_IO_stdin_used+0x350>
    1fc5:	movapd xmm1,xmm0
    1fc9:	movq   xmm0,rax
    1fce:	mov    rdi,rdx
    1fd1:	mov    eax,0x2
    1fd6:	call   1070 <printf@plt>
    for (usize i = 0; i < STATIC_ARRAY_COUNT(g_profiler.zones); i++)
    1fdb:	add    QWORD PTR [rbp-0x40],0x1
    1fe0:	cmp    QWORD PTR [rbp-0x40],0xfff
    1fe8:	jbe    1d00 <end_profiling+0xdc>
        }
      }
    }
  }
}
    1fee:	nop
    1fef:	leave
    1ff0:	ret

0000000000001ff1 <__profile_begin_pass>:

static
Profile_Pass __profile_begin_pass(String name, usize zone_index, u64 bytes_processed)
{
    1ff1:	push   rbp
    1ff2:	mov    rbp,rsp
    1ff5:	push   rbx
    1ff6:	sub    rsp,0x78
    1ffa:	mov    QWORD PTR [rbp-0x58],rdi
    1ffe:	mov    rax,rsi
    2001:	mov    rsi,rdx
    2004:	mov    rax,rax
    2007:	mov    edx,0x0
    200c:	mov    rdx,rsi
    200f:	mov    QWORD PTR [rbp-0x70],rax
    2013:	mov    QWORD PTR [rbp-0x68],rdx
    2017:	mov    QWORD PTR [rbp-0x60],rcx
    201b:	mov    QWORD PTR [rbp-0x78],r8
  Profile_Pass pass =
    201f:	pxor   xmm0,xmm0
    2023:	movaps XMMWORD PTR [rbp-0x50],xmm0
    2027:	movaps XMMWORD PTR [rbp-0x40],xmm0
    202b:	movaps XMMWORD PTR [rbp-0x30],xmm0
    202f:	movq   QWORD PTR [rbp-0x20],xmm0
    2034:	mov    rax,QWORD PTR [rbp-0x70]
    2038:	mov    rdx,QWORD PTR [rbp-0x68]
    203c:	mov    QWORD PTR [rbp-0x50],rax
    2040:	mov    QWORD PTR [rbp-0x48],rdx
  {
    .parent_index = g_profiler.current_parent_zone,
    .name         = name,
    .zone_index   = zone_index,
    .old_elapsed_inclusive = g_profiler.zones[zone_index].elapsed_inclusive, // Save the original so it get overwritten in the case of children
    2044:	mov    rdx,QWORD PTR [rbp-0x60]
    2048:	mov    rax,rdx
    204b:	add    rax,rax
    204e:	add    rax,rdx
    2051:	shl    rax,0x4
    2055:	mov    rdx,rax
    2058:	lea    rax,[rip+0x5169]        # 71c8 <g_profiler+0x28>
    205f:	mov    rax,QWORD PTR [rdx+rax*1]
  Profile_Pass pass =
    2063:	mov    QWORD PTR [rbp-0x38],rax
    2067:	mov    rax,QWORD PTR [rbp-0x60]
    206b:	mov    QWORD PTR [rbp-0x30],rax
    .parent_index = g_profiler.current_parent_zone,
    206f:	mov    rax,QWORD PTR [rip+0x5132]        # 71a8 <g_profiler+0x8>
  Profile_Pass pass =
    2076:	mov    QWORD PTR [rbp-0x28],rax
    207a:	mov    rax,QWORD PTR [rbp-0x78]
    207e:	mov    QWORD PTR [rbp-0x20],rax
    .bytes_processed = bytes_processed,
  };

  // Push parent
  g_profiler.current_parent_zone = zone_index;
    2082:	mov    rax,QWORD PTR [rbp-0x60]
    2086:	mov    QWORD PTR [rip+0x511b],rax        # 71a8 <g_profiler+0x8>

  // Last!
  pass.start = read_cpu_timer();
    208d:	call   1a4b <read_cpu_timer>
    2092:	mov    QWORD PTR [rbp-0x40],rax

  return pass;
    2096:	mov    rax,QWORD PTR [rbp-0x58]
    209a:	mov    rcx,QWORD PTR [rbp-0x50]
    209e:	mov    rbx,QWORD PTR [rbp-0x48]
    20a2:	mov    QWORD PTR [rax],rcx
    20a5:	mov    QWORD PTR [rax+0x8],rbx
    20a9:	mov    rcx,QWORD PTR [rbp-0x40]
    20ad:	mov    rbx,QWORD PTR [rbp-0x38]
    20b1:	mov    QWORD PTR [rax+0x10],rcx
    20b5:	mov    QWORD PTR [rax+0x18],rbx
    20b9:	mov    rcx,QWORD PTR [rbp-0x30]
    20bd:	mov    rbx,QWORD PTR [rbp-0x28]
    20c1:	mov    QWORD PTR [rax+0x20],rcx
    20c5:	mov    QWORD PTR [rax+0x28],rbx
    20c9:	mov    rdx,QWORD PTR [rbp-0x20]
    20cd:	mov    QWORD PTR [rax+0x30],rdx
}
    20d1:	mov    rax,QWORD PTR [rbp-0x58]
    20d5:	mov    rbx,QWORD PTR [rbp-0x8]
    20d9:	leave
    20da:	ret

00000000000020db <__profile_close_pass>:

static
void __profile_close_pass(Profile_Pass pass)
{
    20db:	push   rbp
    20dc:	mov    rbp,rsp
    20df:	sub    rsp,0x20
  // First!
  u64 elapsed = read_cpu_timer() - pass.start;
    20e3:	call   1a4b <read_cpu_timer>
    20e8:	mov    rdx,rax
    20eb:	mov    rax,QWORD PTR [rbp+0x20]
    20ef:	sub    rdx,rax
    20f2:	mov    QWORD PTR [rbp-0x18],rdx

  // Pop parent
  g_profiler.current_parent_zone = pass.parent_index;
    20f6:	mov    rax,QWORD PTR [rbp+0x38]
    20fa:	mov    QWORD PTR [rip+0x50a7],rax        # 71a8 <g_profiler+0x8>

  Profile_Zone *current = &g_profiler.zones[pass.zone_index];
    2101:	mov    rdx,QWORD PTR [rbp+0x30]
    2105:	mov    rax,rdx
    2108:	add    rax,rax
    210b:	add    rax,rdx
    210e:	shl    rax,0x4
    2112:	lea    rdx,[rax+0x10]
    2116:	lea    rax,[rip+0x5083]        # 71a0 <g_profiler>
    211d:	add    rax,rdx
    2120:	mov    QWORD PTR [rbp-0x10],rax
  current->elapsed_exclusive += elapsed;
    2124:	mov    rax,QWORD PTR [rbp-0x10]
    2128:	mov    rdx,QWORD PTR [rax+0x10]
    212c:	mov    rax,QWORD PTR [rbp-0x18]
    2130:	add    rdx,rax
    2133:	mov    rax,QWORD PTR [rbp-0x10]
    2137:	mov    QWORD PTR [rax+0x10],rdx
  current->hit_count += 1;
    213b:	mov    rax,QWORD PTR [rbp-0x10]
    213f:	mov    rax,QWORD PTR [rax+0x20]
    2143:	lea    rdx,[rax+0x1]
    2147:	mov    rax,QWORD PTR [rbp-0x10]
    214b:	mov    QWORD PTR [rax+0x20],rdx
  current->name = pass.name; // Stupid...
    214f:	mov    rcx,QWORD PTR [rbp-0x10]
    2153:	mov    rax,QWORD PTR [rbp+0x10]
    2157:	mov    rdx,QWORD PTR [rbp+0x18]
    215b:	mov    QWORD PTR [rcx],rax
    215e:	mov    QWORD PTR [rcx+0x8],rdx
  current->elapsed_inclusive = pass.old_elapsed_inclusive + elapsed; // So that only the final out of potential recursive calls writes inclusive time
    2162:	mov    rdx,QWORD PTR [rbp+0x28]
    2166:	mov    rax,QWORD PTR [rbp-0x18]
    216a:	add    rdx,rax
    216d:	mov    rax,QWORD PTR [rbp-0x10]
    2171:	mov    QWORD PTR [rax+0x18],rdx
  current->bytes_processed += pass.bytes_processed;
    2175:	mov    rax,QWORD PTR [rbp-0x10]
    2179:	mov    rdx,QWORD PTR [rax+0x28]
    217d:	mov    rax,QWORD PTR [rbp+0x40]
    2181:	add    rdx,rax
    2184:	mov    rax,QWORD PTR [rbp-0x10]
    2188:	mov    QWORD PTR [rax+0x28],rdx

  // Accumulate to parent time
  Profile_Zone *parent = &g_profiler.zones[pass.parent_index];
    218c:	mov    rdx,QWORD PTR [rbp+0x38]
    2190:	mov    rax,rdx
    2193:	add    rax,rax
    2196:	add    rax,rdx
    2199:	shl    rax,0x4
    219d:	lea    rdx,[rax+0x10]
    21a1:	lea    rax,[rip+0x4ff8]        # 71a0 <g_profiler>
    21a8:	add    rax,rdx
    21ab:	mov    QWORD PTR [rbp-0x8],rax
  parent->elapsed_exclusive -= elapsed;
    21af:	mov    rax,QWORD PTR [rbp-0x8]
    21b3:	mov    rax,QWORD PTR [rax+0x10]
    21b7:	sub    rax,QWORD PTR [rbp-0x18]
    21bb:	mov    rdx,rax
    21be:	mov    rax,QWORD PTR [rbp-0x8]
    21c2:	mov    QWORD PTR [rax+0x10],rdx
}
    21c6:	nop
    21c7:	leave
    21c8:	ret

00000000000021c9 <parser_at>:
  b32    had_error;
};

static
u8 *parser_at(JSON_Parser *parser)
{
    21c9:	push   rbp
    21ca:	mov    rbp,rsp
    21cd:	sub    rsp,0x10
    21d1:	mov    QWORD PTR [rbp-0x8],rdi
  ASSERT(parser->at < parser->source.count, "Attempted to read past parser source");
    21d5:	mov    rax,QWORD PTR [rbp-0x8]
    21d9:	mov    rdx,QWORD PTR [rax+0x10]
    21dd:	mov    rax,QWORD PTR [rbp-0x8]
    21e1:	mov    rax,QWORD PTR [rax+0x8]
    21e5:	cmp    rdx,rax
    21e8:	jb     220f <parser_at+0x46>
    21ea:	lea    rdx,[rip+0x25f7]        # 47e8 <__PRETTY_FUNCTION__.5>
    21f1:	lea    rsi,[rip+0x228a]        # 4482 <_IO_stdin_used+0x482>
    21f8:	lea    rax,[rip+0x2299]        # 4498 <_IO_stdin_used+0x498>
    21ff:	mov    rcx,rdx
    2202:	mov    edx,0x30
    2207:	mov    rdi,rax
    220a:	call   1090 <__assert_fail@plt>
  return parser->source.data + parser->at;
    220f:	mov    rax,QWORD PTR [rbp-0x8]
    2213:	mov    rdx,QWORD PTR [rax]
    2216:	mov    rax,QWORD PTR [rbp-0x8]
    221a:	mov    rax,QWORD PTR [rax+0x10]
    221e:	add    rax,rdx
}
    2221:	leave
    2222:	ret

0000000000002223 <parser_peek>:

// TODO: Use this to peek so don't have to always advance one at a time
static
u8 *parser_peek(JSON_Parser *parser, usize advance)
{
    2223:	push   rbp
    2224:	mov    rbp,rsp
    2227:	sub    rsp,0x10
    222b:	mov    QWORD PTR [rbp-0x8],rdi
    222f:	mov    QWORD PTR [rbp-0x10],rsi
  return parser_at(parser) + advance;
    2233:	mov    rax,QWORD PTR [rbp-0x8]
    2237:	mov    rdi,rax
    223a:	call   21c9 <parser_at>
    223f:	mov    rdx,QWORD PTR [rbp-0x10]
    2243:	add    rax,rdx
}
    2246:	leave
    2247:	ret

0000000000002248 <parser_advance>:

static
void parser_advance(JSON_Parser *parser, usize advance)
{
    2248:	push   rbp
    2249:	mov    rbp,rsp
    224c:	mov    QWORD PTR [rbp-0x8],rdi
    2250:	mov    QWORD PTR [rbp-0x10],rsi
  parser->at += advance;
    2254:	mov    rax,QWORD PTR [rbp-0x8]
    2258:	mov    rdx,QWORD PTR [rax+0x10]
    225c:	mov    rax,QWORD PTR [rbp-0x10]
    2260:	add    rdx,rax
    2263:	mov    rax,QWORD PTR [rbp-0x8]
    2267:	mov    QWORD PTR [rax+0x10],rdx
}
    226b:	nop
    226c:	pop    rbp
    226d:	ret

000000000000226e <parser_incomplete>:

static
b8 parser_incomplete(JSON_Parser *parser)
{
    226e:	push   rbp
    226f:	mov    rbp,rsp
    2272:	mov    QWORD PTR [rbp-0x8],rdi
  return parser->at < parser->source.count && !parser->had_error;
    2276:	mov    rax,QWORD PTR [rbp-0x8]
    227a:	mov    rdx,QWORD PTR [rax+0x10]
    227e:	mov    rax,QWORD PTR [rbp-0x8]
    2282:	mov    rax,QWORD PTR [rax+0x8]
    2286:	cmp    rdx,rax
    2289:	jae    229d <parser_incomplete+0x2f>
    228b:	mov    rax,QWORD PTR [rbp-0x8]
    228f:	mov    eax,DWORD PTR [rax+0x18]
    2292:	test   eax,eax
    2294:	jne    229d <parser_incomplete+0x2f>
    2296:	mov    eax,0x1
    229b:	jmp    22a2 <parser_incomplete+0x34>
    229d:	mov    eax,0x0
}
    22a2:	pop    rbp
    22a3:	ret

00000000000022a4 <parser_token_is_literal>:

static
b8 parser_token_is_literal(JSON_Parser *parser, String literal_string)
{
    22a4:	push   rbp
    22a5:	mov    rbp,rsp
    22a8:	push   r12
    22aa:	push   rbx
    22ab:	sub    rsp,0x20
    22af:	mov    QWORD PTR [rbp-0x18],rdi
    22b3:	mov    rax,rsi
    22b6:	mov    rcx,rdx
    22b9:	mov    rax,rax
    22bc:	mov    edx,0x0
    22c1:	mov    rdx,rcx
    22c4:	mov    QWORD PTR [rbp-0x30],rax
    22c8:	mov    QWORD PTR [rbp-0x28],rdx

  return memcmp(parser_at(parser), literal_string.data, literal_string.count) == 0;
    22cc:	mov    rax,QWORD PTR [rbp-0x28]
    22d0:	mov    r12,rax
    22d3:	mov    rbx,QWORD PTR [rbp-0x30]
    22d7:	mov    rax,QWORD PTR [rbp-0x18]
    22db:	mov    rdi,rax
    22de:	call   21c9 <parser_at>
    22e3:	mov    rdx,r12
    22e6:	mov    rsi,rbx
    22e9:	mov    rdi,rax
    22ec:	call   10d0 <memcmp@plt>
    22f1:	test   eax,eax
    22f3:	sete   al
}
    22f6:	add    rsp,0x20
    22fa:	pop    rbx
    22fb:	pop    r12
    22fd:	pop    rbp
    22fe:	ret

00000000000022ff <is_numeric>:

static
b8 is_numeric(u8 ch)
{
    22ff:	push   rbp
    2300:	mov    rbp,rsp
    2303:	mov    eax,edi
    2305:	mov    BYTE PTR [rbp-0x14],al
  b8 result = false;
    2308:	mov    BYTE PTR [rbp-0x1],0x0

  switch (ch)
    230c:	movzx  eax,BYTE PTR [rbp-0x14]
    2310:	cmp    eax,0x2e
    2313:	jg     231c <is_numeric+0x1d>
    2315:	cmp    eax,0x2d
    2318:	jge    2324 <is_numeric+0x25>
    231a:	jmp    2329 <is_numeric+0x2a>
    231c:	sub    eax,0x30
    231f:	cmp    eax,0x9
    2322:	ja     2329 <is_numeric+0x2a>
    case '8':
    case '9':
    case '.':
    case '-':
    {
      result = true;
    2324:	mov    BYTE PTR [rbp-0x1],0x1
    }
    break;
    2328:	nop
  }


  return result;
    2329:	movzx  eax,BYTE PTR [rbp-0x1]
}
    232d:	pop    rbp
    232e:	ret

000000000000232f <get_json_token>:

JSON_Token get_json_token(JSON_Parser *parser)
{
    232f:	push   rbp
    2330:	mov    rbp,rsp
    2333:	sub    rsp,0x50
    2337:	mov    QWORD PTR [rbp-0x48],rdi
    233b:	mov    QWORD PTR [rbp-0x50],rsi
  JSON_Token token = {0};
    233f:	pxor   xmm0,xmm0
    2343:	movaps XMMWORD PTR [rbp-0x20],xmm0
    2347:	movq   QWORD PTR [rbp-0x10],xmm0

  // Eat white spaces
  while (parser_incomplete(parser)  &&
    234c:	jmp    235f <get_json_token+0x30>
          *parser_at(parser) == '\n' ||
          *parser_at(parser) == '\r' ||
          *parser_at(parser) == '\t'))
  {
    // TODO: Probably just count all white space and then advance once for all at the end
    parser_advance(parser, 1);
    234e:	mov    rax,QWORD PTR [rbp-0x50]
    2352:	mov    esi,0x1
    2357:	mov    rdi,rax
    235a:	call   2248 <parser_advance>
  while (parser_incomplete(parser)  &&
    235f:	mov    rax,QWORD PTR [rbp-0x50]
    2363:	mov    rdi,rax
    2366:	call   226e <parser_incomplete>
    236b:	test   al,al
    236d:	je     23bb <get_json_token+0x8c>
         (*parser_at(parser) == ' '  ||
    236f:	mov    rax,QWORD PTR [rbp-0x50]
    2373:	mov    rdi,rax
    2376:	call   21c9 <parser_at>
    237b:	movzx  eax,BYTE PTR [rax]
  while (parser_incomplete(parser)  &&
    237e:	cmp    al,0x20
    2380:	je     234e <get_json_token+0x1f>
          *parser_at(parser) == '\n' ||
    2382:	mov    rax,QWORD PTR [rbp-0x50]
    2386:	mov    rdi,rax
    2389:	call   21c9 <parser_at>
    238e:	movzx  eax,BYTE PTR [rax]
         (*parser_at(parser) == ' '  ||
    2391:	cmp    al,0xa
    2393:	je     234e <get_json_token+0x1f>
          *parser_at(parser) == '\r' ||
    2395:	mov    rax,QWORD PTR [rbp-0x50]
    2399:	mov    rdi,rax
    239c:	call   21c9 <parser_at>
    23a1:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\n' ||
    23a4:	cmp    al,0xd
    23a6:	je     234e <get_json_token+0x1f>
          *parser_at(parser) == '\t'))
    23a8:	mov    rax,QWORD PTR [rbp-0x50]
    23ac:	mov    rdi,rax
    23af:	call   21c9 <parser_at>
    23b4:	movzx  eax,BYTE PTR [rax]
          *parser_at(parser) == '\r' ||
    23b7:	cmp    al,0x9
    23b9:	je     234e <get_json_token+0x1f>
  }

  if (parser_incomplete(parser)) // If we've not reached the end of file
    23bb:	mov    rax,QWORD PTR [rbp-0x50]
    23bf:	mov    rdi,rax
    23c2:	call   226e <parser_incomplete>
    23c7:	test   al,al
    23c9:	je     2817 <get_json_token+0x4e8>
  {
    token.value.data = parser_at(parser);
    23cf:	mov    rax,QWORD PTR [rbp-0x50]
    23d3:	mov    rdi,rax
    23d6:	call   21c9 <parser_at>
    23db:	mov    QWORD PTR [rbp-0x18],rax
    switch (*parser_at(parser))
    23df:	mov    rax,QWORD PTR [rbp-0x50]
    23e3:	mov    rdi,rax
    23e6:	call   21c9 <parser_at>
    23eb:	movzx  eax,BYTE PTR [rax]
    23ee:	movzx  eax,al
    23f1:	cmp    eax,0x7d
    23f4:	je     24e1 <get_json_token+0x1b2>
    23fa:	cmp    eax,0x7d
    23fd:	jg     2828 <get_json_token+0x4f9>
    2403:	cmp    eax,0x7b
    2406:	je     24bc <get_json_token+0x18d>
    240c:	cmp    eax,0x7b
    240f:	jg     2828 <get_json_token+0x4f9>
    2415:	cmp    eax,0x74
    2418:	je     2664 <get_json_token+0x335>
    241e:	cmp    eax,0x74
    2421:	jg     2828 <get_json_token+0x4f9>
    2427:	cmp    eax,0x6e
    242a:	je     278a <get_json_token+0x45b>
    2430:	cmp    eax,0x6e
    2433:	jg     2828 <get_json_token+0x4f9>
    2439:	cmp    eax,0x66
    243c:	je     26f7 <get_json_token+0x3c8>
    2442:	cmp    eax,0x66
    2445:	jg     2828 <get_json_token+0x4f9>
    244b:	cmp    eax,0x5d
    244e:	je     252b <get_json_token+0x1fc>
    2454:	cmp    eax,0x5d
    2457:	jg     2828 <get_json_token+0x4f9>
    245d:	cmp    eax,0x5b
    2460:	je     2506 <get_json_token+0x1d7>
    2466:	cmp    eax,0x5b
    2469:	jg     2828 <get_json_token+0x4f9>
    246f:	cmp    eax,0x3a
    2472:	je     2575 <get_json_token+0x246>
    2478:	cmp    eax,0x3a
    247b:	jg     2828 <get_json_token+0x4f9>
    2481:	cmp    eax,0x39
    2484:	jg     2828 <get_json_token+0x4f9>
    248a:	cmp    eax,0x30
    248d:	jge    2613 <get_json_token+0x2e4>
    2493:	cmp    eax,0x2e
    2496:	jg     2828 <get_json_token+0x4f9>
    249c:	cmp    eax,0x2d
    249f:	jge    2613 <get_json_token+0x2e4>
    24a5:	cmp    eax,0x22
    24a8:	je     259a <get_json_token+0x26b>
    24ae:	cmp    eax,0x2c
    24b1:	je     2550 <get_json_token+0x221>
    24b7:	jmp    2828 <get_json_token+0x4f9>
    {
      case '{':
      {
        token.type = JSON_TOKEN_OPEN_CURLY_BRACE;
    24bc:	mov    DWORD PTR [rbp-0x20],0x1
        token.value.count = 1;
    24c3:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24cb:	mov    rax,QWORD PTR [rbp-0x50]
    24cf:	mov    esi,0x1
    24d4:	mov    rdi,rax
    24d7:	call   2248 <parser_advance>
      }
      break;
    24dc:	jmp    2828 <get_json_token+0x4f9>
      case '}':
      {
        token.type = JSON_TOKEN_CLOSE_CURLY_BRACE;
    24e1:	mov    DWORD PTR [rbp-0x20],0x2
        token.value.count = 1;
    24e8:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    24f0:	mov    rax,QWORD PTR [rbp-0x50]
    24f4:	mov    esi,0x1
    24f9:	mov    rdi,rax
    24fc:	call   2248 <parser_advance>
      }
      break;
    2501:	jmp    2828 <get_json_token+0x4f9>
      case '[':
      {
        token.type = JSON_TOKEN_OPEN_SQUARE_BRACE;
    2506:	mov    DWORD PTR [rbp-0x20],0x3
        token.value.count = 1;
    250d:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2515:	mov    rax,QWORD PTR [rbp-0x50]
    2519:	mov    esi,0x1
    251e:	mov    rdi,rax
    2521:	call   2248 <parser_advance>
      }
      break;
    2526:	jmp    2828 <get_json_token+0x4f9>
      case ']':
      {
        token.type = JSON_TOKEN_CLOSE_SQUARE_BRACE;
    252b:	mov    DWORD PTR [rbp-0x20],0x4
        token.value.count = 1;
    2532:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    253a:	mov    rax,QWORD PTR [rbp-0x50]
    253e:	mov    esi,0x1
    2543:	mov    rdi,rax
    2546:	call   2248 <parser_advance>
      }
      break;
    254b:	jmp    2828 <get_json_token+0x4f9>
      case ',':
      {
        token.type = JSON_TOKEN_COMMA;
    2550:	mov    DWORD PTR [rbp-0x20],0x5
        token.value.count = 1;
    2557:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    255f:	mov    rax,QWORD PTR [rbp-0x50]
    2563:	mov    esi,0x1
    2568:	mov    rdi,rax
    256b:	call   2248 <parser_advance>
      }
      break;
    2570:	jmp    2828 <get_json_token+0x4f9>
      case ':':
      {
        token.type = JSON_TOKEN_COLON;
    2575:	mov    DWORD PTR [rbp-0x20],0x6
        token.value.count = 1;
    257c:	mov    QWORD PTR [rbp-0x10],0x1
        parser_advance(parser, 1);
    2584:	mov    rax,QWORD PTR [rbp-0x50]
    2588:	mov    esi,0x1
    258d:	mov    rdi,rax
    2590:	call   2248 <parser_advance>
      }
      break;
    2595:	jmp    2828 <get_json_token+0x4f9>
      case '"':
      {
        token.type = JSON_TOKEN_STRING;
    259a:	mov    DWORD PTR [rbp-0x20],0x7

        parser_advance(parser, 1); // For the quotation mark
    25a1:	mov    rax,QWORD PTR [rbp-0x50]
    25a5:	mov    esi,0x1
    25aa:	mov    rdi,rax
    25ad:	call   2248 <parser_advance>

        token.value.data = parser_at(parser); // Special case, we want the start to ignore the "
    25b2:	mov    rax,QWORD PTR [rbp-0x50]
    25b6:	mov    rdi,rax
    25b9:	call   21c9 <parser_at>
    25be:	mov    QWORD PTR [rbp-0x18],rax

        // TODO: account for escaped quotes
        usize string_count = 0;
    25c2:	mov    QWORD PTR [rbp-0x40],0x0
        while (*parser_at(parser) != '"')
    25ca:	jmp    25e2 <get_json_token+0x2b3>
        {
          string_count += 1;
    25cc:	add    QWORD PTR [rbp-0x40],0x1
          parser_advance(parser, 1);
    25d1:	mov    rax,QWORD PTR [rbp-0x50]
    25d5:	mov    esi,0x1
    25da:	mov    rdi,rax
    25dd:	call   2248 <parser_advance>
        while (*parser_at(parser) != '"')
    25e2:	mov    rax,QWORD PTR [rbp-0x50]
    25e6:	mov    rdi,rax
    25e9:	call   21c9 <parser_at>
    25ee:	movzx  eax,BYTE PTR [rax]
    25f1:	cmp    al,0x22
    25f3:	jne    25cc <get_json_token+0x29d>
        }
        token.value.count = string_count;
    25f5:	mov    rax,QWORD PTR [rbp-0x40]
    25f9:	mov    QWORD PTR [rbp-0x10],rax

        parser_advance(parser, 1); // For the other quotation mark
    25fd:	mov    rax,QWORD PTR [rbp-0x50]
    2601:	mov    esi,0x1
    2606:	mov    rdi,rax
    2609:	call   2248 <parser_advance>
      }
      break;
    260e:	jmp    2828 <get_json_token+0x4f9>
      case '8':
      case '9':
      case '.':
      case '-':
      {
        token.type  = JSON_TOKEN_NUMBER;
    2613:	mov    DWORD PTR [rbp-0x20],0x8

        usize digit_count = 0;
    261a:	mov    QWORD PTR [rbp-0x38],0x0
        while (is_numeric(*parser_at(parser)))
    2622:	jmp    263a <get_json_token+0x30b>
        {
          digit_count += 1;
    2624:	add    QWORD PTR [rbp-0x38],0x1
          parser_advance(parser, 1);
    2629:	mov    rax,QWORD PTR [rbp-0x50]
    262d:	mov    esi,0x1
    2632:	mov    rdi,rax
    2635:	call   2248 <parser_advance>
        while (is_numeric(*parser_at(parser)))
    263a:	mov    rax,QWORD PTR [rbp-0x50]
    263e:	mov    rdi,rax
    2641:	call   21c9 <parser_at>
    2646:	movzx  eax,BYTE PTR [rax]
    2649:	movzx  eax,al
    264c:	mov    edi,eax
    264e:	call   22ff <is_numeric>
    2653:	test   al,al
    2655:	jne    2624 <get_json_token+0x2f5>
        }
        token.value.count = digit_count;
    2657:	mov    rax,QWORD PTR [rbp-0x38]
    265b:	mov    QWORD PTR [rbp-0x10],rax
      }
      break;
    265f:	jmp    2828 <get_json_token+0x4f9>
      case 't':
      {
        String string = String("true");
    2664:	lea    rax,[rip+0x1e79]        # 44e4 <_IO_stdin_used+0x4e4>
    266b:	mov    QWORD PTR [rbp-0x30],rax
    266f:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    2677:	mov    rcx,QWORD PTR [rbp-0x30]
    267b:	mov    rdx,QWORD PTR [rbp-0x28]
    267f:	mov    rax,QWORD PTR [rbp-0x50]
    2683:	mov    rsi,rcx
    2686:	mov    rdi,rax
    2689:	call   22a4 <parser_token_is_literal>
    268e:	test   al,al
    2690:	je     26b4 <get_json_token+0x385>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_TRUE;
    2692:	mov    DWORD PTR [rbp-0x20],0x9
          parser_advance(parser, string.count);
    2699:	mov    rax,QWORD PTR [rbp-0x28]
    269d:	mov    rdx,rax
    26a0:	mov    rax,QWORD PTR [rbp-0x50]
    26a4:	mov    rsi,rdx
    26a7:	mov    rdi,rax
    26aa:	call   2248 <parser_advance>
    26af:	jmp    2828 <get_json_token+0x4f9>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    26b4:	mov    rax,QWORD PTR [rbp-0x50]
    26b8:	mov    rcx,QWORD PTR [rax+0x10]
    26bc:	lea    rdx,[rip+0x1e2d]        # 44f0 <_IO_stdin_used+0x4f0>
    26c3:	lea    rax,[rip+0x1db8]        # 4482 <_IO_stdin_used+0x482>
    26ca:	mov    r8,rcx
    26cd:	mov    rcx,rdx
    26d0:	mov    edx,0xe0
    26d5:	mov    rsi,rax
    26d8:	mov    edi,0x1
    26dd:	mov    eax,0x0
    26e2:	call   14a4 <log_message>
          parser->had_error = true;
    26e7:	mov    rax,QWORD PTR [rbp-0x50]
    26eb:	mov    DWORD PTR [rax+0x18],0x1
        }
      }
      break;
    26f2:	jmp    2828 <get_json_token+0x4f9>
      case 'f':
      {
        String string = String("false");
    26f7:	lea    rax,[rip+0x1e1f]        # 451d <_IO_stdin_used+0x51d>
    26fe:	mov    QWORD PTR [rbp-0x30],rax
    2702:	mov    QWORD PTR [rbp-0x28],0x5
        if (parser_token_is_literal(parser, string))
    270a:	mov    rcx,QWORD PTR [rbp-0x30]
    270e:	mov    rdx,QWORD PTR [rbp-0x28]
    2712:	mov    rax,QWORD PTR [rbp-0x50]
    2716:	mov    rsi,rcx
    2719:	mov    rdi,rax
    271c:	call   22a4 <parser_token_is_literal>
    2721:	test   al,al
    2723:	je     2747 <get_json_token+0x418>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_FALSE;
    2725:	mov    DWORD PTR [rbp-0x20],0xa
          parser_advance(parser, string.count);
    272c:	mov    rax,QWORD PTR [rbp-0x28]
    2730:	mov    rdx,rax
    2733:	mov    rax,QWORD PTR [rbp-0x50]
    2737:	mov    rsi,rdx
    273a:	mov    rdi,rax
    273d:	call   2248 <parser_advance>
    2742:	jmp    2828 <get_json_token+0x4f9>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    2747:	mov    rax,QWORD PTR [rbp-0x50]
    274b:	mov    rcx,QWORD PTR [rax+0x10]
    274f:	lea    rdx,[rip+0x1d9a]        # 44f0 <_IO_stdin_used+0x4f0>
    2756:	lea    rax,[rip+0x1d25]        # 4482 <_IO_stdin_used+0x482>
    275d:	mov    r8,rcx
    2760:	mov    rcx,rdx
    2763:	mov    edx,0xf0
    2768:	mov    rsi,rax
    276b:	mov    edi,0x1
    2770:	mov    eax,0x0
    2775:	call   14a4 <log_message>
          parser->had_error = true;
    277a:	mov    rax,QWORD PTR [rbp-0x50]
    277e:	mov    DWORD PTR [rax+0x18],0x1
        }
      }
      break;
    2785:	jmp    2828 <get_json_token+0x4f9>
      case 'n':
      {
        String string = String("null");
    278a:	lea    rax,[rip+0x1d92]        # 4523 <_IO_stdin_used+0x523>
    2791:	mov    QWORD PTR [rbp-0x30],rax
    2795:	mov    QWORD PTR [rbp-0x28],0x4
        if (parser_token_is_literal(parser, string))
    279d:	mov    rcx,QWORD PTR [rbp-0x30]
    27a1:	mov    rdx,QWORD PTR [rbp-0x28]
    27a5:	mov    rax,QWORD PTR [rbp-0x50]
    27a9:	mov    rsi,rcx
    27ac:	mov    rdi,rax
    27af:	call   22a4 <parser_token_is_literal>
    27b4:	test   al,al
    27b6:	je     27d7 <get_json_token+0x4a8>
        {
          // No 'value' for this
          token.type  = JSON_TOKEN_NULL;
    27b8:	mov    DWORD PTR [rbp-0x20],0xb
          parser_advance(parser, string.count);
    27bf:	mov    rax,QWORD PTR [rbp-0x28]
    27c3:	mov    rdx,rax
    27c6:	mov    rax,QWORD PTR [rbp-0x50]
    27ca:	mov    rsi,rdx
    27cd:	mov    rdi,rax
    27d0:	call   2248 <parser_advance>
    27d5:	jmp    2828 <get_json_token+0x4f9>
        }
        else
        {
          LOG_ERROR("Encountered unrecognized literal at byte %lu", parser->at);
    27d7:	mov    rax,QWORD PTR [rbp-0x50]
    27db:	mov    rcx,QWORD PTR [rax+0x10]
    27df:	lea    rdx,[rip+0x1d0a]        # 44f0 <_IO_stdin_used+0x4f0>
    27e6:	lea    rax,[rip+0x1c95]        # 4482 <_IO_stdin_used+0x482>
    27ed:	mov    r8,rcx
    27f0:	mov    rcx,rdx
    27f3:	mov    edx,0x100
    27f8:	mov    rsi,rax
    27fb:	mov    edi,0x1
    2800:	mov    eax,0x0
    2805:	call   14a4 <log_message>
          parser->had_error = true;
    280a:	mov    rax,QWORD PTR [rbp-0x50]
    280e:	mov    DWORD PTR [rax+0x18],0x1
        }
      }
      break;
    2815:	jmp    2828 <get_json_token+0x4f9>
    }
  }
  else
  {
    // EOF, do nothing else
    parser_advance(parser, 1);
    2817:	mov    rax,QWORD PTR [rbp-0x50]
    281b:	mov    esi,0x1
    2820:	mov    rdi,rax
    2823:	call   2248 <parser_advance>
  }

  return token;
    2828:	mov    rcx,QWORD PTR [rbp-0x48]
    282c:	mov    rax,QWORD PTR [rbp-0x20]
    2830:	mov    rdx,QWORD PTR [rbp-0x18]
    2834:	mov    QWORD PTR [rcx],rax
    2837:	mov    QWORD PTR [rcx+0x8],rdx
    283b:	mov    rax,QWORD PTR [rbp-0x10]
    283f:	mov    QWORD PTR [rcx+0x10],rax
}
    2843:	mov    rax,QWORD PTR [rbp-0x48]
    2847:	leave
    2848:	ret

0000000000002849 <json_token_type_is_value_type>:

b32 json_token_type_is_value_type(JSON_Token_Type type)
{
    2849:	push   rbp
    284a:	mov    rbp,rsp
    284d:	mov    DWORD PTR [rbp-0x14],edi
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
                       type == JSON_TOKEN_TRUE   ||
                       type == JSON_TOKEN_FALSE  ||
                       type == JSON_TOKEN_NULL   ||
    2850:	cmp    DWORD PTR [rbp-0x14],0x7
    2854:	je     286e <json_token_type_is_value_type+0x25>
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    2856:	cmp    DWORD PTR [rbp-0x14],0x9
    285a:	je     286e <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_TRUE   ||
    285c:	cmp    DWORD PTR [rbp-0x14],0xa
    2860:	je     286e <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_FALSE  ||
    2862:	cmp    DWORD PTR [rbp-0x14],0xb
    2866:	je     286e <json_token_type_is_value_type+0x25>
                       type == JSON_TOKEN_NULL   ||
    2868:	cmp    DWORD PTR [rbp-0x14],0x8
    286c:	jne    2875 <json_token_type_is_value_type+0x2c>
    286e:	mov    eax,0x1
    2873:	jmp    287a <json_token_type_is_value_type+0x31>
    2875:	mov    eax,0x0
  b32 is_value_type = (type == JSON_TOKEN_STRING ||
    287a:	mov    DWORD PTR [rbp-0x4],eax
                       type == JSON_TOKEN_NUMBER);
  return is_value_type;
    287d:	mov    eax,DWORD PTR [rbp-0x4]
}
    2880:	pop    rbp
    2881:	ret

0000000000002882 <parse_json_object>:
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys);

static
JSON_Object *parse_json_object(Arena *arena, JSON_Parser *parser, String key, JSON_Token token)
{
    2882:	push   rbp
    2883:	mov    rbp,rsp
    2886:	push   rbx
    2887:	sub    rsp,0x88
    288e:	mov    QWORD PTR [rbp-0x78],rdi
    2892:	mov    QWORD PTR [rbp-0x80],rsi
    2896:	mov    QWORD PTR [rbp-0x90],rdx
    289d:	mov    QWORD PTR [rbp-0x88],rcx
    28a4:	mov    rax,QWORD PTR fs:0x28
    28ad:	mov    QWORD PTR [rbp-0x18],rax
    28b1:	xor    eax,eax
  profile_begin_func();
    28b3:	lea    r8,[rip+0x1f46]        # 4800 <__func__.4>
    28ba:	mov    r9d,0x11
    28c0:	lea    rax,[rbp-0x50]
    28c4:	mov    rsi,r8
    28c7:	mov    rdx,r9
    28ca:	mov    r8d,0x0
    28d0:	mov    ecx,0x1
    28d5:	mov    rdi,rax
    28d8:	call   1ff1 <__profile_begin_pass>

  JSON_Object *first_child = NULL;
    28dd:	mov    QWORD PTR [rbp-0x60],0x0

  if (token.type == JSON_TOKEN_OPEN_CURLY_BRACE)
    28e5:	mov    eax,DWORD PTR [rbp+0x10]
    28e8:	cmp    eax,0x1
    28eb:	jne    2917 <parse_json_object+0x95>
  {
    // Normal key : value pairs
    b32 has_keys = true;
    28ed:	mov    DWORD PTR [rbp-0x64],0x1
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_CURLY_BRACE, has_keys);
    28f4:	mov    edx,DWORD PTR [rbp-0x64]
    28f7:	mov    rsi,QWORD PTR [rbp-0x80]
    28fb:	mov    rax,QWORD PTR [rbp-0x78]
    28ff:	mov    ecx,edx
    2901:	mov    edx,0x2
    2906:	mov    rdi,rax
    2909:	call   2a74 <parse_json_children>
    290e:	mov    QWORD PTR [rbp-0x60],rax
    2912:	jmp    29ac <parse_json_object+0x12a>
  }
  else if (token.type == JSON_TOKEN_OPEN_SQUARE_BRACE)
    2917:	mov    eax,DWORD PTR [rbp+0x10]
    291a:	cmp    eax,0x3
    291d:	jne    2946 <parse_json_object+0xc4>
  {
    // Array, no key
    b32 has_keys = false;
    291f:	mov    DWORD PTR [rbp-0x68],0x0
    first_child = parse_json_children(arena, parser, JSON_TOKEN_CLOSE_SQUARE_BRACE, has_keys);
    2926:	mov    edx,DWORD PTR [rbp-0x68]
    2929:	mov    rsi,QWORD PTR [rbp-0x80]
    292d:	mov    rax,QWORD PTR [rbp-0x78]
    2931:	mov    ecx,edx
    2933:	mov    edx,0x4
    2938:	mov    rdi,rax
    293b:	call   2a74 <parse_json_children>
    2940:	mov    QWORD PTR [rbp-0x60],rax
    2944:	jmp    29ac <parse_json_object+0x12a>
  }
  // else it should be a leaf node containing a value only, not an array or table
  else if (json_token_type_is_value_type(token.type))
    2946:	mov    eax,DWORD PTR [rbp+0x10]
    2949:	mov    edi,eax
    294b:	call   2849 <json_token_type_is_value_type>
    2950:	test   eax,eax
    2952:	jne    29ac <parse_json_object+0x12a>
  {
    // Do nothing, no children to parse
  }
  else
  {
    LOG_ERROR("Unexpected token type encountered while parsing json object: %s, (value = %.*s)", JSON_Token_Type_strings[token.type], token.value);
    2954:	mov    eax,DWORD PTR [rbp+0x10]
    2957:	mov    eax,eax
    2959:	lea    rdx,[rax*8+0x0]
    2961:	lea    rax,[rip+0x4778]        # 70e0 <JSON_Token_Type_strings>
    2968:	mov    rcx,QWORD PTR [rdx+rax*1]
    296c:	lea    rdx,[rip+0x1bb5]        # 4528 <_IO_stdin_used+0x528>
    2973:	lea    rax,[rip+0x1b08]        # 4482 <_IO_stdin_used+0x482>
    297a:	push   QWORD PTR [rbp+0x20]
    297d:	push   QWORD PTR [rbp+0x18]
    2980:	mov    r8,rcx
    2983:	mov    rcx,rdx
    2986:	mov    edx,0x138
    298b:	mov    rsi,rax
    298e:	mov    edi,0x1
    2993:	mov    eax,0x0
    2998:	call   14a4 <log_message>
    299d:	add    rsp,0x10
          parser->had_error = true;
    29a1:	mov    rax,QWORD PTR [rbp-0x80]
    29a5:	mov    DWORD PTR [rax+0x18],0x1
  }

  JSON_Object *result  = arena_new(arena, JSON_Object);
    29ac:	mov    rax,QWORD PTR [rbp-0x78]
    29b0:	mov    edx,0x8
    29b5:	mov    esi,0x30
    29ba:	mov    rdi,rax
    29bd:	call   17d6 <arena_alloc>
    29c2:	mov    QWORD PTR [rbp-0x58],rax
  result->key          = key;
    29c6:	mov    rcx,QWORD PTR [rbp-0x58]
    29ca:	mov    rax,QWORD PTR [rbp-0x90]
    29d1:	mov    rdx,QWORD PTR [rbp-0x88]
    29d8:	mov    QWORD PTR [rcx],rax
    29db:	mov    QWORD PTR [rcx+0x8],rdx
  result->first_child  = first_child;
    29df:	mov    rax,QWORD PTR [rbp-0x58]
    29e3:	mov    rdx,QWORD PTR [rbp-0x60]
    29e7:	mov    QWORD PTR [rax+0x20],rdx
  result->next_sibling = NULL;
    29eb:	mov    rax,QWORD PTR [rbp-0x58]
    29ef:	mov    QWORD PTR [rax+0x28],0x0
  result->value        = token.value;
    29f7:	mov    rcx,QWORD PTR [rbp-0x58]
    29fb:	mov    rax,QWORD PTR [rbp+0x18]
    29ff:	mov    rdx,QWORD PTR [rbp+0x20]
    2a03:	mov    QWORD PTR [rcx+0x10],rax
    2a07:	mov    QWORD PTR [rcx+0x18],rdx

  profile_close_func();
    2a0b:	sub    rsp,0x8
    2a0f:	sub    rsp,0x38
    2a13:	mov    rax,rsp
    2a16:	mov    rcx,QWORD PTR [rbp-0x50]
    2a1a:	mov    rbx,QWORD PTR [rbp-0x48]
    2a1e:	mov    QWORD PTR [rax],rcx
    2a21:	mov    QWORD PTR [rax+0x8],rbx
    2a25:	mov    rcx,QWORD PTR [rbp-0x40]
    2a29:	mov    rbx,QWORD PTR [rbp-0x38]
    2a2d:	mov    QWORD PTR [rax+0x10],rcx
    2a31:	mov    QWORD PTR [rax+0x18],rbx
    2a35:	mov    rcx,QWORD PTR [rbp-0x30]
    2a39:	mov    rbx,QWORD PTR [rbp-0x28]
    2a3d:	mov    QWORD PTR [rax+0x20],rcx
    2a41:	mov    QWORD PTR [rax+0x28],rbx
    2a45:	mov    rdx,QWORD PTR [rbp-0x20]
    2a49:	mov    QWORD PTR [rax+0x30],rdx
    2a4d:	call   20db <__profile_close_pass>
    2a52:	add    rsp,0x40

  return result;
    2a56:	mov    rax,QWORD PTR [rbp-0x58]
}
    2a5a:	mov    rdx,QWORD PTR [rbp-0x18]
    2a5e:	sub    rdx,QWORD PTR fs:0x28
    2a67:	je     2a6e <parse_json_object+0x1ec>
    2a69:	call   1060 <__stack_chk_fail@plt>
    2a6e:	mov    rbx,QWORD PTR [rbp-0x8]
    2a72:	leave
    2a73:	ret

0000000000002a74 <parse_json_children>:

static
JSON_Object *parse_json_children(Arena *arena, JSON_Parser *parser,
                                 JSON_Token_Type end_token, b32 has_keys)
{
    2a74:	push   rbp
    2a75:	mov    rbp,rsp
    2a78:	push   rbx
    2a79:	sub    rsp,0x108
    2a80:	mov    QWORD PTR [rbp-0xd8],rdi
    2a87:	mov    QWORD PTR [rbp-0xe0],rsi
    2a8e:	mov    DWORD PTR [rbp-0xe4],edx
    2a94:	mov    DWORD PTR [rbp-0xe8],ecx
    2a9a:	mov    rax,QWORD PTR fs:0x28
    2aa3:	mov    QWORD PTR [rbp-0x18],rax
    2aa7:	xor    eax,eax
  profile_begin_func();
    2aa9:	lea    r8,[rip+0x1d70]        # 4820 <__func__.3>
    2ab0:	mov    r9d,0x13
    2ab6:	lea    rax,[rbp-0x50]
    2aba:	mov    rsi,r8
    2abd:	mov    rdx,r9
    2ac0:	mov    r8d,0x0
    2ac6:	mov    ecx,0x2
    2acb:	mov    rdi,rax
    2ace:	call   1ff1 <__profile_begin_pass>

  JSON_Object *first_child        = NULL;
    2ad3:	mov    QWORD PTR [rbp-0xc8],0x0
  JSON_Object *current_last_child = NULL;
    2ade:	mov    QWORD PTR [rbp-0xc0],0x0

  while (parser_incomplete(parser))
    2ae9:	jmp    2df0 <parse_json_children+0x37c>
  {
    JSON_Token key_token = {0};
    2aee:	pxor   xmm0,xmm0
    2af2:	movaps XMMWORD PTR [rbp-0xb0],xmm0
    2af9:	movq   QWORD PTR [rbp-0xa0],xmm0
    JSON_Token value_token = {0};
    2b01:	pxor   xmm0,xmm0
    2b05:	movaps XMMWORD PTR [rbp-0x90],xmm0
    2b0c:	movq   QWORD PTR [rbp-0x80],xmm0

    // Grab in the key, if needed, and it's value
    if (has_keys)
    2b11:	cmp    DWORD PTR [rbp-0xe8],0x0
    2b18:	je     2c45 <parse_json_children+0x1d1>
    {
      key_token = get_json_token(parser);
    2b1e:	lea    rax,[rbp-0xb0]
    2b25:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b2c:	mov    rsi,rdx
    2b2f:	mov    rdi,rax
    2b32:	call   232f <get_json_token>

      if (key_token.type == JSON_TOKEN_STRING)
    2b37:	mov    eax,DWORD PTR [rbp-0xb0]
    2b3d:	cmp    eax,0x7
    2b40:	jne    2bd3 <parse_json_children+0x15f>
      {
        JSON_Token expect_colon = get_json_token(parser);
    2b46:	lea    rax,[rbp-0x70]
    2b4a:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b51:	mov    rsi,rdx
    2b54:	mov    rdi,rax
    2b57:	call   232f <get_json_token>

        if (expect_colon.type == JSON_TOKEN_COLON)
    2b5c:	mov    eax,DWORD PTR [rbp-0x70]
    2b5f:	cmp    eax,0x6
    2b62:	jne    2b82 <parse_json_children+0x10e>
        {
          value_token = get_json_token(parser);
    2b64:	lea    rax,[rbp-0x90]
    2b6b:	mov    rdx,QWORD PTR [rbp-0xe0]
    2b72:	mov    rsi,rdx
    2b75:	mov    rdi,rax
    2b78:	call   232f <get_json_token>
    2b7d:	jmp    2c85 <parse_json_children+0x211>
        }
        else
        {
          LOG_ERROR("Expected colon after key: %*.s", String_Format(key_token.value));
    2b82:	mov    rcx,QWORD PTR [rbp-0xa8]
    2b89:	mov    rax,QWORD PTR [rbp-0xa0]
    2b90:	mov    esi,eax
    2b92:	lea    rdx,[rip+0x19df]        # 4578 <_IO_stdin_used+0x578>
    2b99:	lea    rax,[rip+0x18e2]        # 4482 <_IO_stdin_used+0x482>
    2ba0:	mov    r9,rcx
    2ba3:	mov    r8d,esi
    2ba6:	mov    rcx,rdx
    2ba9:	mov    edx,0x164
    2bae:	mov    rsi,rax
    2bb1:	mov    edi,0x1
    2bb6:	mov    eax,0x0
    2bbb:	call   14a4 <log_message>
          parser->had_error = true;
    2bc0:	mov    rax,QWORD PTR [rbp-0xe0]
    2bc7:	mov    DWORD PTR [rax+0x18],0x1
    2bce:	jmp    2c85 <parse_json_children+0x211>
        }
      }
      else
      {
        LOG_ERROR("Unexpected key type: %s, (value = %*.s)", JSON_Token_Type_strings[key_token.type], String_Format(key_token.value));
    2bd3:	mov    rcx,QWORD PTR [rbp-0xa8]
    2bda:	mov    rax,QWORD PTR [rbp-0xa0]
    2be1:	mov    edi,eax
    2be3:	mov    eax,DWORD PTR [rbp-0xb0]
    2be9:	mov    eax,eax
    2beb:	lea    rdx,[rax*8+0x0]
    2bf3:	lea    rax,[rip+0x44e6]        # 70e0 <JSON_Token_Type_strings>
    2bfa:	mov    rsi,QWORD PTR [rdx+rax*1]
    2bfe:	lea    rdx,[rip+0x1993]        # 4598 <_IO_stdin_used+0x598>
    2c05:	lea    rax,[rip+0x1876]        # 4482 <_IO_stdin_used+0x482>
    2c0c:	sub    rsp,0x8
    2c10:	push   rcx
    2c11:	mov    r9d,edi
    2c14:	mov    r8,rsi
    2c17:	mov    rcx,rdx
    2c1a:	mov    edx,0x16a
    2c1f:	mov    rsi,rax
    2c22:	mov    edi,0x1
    2c27:	mov    eax,0x0
    2c2c:	call   14a4 <log_message>
    2c31:	add    rsp,0x10
        parser->had_error = true;
    2c35:	mov    rax,QWORD PTR [rbp-0xe0]
    2c3c:	mov    DWORD PTR [rax+0x18],0x1
    2c43:	jmp    2c85 <parse_json_children+0x211>
      }
    }
    // Its just values and no keys
    else
    {
      value_token = get_json_token(parser);
    2c45:	lea    rax,[rbp-0x110]
    2c4c:	mov    rdx,QWORD PTR [rbp-0xe0]
    2c53:	mov    rsi,rdx
    2c56:	mov    rdi,rax
    2c59:	call   232f <get_json_token>
    2c5e:	mov    rax,QWORD PTR [rbp-0x110]
    2c65:	mov    rdx,QWORD PTR [rbp-0x108]
    2c6c:	mov    QWORD PTR [rbp-0x90],rax
    2c73:	mov    QWORD PTR [rbp-0x88],rdx
    2c7a:	mov    rax,QWORD PTR [rbp-0x100]
    2c81:	mov    QWORD PTR [rbp-0x80],rax
    }

    if (value_token.type == end_token)
    2c85:	mov    eax,DWORD PTR [rbp-0x90]
    2c8b:	cmp    DWORD PTR [rbp-0xe4],eax
    2c91:	je     2e09 <parse_json_children+0x395>
    {
      // We're done
      break;
    }

    JSON_Object *object = parse_json_object(arena, parser, key_token.value, value_token);
    2c97:	mov    rax,QWORD PTR [rbp-0xa8]
    2c9e:	mov    rdx,QWORD PTR [rbp-0xa0]
    2ca5:	mov    r8,QWORD PTR [rbp-0xe0]
    2cac:	mov    rdi,QWORD PTR [rbp-0xd8]
    2cb3:	sub    rsp,0x8
    2cb7:	sub    rsp,0x18
    2cbb:	mov    rsi,rsp
    2cbe:	mov    rcx,QWORD PTR [rbp-0x90]
    2cc5:	mov    rbx,QWORD PTR [rbp-0x88]
    2ccc:	mov    QWORD PTR [rsi],rcx
    2ccf:	mov    QWORD PTR [rsi+0x8],rbx
    2cd3:	mov    rcx,QWORD PTR [rbp-0x80]
    2cd7:	mov    QWORD PTR [rsi+0x10],rcx
    2cdb:	mov    rcx,rdx
    2cde:	mov    rdx,rax
    2ce1:	mov    rsi,r8
    2ce4:	call   2882 <parse_json_object>
    2ce9:	add    rsp,0x20
    2ced:	mov    QWORD PTR [rbp-0xb8],rax
    if (object)
    2cf4:	cmp    QWORD PTR [rbp-0xb8],0x0
    2cfc:	je     2d46 <parse_json_children+0x2d2>
    {
      // Create links
      if (!first_child)
    2cfe:	cmp    QWORD PTR [rbp-0xc8],0x0
    2d06:	jne    2d26 <parse_json_children+0x2b2>
      {
        first_child        = object;
    2d08:	mov    rax,QWORD PTR [rbp-0xb8]
    2d0f:	mov    QWORD PTR [rbp-0xc8],rax
        current_last_child = object;
    2d16:	mov    rax,QWORD PTR [rbp-0xb8]
    2d1d:	mov    QWORD PTR [rbp-0xc0],rax
    2d24:	jmp    2d46 <parse_json_children+0x2d2>
      }
      else
      {
        current_last_child->next_sibling = object;
    2d26:	mov    rax,QWORD PTR [rbp-0xc0]
    2d2d:	mov    rdx,QWORD PTR [rbp-0xb8]
    2d34:	mov    QWORD PTR [rax+0x28],rdx
        current_last_child = object;
    2d38:	mov    rax,QWORD PTR [rbp-0xb8]
    2d3f:	mov    QWORD PTR [rbp-0xc0],rax
      }
    }

    // We either want the end, or a comma
    JSON_Token expect_comma_or_end = get_json_token(parser);
    2d46:	lea    rax,[rbp-0x70]
    2d4a:	mov    rdx,QWORD PTR [rbp-0xe0]
    2d51:	mov    rsi,rdx
    2d54:	mov    rdi,rax
    2d57:	call   232f <get_json_token>
    if (expect_comma_or_end.type == end_token)
    2d5c:	mov    eax,DWORD PTR [rbp-0x70]
    2d5f:	cmp    DWORD PTR [rbp-0xe4],eax
    2d65:	je     2e0c <parse_json_children+0x398>
    {
      break;
    }
    else if (expect_comma_or_end.type != JSON_TOKEN_COMMA)
    2d6b:	mov    eax,DWORD PTR [rbp-0x70]
    2d6e:	cmp    eax,0x5
    2d71:	je     2df0 <parse_json_children+0x37c>
    {
      LOG_ERROR("Expected comma, parsed Token :: Type = %s, Value = '%.*s', \n", JSON_Token_Type_strings[expect_comma_or_end.type],
    2d73:	mov    r8,QWORD PTR [rbp-0x68]
    2d77:	mov    rax,QWORD PTR [rbp-0x60]
    2d7b:	mov    r9d,eax
    2d7e:	mov    eax,DWORD PTR [rbp-0x70]
    2d81:	mov    eax,eax
    2d83:	lea    rdx,[rax*8+0x0]
    2d8b:	lea    rax,[rip+0x434e]        # 70e0 <JSON_Token_Type_strings>
    2d92:	mov    r10,QWORD PTR [rdx+rax*1]
    2d96:	lea    rdi,[rip+0x1823]        # 45c0 <_IO_stdin_used+0x5c0>
    2d9d:	lea    rsi,[rip+0x16de]        # 4482 <_IO_stdin_used+0x482>
    2da4:	sub    rsp,0x18
    2da8:	mov    rcx,rsp
    2dab:	mov    rax,QWORD PTR [rbp-0x70]
    2daf:	mov    rdx,QWORD PTR [rbp-0x68]
    2db3:	mov    QWORD PTR [rcx],rax
    2db6:	mov    QWORD PTR [rcx+0x8],rdx
    2dba:	mov    rax,QWORD PTR [rbp-0x60]
    2dbe:	mov    QWORD PTR [rcx+0x10],rax
    2dc2:	push   r8
    2dc4:	mov    r8,r10
    2dc7:	mov    rcx,rdi
    2dca:	mov    edx,0x192
    2dcf:	mov    edi,0x1
    2dd4:	mov    eax,0x0
    2dd9:	call   14a4 <log_message>
    2dde:	add    rsp,0x20
                String_Format(expect_comma_or_end.value), expect_comma_or_end);
        parser->had_error = true;
    2de2:	mov    rax,QWORD PTR [rbp-0xe0]
    2de9:	mov    DWORD PTR [rax+0x18],0x1
  while (parser_incomplete(parser))
    2df0:	mov    rax,QWORD PTR [rbp-0xe0]
    2df7:	mov    rdi,rax
    2dfa:	call   226e <parser_incomplete>
    2dff:	test   al,al
    2e01:	jne    2aee <parse_json_children+0x7a>
    2e07:	jmp    2e0d <parse_json_children+0x399>
      break;
    2e09:	nop
    2e0a:	jmp    2e0d <parse_json_children+0x399>
      break;
    2e0c:	nop
    }
  }

  profile_close_func();
    2e0d:	sub    rsp,0x8
    2e11:	sub    rsp,0x38
    2e15:	mov    rax,rsp
    2e18:	mov    rcx,QWORD PTR [rbp-0x50]
    2e1c:	mov    rbx,QWORD PTR [rbp-0x48]
    2e20:	mov    QWORD PTR [rax],rcx
    2e23:	mov    QWORD PTR [rax+0x8],rbx
    2e27:	mov    rcx,QWORD PTR [rbp-0x40]
    2e2b:	mov    rbx,QWORD PTR [rbp-0x38]
    2e2f:	mov    QWORD PTR [rax+0x10],rcx
    2e33:	mov    QWORD PTR [rax+0x18],rbx
    2e37:	mov    rcx,QWORD PTR [rbp-0x30]
    2e3b:	mov    rbx,QWORD PTR [rbp-0x28]
    2e3f:	mov    QWORD PTR [rax+0x20],rcx
    2e43:	mov    QWORD PTR [rax+0x28],rbx
    2e47:	mov    rdx,QWORD PTR [rbp-0x20]
    2e4b:	mov    QWORD PTR [rax+0x30],rdx
    2e4f:	call   20db <__profile_close_pass>
    2e54:	add    rsp,0x40

  return first_child;
    2e58:	mov    rax,QWORD PTR [rbp-0xc8]
}
    2e5f:	mov    rdx,QWORD PTR [rbp-0x18]
    2e63:	sub    rdx,QWORD PTR fs:0x28
    2e6c:	je     2e73 <parse_json_children+0x3ff>
    2e6e:	call   1060 <__stack_chk_fail@plt>
    2e73:	mov    rbx,QWORD PTR [rbp-0x8]
    2e77:	leave
    2e78:	ret

0000000000002e79 <parse_json>:

// Returns the very first object
static
JSON_Object *parse_json(Arena *arena, String source)
{
    2e79:	push   rbp
    2e7a:	mov    rbp,rsp
    2e7d:	push   rbx
    2e7e:	sub    rsp,0xb8
    2e85:	mov    QWORD PTR [rbp-0xa8],rdi
    2e8c:	mov    rax,rsi
    2e8f:	mov    rsi,rdx
    2e92:	mov    rax,rax
    2e95:	mov    edx,0x0
    2e9a:	mov    rdx,rsi
    2e9d:	mov    QWORD PTR [rbp-0xc0],rax
    2ea4:	mov    QWORD PTR [rbp-0xb8],rdx
    2eab:	mov    rax,QWORD PTR fs:0x28
    2eb4:	mov    QWORD PTR [rbp-0x18],rax
    2eb8:	xor    eax,eax
  profile_begin_func();
    2eba:	lea    rcx,[rip+0x1977]        # 4838 <__func__.2>
    2ec1:	mov    ebx,0xa
    2ec6:	lea    rax,[rbp-0x50]
    2eca:	mov    rsi,rcx
    2ecd:	mov    rdx,rbx
    2ed0:	mov    r8d,0x0
    2ed6:	mov    ecx,0x3
    2edb:	mov    rdi,rax
    2ede:	call   1ff1 <__profile_begin_pass>

  JSON_Parser parser =
    2ee3:	pxor   xmm0,xmm0
    2ee7:	movaps XMMWORD PTR [rbp-0x70],xmm0
    2eeb:	movaps XMMWORD PTR [rbp-0x60],xmm0
    2eef:	mov    rax,QWORD PTR [rbp-0xc0]
    2ef6:	mov    rdx,QWORD PTR [rbp-0xb8]
    2efd:	mov    QWORD PTR [rbp-0x70],rax
    2f01:	mov    QWORD PTR [rbp-0x68],rdx
  {
    .source = source,
    .at     = 0,
  };

  JSON_Object *outer = parse_json_object(arena, &parser, (String){0}, get_json_token(&parser));
    2f05:	lea    rax,[rbp-0x90]
    2f0c:	lea    rdx,[rbp-0x70]
    2f10:	mov    rsi,rdx
    2f13:	mov    rdi,rax
    2f16:	call   232f <get_json_token>
    2f1b:	mov    ecx,0x0
    2f20:	mov    ebx,0x0
    2f25:	lea    r8,[rbp-0x70]
    2f29:	mov    rdi,QWORD PTR [rbp-0xa8]
    2f30:	sub    rsp,0x8
    2f34:	sub    rsp,0x18
    2f38:	mov    rsi,rsp
    2f3b:	mov    rax,QWORD PTR [rbp-0x90]
    2f42:	mov    rdx,QWORD PTR [rbp-0x88]
    2f49:	mov    QWORD PTR [rsi],rax
    2f4c:	mov    QWORD PTR [rsi+0x8],rdx
    2f50:	mov    rax,QWORD PTR [rbp-0x80]
    2f54:	mov    QWORD PTR [rsi+0x10],rax
    2f58:	mov    rdx,rcx
    2f5b:	mov    rcx,rbx
    2f5e:	mov    rsi,r8
    2f61:	call   2882 <parse_json_object>
    2f66:	add    rsp,0x20
    2f6a:	mov    QWORD PTR [rbp-0x98],rax

  profile_close_func();
    2f71:	sub    rsp,0x8
    2f75:	sub    rsp,0x38
    2f79:	mov    rax,rsp
    2f7c:	mov    rcx,QWORD PTR [rbp-0x50]
    2f80:	mov    rbx,QWORD PTR [rbp-0x48]
    2f84:	mov    QWORD PTR [rax],rcx
    2f87:	mov    QWORD PTR [rax+0x8],rbx
    2f8b:	mov    rcx,QWORD PTR [rbp-0x40]
    2f8f:	mov    rbx,QWORD PTR [rbp-0x38]
    2f93:	mov    QWORD PTR [rax+0x10],rcx
    2f97:	mov    QWORD PTR [rax+0x18],rbx
    2f9b:	mov    rcx,QWORD PTR [rbp-0x30]
    2f9f:	mov    rbx,QWORD PTR [rbp-0x28]
    2fa3:	mov    QWORD PTR [rax+0x20],rcx
    2fa7:	mov    QWORD PTR [rax+0x28],rbx
    2fab:	mov    rdx,QWORD PTR [rbp-0x20]
    2faf:	mov    QWORD PTR [rax+0x30],rdx
    2fb3:	call   20db <__profile_close_pass>
    2fb8:	add    rsp,0x40

  return outer;
    2fbc:	mov    rax,QWORD PTR [rbp-0x98]
}
    2fc3:	mov    rdx,QWORD PTR [rbp-0x18]
    2fc7:	sub    rdx,QWORD PTR fs:0x28
    2fd0:	je     2fd7 <parse_json+0x15e>
    2fd2:	call   1060 <__stack_chk_fail@plt>
    2fd7:	mov    rbx,QWORD PTR [rbp-0x8]
    2fdb:	leave
    2fdc:	ret

0000000000002fdd <lookup_json_object>:

static
JSON_Object *lookup_json_object(JSON_Object *current, String key)
{
    2fdd:	push   rbp
    2fde:	mov    rbp,rsp
    2fe1:	push   rbx
    2fe2:	sub    rsp,0x78
    2fe6:	mov    QWORD PTR [rbp-0x68],rdi
    2fea:	mov    rax,rsi
    2fed:	mov    rsi,rdx
    2ff0:	mov    rax,rax
    2ff3:	mov    edx,0x0
    2ff8:	mov    rdx,rsi
    2ffb:	mov    QWORD PTR [rbp-0x80],rax
    2fff:	mov    QWORD PTR [rbp-0x78],rdx
    3003:	mov    rax,QWORD PTR fs:0x28
    300c:	mov    QWORD PTR [rbp-0x18],rax
    3010:	xor    eax,eax
  profile_begin_func();
    3012:	lea    rcx,[rip+0x1837]        # 4850 <__func__.1>
    3019:	mov    ebx,0x12
    301e:	lea    rax,[rbp-0x50]
    3022:	mov    rsi,rcx
    3025:	mov    rdx,rbx
    3028:	mov    r8d,0x0
    302e:	mov    ecx,0x4
    3033:	mov    rdi,rax
    3036:	call   1ff1 <__profile_begin_pass>

  JSON_Object *result = NULL;
    303b:	mov    QWORD PTR [rbp-0x60],0x0

  if (current)
    3043:	cmp    QWORD PTR [rbp-0x68],0x0
    3048:	je     3097 <lookup_json_object+0xba>
  {
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    304a:	mov    rax,QWORD PTR [rbp-0x68]
    304e:	mov    rax,QWORD PTR [rax+0x20]
    3052:	mov    QWORD PTR [rbp-0x58],rax
    3056:	jmp    3090 <lookup_json_object+0xb3>
    {
      if (strings_equal(key, cursor->key))
    3058:	mov    rax,QWORD PTR [rbp-0x58]
    305c:	mov    rdx,QWORD PTR [rax+0x8]
    3060:	mov    rax,QWORD PTR [rax]
    3063:	mov    rdi,QWORD PTR [rbp-0x80]
    3067:	mov    rsi,QWORD PTR [rbp-0x78]
    306b:	mov    rcx,rdx
    306e:	mov    rdx,rax
    3071:	call   1442 <strings_equal>
    3076:	test   al,al
    3078:	je     3084 <lookup_json_object+0xa7>
      {
        result = cursor;
    307a:	mov    rax,QWORD PTR [rbp-0x58]
    307e:	mov    QWORD PTR [rbp-0x60],rax
        break;
    3082:	jmp    3097 <lookup_json_object+0xba>
    for (JSON_Object *cursor = current->first_child; cursor; cursor = cursor->next_sibling)
    3084:	mov    rax,QWORD PTR [rbp-0x58]
    3088:	mov    rax,QWORD PTR [rax+0x28]
    308c:	mov    QWORD PTR [rbp-0x58],rax
    3090:	cmp    QWORD PTR [rbp-0x58],0x0
    3095:	jne    3058 <lookup_json_object+0x7b>
      }
    }
  }

  profile_close_func();
    3097:	sub    rsp,0x8
    309b:	sub    rsp,0x38
    309f:	mov    rax,rsp
    30a2:	mov    rcx,QWORD PTR [rbp-0x50]
    30a6:	mov    rbx,QWORD PTR [rbp-0x48]
    30aa:	mov    QWORD PTR [rax],rcx
    30ad:	mov    QWORD PTR [rax+0x8],rbx
    30b1:	mov    rcx,QWORD PTR [rbp-0x40]
    30b5:	mov    rbx,QWORD PTR [rbp-0x38]
    30b9:	mov    QWORD PTR [rax+0x10],rcx
    30bd:	mov    QWORD PTR [rax+0x18],rbx
    30c1:	mov    rcx,QWORD PTR [rbp-0x30]
    30c5:	mov    rbx,QWORD PTR [rbp-0x28]
    30c9:	mov    QWORD PTR [rax+0x20],rcx
    30cd:	mov    QWORD PTR [rax+0x28],rbx
    30d1:	mov    rdx,QWORD PTR [rbp-0x20]
    30d5:	mov    QWORD PTR [rax+0x30],rdx
    30d9:	call   20db <__profile_close_pass>
    30de:	add    rsp,0x40

  return result;
    30e2:	mov    rax,QWORD PTR [rbp-0x60]
}
    30e6:	mov    rdx,QWORD PTR [rbp-0x18]
    30ea:	sub    rdx,QWORD PTR fs:0x28
    30f3:	je     30fa <lookup_json_object+0x11d>
    30f5:	call   1060 <__stack_chk_fail@plt>
    30fa:	mov    rbx,QWORD PTR [rbp-0x8]
    30fe:	leave
    30ff:	ret

0000000000003100 <json_object_to_f64>:

f64 json_object_to_f64(JSON_Object *object)
{
    3100:	push   rbp
    3101:	mov    rbp,rsp
    3104:	sub    rsp,0x50
    3108:	mov    QWORD PTR [rbp-0x48],rdi
  ASSERT(object, "Must pass valid object to f64 conversion");
    310c:	cmp    QWORD PTR [rbp-0x48],0x0
    3111:	jne    3138 <json_object_to_f64+0x38>
    3113:	lea    rdx,[rip+0x1756]        # 4870 <__PRETTY_FUNCTION__.0>
    311a:	lea    rsi,[rip+0x1361]        # 4482 <_IO_stdin_used+0x482>
    3121:	lea    rax,[rip+0x14d8]        # 4600 <_IO_stdin_used+0x600>
    3128:	mov    rcx,rdx
    312b:	mov    edx,0x1ca
    3130:	mov    rdi,rax
    3133:	call   1090 <__assert_fail@plt>

  String val = object->value;
    3138:	mov    rax,QWORD PTR [rbp-0x48]
    313c:	mov    rdx,QWORD PTR [rax+0x18]
    3140:	mov    rax,QWORD PTR [rax+0x10]
    3144:	mov    QWORD PTR [rbp-0x10],rax
    3148:	mov    QWORD PTR [rbp-0x8],rdx
  // Get sign.
  usize at = 0;
    314c:	mov    QWORD PTR [rbp-0x30],0x0

  f64 sign = 1.0;
    3154:	movsd  xmm0,QWORD PTR [rip+0x174c]        # 48a8 <__PRETTY_FUNCTION__.0+0x38>
    315c:	movsd  QWORD PTR [rbp-0x28],xmm0
  if (val.count > at && val.data[at] == '-')
    3161:	mov    rax,QWORD PTR [rbp-0x8]
    3165:	cmp    QWORD PTR [rbp-0x30],rax
    3169:	jae    318f <json_object_to_f64+0x8f>
    316b:	mov    rdx,QWORD PTR [rbp-0x10]
    316f:	mov    rax,QWORD PTR [rbp-0x30]
    3173:	add    rax,rdx
    3176:	movzx  eax,BYTE PTR [rax]
    3179:	cmp    al,0x2d
    317b:	jne    318f <json_object_to_f64+0x8f>
  {
    sign = -1.0;
    317d:	movsd  xmm0,QWORD PTR [rip+0x172b]        # 48b0 <__PRETTY_FUNCTION__.0+0x40>
    3185:	movsd  QWORD PTR [rbp-0x28],xmm0
    at += 1;
    318a:	add    QWORD PTR [rbp-0x30],0x1
  }

  f64 result = 0.0;
    318f:	pxor   xmm0,xmm0
    3193:	movsd  QWORD PTR [rbp-0x20],xmm0

  // Before decimal
  while (at < val.count)
    3198:	jmp    31df <json_object_to_f64+0xdf>
  {
    u8 digit = val.data[at] - (u8)'0';
    319a:	mov    rdx,QWORD PTR [rbp-0x10]
    319e:	mov    rax,QWORD PTR [rbp-0x30]
    31a2:	add    rax,rdx
    31a5:	movzx  eax,BYTE PTR [rax]
    31a8:	sub    eax,0x30
    31ab:	mov    BYTE PTR [rbp-0x32],al
    if (digit < 10)
    31ae:	cmp    BYTE PTR [rbp-0x32],0x9
    31b2:	ja     31eb <json_object_to_f64+0xeb>
    {
      // We go left to right so each previous result is 10 times bigger
      result = 10 * result + (f64)digit;
    31b4:	movsd  xmm1,QWORD PTR [rbp-0x20]
    31b9:	movsd  xmm0,QWORD PTR [rip+0x16f7]        # 48b8 <__PRETTY_FUNCTION__.0+0x48>
    31c1:	mulsd  xmm1,xmm0
    31c5:	movzx  eax,BYTE PTR [rbp-0x32]
    31c9:	pxor   xmm0,xmm0
    31cd:	cvtsi2sd xmm0,eax
    31d1:	addsd  xmm0,xmm1
    31d5:	movsd  QWORD PTR [rbp-0x20],xmm0
      at += 1;
    31da:	add    QWORD PTR [rbp-0x30],0x1
  while (at < val.count)
    31df:	mov    rax,QWORD PTR [rbp-0x8]
    31e3:	cmp    QWORD PTR [rbp-0x30],rax
    31e7:	jb     319a <json_object_to_f64+0x9a>
    31e9:	jmp    31ec <json_object_to_f64+0xec>
    }
    else // Not a digit
    {
      break;
    31eb:	nop
    }
  }

  // After decimal (if there)
  if (at < val.count && val.data[at] == '.')
    31ec:	mov    rax,QWORD PTR [rbp-0x8]
    31f0:	cmp    QWORD PTR [rbp-0x30],rax
    31f4:	jae    3281 <json_object_to_f64+0x181>
    31fa:	mov    rdx,QWORD PTR [rbp-0x10]
    31fe:	mov    rax,QWORD PTR [rbp-0x30]
    3202:	add    rax,rdx
    3205:	movzx  eax,BYTE PTR [rax]
    3208:	cmp    al,0x2e
    320a:	jne    3281 <json_object_to_f64+0x181>
  {
    at += 1;
    320c:	add    QWORD PTR [rbp-0x30],0x1

    f64 factor = 1.0 / 10.0;
    3211:	movsd  xmm0,QWORD PTR [rip+0x16a7]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    3219:	movsd  QWORD PTR [rbp-0x18],xmm0
    while (at < val.count)
    321e:	jmp    3274 <json_object_to_f64+0x174>
    {
      u8 digit = val.data[at] - (u8)'0';
    3220:	mov    rdx,QWORD PTR [rbp-0x10]
    3224:	mov    rax,QWORD PTR [rbp-0x30]
    3228:	add    rax,rdx
    322b:	movzx  eax,BYTE PTR [rax]
    322e:	sub    eax,0x30
    3231:	mov    BYTE PTR [rbp-0x31],al
      if (digit < 10)
    3234:	cmp    BYTE PTR [rbp-0x31],0x9
    3238:	ja     3280 <json_object_to_f64+0x180>
      {
        // We go left to right so each additional digit is 10 times smaller
        result = result + factor * (f64)digit;
    323a:	movzx  eax,BYTE PTR [rbp-0x31]
    323e:	pxor   xmm0,xmm0
    3242:	cvtsi2sd xmm0,eax
    3246:	mulsd  xmm0,QWORD PTR [rbp-0x18]
    324b:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3250:	addsd  xmm0,xmm1
    3254:	movsd  QWORD PTR [rbp-0x20],xmm0
        factor *= 1.0 / 10.0;
    3259:	movsd  xmm1,QWORD PTR [rbp-0x18]
    325e:	movsd  xmm0,QWORD PTR [rip+0x165a]        # 48c0 <__PRETTY_FUNCTION__.0+0x50>
    3266:	mulsd  xmm0,xmm1
    326a:	movsd  QWORD PTR [rbp-0x18],xmm0
        at += 1;
    326f:	add    QWORD PTR [rbp-0x30],0x1
    while (at < val.count)
    3274:	mov    rax,QWORD PTR [rbp-0x8]
    3278:	cmp    QWORD PTR [rbp-0x30],rax
    327c:	jb     3220 <json_object_to_f64+0x120>
    327e:	jmp    3281 <json_object_to_f64+0x181>
      }
      else // Not a digit
      {
        break;
    3280:	nop
      }
    }
  }

  return sign * result;
    3281:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3286:	mulsd  xmm0,QWORD PTR [rbp-0x20]
}
    328b:	leave
    328c:	ret

000000000000328d <to_radians>:

#include <math.h>

static
f64 to_radians(f64 degrees)
{
    328d:	push   rbp
    328e:	mov    rbp,rsp
    3291:	movsd  QWORD PTR [rbp-0x8],xmm0
  return degrees / PI;
    3296:	movsd  xmm0,QWORD PTR [rbp-0x8]
    329b:	movsd  xmm1,QWORD PTR [rip+0x1625]        # 48c8 <__PRETTY_FUNCTION__.0+0x58>
    32a3:	divsd  xmm0,xmm1
}
    32a7:	pop    rbp
    32a8:	ret

00000000000032a9 <square>:

static
f64 square(f64 x)
{
    32a9:	push   rbp
    32aa:	mov    rbp,rsp
    32ad:	movsd  QWORD PTR [rbp-0x8],xmm0
  return x * x;
    32b2:	movsd  xmm0,QWORD PTR [rbp-0x8]
    32b7:	mulsd  xmm0,xmm0
}
    32bb:	pop    rbp
    32bc:	ret

00000000000032bd <reference_haversine>:
  f64 y1;
};

static
f64 reference_haversine(f64 x0, f64 y0, f64 x1, f64 y1, f64 sphere_radius)
{
    32bd:	push   rbp
    32be:	mov    rbp,rsp
    32c1:	sub    rsp,0x90
    32c8:	movsd  QWORD PTR [rbp-0x58],xmm0
    32cd:	movsd  QWORD PTR [rbp-0x60],xmm1
    32d2:	movsd  QWORD PTR [rbp-0x68],xmm2
    32d7:	movsd  QWORD PTR [rbp-0x70],xmm3
    32dc:	movsd  QWORD PTR [rbp-0x78],xmm4
  f64 lat1 = y0;
    32e1:	movsd  xmm0,QWORD PTR [rbp-0x60]
    32e6:	movsd  QWORD PTR [rbp-0x48],xmm0
  f64 lat2 = y1;
    32eb:	movsd  xmm0,QWORD PTR [rbp-0x70]
    32f0:	movsd  QWORD PTR [rbp-0x40],xmm0
  f64 lon1 = x0;
    32f5:	movsd  xmm0,QWORD PTR [rbp-0x58]
    32fa:	movsd  QWORD PTR [rbp-0x38],xmm0
  f64 lon2 = x1;
    32ff:	movsd  xmm0,QWORD PTR [rbp-0x68]
    3304:	movsd  QWORD PTR [rbp-0x30],xmm0

  f64 d_lat = to_radians(lat2 - lat1);
    3309:	movsd  xmm0,QWORD PTR [rbp-0x40]
    330e:	subsd  xmm0,QWORD PTR [rbp-0x48]
    3313:	movq   rax,xmm0
    3318:	movq   xmm0,rax
    331d:	call   328d <to_radians>
    3322:	movq   rax,xmm0
    3327:	mov    QWORD PTR [rbp-0x28],rax
  f64 d_lon = to_radians(lon2 - lon1);
    332b:	movsd  xmm0,QWORD PTR [rbp-0x30]
    3330:	subsd  xmm0,QWORD PTR [rbp-0x38]
    3335:	movq   rax,xmm0
    333a:	movq   xmm0,rax
    333f:	call   328d <to_radians>
    3344:	movq   rax,xmm0
    3349:	mov    QWORD PTR [rbp-0x20],rax
  lat1 = to_radians(lat1);
    334d:	mov    rax,QWORD PTR [rbp-0x48]
    3351:	movq   xmm0,rax
    3356:	call   328d <to_radians>
    335b:	movq   rax,xmm0
    3360:	mov    QWORD PTR [rbp-0x48],rax
  lat2 = to_radians(lat2);
    3364:	mov    rax,QWORD PTR [rbp-0x40]
    3368:	movq   xmm0,rax
    336d:	call   328d <to_radians>
    3372:	movq   rax,xmm0
    3377:	mov    QWORD PTR [rbp-0x40],rax

  f64 a = square(sin(d_lat/2.0)) + cos(lat1) * cos(lat2) * square(sin(d_lon/2.0));
    337b:	movsd  xmm0,QWORD PTR [rbp-0x28]
    3380:	movsd  xmm1,QWORD PTR [rip+0x1548]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    3388:	divsd  xmm0,xmm1
    338c:	movq   rax,xmm0
    3391:	movq   xmm0,rax
    3396:	call   1130 <sin@plt>
    339b:	movq   rax,xmm0
    33a0:	movq   xmm0,rax
    33a5:	call   32a9 <square>
    33aa:	movsd  QWORD PTR [rbp-0x80],xmm0
    33af:	mov    rax,QWORD PTR [rbp-0x48]
    33b3:	movq   xmm0,rax
    33b8:	call   10b0 <cos@plt>
    33bd:	movsd  QWORD PTR [rbp-0x88],xmm0
    33c5:	mov    rax,QWORD PTR [rbp-0x40]
    33c9:	movq   xmm0,rax
    33ce:	call   10b0 <cos@plt>
    33d3:	movapd xmm5,xmm0
    33d7:	mulsd  xmm5,QWORD PTR [rbp-0x88]
    33df:	movsd  QWORD PTR [rbp-0x88],xmm5
    33e7:	movsd  xmm0,QWORD PTR [rbp-0x20]
    33ec:	movsd  xmm1,QWORD PTR [rip+0x14dc]        # 48d0 <__PRETTY_FUNCTION__.0+0x60>
    33f4:	movapd xmm6,xmm0
    33f8:	divsd  xmm6,xmm1
    33fc:	movq   rax,xmm6
    3401:	movq   xmm0,rax
    3406:	call   1130 <sin@plt>
    340b:	movq   rax,xmm0
    3410:	movq   xmm0,rax
    3415:	call   32a9 <square>
    341a:	mulsd  xmm0,QWORD PTR [rbp-0x88]
    3422:	addsd  xmm0,QWORD PTR [rbp-0x80]
    3427:	movsd  QWORD PTR [rbp-0x18],xmm0
  f64 c = 2.0 * asin(sqrt(a));
    342c:	mov    rax,QWORD PTR [rbp-0x18]
    3430:	movq   xmm0,rax
    3435:	call   1160 <sqrt@plt>
    343a:	movq   rax,xmm0
    343f:	movq   xmm0,rax
    3444:	call   1140 <asin@plt>
    3449:	addsd  xmm0,xmm0
    344d:	movsd  QWORD PTR [rbp-0x10],xmm0

  f64 result = sphere_radius * c;
    3452:	movsd  xmm0,QWORD PTR [rbp-0x78]
    3457:	mulsd  xmm0,QWORD PTR [rbp-0x10]
    345c:	movsd  QWORD PTR [rbp-0x8],xmm0

  return result;
    3461:	movsd  xmm0,QWORD PTR [rbp-0x8]
}
    3466:	leave
    3467:	ret

0000000000003468 <epsilon_equal>:

#define DESIRED_ARG_COUNT 2 + 1

static
b32 epsilon_equal(f64 a, f64 b)
{
    3468:	push   rbp
    3469:	mov    rbp,rsp
    346c:	movsd  QWORD PTR [rbp-0x18],xmm0
    3471:	movsd  QWORD PTR [rbp-0x20],xmm1
  f64 epsilon = 0.00001;
    3476:	movsd  xmm0,QWORD PTR [rip+0x145a]        # 48d8 <__PRETTY_FUNCTION__.0+0x68>
    347e:	movsd  QWORD PTR [rbp-0x8],xmm0

  return (fabs(a) - fabs(b)) <= epsilon;
    3483:	movsd  xmm0,QWORD PTR [rbp-0x18]
    3488:	movq   xmm1,QWORD PTR [rip+0x1450]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    3490:	andpd  xmm0,xmm1
    3494:	movsd  xmm1,QWORD PTR [rbp-0x20]
    3499:	movq   xmm2,QWORD PTR [rip+0x143f]        # 48e0 <__PRETTY_FUNCTION__.0+0x70>
    34a1:	andpd  xmm2,xmm1
    34a5:	movapd xmm1,xmm0
    34a9:	subsd  xmm1,xmm2
    34ad:	movsd  xmm0,QWORD PTR [rbp-0x8]
    34b2:	comisd xmm0,xmm1
    34b6:	setae  al
    34b9:	movzx  eax,al
}
    34bc:	pop    rbp
    34bd:	ret

00000000000034be <main>:

int main(int args_count, char **args)
{
    34be:	push   rbp
    34bf:	mov    rbp,rsp
    34c2:	push   r15
    34c4:	push   r14
    34c6:	push   r13
    34c8:	push   r12
    34ca:	push   rbx
    34cb:	sub    rsp,0x268
    34d2:	mov    DWORD PTR [rbp-0x1f4],edi
    34d8:	mov    QWORD PTR [rbp-0x200],rsi
    34df:	mov    rax,QWORD PTR fs:0x28
    34e8:	mov    QWORD PTR [rbp-0x38],rax
    34ec:	xor    eax,eax
  if (args_count != DESIRED_ARG_COUNT)
    34ee:	cmp    DWORD PTR [rbp-0x1f4],0x3
    34f5:	je     3522 <main+0x64>
  {
    printf("Usage: %s [haversine_json] [solution_dump]\n", args[0]);
    34f7:	mov    rax,QWORD PTR [rbp-0x200]
    34fe:	mov    rax,QWORD PTR [rax]
    3501:	lea    rdx,[rip+0x1130]        # 4638 <_IO_stdin_used+0x638>
    3508:	mov    rsi,rax
    350b:	mov    rdi,rdx
    350e:	mov    eax,0x0
    3513:	call   1070 <printf@plt>
    return 1;
    3518:	mov    eax,0x1
    351d:	jmp    3e28 <main+0x96a>
  }

  begin_profiling();
    3522:	call   1bc6 <begin_profiling>

  Arena arena = {0};
    3527:	pxor   xmm0,xmm0
    352b:	movaps XMMWORD PTR [rbp-0x150],xmm0
    3532:	movaps XMMWORD PTR [rbp-0x140],xmm0
  arena = arena_make(GB(4));
    3539:	lea    rdx,[rbp-0x220]
    3540:	movabs rax,0x100000000
    354a:	mov    rsi,rax
    354d:	mov    rdi,rdx
    3550:	call   1635 <arena_make>
    3555:	mov    rax,QWORD PTR [rbp-0x220]
    355c:	mov    rdx,QWORD PTR [rbp-0x218]
    3563:	mov    QWORD PTR [rbp-0x150],rax
    356a:	mov    QWORD PTR [rbp-0x148],rdx
    3571:	mov    rax,QWORD PTR [rbp-0x210]
    3578:	mov    rdx,QWORD PTR [rbp-0x208]
    357f:	mov    QWORD PTR [rbp-0x140],rax
    3586:	mov    QWORD PTR [rbp-0x138],rdx

  String source = {0};
    358d:	mov    QWORD PTR [rbp-0x160],0x0
    3598:	mov    QWORD PTR [rbp-0x158],0x0
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    35a3:	mov    rax,QWORD PTR [rbp-0x200]
    35aa:	add    rax,0x8
    35ae:	mov    rax,QWORD PTR [rax]
    35b1:	mov    rdi,rax
    35b4:	call   1306 <file_size>
    35b9:	mov    rcx,rax
    35bc:	lea    r12,[rip+0x10a1]        # 4664 <_IO_stdin_used+0x664>
    35c3:	mov    r13d,0x4
    35c9:	lea    rdi,[rbp-0x130]
    35d0:	mov    rdx,r12
    35d3:	mov    rax,r13
    35d6:	mov    r8,rcx
    35d9:	mov    ecx,0x5
    35de:	mov    rsi,rdx
    35e1:	mov    rdx,rax
    35e4:	call   1ff1 <__profile_begin_pass>
    35e9:	mov    QWORD PTR [rbp-0x1e0],0x0
    35f4:	jmp    368f <main+0x1d1>
  {
    source = read_file_to_arena(&arena, args[1]);
    35f9:	mov    rax,QWORD PTR [rbp-0x200]
    3600:	add    rax,0x8
    3604:	mov    rdx,QWORD PTR [rax]
    3607:	lea    rax,[rbp-0x150]
    360e:	mov    rsi,rdx
    3611:	mov    rdi,rax
    3614:	call   135a <read_file_to_arena>
    3619:	mov    QWORD PTR [rbp-0x160],rax
    3620:	mov    QWORD PTR [rbp-0x158],rdx
  PROFILE_SCOPE_BANDWIDTH("read", file_size(args[1]))
    3627:	add    QWORD PTR [rbp-0x1e0],0x1
    362f:	sub    rsp,0x8
    3633:	sub    rsp,0x38
    3637:	mov    rcx,rsp
    363a:	mov    rax,QWORD PTR [rbp-0x130]
    3641:	mov    rdx,QWORD PTR [rbp-0x128]
    3648:	mov    QWORD PTR [rcx],rax
    364b:	mov    QWORD PTR [rcx+0x8],rdx
    364f:	mov    rax,QWORD PTR [rbp-0x120]
    3656:	mov    rdx,QWORD PTR [rbp-0x118]
    365d:	mov    QWORD PTR [rcx+0x10],rax
    3661:	mov    QWORD PTR [rcx+0x18],rdx
    3665:	mov    rax,QWORD PTR [rbp-0x110]
    366c:	mov    rdx,QWORD PTR [rbp-0x108]
    3673:	mov    QWORD PTR [rcx+0x20],rax
    3677:	mov    QWORD PTR [rcx+0x28],rdx
    367b:	mov    rax,QWORD PTR [rbp-0x100]
    3682:	mov    QWORD PTR [rcx+0x30],rax
    3686:	call   20db <__profile_close_pass>
    368b:	add    rsp,0x40
    368f:	cmp    QWORD PTR [rbp-0x1e0],0x0
    3697:	je     35f9 <main+0x13b>
  }

  usize min_pair_bytes = 6 * 4; // 6 chars for something like "x0:0" (at least) and 4 of those
    369d:	mov    QWORD PTR [rbp-0x1a8],0x18
  usize max_pairs = source.count / min_pair_bytes; // Roughly, overestimate at least
    36a8:	mov    rax,QWORD PTR [rbp-0x158]
    36af:	mov    edx,0x0
    36b4:	div    QWORD PTR [rbp-0x1a8]
    36bb:	mov    QWORD PTR [rbp-0x1a0],rax
  Haversine_Pair * pairs = arena_calloc(&arena, max_pairs, Haversine_Pair);
    36c2:	mov    rax,QWORD PTR [rbp-0x1a0]
    36c9:	shl    rax,0x5
    36cd:	mov    rcx,rax
    36d0:	lea    rax,[rbp-0x150]
    36d7:	mov    edx,0x8
    36dc:	mov    rsi,rcx
    36df:	mov    rdi,rax
    36e2:	call   17d6 <arena_alloc>
    36e7:	mov    QWORD PTR [rbp-0x198],rax
  i32 pair_count = 0;
    36ee:	mov    DWORD PTR [rbp-0x1e8],0x0

  JSON_Object *root = NULL;
    36f8:	mov    QWORD PTR [rbp-0x190],0x0
  root = parse_json(&arena, source);
    3703:	mov    rcx,QWORD PTR [rbp-0x160]
    370a:	mov    rdx,QWORD PTR [rbp-0x158]
    3711:	lea    rax,[rbp-0x150]
    3718:	mov    rsi,rcx
    371b:	mov    rdi,rax
    371e:	call   2e79 <parse_json>
    3723:	mov    QWORD PTR [rbp-0x190],rax

  f64 haversine_sum = 0.0;
    372a:	pxor   xmm0,xmm0
    372e:	movsd  QWORD PTR [rbp-0x188],xmm0

  JSON_Object *pairs_object = lookup_json_object(root, String("pairs"));
    3736:	lea    r14,[rip+0xf2c]        # 4669 <_IO_stdin_used+0x669>
    373d:	mov    r15d,0x5
    3743:	mov    rcx,r14
    3746:	mov    rdx,r15
    3749:	mov    rax,QWORD PTR [rbp-0x190]
    3750:	mov    rsi,rcx
    3753:	mov    rdi,rax
    3756:	call   2fdd <lookup_json_object>
    375b:	mov    QWORD PTR [rbp-0x180],rax
  if (pairs)
    3762:	cmp    QWORD PTR [rbp-0x198],0x0
    376a:	je     392f <main+0x471>
  {
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    3770:	mov    rax,QWORD PTR [rbp-0x180]
    3777:	mov    rax,QWORD PTR [rax+0x20]
    377b:	mov    QWORD PTR [rbp-0x1d8],rax
    3782:	jmp    3910 <main+0x452>
    {
      Haversine_Pair pair =
      {
        .x0 = json_object_to_f64(lookup_json_object(cursor, String("x0"))),
    3787:	lea    rax,[rip+0xee1]        # 466f <_IO_stdin_used+0x66f>
    378e:	mov    QWORD PTR [rbp-0x260],rax
    3795:	mov    QWORD PTR [rbp-0x258],0x2
    37a0:	mov    rbx,QWORD PTR [rbp-0x260]
    37a7:	mov    rsi,QWORD PTR [rbp-0x258]
    37ae:	mov    rax,rbx
    37b1:	mov    rdx,rsi
    37b4:	mov    rcx,QWORD PTR [rbp-0x1d8]
    37bb:	mov    rsi,rax
    37be:	mov    rdi,rcx
    37c1:	call   2fdd <lookup_json_object>
    37c6:	mov    rdi,rax
    37c9:	call   3100 <json_object_to_f64>
    37ce:	movq   rax,xmm0
      Haversine_Pair pair =
    37d3:	mov    QWORD PTR [rbp-0x70],rax
        .y0 = json_object_to_f64(lookup_json_object(cursor, String("y0"))),
    37d7:	lea    rax,[rip+0xe94]        # 4672 <_IO_stdin_used+0x672>
    37de:	mov    QWORD PTR [rbp-0x270],rax
    37e5:	mov    QWORD PTR [rbp-0x268],0x2
    37f0:	mov    rax,QWORD PTR [rbp-0x270]
    37f7:	mov    rdx,QWORD PTR [rbp-0x268]
    37fe:	mov    rcx,rax
    3801:	mov    rax,QWORD PTR [rbp-0x1d8]
    3808:	mov    rsi,rcx
    380b:	mov    rdi,rax
    380e:	call   2fdd <lookup_json_object>
    3813:	mov    rdi,rax
    3816:	call   3100 <json_object_to_f64>
    381b:	movq   rax,xmm0
      Haversine_Pair pair =
    3820:	mov    QWORD PTR [rbp-0x68],rax
        .x1 = json_object_to_f64(lookup_json_object(cursor, String("x1"))),
    3824:	lea    rax,[rip+0xe4a]        # 4675 <_IO_stdin_used+0x675>
    382b:	mov    QWORD PTR [rbp-0x280],rax
    3832:	mov    QWORD PTR [rbp-0x278],0x2
    383d:	mov    rax,QWORD PTR [rbp-0x280]
    3844:	mov    rdx,QWORD PTR [rbp-0x278]
    384b:	mov    rcx,rax
    384e:	mov    rax,QWORD PTR [rbp-0x1d8]
    3855:	mov    rsi,rcx
    3858:	mov    rdi,rax
    385b:	call   2fdd <lookup_json_object>
    3860:	mov    rdi,rax
    3863:	call   3100 <json_object_to_f64>
    3868:	movq   rax,xmm0
      Haversine_Pair pair =
    386d:	mov    QWORD PTR [rbp-0x60],rax
        .y1 = json_object_to_f64(lookup_json_object(cursor, String("y1"))),
    3871:	lea    rax,[rip+0xe00]        # 4678 <_IO_stdin_used+0x678>
    3878:	mov    QWORD PTR [rbp-0x290],rax
    387f:	mov    QWORD PTR [rbp-0x288],0x2
    388a:	mov    rax,QWORD PTR [rbp-0x290]
    3891:	mov    rdx,QWORD PTR [rbp-0x288]
    3898:	mov    rcx,rax
    389b:	mov    rax,QWORD PTR [rbp-0x1d8]
    38a2:	mov    rsi,rcx
    38a5:	mov    rdi,rax
    38a8:	call   2fdd <lookup_json_object>
    38ad:	mov    rdi,rax
    38b0:	call   3100 <json_object_to_f64>
    38b5:	movq   rax,xmm0
      Haversine_Pair pair =
    38ba:	mov    QWORD PTR [rbp-0x58],rax
      };

      pairs[pair_count] = pair;
    38be:	mov    eax,DWORD PTR [rbp-0x1e8]
    38c4:	cdqe
    38c6:	shl    rax,0x5
    38ca:	mov    rdx,rax
    38cd:	mov    rax,QWORD PTR [rbp-0x198]
    38d4:	lea    rcx,[rdx+rax*1]
    38d8:	mov    rax,QWORD PTR [rbp-0x70]
    38dc:	mov    rdx,QWORD PTR [rbp-0x68]
    38e0:	mov    QWORD PTR [rcx],rax
    38e3:	mov    QWORD PTR [rcx+0x8],rdx
    38e7:	mov    rax,QWORD PTR [rbp-0x60]
    38eb:	mov    rdx,QWORD PTR [rbp-0x58]
    38ef:	mov    QWORD PTR [rcx+0x10],rax
    38f3:	mov    QWORD PTR [rcx+0x18],rdx
      pair_count += 1;
    38f7:	add    DWORD PTR [rbp-0x1e8],0x1
    for (JSON_Object *cursor = pairs_object->first_child; cursor && pair_count < max_pairs; cursor = cursor->next_sibling)
    38fe:	mov    rax,QWORD PTR [rbp-0x1d8]
    3905:	mov    rax,QWORD PTR [rax+0x28]
    3909:	mov    QWORD PTR [rbp-0x1d8],rax
    3910:	cmp    QWORD PTR [rbp-0x1d8],0x0
    3918:	je     392f <main+0x471>
    391a:	mov    eax,DWORD PTR [rbp-0x1e8]
    3920:	cdqe
    3922:	cmp    rax,QWORD PTR [rbp-0x1a0]
    3929:	jb     3787 <main+0x2c9>
    }
  }

  f64 sum = 0.0;
    392f:	pxor   xmm0,xmm0
    3933:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    393b:	mov    eax,DWORD PTR [rbp-0x1e8]
    3941:	cdqe
    3943:	shl    rax,0x5
    3947:	mov    rdx,rax
    394a:	lea    rax,[rip+0xd2a]        # 467b <_IO_stdin_used+0x67b>
    3951:	mov    QWORD PTR [rbp-0x230],rax
    3958:	mov    QWORD PTR [rbp-0x228],0x3
    3963:	lea    rax,[rbp-0xf0]
    396a:	mov    rcx,QWORD PTR [rbp-0x230]
    3971:	mov    rbx,QWORD PTR [rbp-0x228]
    3978:	mov    rsi,rcx
    397b:	mov    rdi,rbx
    397e:	mov    r8,rdx
    3981:	mov    ecx,0x6
    3986:	mov    rdx,rdi
    3989:	mov    rdi,rax
    398c:	call   1ff1 <__profile_begin_pass>
    3991:	mov    QWORD PTR [rbp-0x1c8],0x0
    399c:	jmp    3b1e <main+0x660>
  {
    for (usize i = 0; i < pair_count; i++)
    39a1:	mov    QWORD PTR [rbp-0x1c0],0x0
    39ac:	jmp    3a81 <main+0x5c3>
    {
      f64 earth_radius = 6372.8;
    39b1:	movsd  xmm0,QWORD PTR [rip+0xf37]        # 48f0 <__PRETTY_FUNCTION__.0+0x80>
    39b9:	movsd  QWORD PTR [rbp-0x170],xmm0
      f64 result = reference_haversine(pairs[i].x0,pairs[i].y0,pairs[i].x1,pairs[i].y1, earth_radius);
    39c1:	mov    rax,QWORD PTR [rbp-0x1c0]
    39c8:	shl    rax,0x5
    39cc:	mov    rdx,rax
    39cf:	mov    rax,QWORD PTR [rbp-0x198]
    39d6:	add    rax,rdx
    39d9:	movsd  xmm2,QWORD PTR [rax+0x18]
    39de:	mov    rax,QWORD PTR [rbp-0x1c0]
    39e5:	shl    rax,0x5
    39e9:	mov    rdx,rax
    39ec:	mov    rax,QWORD PTR [rbp-0x198]
    39f3:	add    rax,rdx
    39f6:	movsd  xmm1,QWORD PTR [rax+0x10]
    39fb:	mov    rax,QWORD PTR [rbp-0x1c0]
    3a02:	shl    rax,0x5
    3a06:	mov    rdx,rax
    3a09:	mov    rax,QWORD PTR [rbp-0x198]
    3a10:	add    rax,rdx
    3a13:	movsd  xmm0,QWORD PTR [rax+0x8]
    3a18:	mov    rax,QWORD PTR [rbp-0x1c0]
    3a1f:	shl    rax,0x5
    3a23:	mov    rdx,rax
    3a26:	mov    rax,QWORD PTR [rbp-0x198]
    3a2d:	add    rax,rdx
    3a30:	mov    rax,QWORD PTR [rax]
    3a33:	movsd  xmm3,QWORD PTR [rbp-0x170]
    3a3b:	movapd xmm4,xmm3
    3a3f:	movapd xmm3,xmm2
    3a43:	movapd xmm2,xmm1
    3a47:	movapd xmm1,xmm0
    3a4b:	movq   xmm0,rax
    3a50:	call   32bd <reference_haversine>
    3a55:	movq   rax,xmm0
    3a5a:	mov    QWORD PTR [rbp-0x168],rax
      sum += result;
    3a61:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3a69:	addsd  xmm0,QWORD PTR [rbp-0x168]
    3a71:	movsd  QWORD PTR [rbp-0x1d0],xmm0
    for (usize i = 0; i < pair_count; i++)
    3a79:	add    QWORD PTR [rbp-0x1c0],0x1
    3a81:	mov    eax,DWORD PTR [rbp-0x1e8]
    3a87:	cdqe
    3a89:	cmp    QWORD PTR [rbp-0x1c0],rax
    3a90:	jb     39b1 <main+0x4f3>
    }
    sum /= pair_count;
    3a96:	pxor   xmm1,xmm1
    3a9a:	cvtsi2sd xmm1,DWORD PTR [rbp-0x1e8]
    3aa2:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3aaa:	divsd  xmm0,xmm1
    3aae:	movsd  QWORD PTR [rbp-0x1d0],xmm0
  PROFILE_SCOPE_BANDWIDTH("sum", pair_count * sizeof(Haversine_Pair))
    3ab6:	add    QWORD PTR [rbp-0x1c8],0x1
    3abe:	sub    rsp,0x8
    3ac2:	sub    rsp,0x38
    3ac6:	mov    rax,rsp
    3ac9:	mov    rcx,QWORD PTR [rbp-0xf0]
    3ad0:	mov    rbx,QWORD PTR [rbp-0xe8]
    3ad7:	mov    QWORD PTR [rax],rcx
    3ada:	mov    QWORD PTR [rax+0x8],rbx
    3ade:	mov    rcx,QWORD PTR [rbp-0xe0]
    3ae5:	mov    rbx,QWORD PTR [rbp-0xd8]
    3aec:	mov    QWORD PTR [rax+0x10],rcx
    3af0:	mov    QWORD PTR [rax+0x18],rbx
    3af4:	mov    rcx,QWORD PTR [rbp-0xd0]
    3afb:	mov    rbx,QWORD PTR [rbp-0xc8]
    3b02:	mov    QWORD PTR [rax+0x20],rcx
    3b06:	mov    QWORD PTR [rax+0x28],rbx
    3b0a:	mov    rdx,QWORD PTR [rbp-0xc0]
    3b11:	mov    QWORD PTR [rax+0x30],rdx
    3b15:	call   20db <__profile_close_pass>
    3b1a:	add    rsp,0x40
    3b1e:	cmp    QWORD PTR [rbp-0x1c8],0x0
    3b26:	je     39a1 <main+0x4e3>
  }

  PROFILE_SCOPE("check")
    3b2c:	lea    rax,[rip+0xb4c]        # 467f <_IO_stdin_used+0x67f>
    3b33:	mov    QWORD PTR [rbp-0x240],rax
    3b3a:	mov    QWORD PTR [rbp-0x238],0x5
    3b45:	lea    rax,[rbp-0xb0]
    3b4c:	mov    rcx,QWORD PTR [rbp-0x240]
    3b53:	mov    rbx,QWORD PTR [rbp-0x238]
    3b5a:	mov    rsi,rcx
    3b5d:	mov    rdx,rbx
    3b60:	mov    r8d,0x0
    3b66:	mov    ecx,0x7
    3b6b:	mov    rdi,rax
    3b6e:	call   1ff1 <__profile_begin_pass>
    3b73:	mov    QWORD PTR [rbp-0x1b8],0x0
    3b7e:	jmp    3d53 <main+0x895>
  {
    // Get solutions out of binary dump and verify
    String solution_dump = read_file_to_arena(&arena, args[2]);
    3b83:	mov    rax,QWORD PTR [rbp-0x200]
    3b8a:	add    rax,0x10
    3b8e:	mov    rdx,QWORD PTR [rax]
    3b91:	lea    rax,[rbp-0x150]
    3b98:	mov    rsi,rdx
    3b9b:	mov    rdi,rax
    3b9e:	call   135a <read_file_to_arena>
    3ba3:	mov    QWORD PTR [rbp-0x70],rax
    3ba7:	mov    QWORD PTR [rbp-0x68],rdx
    if (solution_dump.count >= sizeof(f64) + sizeof(i32))
    3bab:	mov    rax,QWORD PTR [rbp-0x68]
    3baf:	cmp    rax,0xb
    3bb3:	jbe    3cc6 <main+0x808>
    {
      f64 solution_sum   = *(f64 *)solution_dump.data;
    3bb9:	mov    rax,QWORD PTR [rbp-0x70]
    3bbd:	movsd  xmm0,QWORD PTR [rax]
    3bc1:	movsd  QWORD PTR [rbp-0x178],xmm0
      i32 solution_pairs = *(i32 *)(solution_dump.data + sizeof(f64));
    3bc9:	mov    rax,QWORD PTR [rbp-0x70]
    3bcd:	mov    eax,DWORD PTR [rax+0x8]
    3bd0:	mov    DWORD PTR [rbp-0x1e4],eax

      if (solution_pairs == pair_count)
    3bd6:	mov    eax,DWORD PTR [rbp-0x1e4]
    3bdc:	cmp    eax,DWORD PTR [rbp-0x1e8]
    3be2:	jne    3c8a <main+0x7cc>
      {
        if (epsilon_equal(solution_sum, sum))
    3be8:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3bf0:	mov    rax,QWORD PTR [rbp-0x178]
    3bf7:	movapd xmm1,xmm0
    3bfb:	movq   xmm0,rax
    3c00:	call   3468 <epsilon_equal>
    3c05:	test   eax,eax
    3c07:	je     3c4b <main+0x78d>
        {
          LOG_INFO("Solutions (solution: %f, calculated: %f) match! :)", solution_sum, sum);
    3c09:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3c11:	mov    rax,QWORD PTR [rbp-0x178]
    3c18:	lea    rdx,[rip+0xa69]        # 4688 <_IO_stdin_used+0x688>
    3c1f:	lea    rsi,[rip+0xa95]        # 46bb <_IO_stdin_used+0x6bb>
    3c26:	movapd xmm1,xmm0
    3c2a:	movq   xmm0,rax
    3c2f:	mov    rcx,rdx
    3c32:	mov    edx,0x5b
    3c37:	mov    edi,0x3
    3c3c:	mov    eax,0x2
    3c41:	call   14a4 <log_message>
    3c46:	jmp    3cee <main+0x830>
        }
        else
        {
          LOG_ERROR("Solution sum (%f) does not match calculated sum (%f)", solution_sum, sum);
    3c4b:	movsd  xmm0,QWORD PTR [rbp-0x1d0]
    3c53:	mov    rax,QWORD PTR [rbp-0x178]
    3c5a:	lea    rdx,[rip+0xa6f]        # 46d0 <_IO_stdin_used+0x6d0>
    3c61:	lea    rsi,[rip+0xa53]        # 46bb <_IO_stdin_used+0x6bb>
    3c68:	movapd xmm1,xmm0
    3c6c:	movq   xmm0,rax
    3c71:	mov    rcx,rdx
    3c74:	mov    edx,0x5f
    3c79:	mov    edi,0x1
    3c7e:	mov    eax,0x2
    3c83:	call   14a4 <log_message>
    3c88:	jmp    3cee <main+0x830>
        }
      }
      else
      {
        LOG_ERROR("Solution pair counts (%d) and parsed pair count (%d) do not match", solution_pairs, pair_count);
    3c8a:	mov    esi,DWORD PTR [rbp-0x1e8]
    3c90:	mov    ecx,DWORD PTR [rbp-0x1e4]
    3c96:	lea    rdx,[rip+0xa6b]        # 4708 <_IO_stdin_used+0x708>
    3c9d:	lea    rax,[rip+0xa17]        # 46bb <_IO_stdin_used+0x6bb>
    3ca4:	mov    r9d,esi
    3ca7:	mov    r8d,ecx
    3caa:	mov    rcx,rdx
    3cad:	mov    edx,0x64
    3cb2:	mov    rsi,rax
    3cb5:	mov    edi,0x1
    3cba:	mov    eax,0x0
    3cbf:	call   14a4 <log_message>
    3cc4:	jmp    3cee <main+0x830>
      }
    }
    else
    {
      LOG_ERROR("Solution dump is not large enough to hold actual solutions");
    3cc6:	lea    rdx,[rip+0xa83]        # 4750 <_IO_stdin_used+0x750>
    3ccd:	lea    rax,[rip+0x9e7]        # 46bb <_IO_stdin_used+0x6bb>
    3cd4:	mov    rcx,rdx
    3cd7:	mov    edx,0x69
    3cdc:	mov    rsi,rax
    3cdf:	mov    edi,0x1
    3ce4:	mov    eax,0x0
    3ce9:	call   14a4 <log_message>
  PROFILE_SCOPE("check")
    3cee:	add    QWORD PTR [rbp-0x1b8],0x1
    3cf6:	sub    rsp,0x8
    3cfa:	sub    rsp,0x38
    3cfe:	mov    rax,rsp
    3d01:	mov    rcx,QWORD PTR [rbp-0xb0]
    3d08:	mov    rbx,QWORD PTR [rbp-0xa8]
    3d0f:	mov    QWORD PTR [rax],rcx
    3d12:	mov    QWORD PTR [rax+0x8],rbx
    3d16:	mov    rcx,QWORD PTR [rbp-0xa0]
    3d1d:	mov    rbx,QWORD PTR [rbp-0x98]
    3d24:	mov    QWORD PTR [rax+0x10],rcx
    3d28:	mov    QWORD PTR [rax+0x18],rbx
    3d2c:	mov    rcx,QWORD PTR [rbp-0x90]
    3d33:	mov    rbx,QWORD PTR [rbp-0x88]
    3d3a:	mov    QWORD PTR [rax+0x20],rcx
    3d3e:	mov    QWORD PTR [rax+0x28],rbx
    3d42:	mov    rdx,QWORD PTR [rbp-0x80]
    3d46:	mov    QWORD PTR [rax+0x30],rdx
    3d4a:	call   20db <__profile_close_pass>
    3d4f:	add    rsp,0x40
    3d53:	cmp    QWORD PTR [rbp-0x1b8],0x0
    3d5b:	je     3b83 <main+0x6c5>
    }
  }

  PROFILE_SCOPE("free")
    3d61:	lea    rax,[rip+0xa23]        # 478b <_IO_stdin_used+0x78b>
    3d68:	mov    QWORD PTR [rbp-0x250],rax
    3d6f:	mov    QWORD PTR [rbp-0x248],0x4
    3d7a:	lea    rax,[rbp-0x70]
    3d7e:	mov    rcx,QWORD PTR [rbp-0x250]
    3d85:	mov    rbx,QWORD PTR [rbp-0x248]
    3d8c:	mov    rsi,rcx
    3d8f:	mov    rdx,rbx
    3d92:	mov    r8d,0x0
    3d98:	mov    ecx,0x8
    3d9d:	mov    rdi,rax
    3da0:	call   1ff1 <__profile_begin_pass>
    3da5:	mov    QWORD PTR [rbp-0x1b0],0x0
    3db0:	jmp    3e14 <main+0x956>
  {
    arena_free(&arena);
    3db2:	lea    rax,[rbp-0x150]
    3db9:	mov    rdi,rax
    3dbc:	call   1794 <arena_free>
  PROFILE_SCOPE("free")
    3dc1:	add    QWORD PTR [rbp-0x1b0],0x1
    3dc9:	sub    rsp,0x8
    3dcd:	sub    rsp,0x38
    3dd1:	mov    rax,rsp
    3dd4:	mov    rcx,QWORD PTR [rbp-0x70]
    3dd8:	mov    rbx,QWORD PTR [rbp-0x68]
    3ddc:	mov    QWORD PTR [rax],rcx
    3ddf:	mov    QWORD PTR [rax+0x8],rbx
    3de3:	mov    rcx,QWORD PTR [rbp-0x60]
    3de7:	mov    rbx,QWORD PTR [rbp-0x58]
    3deb:	mov    QWORD PTR [rax+0x10],rcx
    3def:	mov    QWORD PTR [rax+0x18],rbx
    3df3:	mov    rcx,QWORD PTR [rbp-0x50]
    3df7:	mov    rbx,QWORD PTR [rbp-0x48]
    3dfb:	mov    QWORD PTR [rax+0x20],rcx
    3dff:	mov    QWORD PTR [rax+0x28],rbx
    3e03:	mov    rdx,QWORD PTR [rbp-0x40]
    3e07:	mov    QWORD PTR [rax+0x30],rdx
    3e0b:	call   20db <__profile_close_pass>
    3e10:	add    rsp,0x40
    3e14:	cmp    QWORD PTR [rbp-0x1b0],0x0
    3e1c:	je     3db2 <main+0x8f4>
  }

  end_profiling();
    3e1e:	call   1c24 <end_profiling>
    3e23:	mov    eax,0x0
}
    3e28:	mov    rdx,QWORD PTR [rbp-0x38]
    3e2c:	sub    rdx,QWORD PTR fs:0x28
    3e35:	je     3e3c <main+0x97e>
    3e37:	call   1060 <__stack_chk_fail@plt>
    3e3c:	lea    rsp,[rbp-0x28]
    3e40:	pop    rbx
    3e41:	pop    r12
    3e43:	pop    r13
    3e45:	pop    r14
    3e47:	pop    r15
    3e49:	pop    rbp
    3e4a:	ret

Disassembly of section .fini:

0000000000003e4c <_fini>:
    3e4c:	endbr64
    3e50:	sub    rsp,0x8
    3e54:	add    rsp,0x8
    3e58:	ret
